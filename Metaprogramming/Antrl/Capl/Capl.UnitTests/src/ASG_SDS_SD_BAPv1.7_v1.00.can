/*@@var:*/
/********************************************************************************/ 
/*  Author:      Roy Buehring                                                   */ 
/*  Department:  IAV, VC-F-23                                                   */ 
/*  Email (IAV): roy.buehring@IAV.de                                            */
/*  Email (VW):  extern.roy.buehring@volkswagen.de                              */
/*  Mobil:       +49 152 21881956                                               */ 
/*                                                                              */ 
/*  Substitute:  Christian Franz                                                */ 
/*  Department:  VW, EECF/1                                                     */ 
/*  Phone:       +49-5361-9-42880                                               */ 
/*                                                                              */ 
/*  Purpose:     CANoe simulation for stand alone SDS secondary Display	        */ 
/********************************************************************************/ 

includes
{
//Jen's email 05.03.2013
#pragma library ("..\BAP170.dll")
}

/* Global variables for the SDS_SD CANoe BAP simulation */
variables 
{
    // CAPL constants
    dword gBAP_Trace, gError_Trace;
    const CAPL_WRITE_LINE_SUCCESS                   = 0;
    const CAPL_WRITE_LINE_INFORMATION               = 1;
    const CAPL_WRITE_LINE_WARNING                   = 2;
    const CAPL_WRITE_LINE_ERROR                     = 3;

    char dbc_path[255]  ="DBs\\BAP_only_MQB_MLBevo_v1.19.dbc";	            // relative path for dbc-file											
    char xml_path[255]  ="XML\\BAP_SW17_KI_FPK_MQB_v1_74_F_mod.xml";        // relative path for xml-file  _mod
    dword NODE_INDEX;
    
    // Timers
    mstimer TaskTimer;													    // timer for BAP-Task	
    mstimer startupTimer;                                                   // timer for startup (init-time)
    mstimer initTimer;                                                      // avoids start of Bap stack before complete initialisation													

    // general values for readable code
    const FALSE                                     = 0;
	const TRUE                                      = 1;

    // BAP constants
    const BAP_HEADER_SIZE                           = 6;
    const BAP_BUFFER_SIZE                           = 4000;

    //BAP Data Type 
    const Bap_Void			                        = 0;
    const Bap_UInt8			                        = 1;
    const Bap_UInt16		                        = 2;
    const Bap_UInt32		                        = 3;
    const Bap_ByteSequence	                        = 4;
    const Bap_Error			                        = 5;
    const Bap_Acknowledge                           = 6;

    //BAP request types (ASG)
    const DataSetGet_REQ	                        = 0x00;
    const DataSet_REQ		                        = 0x01;
    const DataGet_REQ		                        = 0x02;
    const Start_REQ			                        = 0x05;
    const StartResult_REQ	                        = 0x06;
    const AbortResult_REQ	                        = 0x07;
    const Ack_REQ                                   = 0x0B; 
    const DataGet_REQ_CAN		                    = 0x10;   

    //BAP indication types (ASG)
    const Data_IND			                        = 0x00;
    const Reset_IND                                 = 0x01;
    const DataAck_IND                               = 0x02;
    const Result_IND		                        = 0x03;
    const Processing_IND                            = 0x04;  
    const Changed_IND		                        = 0x05;

    // BAP and BAL error codes
	const BAP_NO_ERROR                              = 0x00;
	const BAP_BAL_OUT_OF_RANGE                      = 0x41;
	const BAP_BAL_TEMP_NOT_AVAILABLE                = 0x42;
	const BAP_BAL_MAX_DL_EXCEEDED                   = 0x43;
	const BAP_BAL_UNIT_MISMATCH                     = 0x44;
    const Error_IND                                 = 0x55;                 // eigene Error-Definition

    /*** FSG specific global consts. ***/
    const LSG_SDS_SD	                            = 0x46;
    message BAP_SDS_ASG_01 ASG_CAN_Message;                                 // Needed because of no dll functionality
    const ASG_GET_MESSAGE_BYTE0                     = 0x10;
    const ASG_GET_MESSAGE_DLC                       = 2;

    /*** GetAll ***/
    const GET_ALL_FCT_ID                            = 0x01;
    const GET_ALL_BAP_DATA_TYPE                     = 0;                    // Void 

    /*** BAP_Config ***/
    const BAP_CONFIG_FCT_ID                         = 0x02;
    const BAP_CONFIG_BAP_DATA_TYPE                  = 0;                    // Void
    const BAP_CONFIG_BAP_DATA_LENGTH                = 6;

    /*** FunctionList ***/
    const FUNCTION_LIST_FCT_ID                      = 0x03;
    const FUNCTION_LIST_BAP_DATA_TYPE               = 0;                    // Void

    /*** Heartbeat ***/
    const HEART_BEAT_FCT_ID                         = 0x04;
    const HEART_BEAT_BAP_DATA_TYPE                  = 0;                    // Void
    const HEART_BEAT_BAP_DATA_LENGTH                = 0;                    // not relevant

    /*** FSG_Setup ***/
    const FSG_SETUP_FCT_ID                          = 0x0E;
    const FSG_SETUP_BAP_DATA_TYPE                   = 0;                    // Void
    const FSG_SETUP_BAP_DATA_LENGTH                 = 6;

    /*** FSG_OperationState ***/
    const FSG_OPERATION_STATE_FCT_ID                = 0x0F;
    const FSG_OPERATION_STATE_BAP_DATA_TYPE         = 0;                    // Void
    const FSG_OPERATION_STATE_BAP_DATA_LENGTH       = 0;                    // not relevant 
    const FSG_OPERATION_STATE_NORMAL                = 0;

    /*** ASG_Capabilities ***/
    const ASG_CAPABILITIES_FCT_ID                   = 0x10;
    const ASG_CAPABILITIES_BAP_DATA_TYPE_GET        = 0;                    // Void
    const ASG_CAPABILITIES_BAP_DATA_TYPE_SETGET     = 4;                    // ByteSequence
    const ASG_CAPABILITIES_BAP_DATA_LENGTH          = 6;

    /*** SDS_ContextState ***/
    const SDS_CONTEXT_STATE_FCT_ID                  = 0x11;
    const SDS_CONTEXT_STATE_BAP_DATA_TYPE           = 0;                    // Void

    /*** CommandList ***/
    const COMMAND_LIST_FCT_ID 	                    = 0x12;
    const COMMAND_LIST_BAP_DATA_TYPE                = 4;                    // Array
    const COMMANDLIST_ENTRIES                       = 254;                  
    const COMMANDLIST_COMMANDTEXT_LENGTH            = 61;
    const COMMANDLIST_EXTENSION_LENGTH              = 2;
    const COMMANDLIST_RECADDR_ID_TEXT               = 1;
    const COMMANDLIST_RECADDR_ID                    = 2;
    const COMMANDLIST_RECADDR_TEXT                  = 3;
    const COMMANDLIST_ASGID                         = 0x0C;
    // global variables to store all possible elements
    word CommandList_Data_Pos[COMMANDLIST_ENTRIES];
    word CommandList_Data_CommandID[COMMANDLIST_ENTRIES];
    char CommandList_Data_CommandText[COMMANDLIST_ENTRIES][COMMANDLIST_COMMANDTEXT_LENGTH];
    int  CommandList_Data_illustrationOffset        = 0;
    byte CommandList_Data_lastRequestedTAID         = 0;

    /*** ResultList ***/
    const RESULT_LIST_FCT_ID                        = 0x13;
    const RESULT_LIST_BAP_DATA_TYPE                 = 4;                    // Array
    const RESULT_LIST_ENTRIES                       = 254;
    const RESULT_LIST_RESULTTEXT_LENGTH             = 171;
    const RESULT_LIST_EXTENSION_LENGTH              = 2;
    const RESULT_LIST_TYPE_TEXT                     = 1;
    const RESULT_LIST_TEXT                          = 2;
    const RESULT_LIST_ASGID                         = 0x0C;
    // global variables to store all possible elements
    byte ResultList_Data_Pos[RESULT_LIST_ENTRIES];
    byte ResultList_Data_ResultType[RESULT_LIST_ENTRIES];
    char ResultList_Data_ResultText[RESULT_LIST_ENTRIES][RESULT_LIST_RESULTTEXT_LENGTH];
    int  ResultList_Data_illustrationOffset         = 0;
    byte ResultList_Data_lastRequestedTAID          = 0;

    /*** InfoStates ***/
    const INFOSTATES_FCT_ID                         = 0x14;
    const INFOSTATES_BAP_DATA_TYPE                  = 0;                    // Void
    const INFOSTATES_BAP_DATA_LENGTH                = 6;
}
/*@@end*/

/*@@preStart:PreStart:*/
on preStart
{
    int error;
    char Path[255];
    char BAPVersion [200];

	// create write window for BAP communication
    gBAP_Trace  = writecreate("SDS_SD_ASG BAP-Trace");								
    writeclear(gBAP_Trace);													
	gError_Trace = writecreate("SDS_SD_ASG Error");									
	writeclear(gError_Trace);												

    //clear CAPL-window in write-window
    writeclear(1);	

    //get version from Stack
	Bap170_GetVersions(BAPVersion, 200);
	writelineEx(gBAP_Trace, CAPL_WRITE_LINE_SUCCESS, "*********************************************************************************");
	writelineEx(gBAP_Trace, CAPL_WRITE_LINE_SUCCESS, BAPVersion);
	writelineEx(gBAP_Trace, CAPL_WRITE_LINE_SUCCESS, "*********************************************************************************");


    // Create Node
	NODE_INDEX = Bap170_CreateNode();

    // Load DBC and XML files. 
    // load dbc-file
    getAbsFilePath(dbc_path, Path, 255);
	writelineEx(gBAP_Trace, CAPL_WRITE_LINE_SUCCESS, "ASG-SDS_SD: Loading BAP_DBC-File: '%s'", Path);
   
	if(Bap170_LoadDBC(NODE_INDEX, 1, Path) != BAP_NO_ERROR)						
		writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "ASG-SDS_SD Fehler beim Laden: '%s', Path");

	//load xml-file 
	getAbsFilePath(xml_path, Path, 255);
    writelineEx(gBAP_Trace, CAPL_WRITE_LINE_SUCCESS, "ASG-SDS_SD: Load BAP-XML-File: '%s'", Path);
	
  
    if (Bap170_LoadConfig(NODE_INDEX,Path,"") != BAP_NO_ERROR) 
	    writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "ASG-SDS_SD: Fehler beim Laden: '%s' !", Path);	   
    writelineEx(gBAP_Trace, CAPL_WRITE_LINE_SUCCESS, "*********************************************************************************");

    // BAP DLL: Add CAN channel: BAP channel 1 is mapped to CAN card channel 1.
	Bap170_AddCanMap(NODE_INDEX, 1, 1);	
    
    // BAP INIT
	error = Bap170_Init(NODE_INDEX,LSG_SDS_SD);
    // Check for initialisation error.
    if(error == BAP_NO_ERROR)
	    writelineEx(gBAP_Trace, CAPL_WRITE_LINE_SUCCESS, "ASG-SDS_SD BAP_Init successful");	
    else
	    writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR,"ASG-SDS_SD error in BAP_DLL_StackStart () - BAP INIT: 0x%x", error);	
}
/*@@end*/

/*@@startStart:Start:*/
on start
{
    init_variables_controls();

    //Panel
    closePanel("SDS_SD_ASG_Main");
    closePanel("SDS_SD_ASG_Properties");
    closePanel("SDS_SD_ASG_CommandList");
    closePanel("SDS_SD_ASG_ResultList");

    controls_enable_all();

    openPanel("SDS_SD_Main");  
    
    init_variables();
    setTimer(initTimer, 3000);
}
/*@@end*/

/*@@timer:TaskTimer:*/
on timer TaskTimer
{
	Bap170_Task(NODE_INDEX);	// DLL-Task
	
    BAP_DLL_Indication();
	
    BAP_CAN_TX_Request();       // Get new CAN messages in BAP stack

	setTimer(TaskTimer, 10);	// restart BAP-DLL-Timer
}
/*@@end*/

/*@@timer:startupTimer:*/
on timer startupTimer
{
    if(@sysvar::SDS_SD_General::Smart && @sysvar::SDS_SD_ASG::x03_FctList_0x10_ASGCap && @sysvar::SDS_SD_ASG::control_OnOff)
    {
        Request_0x10_ASG_Capabilities(DataSetGet_REQ);
    }
}
/*@@end*/

/*@@stop:StopMeasurement:*/
on stopMeasurement
{
    BAP170_ReleaseNode(NODE_INDEX);
}
/*@@end*/

/*@@caplFunc:BAP_CAN_TX_Request():*/
void BAP_CAN_TX_Request()
{
	int i;
	byte TX_Data[8];			// CAN data 
	dword TX_Header[3];			// CAN header 
	message 0x100 TX_Message;	// dummy message 

	TX_Header[2] = 8; // max-Length of TX_Data

	// Get BAP data in CAN format from DLL.
	while (Bap170_CAN_GetTxDat(NODE_INDEX,TX_Header,TX_Data) == 0) // as long as data are to be sent...
	{
		TX_Message.CAN = TX_Header[0]; // CAN channel
		TX_Message.ID  = TX_Header[1]; // CAN ID
		TX_Message.DLC = TX_Header[2]; // received length from BAP-DLL. 

		// CAN data bytes
		for (i=0; i < TX_Message.DLC; i++) 
			TX_Message.byte(i) = TX_Data[i];
		

		output(TX_Message); // send CAN message

		// Correct bug on CAPL CAN interface.
		// Rewrite length information (max length). 
		TX_Header[2] = 8; // max. length of TX data.

	} /* end of: while (Bap150_CAN_GetTxDat(NODE_INDEX,TX_Header,TX_Data) == 0) */
} /* end of function */
/*@@end*/

/*@@caplFunc:BAP_DLL_Indication():*/
void BAP_DLL_Indication()
{
    int i, bapErrorCode;
    int fct_ID, lsg_ID, bapIndication_t, BAP_data_type; 
    int datalength;
    dword indicationHeader[BAP_HEADER_SIZE];
    byte indicationData[BAP_BUFFER_SIZE];
    byte requestarray[BAP_HEADER_SIZE];

    // Hinweis: Die Länge (indication[4]) muss vor Aufruf der Funktion auf die Länge von „data“ gesetzt werden!
    // Ist das Datenfeld zu kurz, wird der Fehler „BapErr_InvalidArg“ zurückgegeben!
    indicationHeader[4] = elCount(indicationData);

    bapErrorCode = Bap170_GetInd(NODE_INDEX, indicationHeader, indicationData);

    if(bapErrorCode == 0)
	{
		lsg_ID = indicationHeader[0];									            // LSG-ID
		fct_ID = indicationHeader[1];									            // Function-ID
		bapIndication_t = indicationHeader[2];									    // indication
		BAP_data_type = indicationHeader[3];									    // BAP data type
		datalength = indicationHeader[4];

        if(indicationHeader[0] != LSG_SDS_SD)                                       // catch invalid LSG-ID
        {
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "ASG: Error BAP_Indication: invalid/unhandled LSG-ID %x", indicationHeader[0]);
            return;
        }

        switch (fct_ID)
	    {
            case GET_ALL_FCT_ID:
                Indication_0x01_GetAll(indicationHeader, indicationData, datalength);
		        break;

            case BAP_CONFIG_FCT_ID:
                Indication_0x02_BAP_Config(indicationHeader, indicationData, datalength);
		        break;

            case FUNCTION_LIST_FCT_ID:
                Indication_0x03_FunctionList(indicationHeader, indicationData, datalength);
		        break;

            case HEART_BEAT_FCT_ID:
                Indication_0x04_HeartBeat(indicationHeader, indicationData, datalength);
		        break;

            case FSG_SETUP_FCT_ID:
                Indication_0x0E_FSG_Setup(indicationHeader, indicationData, datalength);
		        break;

            case FSG_OPERATION_STATE_FCT_ID:
			    Indication_0x0F_FSG_OperationState(indicationHeader, indicationData, datalength);
		        break;

		    case ASG_CAPABILITIES_FCT_ID:
			    Indication_0x10_ASG_Capabilities(indicationHeader, indicationData, datalength);
		        break;

		    case SDS_CONTEXT_STATE_FCT_ID:
			    Indication_0x11_SDS_ContextState(indicationHeader, indicationData, datalength);
		        break;

		    case COMMAND_LIST_FCT_ID:
			    Indication_0x12_CommandList(indicationHeader, indicationData, datalength);
		        break;
                	
		    case RESULT_LIST_FCT_ID:
			    Indication_0x13_ResultList(indicationHeader, indicationData, datalength);
		        break;

		    case INFOSTATES_FCT_ID:
			    Indication_0x14_InfoState(indicationHeader, indicationData, datalength);
		        break;
                        
		    default:
			    writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "ASG: BAP_DLL_Indication: invalid funcion-ID %x", indicationHeader[1]);
		    
                // send error message.
	            requestarray[0] = LSG_SDS_SD;					    // LSG-ID
	            requestarray[1] = indicationHeader[1];	            // Fct.-ID
	            requestarray[2] = Error_IND;                        // request type
			    requestarray[3] = BAP_BAL_TEMP_NOT_AVAILABLE;       // errorcode
			
                break;
	    }	
	}
}
/*@@end*/

/*@@caplFunc:Indication_0x10_ASG_Capabilities(dword[],byte[],int):*/
void Indication_0x10_ASG_Capabilities(dword indication_header [], byte indication_data[], int datalength)
{
    switch (indication_header[2])
	{
		case Data_IND:
			@sysvar::SDS_SD_ASG_Prop::x10_ASGCap_displaySizeClass = indication_data[0];
            @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_extension1 = indication_data[1];
            @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_extension2 = indication_data[2];
            @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_extension3 = indication_data[3];
            @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_extension4 = indication_data[4];
            @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_extension5 = indication_data[5];
            break;
        
        case Error_IND:
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "SDS_SD_ASG: Error-Indication in Indication_0x10_ASG_Capabilities: Error 0x%x", indication_header[5]);
		    break;
		
        default:
			writelineEx(gBAP_Trace, CAPL_WRITE_LINE_INFORMATION, "SDS_SD_ASG: Unhandled indication 0x%x in Indication_0x10_ASG_Capabilities.", indication_header[2]);
		    break;
	}
}
/*@@end*/

/*@@caplFunc:Request_0x10_ASG_Capabilities(byte):*/
void Request_0x10_ASG_Capabilities(byte request)
{
    dword header [BAP_HEADER_SIZE];
    byte data[ASG_CAPABILITIES_BAP_DATA_LENGTH];
    
    switch(request)
    {
        case DataGet_REQ_CAN:
            /*** NO FUNCTION WITH BAP DLL (CacheAvailability=true) -> Call via CAN ***/
            CAN_sendGetMessage(ASG_CAPABILITIES_FCT_ID);
            break;

        case DataGet_REQ:
            /*** Cache data request ***/
            BAP_createHeader(ASG_CAPABILITIES_FCT_ID, header, elCount(data), request);
            BAP_DLL_Request(request, header, data);
            break;

        case DataSetGet_REQ:
            // create Data field
            data[0] = @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_displaySizeClass;
            data[1] = @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_extension1;
            data[2] = @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_extension2;
            data[3] = @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_extension3;
            data[4] = @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_extension4;
            data[5] = @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_extension5;
            BAP_createHeader(ASG_CAPABILITIES_FCT_ID, header, elCount(data), request);
            BAP_DLL_Request(request, header, data);
            break;

        default:
            break;
    }


}
/*@@end*/

/*@@caplFunc:Request_0x11_SDS_ContextState(byte):*/
void Request_0x11_SDS_ContextState(byte request)
{
    dword header [BAP_HEADER_SIZE];
    byte data[1];

    switch(request)
    {
        case DataGet_REQ_CAN:
            /*** NO FUNCTION WITH BAP DLL (CacheAvailability=true) -> Call via CAN ***/
            CAN_sendGetMessage(SDS_CONTEXT_STATE_FCT_ID);
            break;
        
        case DataGet_REQ:
            /*** Cache data request ***/
            BAP_createHeader(SDS_CONTEXT_STATE_FCT_ID, header, elCount(data), request);
            BAP_DLL_Request(request, header, data);
            break;

        default:
            break;
    }
}
/*@@end*/

/*@@caplFunc:Indication_0x12_CommandList(dword[],byte[],int):*/
void Indication_0x12_CommandList(dword indication_header [], byte indication_data[], int datalength)
{
    int tnle;
    int i;
    byte commandID_upper, commandID_lower;
    word commandID;

    tnle = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TNLE;

    if(!@sysvar::SDS_SD_ASG_CommandList::x12_CommandList_control_onOff)
        return;

    switch (indication_header[2]) // indication
	{
		case Changed_IND:
            // Clear old Array data
            CommandList_clearData();

            // Get First Element
            CommandList_getElement(1);
		    break;

        case Data_IND:
            // Check right Addressing 
            if(Array_DecodeFirstByte_getASGID(indication_data[0]) != COMMANDLIST_ASGID                      // Only evaluate messages with valid ASGID
            || Array_DecodeFirstByte_getTAID(indication_data[0]) != CommandList_Data_lastRequestedTAID)     // Only evaluate correct answered GetArrays
                return;

            // tnle == 0
            if(tnle >= indication_data[1] )                                             
                return;

            // Check if Get-Parameters are OK
            if(Array_DecodeModeByte_getShift(indication_data[2])            != 0                            // No Shift
            || Array_DecodeModeByte_getDirection(indication_data[2])        != 0                            // Forwards
            || Array_DecodeModeByte_getIdxSize(indication_data[2])          != 0                            // 8 Bit
            || Array_DecodeModeByte_getRecordAddress(indication_data[2])    != COMMANDLIST_RECADDR_ID_TEXT  // Full data
            || indication_data[4]                                           != 1)                           // Elements
                return;

            // Everything OK, take Data
            tnle = indication_data[1];                                                                                          // total number of elements
            CommandList_Data_Pos[@sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TNLE]           = indication_data[5];
            ResultList_Data_ResultType[@sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TNLE]    = indication_data[6];
            commandID_lower = indication_data[6];
            commandID_upper = indication_data[7];
            commandID = commandID_lower;
            commandID |= (commandID_upper << 8);
            CommandList_Data_CommandID[@sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TNLE] = commandID;

            for(i=0; i<indication_data[8]; i++)
                CommandList_Data_CommandText[@sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TNLE][i] = indication_data[9+i];

            @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TNLE = (@sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TNLE + 1);    // elements count
            
            CommandList_actualize_sysvar ();

            // Get next element, if tnle>this
            if(@sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TNLE < tnle)
                CommandList_getElement(indication_data[5] + 1);

		    break;

		case Error_IND:
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "SDS_SD_ASG: Error-Indication in Indication_0x12_CommandList: Error 0x%x", indication_header[5]);
		    break;
		
        default:
			writelineEx(gBAP_Trace, CAPL_WRITE_LINE_INFORMATION, "SDS_SD_ASG: Unhandled indication 0x%x in Indication_0x12_CommandList.", indication_header[2]);
		    break;
	} 
}
/*@@end*/

/*@@caplFunc:Request_0x12_CommandList(byte):*/
void Request_0x12_CommandList (byte request)
{
    // BAP stack buffer
    dword header [BAP_HEADER_SIZE];
    byte data[BAP_BUFFER_SIZE];
    byte modeByte;
    int i;

    byte recordAddress, shift, direction, transmitPos, idxSize, ASG_ID, TAID;
    word start_pos, elements;

    // clear variables
    for(i=0; i<elCount(header); i++)
        header[i] = 0;
    for(i=0; i<elCount(data); i++)
        data[i] = 0;

    // get data
    shift           = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_shift;
    direction       = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_direction;
    transmitPos     = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_transmitPos;
    idxSize         = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_indexSize;
    recordAddress   = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_recordAddress;

    ASG_ID          = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_ASGID;
    TAID            = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TAID_hex;

    start_pos       = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_start_hex;
    elements        = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_elements_hex;

    modeByte        = Array_createModeByte (shift, direction, transmitPos, idxSize, recordAddress);
    i = Array_createHeader_get (data, start_pos, elements, ASG_ID, TAID, modeByte, idxSize);

    BAP_createHeader(COMMAND_LIST_FCT_ID, header, i, request);
    BAP_DLL_Request(request, header, data);
}
/*@@end*/

/*@@caplFunc:Indication_0x13_ResultList(dword[],byte[],int):*/
void Indication_0x13_ResultList(dword indication_header [], byte indication_data[], int datalength)
{
    int tnle;
    int i;
    tnle = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TNLE;

    if(!@sysvar::SDS_SD_ASG_ResultList::x13_ResultList_control_OnOff)
        return;

    switch (indication_header[2]) // indication
	{
		case Changed_IND:
            // Clear old Array data
            ResultList_clearData();

            // Get First Element
            ResultList_getElement(1);
		    break;

        case Data_IND:
            // Check right Addressing 
            if(Array_DecodeFirstByte_getASGID(indication_data[0]) != RESULT_LIST_ASGID                  // Only evaluate messages with valid ASGID
            || Array_DecodeFirstByte_getTAID(indication_data[0]) != ResultList_Data_lastRequestedTAID) // Only evaluate correct answered GetArrays
                return;

            // tnle == 0
            if(tnle >= indication_data[1] )                                             
                return;

            // Check if Get-Parameters are OK
            if(Array_DecodeModeByte_getShift(indication_data[2])            != 0                        // No Shift
            || Array_DecodeModeByte_getDirection(indication_data[2])        != 0                        // Forwards
            || Array_DecodeModeByte_getIdxSize(indication_data[2])          != 0                        // 8 Bit
            || Array_DecodeModeByte_getRecordAddress(indication_data[2])    != RESULT_LIST_TYPE_TEXT    // Full data
            || indication_data[4]                                           != 1)                       // Elements
                return;

            // Everything OK, take Data
            tnle = indication_data[1];                                                                                          // total number of elements
            ResultList_Data_Pos[@sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TNLE]           = indication_data[5];
            ResultList_Data_ResultType[@sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TNLE]    = indication_data[6];
            for(i=0; i<indication_data[7]; i++)
                ResultList_Data_ResultText[@sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TNLE][i] = indication_data[8+i];

            @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TNLE = (@sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TNLE + 1);    // elements count
            
            ResultList_actualize_sysvar ();

            // Get next element, if tnle>this
            if(@sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TNLE < tnle)
                ResultList_getElement(indication_data[5] + 1);

		    break;

		case Error_IND:
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "SDS_SD_ASG: Error-Indication in Indication_0x13_ResultList: Error 0x%x", indication_header[5]);
		    break;
		
        default:
			writelineEx(gBAP_Trace, CAPL_WRITE_LINE_INFORMATION, "SDS_SD_ASG: Unhandled indication 0x%x in Indication_0x13_ResultList.", indication_header[2]);
		    break;
	}  
}
/*@@end*/

/*@@caplFunc:Request_0x13_ResultList(byte):*/
void Request_0x13_ResultList (byte request)
{   
    // BAP stack buffer
    dword header [BAP_HEADER_SIZE];
    byte data[BAP_BUFFER_SIZE];
    byte modeByte;
    int i;

    byte recordAddress, shift, direction, transmitPos, idxSize, ASG_ID, TAID;
    word start_pos, elements;

    // clear variables
    for(i=0; i<elCount(header); i++)
        header[i] = 0;
    for(i=0; i<elCount(data); i++)
        data[i] = 0;

    // get data
    shift           = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_shift;
    direction       = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_direction;
    transmitPos     = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_transmitPos;
    idxSize         = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_indexSize;
    recordAddress   = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_recordAddress;

    ASG_ID          = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_ASGID;
    TAID            = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TAID_hex;

    start_pos       = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_start_hex;
    elements        = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_elements_hex;

    modeByte        = Array_createModeByte (shift, direction, transmitPos, idxSize, recordAddress);
    i = Array_createHeader_get (data, start_pos, elements, ASG_ID, TAID, modeByte, idxSize);

    BAP_createHeader(RESULT_LIST_FCT_ID, header, i, request);
    BAP_DLL_Request(request, header, data);
}
/*@@end*/

/*@@caplFunc:Indication_0x14_InfoState(dword[],byte[],int):*/
void Indication_0x14_InfoState(dword indication_header [], byte indication_data[], int datalength)
{
    switch (indication_header[2])
	{
		case Data_IND:
            @sysvar::SDS_SD_ASG_Prop::x14_InfoStates_States     = indication_data[0];
			@sysvar::SDS_SD_ASG_Prop::x14_InfoStates_extension1 = indication_data[1];
            @sysvar::SDS_SD_ASG_Prop::x14_InfoStates_extension2 = indication_data[2];
            @sysvar::SDS_SD_ASG_Prop::x14_InfoStates_extension3 = indication_data[3];
            @sysvar::SDS_SD_ASG_Prop::x14_InfoStates_extension4 = indication_data[4];
            @sysvar::SDS_SD_ASG_Prop::x14_InfoStates_extension5 = indication_data[5];
            break;
		
        case Error_IND:
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "SDS_SD_ASG: Error-Indication in Indication_0x14_InfoState: Error 0x%x", indication_header[5]);
		    break;

        default:
			writelineEx(gBAP_Trace, CAPL_WRITE_LINE_INFORMATION, "SDS_SD_ASG: Unhandled indication 0x%x in Indication_0x14_InfoState.", indication_header[2]);
		    break;
	} 
}
/*@@end*/

/*@@caplFunc:Request_0x14_InfoState(byte):*/
void Request_0x14_InfoState(byte request)
{
    dword header [BAP_HEADER_SIZE];
    byte data[1];

    switch(request)
    {
        case DataGet_REQ_CAN:
            /*** NO FUNCTION WITH BAP DLL (CacheAvailability=true) -> Call via CAN ***/
            CAN_sendGetMessage(INFOSTATES_FCT_ID);
            break;
        
        case DataGet_REQ:
            /*** Cache data request ***/
            BAP_createHeader(INFOSTATES_FCT_ID, header, elCount(data), request);
            BAP_DLL_Request(request, header, data);
            break;

        default:
            break;
    }
}
/*@@end*/

/*@@caplFunc:Indication_0x0E_FSG_Setup(dword[],byte[],int):*/
void Indication_0x0E_FSG_Setup(dword indication_header [], byte indication_data[], int datalength)
{
    switch (indication_header[2])
	{
		case Data_IND:
			@sysvar::SDS_SD_ASG::x0E_FSGSetup_setupValue_commandIDSupported = (indication_data[0] & 0x01);
            break;
		
        case Error_IND:
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "SDS_SD_ASG: Error-Indication in Indication_0x0E_FSG_Setup: Error 0x%x", indication_header[5]);
		    break;

        default:
			writelineEx(gBAP_Trace, CAPL_WRITE_LINE_INFORMATION, "SDS_SD_ASG: Unhandled indication 0x%x in Indication_0x0E_FSG_Setup.", indication_header[2]);
		    break;
	} 
}
/*@@end*/

/*@@caplFunc:Indication_0x0F_FSG_OperationState(dword[],byte[],int):*/
void Indication_0x0F_FSG_OperationState(dword indication_header [], byte indication_data[], int datalength)
{
    switch (indication_header[2])
	{
		case Data_IND:
			@sysvar::SDS_SD_ASG::x0F_FSGOPState_OPState = indication_header[5];
            break;
		
        case Error_IND:
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "SDS_SD_ASG: Error-Indication in Indication_0x0F_FSG_OperationState: Error 0x%x", indication_header[5]);
		    break;

        default:
			writelineEx(gBAP_Trace, CAPL_WRITE_LINE_INFORMATION, "SDS_SD_ASG: Unhandled indication 0x%x in Indication_0x0F_FSG_OperationState.", indication_header[2]);
		    break;
	} 
}
/*@@end*/

/*@@caplFunc:Request_0x0F_FSG_OperationState(byte):*/
void Request_0x0F_FSG_OperationState (byte request)
{
    dword header [BAP_HEADER_SIZE];
    byte data[1];

    switch(request)
    {
        case DataGet_REQ_CAN:
            /*** NO FUNCTION WITH BAP DLL (CacheAvailability=true) -> Call via CAN ***/
            CAN_sendGetMessage(FSG_OPERATION_STATE_FCT_ID);
            break;
        
        case DataGet_REQ:
            /*** Cache data request ***/
            BAP_createHeader(FSG_OPERATION_STATE_FCT_ID, header, elCount(data), request);
            BAP_DLL_Request(request, header, data);
            break;

        default:
            break;
    }
}
/*@@end*/

/*@@caplFunc:Indication_0x04_HeartBeat(dword[],byte[],int):*/
void Indication_0x04_HeartBeat(dword indication_header [], byte indication_data[], int datalength)
{
    switch (indication_header[2]) // indication
	{
		case Data_IND: 
            @sysvar::SDS_SD_ASG::x04_HeartBeat_HeartBeatTime = indication_header[5];                
		    break;

		case Error_IND:
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "SDS_SD_ASG: Error-Indication in Indication_0x04_HeartBeat: Error 0x%x", indication_header[5]);
		    break;
		
        default:
			writelineEx(gBAP_Trace, CAPL_WRITE_LINE_INFORMATION, "SDS_SD_ASG: Unhandled indication 0x%x in Indication_0x04_HeartBeat.", indication_header[2]);
		    break;
	}  
}
/*@@end*/

/*@@caplFunc:Request_0x04_HeartBeat(byte):*/
void Request_0x04_HeartBeat (byte request)
{
    dword header [BAP_HEADER_SIZE];
    byte data[1];

    switch(request)
    {
        case DataGet_REQ_CAN:
            /*** NO FUNCTION WITH BAP DLL (CacheAvailability=true) -> Call via CAN ***/
            CAN_sendGetMessage(HEART_BEAT_FCT_ID);
            break;
        
        case DataGet_REQ:
            /*** Cache data request ***/
            BAP_createHeader(HEART_BEAT_FCT_ID, header, elCount(data), request);
            BAP_DLL_Request(request, header, data);
            break;

        default:
            break;
    }
}
/*@@end*/

/*@@msg:CAN1.BAP_only_MQB_MLBevo_v119::BAP_SDS_FSG_01 (0x17334610X):*/
on message CAN1.BAP_SDS_FSG_01  // ASG BAP-message
{
    int i, error;
    byte RX_Data[8];		    // received CAN-DATA
    dword RX_Header[3];		    // received CAN-Header

    RX_Header[0]=this.CAN; 
    RX_Header[1]=this.ID; 
    RX_Header[2]=this.DLC;      // received length
	
	// extract CAN data    																	
	for (i=0; i<this.DLC; i++) 														
	    RX_Data[i]=this.byte(i);		  
	        
	// send recieved CAN-data with CAN-header to BAP-DLL
	error =Bap170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
	if(error !=0)
	    writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "ASG-SDS_SD: BAP_CAN_SetRxData: %d", error);
}
/*@@end*/

/*@@caplFunc:Indication_0x03_FunctionList(dword[],byte[],int):*/
void Indication_0x03_FunctionList(dword indication_header [], byte indication_data[], int datalength)
{
    switch (indication_header[2]) // indication
	{
		case Data_IND: 
            // Byte 1
            @sysvar::SDS_SD_ASG::x03_FctList_0x01_GetAll            = (indication_data[0] & 0x40) >> 6;
            @sysvar::SDS_SD_ASG::x03_FctList_0x02_BAPConfig         = (indication_data[0] & 0x20) >> 5;
            @sysvar::SDS_SD_ASG::x03_FctList_0x03_FctList           = (indication_data[0] & 0x10) >> 4;
            @sysvar::SDS_SD_ASG::x03_FctList_0x04_HeartBeat         = (indication_data[0] & 0x08) >> 3;

            // Byte 2
            @sysvar::SDS_SD_ASG::x03_FctList_0x0E_FSGSetup          = (indication_data[1] & 0x02) >> 1;
            @sysvar::SDS_SD_ASG::x03_FctList_0x0F_FSGOPState        = (indication_data[1] & 0x01) >> 0;

            // Byte 3
            @sysvar::SDS_SD_ASG::x03_FctList_0x10_ASGCap            = (indication_data[2] & 0x80) >> 7;
            @sysvar::SDS_SD_ASG::x03_FctList_0x11_SDSContextState   = (indication_data[2] & 0x40) >> 6;
            @sysvar::SDS_SD_ASG::x03_FctList_0x12_CommandList       = (indication_data[2] & 0x20) >> 5;
            @sysvar::SDS_SD_ASG::x03_FctList_0x13_ResultList        = (indication_data[2] & 0x10) >> 4;
            @sysvar::SDS_SD_ASG::x03_FctList_0x14_InfoStates        = (indication_data[2] & 0x08) >> 3;
		    
            // Enable controls
            controls_enable_all();

            if(@sysvar::SDS_SD_General::Smart)
                Request_0x01_GetAll(DataGet_REQ);

            break;		
		
        case Error_IND:
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "SDS_SD_ASG: Error-Indication in Indication_0x03_FunctionList: Error 0x%x", indication_header[5]);
		    break;

		default:
			writelineEx(gBAP_Trace, CAPL_WRITE_LINE_INFORMATION, "SDS_SD_ASG: Unhandled indication 0x%x in Indication_0x03_FunctionList.", indication_header[2]);
		    break;
	}
}
/*@@end*/

/*@@caplFunc:Request_0x03_FunctionList(byte):*/
void Request_0x03_FunctionList(byte request)
{   
    dword header [BAP_HEADER_SIZE];
    byte data[1];

    switch(request)
    {
        case DataGet_REQ_CAN:
            /*** NO FUNCTION WITH BAP DLL (CacheAvailability=true) -> Call via CAN ***/
            CAN_sendGetMessage(FUNCTION_LIST_FCT_ID);
            break;
        
        case DataGet_REQ:
            /*** Cache data request ***/
            BAP_createHeader(FUNCTION_LIST_FCT_ID, header, elCount(data), request);
            BAP_DLL_Request(request, header, data);
            break;

        default:
            break;
    }
}
/*@@end*/

/*@@caplFunc:Indication_0x02_BAP_Config(dword[],byte[],int):*/
void Indication_0x02_BAP_Config(dword indication_header [], byte indication_data[], int datalength)
{
    switch (indication_header[2])
	{
		case Data_IND:
        case Reset_IND:
			@sysvar::SDS_SD_ASG::x02_BAPConfig_BAP_major = indication_data[0];
            @sysvar::SDS_SD_ASG::x02_BAPConfig_BAP_minor = indication_data[1];
            @sysvar::SDS_SD_ASG::x02_BAPConfig_LSG_Class = indication_data[2];
            @sysvar::SDS_SD_ASG::x02_BAPConfig_LSG_SubClass = indication_data[3];
            @sysvar::SDS_SD_ASG::x02_BAPConfig_DF_VerMajor = indication_data[4];
            @sysvar::SDS_SD_ASG::x02_BAPConfig_DF_VerMinor = indication_data[5];
            break;
        
		case Error_IND:
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "SDS_SD_ASG: Error-Indication in Indication_0x02_BAP_Config: Error 0x%x", indication_header[5]);
		    break;
			
        default:
			writelineEx(gBAP_Trace, CAPL_WRITE_LINE_INFORMATION, "SDS_SD_ASG: Unhandled indication 0x%x in Indication_0x02_BAP_Config.", indication_header[2]);
		    break;
	}
    
    controls_setFunctionActive(FUNCTION_LIST_FCT_ID, TRUE);

    if(@sysvar::SDS_SD_General::Smart)
        Request_0x03_FunctionList(DataGet_REQ);	
}
/*@@end*/

/*@@caplFunc:init_variables():*/
void init_variables()
{
    init_variables_properties();
    init_variables_array_CommandList();
    init_variables_array_ResultList();
}
/*@@end*/

/*@@caplFunc:Shutdown_SDS_SD():*/
void Shutdown_SDS_SD()
{
    // Timer
    canceltimer(TaskTimer);

    // BAP-Stack
    Bap170_Shutdown(NODE_INDEX,LSG_SDS_SD);

    // Reset variables
    if(@sysvar::SDS_SD_General::Smart)
        init_variables();
}
/*@@end*/

/*@@caplFunc:Request_0x01_GetAll(byte):*/
void Request_0x01_GetAll(byte request)
{
    dword header [BAP_HEADER_SIZE];
    byte data[1];
    switch(request)
    {
        case DataGet_REQ_CAN:
            /*** NO FUNCTION WITH BAP DLL (CacheAvailability=true) -> Call via CAN ***/
            CAN_sendGetMessage(GET_ALL_FCT_ID);
            break;
        
        case DataGet_REQ:
            /*** Cache data request ***/
            BAP_createHeader(GET_ALL_FCT_ID, header, elCount(data), request);
            BAP_DLL_Request(request, header, data);
            break;

        default:
            break;
    }
}
/*@@end*/

/*@@caplFunc:init_variables_array_CommandList():*///function
init_variables_array_CommandList ()
{
    long i;

    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TNLE                        = 0;

    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_direction                = 0;
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_elements_hex             = 4;
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_indexSize                = 0;
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_recordAddress            = 0;
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_shift                    = 0;

    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_start_hex                = 0;
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_transmitPos              = 0;

    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_ASGID                       = 0;
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TAID_hex                    = 1;

    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_control_onOff               = 0;

    for(i=0; i<elCount(CommandList_Data_Pos); i++)
        CommandList_Data_Pos[i] = i+1;

    CommandList_actualize_sysvar ();
}
/*@@end*/

/*@@caplFunc:BAP_DLL_StackStart():*///function
BAP_DLL_StackStart ()
{
    int error;

    // BAP Chache
    //error = BAP_DLL_Init_SendBuffer();
    if(error ==BAP_NO_ERROR)
	    writelineEx(gBAP_Trace, CAPL_WRITE_LINE_SUCCESS, "ASG-SDS_SD BAP Cache Request successful");	
    else
	    writelineEx(gError_Trace, 0,"ASG-SDS_SD error in BAP_DLL_StackStart () - BAP Chache: 0x%x", error);

    //BAP-Start
	error = Bap170_Start(NODE_INDEX, LSG_SDS_SD);
		
    if(error ==BAP_NO_ERROR)
		writelineEx(gBAP_Trace, CAPL_WRITE_LINE_SUCCESS, "ASG-SDS_SD BAP_Start successful");
    else
	    writelineEx(gError_Trace, 0,"ASG-SDS_SD error in BAP_DLL_StackStart () - BAP Start: 0x%x", error);

    writelineEx(gBAP_Trace, CAPL_WRITE_LINE_SUCCESS, "*********************************************************************************");
}
/*@@end*/

/*@@caplFunc:init_SDS_SD():*///function
init_SDS_SD ()
{
    if(@sysvar::SDS_SD_General::Smart)
        init_variables();							

    BAP_DLL_StackStart();	      
}
/*@@end*/

/*@@caplFunc:init_variables_properties():*///function
init_variables_properties ()
{
    // 0x03 FunctionList
    @sysvar::SDS_SD_ASG::x03_FctList_0x01_GetAll                        = 0;
    @sysvar::SDS_SD_ASG::x03_FctList_0x02_BAPConfig                     = 0;
    @sysvar::SDS_SD_ASG::x03_FctList_0x03_FctList                       = 0;
    @sysvar::SDS_SD_ASG::x03_FctList_0x04_HeartBeat                     = 0;
    @sysvar::SDS_SD_ASG::x03_FctList_0x0E_FSGSetup                      = 0;
    @sysvar::SDS_SD_ASG::x03_FctList_0x0F_FSGOPState                    = 0;
    @sysvar::SDS_SD_ASG::x03_FctList_0x10_ASGCap                        = 0;
    @sysvar::SDS_SD_ASG::x03_FctList_0x11_SDSContextState               = 0;
    @sysvar::SDS_SD_ASG::x03_FctList_0x12_CommandList                   = 0;
    @sysvar::SDS_SD_ASG::x03_FctList_0x13_ResultList                    = 0;
    @sysvar::SDS_SD_ASG::x03_FctList_0x14_InfoStates                    = 0;

    // 0x04 Heartbeat
    @sysvar::SDS_SD_ASG::x04_HeartBeat_HeartBeatTime                    = 0xA;
  
    // 0x0E FSG-Setup
    @sysvar::SDS_SD_ASG::x0E_FSGSetup_setupValue_commandIDSupported     = 0;
  
    // 0x0F FSG-OperationState
    @sysvar::SDS_SD_ASG::x0F_FSGOPState_OPState                         = 0x3;

	// 0x10 ASG_Capabilities
    @sysvar::SDS_SD_ASG_Prop::x10_ASGCap_displaySizeClass               = 0;

	// 0x11 SDS_ContextState
    @sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_Attributes            = 0;
    @sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_AdditionalInfoType    = 0; 
    @sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_SDSContextType        = 0;
    @sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_SDS_ContextState      = 0;
    sysSetVariableString(sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_AdditionalText, "");
  
	// 0x14 InfoState
    @sysvar::SDS_SD_ASG_Prop::x14_InfoStates_States                     = 0;
}
/*@@end*/

/*@@caplFunc:BAP_createHeader(dword,dword[],dword,dword):*///function
BAP_createHeader (dword FctID, dword headerBuffer[], dword datalength, dword requestType)
{
    dword datatype, data;

    if(elCount(headerBuffer) != BAP_HEADER_SIZE)                            // Buffer not as big as specified.
    {
        writeLineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "Wrong BAP Header size in BAP_createHeader (dword FctID, byte[] headerBuffer)! Not %d but %d bytes long!", BAP_HEADER_SIZE, elCount(headerBuffer));
        return;
    }

    // first, get bap data type, length and data
    switch(FctID)
    {
        case GET_ALL_FCT_ID:
            datatype = GET_ALL_BAP_DATA_TYPE;
            data = 0;                                                       // byteSequence
            break;
        
        case BAP_CONFIG_FCT_ID:
            datatype = BAP_CONFIG_BAP_DATA_TYPE;
            data = 0;                                                       // byteSequence
            break;
        
        case FUNCTION_LIST_FCT_ID:
            datatype = FUNCTION_LIST_BAP_DATA_TYPE;
            data = 0;                                                       // byteSequence
            break;
        
        case HEART_BEAT_FCT_ID:
            datatype = HEART_BEAT_BAP_DATA_TYPE;
            data = @sysvar::SDS_SD_ASG::x04_HeartBeat_HeartBeatTime;
            break;
        
        case FSG_SETUP_FCT_ID:
            datatype = FSG_SETUP_BAP_DATA_TYPE;
            data = 0;                                                       // byteSequence
            break;
        
        case FSG_OPERATION_STATE_FCT_ID:
            datatype = FSG_OPERATION_STATE_BAP_DATA_TYPE;
            data = @sysvar::SDS_SD_ASG::x0F_FSGOPState_OPState;
            break;
        
        case ASG_CAPABILITIES_FCT_ID:
            if(requestType == DataGet_REQ)
                datatype = ASG_CAPABILITIES_BAP_DATA_TYPE_GET;
            if(requestType == DataSetGet_REQ)
                datatype = ASG_CAPABILITIES_BAP_DATA_TYPE_SETGET;
            data = 0;                                                       // byteSequence
            break;
        
        case SDS_CONTEXT_STATE_FCT_ID:
            datatype = SDS_CONTEXT_STATE_BAP_DATA_TYPE;
            data = 0;                                                       // byteSequence
            break;
        
        case COMMAND_LIST_FCT_ID:
            datatype = COMMAND_LIST_BAP_DATA_TYPE;
            data = 0;                                                       // byteSequence
            break;
        
        case RESULT_LIST_FCT_ID:
            datatype = RESULT_LIST_BAP_DATA_TYPE;
            data = 0;                                                       // byteSequence
            break;

        case INFOSTATES_FCT_ID:
            datatype = INFOSTATES_BAP_DATA_TYPE;
            data = 0;                                                       // byteSequence
            break;

        default:
            writeLineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "Unknown Fct-ID in BAP_createHeader (dword FctID): %d", FctID);
    }

    // Create header
    headerBuffer[0] = LSG_SDS_SD;					// LSG-ID
	headerBuffer[1] = FctID;		                // Fct-ID
	headerBuffer[2] = requestType;					// BAP requestType
	headerBuffer[3] = datatype;		                // BAP data-type (BapDataType_t)
	headerBuffer[4] = datalength;				    // Length for data type byte sequence
	headerBuffer[5] = data;                         // data (uint8/uint16/uint32 or Errorcode)
}
/*@@end*/

/*@@caplFunc:init_variables_controls():*///function
init_variables_controls ()
{
    @sysvar::SDS_SD_ASG::control_OnOff              = 0;
    @sysvar::SDS_SD_ASG::control_OnOff_indicator    = 0;
    enableControl("SDS_SD_ASG_Main", "Ctrl_OnOff", FALSE);
}
/*@@end*/

/*@@caplFunc:BAP_DLL_Request(byte,dword[],byte[]):*///function
int BAP_DLL_Request (byte request, dword Request_header[], byte Request_data[])
{
    int ret;                                                                                // Return value
    int i;

    Request_header[2] = request;
    
    if(elCount(Request_header)!= BAP_HEADER_SIZE)			                                // catch wrong header size
    {
        writeLineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "ASG: Wrong BAP Header size in BAP_DLL_Request (dword Request_header[], byte Request_data[])! Not %d but %d bytes long!", BAP_HEADER_SIZE, elCount(Request_header));
        return -1;
    }

    ret = Bap170_Request(NODE_INDEX, Request_header, Request_data);

    if(ret == 0x23) // BAP Stack Busy
    {
        if(Request_header[1] != 0x01)   // Hide GetAll (multiple calls by stack)
            writeLineEx(gBAP_Trace, CAPL_WRITE_LINE_WARNING, "ASG: BAP-Stack busy for Fct. 0x%x!", Request_header[1]);
    } else
    if(ret != 0)
    {
        writeLineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "ASG: BAP-Error in BAP_DLL_Request (dword Request_header[], byte Request_data[])! ErrorCode = 0x%x!", ret);

        for(i=0; i<elCount(Request_header); i++)
            writeLineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "Request_header[%d]=0x%x", i, Request_header[i]);
        for(i=0; i<Request_header[4]; i++)
            writeLineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "Request_data[%d]=0x%x", i, Request_data[i]);
    }
    return ret;
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_CommandList::x12_CommandList_control_down:*/
on sysvar sysvar::SDS_SD_ASG_CommandList::x12_CommandList_control_down
{
    if(@this)
    {
        CommandList_Data_illustrationOffset--;
        CommandList_actualize_sysvar();
    }
}
/*@@end*/

/*@@caplFunc:CommandList_actualize_sysvar():*///function
CommandList_actualize_sysvar ()
{
    int offset;
    int tnle;
    tnle = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TNLE;

    if(CommandList_Data_illustrationOffset==0xFFFFFFFF)     // scrolled up, overflow -> start with last element
        CommandList_Data_illustrationOffset = (tnle - 1);

    if(CommandList_Data_illustrationOffset == tnle )        // last element reached -> start with first element
        CommandList_Data_illustrationOffset = 0;

    offset = CommandList_Data_illustrationOffset;           // take offset for local incrementation
    
    // 1st element
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_pos_element1 = CommandList_Data_Pos[offset];
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_CommandID_element1 = CommandList_Data_CommandID[offset];
    sysSetVariableString(sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_CommandText_element1, CommandList_Data_CommandText[offset]);
    if(offset == (tnle-1) )                                 // last element reached, start from begin
        offset = 0;
    else                                                    // increase offset to get next element
        offset++;
    
    // 2nd element
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_pos_element2 = CommandList_Data_Pos[offset];
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_CommandID_element2 = CommandList_Data_CommandID[offset];
    sysSetVariableString(sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_CommandText_element2, CommandList_Data_CommandText[offset]);
    if(offset == (tnle-1) )                                 // last element reached, start from begin
        offset = 0;
    else                                                    // increase offset to get next element
        offset++;
    
    // 3rd element
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_pos_element3 = CommandList_Data_Pos[offset];
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_CommandID_element3 = CommandList_Data_CommandID[offset];
    sysSetVariableString(sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_CommandText_element3, CommandList_Data_CommandText[offset]);
    if(offset == (tnle-1) )                                 // last element reached, start from begin
        offset = 0;
    else                                                    // increase offset to get next element
        offset++;
    
    // 4th element
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_pos_element4 = CommandList_Data_Pos[offset];
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_CommandID_element4 = CommandList_Data_CommandID[offset];
    sysSetVariableString(sysvar::SDS_SD_ASG_CommandList::x12_CommandList_list_CommandText_element4, CommandList_Data_CommandText[offset]);
    if(offset == (tnle-1) )                                 // last element reached, start from begin
        offset = 0;
    else                                                    // increase offset to get next element
        offset++;

    // Adapt panel
    enableControl("SDS_SD_ASG_CommandList", "CommandList_Element1", FALSE);
    enableControl("SDS_SD_ASG_CommandList", "CommandList_Element2", FALSE);
    enableControl("SDS_SD_ASG_CommandList", "CommandList_Element3", FALSE);
    enableControl("SDS_SD_ASG_CommandList", "CommandList_Element4", FALSE);
    enableControl("SDS_SD_ASG_CommandList", "Ctrl_CommandList_Up",  FALSE);
    enableControl("SDS_SD_ASG_CommandList", "Ctrl_CommandList_Down", FALSE);

    if(tnle>0)
        enableControl("SDS_SD_ASG_CommandList", "CommandList_Element1", TRUE);
    if(tnle>1)
        enableControl("SDS_SD_ASG_CommandList", "CommandList_Element2", TRUE);
    if(tnle>2)
        enableControl("SDS_SD_ASG_CommandList", "CommandList_Element3", TRUE);
    if(tnle>3)
        enableControl("SDS_SD_ASG_CommandList", "CommandList_Element4", TRUE);
    if(tnle>4)
    {
        enableControl("SDS_SD_ASG_CommandList", "Ctrl_CommandList_Up",  TRUE);
        enableControl("SDS_SD_ASG_CommandList", "Ctrl_CommandList_Down", TRUE);
    }
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_ResultList::x13_ResultList_control_down:*/
on sysvar sysvar::SDS_SD_ASG_ResultList::x13_ResultList_control_down
{
    if(@this)
    {
        ResultList_Data_illustrationOffset--;
        ResultList_actualize_sysvar();
    }
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_ResultList::x13_ResultList_control_up:*/
on sysvar sysvar::SDS_SD_ASG_ResultList::x13_ResultList_control_up
{
    if(@this)
    {
        ResultList_Data_illustrationOffset++;
        ResultList_actualize_sysvar();
    }
}
/*@@end*/

/*@@caplFunc:init_variables_array_ResultList():*///function
init_variables_array_ResultList ()
{
    long i;

    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TNLE                        = 0;

    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_direction                = 0;
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_elements_hex             = 4;
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_indexSize                = 0;
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_recordAddress            = 0;
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_shift                    = 0;

    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_start_hex                = 0;
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_transmitPos              = 0;

    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_ASGID                       = 0;
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TAID_hex                    = 1;

    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_control_OnOff               = 0;

    for(i=0; i<elCount(ResultList_Data_Pos); i++)
        ResultList_Data_Pos[i] = (i+1);

    ResultList_actualize_sysvar ();
}
/*@@end*/

/*@@caplFunc:ResultList_actualize_sysvar():*///function
ResultList_actualize_sysvar ()
{
    int offset;
    int tnle;
    tnle = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TNLE;

    if(ResultList_Data_illustrationOffset==0xFFFFFFFF)     // scrolled up, overflow -> start with last element
        ResultList_Data_illustrationOffset = (tnle - 1);

    if(ResultList_Data_illustrationOffset == tnle )        // last element reached -> start with first element
        ResultList_Data_illustrationOffset = 0;

    offset = ResultList_Data_illustrationOffset;           // take offset for local incrementation

    // 1st element
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_pos_element1 = ResultList_Data_Pos[offset];
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_ResultType_element1 = ResultList_Data_ResultType[offset];
    sysSetVariableString(sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_ResultText_element1, ResultList_Data_ResultText[offset]);
    if(offset == (tnle-1) )                                 // last element reached, start from begin
        offset = 0;
    else                                                    // increase offset to get next element
        offset++;
    
    // 2nd element
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_pos_element2 = ResultList_Data_Pos[offset];
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_ResultType_element2 = ResultList_Data_ResultType[offset];
    sysSetVariableString(sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_ResultText_element2, ResultList_Data_ResultText[offset]);
    if(offset == (tnle-1) )                                 // last element reached, start from begin
        offset = 0;
    else                                                    // increase offset to get next element
        offset++;
    
    // 3rd element
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_pos_element3 = ResultList_Data_Pos[offset];
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_ResultType_element3 = ResultList_Data_ResultType[offset];
    sysSetVariableString(sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_ResultText_element3, ResultList_Data_ResultText[offset]);
    if(offset == (tnle-1) )                                 // last element reached, start from begin
        offset = 0;
    else                                                    // increase offset to get next element
        offset++;

    // 4th element
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_pos_element4 = ResultList_Data_Pos[offset];
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_ResultType_element4 = ResultList_Data_ResultType[offset];
    sysSetVariableString(sysvar::SDS_SD_ASG_ResultList::x13_ResultList_list_ResultText_element4, ResultList_Data_ResultText[offset]);
    if(offset == (tnle-1) )                                 // last element reached, start from begin
        offset = 0;
    else                                                    // increase offset to get next element
        offset++;

    // Adapt panel
    enableControl("SDS_SD_ASG_ResultList", "ResultList_Element1", FALSE);
    enableControl("SDS_SD_ASG_ResultList", "ResultList_Element2", FALSE);
    enableControl("SDS_SD_ASG_ResultList", "ResultList_Element3", FALSE);
    enableControl("SDS_SD_ASG_ResultList", "ResultList_Element4", FALSE);
    enableControl("SDS_SD_ASG_ResultList", "Ctrl_ResultList_Up",  FALSE);
    enableControl("SDS_SD_ASG_ResultList", "Ctrl_ResultList_Down", FALSE);

    if(tnle>0)
        enableControl("SDS_SD_ASG_ResultList", "ResultList_Element1", TRUE);
    if(tnle>1)
        enableControl("SDS_SD_ASG_ResultList", "ResultList_Element2", TRUE);
    if(tnle>2)
        enableControl("SDS_SD_ASG_ResultList", "ResultList_Element3", TRUE);
    if(tnle>3)
        enableControl("SDS_SD_ASG_ResultList", "ResultList_Element4", TRUE);
    if(tnle>4)
    {
        enableControl("SDS_SD_ASG_ResultList", "Ctrl_ResultList_Up",  TRUE);
        enableControl("SDS_SD_ASG_ResultList", "Ctrl_ResultList_Down", TRUE);
    }
}
/*@@end*/

/*@@caplFunc:Indication_0x11_SDS_ContextState(dword[],byte[],int):*///function
Indication_0x11_SDS_ContextState (dword indication_header [], byte indication_data[], int datalength)
{
    word wordBuffer;
    byte textlength;
    int i;
    char stringBuffer[BAP_BUFFER_SIZE];

    // clear variables
    wordBuffer = 0;
    for(i=0; i<elCount(stringBuffer); i++)
        stringBuffer[i] = 0;

    switch (indication_header[2])
	{
		case Data_IND:
			@sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_SDS_ContextState = indication_data[0];
            @sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_SDSContextType = indication_data[1];
            @sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_Attributes = indication_data[2];
            wordBuffer |= indication_data[5];
            wordBuffer = wordBuffer << 8;
            wordBuffer |= indication_data[4];
            @sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_AdditionalInfoType = wordBuffer;
            textlength = indication_data[6];
            for(i=0; i<textlength; i++)
                stringBuffer[i] = indication_data[7+i];
            sysSetVariableString(sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_AdditionalText, stringBuffer);
            @sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_extension = indication_data[8+i];
            break;

        case Error_IND:
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "SDS_SD_ASG: Error-Indication in Indication_0x11_SDS_ContextState: Error 0x%x", indication_header[5]);
		    break;

        default:
			writelineEx(gBAP_Trace, CAPL_WRITE_LINE_INFORMATION, "SDS_SD_ASG: Unhandled indication 0x%x in Indication_0x11_SDS_ContextState.", indication_header[2]);
		    break;
	}
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_CommandList::x12_CommandList_control_up:*/
on sysvar sysvar::SDS_SD_ASG_CommandList::x12_CommandList_control_up
{
    if(@this)
    {
        CommandList_Data_illustrationOffset++;
        CommandList_actualize_sysvar();
    }
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG::x0E_FSGSetup_get:*/
on sysvar sysvar::SDS_SD_ASG::x0E_FSGSetup_get
{
    if(@this)
        Request_0x0E_FSG_Setup(DataGet_REQ_CAN);
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG::x04_HeartBeat_HeartBeatTime_get:*/
on sysvar sysvar::SDS_SD_ASG::x04_HeartBeat_HeartBeatTime_get
{
    if(@this)
        Request_0x04_HeartBeat(DataGet_REQ_CAN);
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG::x03_FctList_get:*/
on sysvar sysvar::SDS_SD_ASG::x03_FctList_get
{
    if(@this)
        Request_0x03_FunctionList(DataGet_REQ_CAN);
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_Prop::x10_ASGCap_get:*/
on sysvar sysvar::SDS_SD_ASG_Prop::x10_ASGCap_get
{
    if(@this)
        Request_0x10_ASG_Capabilities(DataGet_REQ_CAN);
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_Prop::x10_ASGCap_setGet:*/
on sysvar sysvar::SDS_SD_ASG_Prop::x10_ASGCap_setGet
{
    if(@this)
        Request_0x10_ASG_Capabilities(DataSetGet_REQ);
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_Prop::x14_InfoStates_get:*/
on sysvar sysvar::SDS_SD_ASG_Prop::x14_InfoStates_get
{
    if(@this)
        Request_0x14_InfoState(DataGet_REQ_CAN);
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_Prop::x11_SDSContextState_get:*/
on sysvar sysvar::SDS_SD_ASG_Prop::x11_SDSContextState_get
{
    if(@this)
        Request_0x11_SDS_ContextState(DataGet_REQ_CAN);
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_CommandList::x12_CommandList_control_GetArray:*/
on sysvar sysvar::SDS_SD_ASG_CommandList::x12_CommandList_control_GetArray
{
    if(@this)
    {
        Request_0x12_CommandList (DataGet_REQ);

        if(@sysvar::SDS_SD_General::Smart)
        {
            if(@sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TAID_hex >= 0xF)
                @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TAID_hex = 1;
            else
                @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TAID_hex = (@sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TAID_hex + 1);
        }
    }
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_ResultList::x13_ResultList_control_GetArray:*/
on sysvar sysvar::SDS_SD_ASG_ResultList::x13_ResultList_control_GetArray
{
    if(@this)
    {
        Request_0x13_ResultList (DataGet_REQ);
        
        if(@sysvar::SDS_SD_General::Smart)
        {
            if(@sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TAID_hex >= 0xF)
                @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TAID_hex = 1;
            else
                @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TAID_hex = (@sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TAID_hex + 1);
        }
    }
}
/*@@end*/

/*@@caplFunc:Request_0x0E_FSG_Setup(byte):*///function
Request_0x0E_FSG_Setup(byte request)
{
    dword header [BAP_HEADER_SIZE];
    byte data[1];

    switch(request)
    {
        case DataGet_REQ_CAN:
            /*** NO FUNCTION WITH BAP DLL (CacheAvailability=true) -> Call via CAN ***/
            CAN_sendGetMessage(FSG_SETUP_FCT_ID);
            break;
        
        case DataGet_REQ:
            /*** Cache data request ***/
            BAP_createHeader(FSG_SETUP_FCT_ID, header, elCount(data), request);
            BAP_DLL_Request(request, header, data);
            break;

        default:
            break;
    }
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG::x0F_FSGOPState_get:*/
on sysvar sysvar::SDS_SD_ASG::x0F_FSGOPState_get
{
    if(@this)
        Request_0x0F_FSG_OperationState(DataGet_REQ_CAN);
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG::x02_BAPConfig_get:*/
on sysvar sysvar::SDS_SD_ASG::x02_BAPConfig_get
{
    if(@this)
        Request_0x02_BAP_Config(DataGet_REQ_CAN);
}
/*@@end*/

/*@@caplFunc:Request_0x02_BAP_Config(byte):*///function
void Request_0x02_BAP_Config(byte request)
{
    dword header [BAP_HEADER_SIZE];
    byte data[1];

    switch(request)
    {
        case DataGet_REQ_CAN:
            /*** NO FUNCTION WITH BAP DLL (CacheAvailability=true) -> Call via CAN ***/
            CAN_sendGetMessage(BAP_CONFIG_FCT_ID);
            break;
        
        case DataGet_REQ:
            /*** Cache data request ***/
            BAP_createHeader(BAP_CONFIG_FCT_ID, header, elCount(data), request);
            BAP_DLL_Request(request, header, data);
            break;

        default:
            break;
    }
}
/*@@end*/

/*@@caplFunc:controls_setFunctionActive(int,int):*///function
controls_setFunctionActive (int fctID, int bool)
{
    switch (fctID)
    {
        case GET_ALL_FCT_ID:
            enableControl("SDS_SD_ASG_Main", "Ctrl_GetAll", bool);
            break;

        case BAP_CONFIG_FCT_ID:
            enableControl("SDS_SD_ASG_Main", "Ctrl_BAP_Config", bool);
            break;

        case FUNCTION_LIST_FCT_ID:
            enableControl("SDS_SD_ASG_Main", "Ctrl_FctList", bool);
            break;

        case HEART_BEAT_FCT_ID:
            enableControl("SDS_SD_ASG_Main", "Ctrl_Heartbeat", bool);
            break;

        case FSG_SETUP_FCT_ID:
            enableControl("SDS_SD_ASG_Main", "Ctrl_FSG_Setup", bool);
            break;

        case FSG_OPERATION_STATE_FCT_ID:
            enableControl("SDS_SD_ASG_Main", "Ctrl_FSG_OPState", bool);
            break;

        case ASG_CAPABILITIES_FCT_ID:
            enableControl("SDS_SD_ASG_Properties", "Ctrl_Properties_ASGCapabilities", bool);
            break;

        case SDS_CONTEXT_STATE_FCT_ID:
            enableControl("SDS_SD_ASG_Properties", "Ctrl_Properties_SDSContextState", bool);
            break;

        case COMMAND_LIST_FCT_ID:
            enableControl("SDS_SD_ASG_Main", "Btn_CommandList", bool);
            break;

        case RESULT_LIST_FCT_ID:
            enableControl("SDS_SD_ASG_Main", "Btn_ResultList", bool);
            break;

        case INFOSTATES_FCT_ID:
            enableControl("SDS_SD_ASG_Properties", "Ctrl_Properties_Infostates", bool);
            break;
        
        default:
            break;
    }
}
        
/*@@end*/

/*@@caplFunc:controls_enable_all():*///function
controls_enable_all ()
{
    byte fctIDs[11] = {GET_ALL_FCT_ID, BAP_CONFIG_FCT_ID, FUNCTION_LIST_FCT_ID, HEART_BEAT_FCT_ID, FSG_SETUP_FCT_ID, FSG_OPERATION_STATE_FCT_ID, ASG_CAPABILITIES_FCT_ID, SDS_CONTEXT_STATE_FCT_ID, COMMAND_LIST_FCT_ID, RESULT_LIST_FCT_ID, INFOSTATES_FCT_ID};
    int idx;
    
    // Disable all
    for(idx=0; idx<elCount(fctIDs); idx++)
        controls_setFunctionActive(fctIDs[idx], FALSE);
        
    enableControl("SDS_SD_ASG_Main", "Btn_Properties", FALSE);
    
    if(@sysvar::SDS_SD_General::Smart)
    {
        // Only enable related to FctList, if ON
        if(@sysvar::SDS_SD_ASG::control_OnOff)
        {
            if(@sysvar::SDS_SD_ASG::x03_FctList_0x01_GetAll)
                controls_setFunctionActive(GET_ALL_FCT_ID, TRUE);

            if(@sysvar::SDS_SD_ASG::x03_FctList_0x02_BAPConfig)
                controls_setFunctionActive(BAP_CONFIG_FCT_ID, TRUE);
        
            if(@sysvar::SDS_SD_ASG::x03_FctList_0x03_FctList)
                controls_setFunctionActive(FUNCTION_LIST_FCT_ID, TRUE);
            
            if(@sysvar::SDS_SD_ASG::x03_FctList_0x04_HeartBeat)
                controls_setFunctionActive(HEART_BEAT_FCT_ID, TRUE);

            if(@sysvar::SDS_SD_ASG::x03_FctList_0x0E_FSGSetup)
                controls_setFunctionActive(FSG_SETUP_FCT_ID, TRUE);

            if(@sysvar::SDS_SD_ASG::x03_FctList_0x0F_FSGOPState)
                controls_setFunctionActive(FSG_OPERATION_STATE_FCT_ID, TRUE);

            if(@sysvar::SDS_SD_ASG::x03_FctList_0x10_ASGCap)
                controls_setFunctionActive(ASG_CAPABILITIES_FCT_ID, TRUE);

            if(@sysvar::SDS_SD_ASG::x03_FctList_0x11_SDSContextState)
                controls_setFunctionActive(SDS_CONTEXT_STATE_FCT_ID, TRUE);

            if(@sysvar::SDS_SD_ASG::x03_FctList_0x12_CommandList)
                controls_setFunctionActive(COMMAND_LIST_FCT_ID, TRUE);
        
            if(@sysvar::SDS_SD_ASG::x03_FctList_0x13_ResultList)
                controls_setFunctionActive(RESULT_LIST_FCT_ID, TRUE);
        
            if(@sysvar::SDS_SD_ASG::x03_FctList_0x14_InfoStates)
                controls_setFunctionActive(INFOSTATES_FCT_ID, TRUE);

            // Subpanels
            if(@sysvar::SDS_SD_ASG::x03_FctList_0x10_ASGCap || @sysvar::SDS_SD_ASG::x03_FctList_0x11_SDSContextState || @sysvar::SDS_SD_ASG::x03_FctList_0x14_InfoStates)
                enableControl("SDS_SD_ASG_Main", "Btn_Properties", TRUE);
        }
    }
    else // not smart, all on
    {
        for(idx=0; idx<elCount(fctIDs); idx++)
            controls_setFunctionActive(fctIDs[idx], TRUE);
        
        enableControl("SDS_SD_ASG_Main", "Btn_Properties", TRUE);
    }
}
/*@@end*/

/*@@sysvarUpdate:SDS_SD_ASG::control_OnOff:*/
on sysvar sysvar::SDS_SD_ASG::control_OnOff
{
	if(@this)               // Startup
    {
        init_SDS_SD();
        setTimer(TaskTimer, 10);
    }
	else                    // Must be a shutdown.	
    {
        Shutdown_SDS_SD();
        cancelTimer(TaskTimer);
    } 

    controls_enable_all();
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG::x01_GetAll_get:*/
on sysvar sysvar::SDS_SD_ASG::x01_GetAll_get
{
    if(@this)
        Request_0x01_GetAll(DataGet_REQ_CAN);
}
/*@@end*/

/*@@caplFunc:Array_DecodeModeByte_getShift(byte):*///function
byte Array_DecodeModeByte_getShift (byte ModeByte)
{
    byte ret;
    ret = 0;

    ret = (ModeByte & 0x10) >> 4;

    return ret;
}
/*@@end*/

/*@@caplFunc:Array_DecodeModeByte_getDirection(byte):*///function
byte Array_DecodeModeByte_getDirection (byte ModeByte)
{
    byte ret;
    ret = 0;

    ret = (ModeByte & 0x20) >> 5;  
                                                       
    return ret;
}
/*@@end*/

/*@@caplFunc:Array_DecodeModeByte_getTransmitPos(byte):*///function
byte Array_DecodeModeByte_getTransmitPos (byte ModeByte)
{
    byte ret;
    ret = 0;

    ret = (ModeByte & 0x40) >> 6;

    return ret;
}
/*@@end*/

/*@@caplFunc:Array_DecodeModeByte_getIdxSize(byte):*///function
byte Array_DecodeModeByte_getIdxSize (byte ModeByte)
{
    byte ret;
    ret = 0;

    ret = (ModeByte & 0x80) >> 7;

    return ret;
}
/*@@end*/

/*@@caplFunc:Array_DecodeModeByte_getRecordAddress(byte):*///function
byte Array_DecodeModeByte_getRecordAddress (byte ModeByte)
{
    byte ret;
    ret = 0;

    ret = (ModeByte & 0x0F);

    return ret;
}
/*@@end*/

/*@@caplFunc:Array_DecodeFirstByte_getASGID(byte):*///function
byte Array_DecodeFirstByte_getASGID (byte dataByte)
{
    byte ret;
    ret = 0;

    ret |= (dataByte & 0xF0) >> 4;
                                                       
    return ret;
}
/*@@end*/

/*@@caplFunc:Array_DecodeFirstByte_getTAID(byte):*///function
byte Array_DecodeFirstByte_getTAID (byte dataByte)
{
    byte ret;
    ret = 0;

    ret |= (dataByte & 0x0F);   // databyte has to be indication_data[0]
                                                       
    return ret;
}
/*@@end*/

/*@@caplFunc:Array_createModeByte(byte,byte,byte,byte,byte):*///function
byte Array_createModeByte (byte shift, byte direction, byte transmitPos, byte idxSize, byte recordAddress)
{
    byte byteBuffer;
    byteBuffer = 0;

    if(shift)
        byteBuffer += (1);
    
    if(direction)
        byteBuffer += (1 << 1);
    
    if(transmitPos)
        byteBuffer += (1 << 2);
    
    if(idxSize)
        byteBuffer += (1 << 3);

    byteBuffer = (byteBuffer << 4);                                                          // upper nibble = Mode byte
    byteBuffer += recordAddress;                                                            // lower nibble = RecordAddress

    return byteBuffer;
}
/*@@end*/

/*@@caplFunc:Array_createHeader_get(byte[],word,word,byte,byte,byte,byte):*///function
int Array_createHeader_get (byte buffer[], word start_el, word elements, byte ASG_ID, byte TAID, byte modeByte, byte idxSize)
{
    byte byteBuffer;
    int nextPos;
    nextPos = 0;

    byteBuffer = 0;
    byteBuffer = (ASG_ID << 4);
    byteBuffer += TAID;
    buffer[0] = byteBuffer;

    buffer[1] = modeByte;

    if(idxSize == 0)                                                                        // 8 bit addressing
    {
        buffer[2] = start_el;
        buffer[3] = elements;
        nextPos = 4;
    }
    else                                                                                    // 16 bit addressing
    {
        byteBuffer = 0;
        byteBuffer = (start_el & 0xFF00) >> 8;
        buffer[2] = byteBuffer;

        byteBuffer = 0;
        byteBuffer = (start_el & 0x00FF);
        buffer[3] = byteBuffer;

        byteBuffer = 0;
        byteBuffer = (elements & 0xFF00) >> 8;
        buffer[4] = byteBuffer;

        byteBuffer = 0;
        byteBuffer = (elements & 0x00FF);
        buffer[5] = byteBuffer;

        nextPos = 6;
    }

    return nextPos;
}
/*@@end*/

/*@@timer:initTimer:*/
on timer initTimer
{
    @sysvar::SDS_SD_ASG::control_OnOff_indicator = 1;
}
/*@@end*/

/*@@caplFunc:CommandList_clearData():*///function
CommandList_clearData ()
{
    int i = 0;
    int j = 0;

	for(i=0;i<COMMANDLIST_ENTRIES;i++) 
	{
		CommandList_Data_Pos[i] = 0;
        CommandList_Data_CommandID[i] = 0;

		for(j=0;j<COMMANDLIST_COMMANDTEXT_LENGTH;j++)
			CommandList_Data_CommandText[i][j] =0;
	}
    
    // Anctualize system variables for Panel
    CommandList_Data_illustrationOffset = 0;
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TNLE = 0;
    CommandList_actualize_sysvar ();
}
/*@@end*/

/*@@caplFunc:ResultList_clearData():*///function
ResultList_clearData ()
{
    int i = 0;
    int j = 0;

	for(i=0;i<RESULT_LIST_ENTRIES;i++) 
	{
		ResultList_Data_Pos[i] = 0;
        ResultList_Data_ResultType[i] = 0;

		for(j=0;j<RESULT_LIST_RESULTTEXT_LENGTH;j++)
			ResultList_Data_ResultText[i][j] =0;
	}

    // Anctualize system variables for Panel
    ResultList_Data_illustrationOffset = 0;
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TNLE = 0;
    ResultList_actualize_sysvar ();
}
/*@@end*/

/*@@caplFunc:ResultList_getElement(int):*///function
ResultList_getElement (int startElement)
{
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_ASGID            = RESULT_LIST_ASGID;        // Individual ASG ID
    
    if(@sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TAID_hex >= 0xF)
        @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TAID_hex = 1;
    else
        @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TAID_hex = (@sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TAID_hex + 1);

    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_shift         = 0;                        // No Shift
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_direction     = 0;                        // Forwards
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_transmitPos   = 1;                        // Transmit ArrayPos
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_indexSize     = 0;                        // 8 Bit
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_recordAddress = RESULT_LIST_TYPE_TEXT;    // Full data
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_start_hex     = startElement;             // following entry 
    @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_AH_elements_hex  = 1;                        // each element individual

    // Request new Array data
    ResultList_Data_lastRequestedTAID = @sysvar::SDS_SD_ASG_ResultList::x13_ResultList_TAID_hex;
    Request_0x13_ResultList (DataGet_REQ); 
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_ResultList::x13_ResultList_control_OnOff:*/
on sysvar sysvar::SDS_SD_ASG_ResultList::x13_ResultList_control_OnOff
{
    ResultList_clearData ();

    if(@this)
        ResultList_getElement(1);
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG_CommandList::x12_CommandList_control_onOff:*/
on sysvar sysvar::SDS_SD_ASG_CommandList::x12_CommandList_control_onOff
{
    CommandList_clearData ();
    
    if(@this)
        CommandList_getElement(1);
}
/*@@end*/

/*@@caplFunc:CommandList_getElement(int):*///function
CommandList_getElement (int startElement)
{
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_ASGID            = COMMANDLIST_ASGID;              // Individual ASG ID

    if(@sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TAID_hex >= 0xF)
        @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TAID_hex = 1;
    else
        @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TAID_hex = (@sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TAID_hex + 1);

    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_shift         = 0;                              // No Shift
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_direction     = 0;                              // Forwards
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_transmitPos   = 1;                              // Transmit ArrayPos
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_indexSize     = 0;                              // 8 Bit
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_recordAddress = COMMANDLIST_RECADDR_ID_TEXT;    // Full data
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_start_hex     = startElement;                   // following entry 
    @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_AH_elements_hex  = 1;                              // each element individual

    // Request new Array data
    CommandList_Data_lastRequestedTAID = @sysvar::SDS_SD_ASG_CommandList::x12_CommandList_TAID_hex;
    Request_0x12_CommandList (DataGet_REQ); 
}
/*@@end*/

/*@@caplFunc:CAN_sendGetMessage(byte):*///function
CAN_sendGetMessage (byte function)
{
    ASG_CAN_Message.DLC      = ASG_GET_MESSAGE_DLC;
    ASG_CAN_Message.byte(0)  = ASG_GET_MESSAGE_BYTE0;
    ASG_CAN_Message.byte(1)  = function;
    output(ASG_CAN_Message);
}
/*@@end*/

/*@@caplFunc:Indication_0x01_GetAll(dword[],byte[],int):*///function
void Indication_0x01_GetAll(dword indication_header [], byte indication_data[], int datalength)
{
    switch (indication_header[2])
	{
		case Data_IND:
            Request_0x04_HeartBeat(DataGet_REQ);
            Request_0x0E_FSG_Setup(DataGet_REQ);
            Request_0x0F_FSG_OperationState(DataGet_REQ);
            Request_0x10_ASG_Capabilities(DataGet_REQ);
            Request_0x11_SDS_ContextState(DataGet_REQ);
            Request_0x14_InfoState(DataGet_REQ);
            break;

        case Error_IND:
            writelineEx(gError_Trace, CAPL_WRITE_LINE_ERROR, "SDS_SD_ASG: Error-Indication in Indication_0x01_GetAll: Error 0x%x", indication_header[5]);
		    break;

        default:
			writelineEx(gBAP_Trace, CAPL_WRITE_LINE_INFORMATION, "SDS_SD_ASG: Unhandled indication 0x%x in Indication_0x01_GetAll.", indication_header[2]);
		    break;
	} 
}
/*@@end*/

/*@@sysvarUpdate:SDS_SD_General::Smart:*/
on sysvar sysvar::SDS_SD_General::Smart
{
    controls_enable_all();
}
/*@@end*/

/*@@sysvarChange:SDS_SD_ASG::control_OnOff_indicator:*/
on sysvar sysvar::SDS_SD_ASG::control_OnOff_indicator
{
    if(@this)
        enableControl("SDS_SD_ASG_Main", "Ctrl_OnOff", TRUE);
    else
        enableControl("SDS_SD_ASG_Main", "Ctrl_OnOff", FALSE);
}
/*@@end*/

