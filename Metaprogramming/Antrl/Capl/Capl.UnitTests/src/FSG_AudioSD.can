/*@!Encoding:1252*/
includes
{ 
  #include "..\..\_DLL\latest_BAP_DLL.cin" 
}
/* Global variables for the AudioSD CANoe BAP simulation */
variables
{
  //***********************************Config Files********************************
  char dbc_path[255] = "BAP\\AudioSD_P30DF50_v3.00_F_man_FSG49\\DBs\\MQB2020.MQB_W_ICAN_KMatrix_V9.04F_20171214_MB.dbc";                //relative path for dbc-file				
  char dbce_path[255] = "BAP\\AudioSD_P30DF50_v3.00_F_man_FSG49\\DBs\\MQB_V7.19F_AR421_20170529.arxml";//relative path for dbc-file  
  char xml_path[255]  = "BAP\\AudioSD_P30DF50_v3.00_F_man_FSG49\\XML\\BAP_SW18_MIB3_OI_MQB37W_CP_V1_11_F_mod.xml";       //relative path for xml-file
  char xmle_path[255] = "BAP\\AudioSD_P30DF50_v3.00_F_man_FSG49\\XML\\BAP_SW18_MIB3_OI_MQB37W_AP_V1_10_F_mod.xml"; //ethernet
  
  
  //*************************General Variables*************************************
  // general values for readable code
  const FALSE             = 0;
  const TRUE              = 1;
  const NULL              = 0x00;
  const VALID             = 0x01;
  const INVALID           = 0x00;
  const FORWARD           = 0;
  const BACKWARD          = 1;
  char empty_string[3] = { 0, 0, 0 };
  char gstring_reserved[10] = "reserved";
  char gstring_defect[10] = "defect";
  char gstring_not_supported[20] = "not supported";
  char gstring_unknown[20] = "unknown";
  //BAP Data Type 
  const Bap_Void              = 0;
  const Bap_UInt8             = 1;
  const Bap_UInt16            = 2;
  const Bap_UInt32            = 3;
  const Bap_ByteSequence      = 4;
  const Bap_Error             = 5;
  const Bap_Acknowledge       = 6;
  //BAP request types (FSG)
  const Data_REQ          = 0x03;
  const DataAck           = 0x0A;
  const Changed_REQ       = 0x04;
  const Processing_REQ    = 0x08;
  const Result_REQ        = 0x09;
  const Invalid_REQ       = 0x1F;  // Interne Kennzeichnung fuer einen ungueltigen Request
  //eigene Error-Definition
  const Error_REQ= 0x55;
  //BAP indication types (FSG)
  const DataSetGet_IND    = 0x06;
  const DataSet_IND       = 0x07;
  const DataGet_IND       = 0x08;
  const Acknowledge_Ind   = 0x09;
  const Processing_CNF    = 0x0A;
  const Start_IND         = 0x0B;
  const StartResult_IND   = 0x0C;
  const Abort_IND         = 0x0D;
  const Invalid_IND       = 0x1F;  // Interne Kennzeichnung fuer eine ungueltige Indication
  //eigene Error-Definition
  const Error_IND= 0x55;
  // BAP and BAL error codes
  const BAP_NO_ERROR               = 0x00;
  const BAP_BAL_OUT_OF_RANGE       = 0x41;
  const BAP_BAL_TEMP_NOT_AVAILABLE = 0x42;
  const BAP_BAL_MAX_DL_EXCEEDED    = 0x43;
  const BAP_BAL_UNIT_MISMATCH      = 0x44;
  // Error codes from BAP API (refer to BAP manual)
  const BAP_ERR_OK = 0x00;
  //Array's
  //values for reading *.csv-file
  const AUDIO_DEFAULT_LIST  = 0;
  const AUDIO_EXTERNAL_LIST = 1;
  const AUDIO_FILENAME_SIZE = 50;
  const AUDIO_BUFFERSIZE    = 0xFFFF;
  const AUDIO_TEXTLENGTH    = 500;
  const AUDIO_TEXTLENGTH_URI    = 600;
  //other
  byte gErrorCode;
  byte gAudioSD_PowerOnOff = FALSE;
  const POWER_OFF = 0x00;
  const POWER_ON  = 0x01;
  byte gBAP_Init = FALSE;
  char gstring_PowerOnOff[2][4]={ "Off",
         							            "On"};
  dword gRGB_red;
  dword gRGB_yellow;
  dword gRGB_green;
  dword gRGB_grey;
  dword gRGB_white;
  //Ethernet
  struct UdpSocket{
    dword Handle;
    dword Id;
  };
  struct UdpSocket gUdpSockets[5];
  dword gUdpSocketCnt;
  int canEthernetDecider;
  
  //*************************BAP node**********************************************
  //Timers
  mstimer TaskTimer;                                                  //timer for BAP-Task
  mstimer Powerontimer;
  mstimer StartFSG_Timer;                                             //timer for start simulation FSG    
  // node index and LSG-IDs
  dword NODE_INDEX;
  const LSG_AudioSD   = 0x31;
  // BAP and LSG-Version information (these are not used, just informations; see XML-file for current definitions!)
  const BAP_VERSION_MAJOR = 0x03;
  const BAP_VERSION_MINOR = 0x01;
  const LSG_CLASS_1       = LSG_AudioSD;
  const LSG_SUBCLASS_1    = 0x00;
  const LSG_VERSION_MAJOR = 0x05;
  const LSG_VERSION_MINOR = 0x00;
  // Function-IDs
  //common function-IDs
  const FctID_GetAll                = 0x01;
  const FctID_BAP_Config            = 0x02;
  const FctID_FunctionList          = 0x03;
  const FctID_HeartBeat             = 0x04;
  const FctID_FSG_Control           = 0x0D;
  const FctID_FSG_Setup             = 0x0E;
  const FctID_FSG_OperationState    = 0x0F;
  // specific function-IDs
  const FctID_ASG_Capabilities      = 0x10;
  const FctID_InfoStates            = 0x11;
  const FctID_SDS_State             = 0x12;
  const FctID_GeneralInfoSwitches   = 0x13;
  const FctID_ActiveSource          = 0x14;
  const FctID_ActiveSourceName      = 0x15;
  const FctID_CurrentVolume         = 0x16;
  const FctID_SourceState           = 0x17;
  const FctID_CurrentStationInfo    = 0x18;
  const FctID_CurrentStation_Handle = 0x19;
  const FctID_PlayPosition          = 0x1A;
  const FctID_Station_Track_Switch  = 0x1B;
  const FctID_AnnouncementInfo      = 0x1C;
  const FctID_AnnouncementEscape    = 0x1D;
  const FctID_ReceptionList         = 0x1E;
  const FctID_RadioTV_PresetList    = 0x1F;
  const FctID_ListSetup             = 0x20;
  const FctID_SourceList            = 0x21;
  const FctID_DedicatedAudioControl = 0x22;
  const FctID_SwitchSource          = 0x23;
  const FctID_Browser_FolderLevel   = 0x24;
  const FctID_Browser               = 0x25;
  const FctID_BrowserPath           = 0x26;
  const FctID_BrowserControl        = 0x27;
  const FctID_Picture               = 0x28;
  
  //***********************************BAP buffer**********************************
  const REQUESTBUFFER_LINES   = 100;
  const BAP_BUFFER_SIZE       = 4000;
  int gBAP_Requestbuffer_status[REQUESTBUFFER_LINES];             //datalength
  int gBAP_Requestbuffer_BAPDataTyp[REQUESTBUFFER_LINES];         //data type
  dword gBAP_Indication[BAP_BUFFER_SIZE];                             //Bap-Indication-buffer
  dword gBAP_Request[REQUESTBUFFER_LINES] [BAP_BUFFER_SIZE];			//ringbuffer for BAP-Request
  int gwrite_requestbuffer_line = 0;                                  //next free position
  int gstatus_requestbuffer = 0;                                 //next position to send
  const gBAP_datalength_error = 0x41;
  
  //***********************************Output windows******************************
  dword gBAP_Trace, gError_Trace;
  dword gReceptionList_writeWindow;
  dword gSourceList_writeWindow;
  dword gRadioTVPresetList_writeWindow;
  dword gMediaBrowser_writeWindow;
  dword gPicture_writeWindow;
  
  //*************************************************************************
  //*****************Fct-IDs*************************************************
  //*************************************************************************

  /***FunctionList***/
  byte gFunctionList[8] ={0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0,
                          0};

  /***FSG-Control***/
  byte gAudioSD_FSGControl_Extension1 = 0;
  byte gAudioSD_FSGControl_Extension2 = 0;
  byte gAudioSD_FSGControl_Extension3 = 0;
  byte gAudioSD_FSGControl_Extension4 = 0;
  byte gAudioSD_FSGControl_Extension5 = 0;
  byte gAudioSD_FSGControl_Extension6 = 0;
  
  /***FSG-Setup***/  
  byte gAudioSD_FSGSetup_FunctionSupport = 0;
  byte gAudioSD_FSGSetup_FunctionSupport_Bit0 = 0;
  byte gAudioSD_FSGSetup_FunctionSupport_Bit1 = 0;
  byte gAudioSD_FSGSetup_FunctionProtection = 0;
  byte gAudioSD_FSGSetup_FunctionProtection_Bit0 = 0;
  byte gAudioSD_FSGSetup_WebAppState = 0;
  byte gAudioSD_FSGSetup_WebAppState_Bit0 = 0;
  byte gAudioSD_FSGSetup_Extension1 = 0;
  byte gAudioSD_FSGSetup_Extension2 = 0;
  byte gAudioSD_FSGSetup_Extension3 = 0;
  byte gAudioSD_FSGSetup_Extension4 = 0;

  /*** FSG-OperationState***/
  const FSGOPERATIONSTATE_NORMALOPERATION = 0x00;
  const FSGOPERATIONSTATE_OFF             = 0x01;
  const FSGOPERATIONSTATE_INITIALIZING    = 0x03;
  const FSGOPERATIONSTATE_DEFECT          = 0x0F;
  byte gAudioSD_FSGOperationState_OpState = FSGOPERATIONSTATE_OFF;
  byte gAudioSD_FSGOperationState_Extension1 = 0;
  byte gAudioSD_FSGOperationState_Extension2 = 0;
  byte gAudioSD_FSGOperationState_Extension3 = 0;
  byte gAudioSD_FSGOperationState_Extension4 = 0;
  byte gAudioSD_FSGOperationState_Extension5 = 0;

  /***ASG_Capabilities***/
  byte gAudioSD_ASGCapabilities_PresentationCapabilities = 0;
  byte gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 = 0;
  char gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0_string[2][20]= {   "DAB short",
                                                                                 "DAB long"};
  byte gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 = 0;
  char gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1_string[2][20]= {   "SDARS short",
                                                                                 "SDARS long"};
  byte gAudioSD_ASGCapabilities_Extension1 = 0;
  byte gAudioSD_ASGCapabilities_Extension2 = 0;
  byte gAudioSD_ASGCapabilities_Extension3 = 0;
  byte gAudioSD_ASGCapabilities_Extension4 = 0;
  byte gAudioSD_ASGCapabilities_Extension5 = 0;
  
  /***InfoStates***/
  mstimer InfoStates_Start_Timer;
  byte gAudioSD_InfoStates_States = 0;
  byte gAudioSD_InfoStates_AdditionalStateInfo = 0;
  byte gAudioSD_InfoStates_AdditionalStateInfo_Bit0 = 0;
  byte gAudioSD_InfoStates_Extension1 = 0;
  byte gAudioSD_InfoStates_Extension2 = 0;
  byte gAudioSD_InfoStates_Extension3 = 0;
  byte gAudioSD_InfoStates_Extension4 = 0;
  
  /***SDS_State***/
  byte gAudioSD_SDSState_State = 0;
  byte gAudioSD_SDSState_Extension1 = 0;
  byte gAudioSD_SDSState_Extension2 = 0;
  byte gAudioSD_SDSState_Extension3 = 0;
  byte gAudioSD_SDSState_Extension4 = 0;
  byte gAudioSD_SDSState_Extension5 = 0;
  
  /***GeneralInfoSwitches***/
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches = 0;
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA      = 0; //Bit0
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS       = 0; //Bit1
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic = 0; //Bit2
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC       = 0; //Bit3
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS      = 0; //Bit4
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online    = 0; //Bit5
  byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB       = 0; //Bit6
  byte gAudioSD_GeneralInfoSwitches_Extension1 = 0;
  byte gAudioSD_GeneralInfoSwitches_Extension2 = 0;
  byte gAudioSD_GeneralInfoSwitches_Extension3 = 0;
  byte gAudioSD_GeneralInfoSwitches_Extension4 = 0;
  byte gAudioSD_GeneralInfoSwitches_Extension5 = 0;
  
  /***ActiveSource***/
  const ACTIVESOURCE_UNKNOWNSOURCE                = 0xFF;
  const ACTIVESOURCE_SOURCETYPE_FM                = 0x01;
  byte gAudioSD_activeSource_SourceType = 0;
  word gAudioSD_activeSource_SourceList_Reference = 0;
  byte gAudioSD_activeSource_ListAvailable = 0;
  byte gAudioSD_activeSource_ListAvailable_Bit0 = 0;
  byte gAudioSD_activeSource_ListAvailable_Bit1 = 0;
  byte gAudioSD_activeSource_ListAvailable_Bit2 = 0;
  const ACTIVESOURCE_LISTSTATE_COMPLETELY_LOADED  = 0x03;
  byte gAudioSD_activeSource_ListState = 0;
  byte gAudioSD_activeSource_Extension1 = 0;
  byte gAudioSD_activeSource_Number = 0;
  
  /***ActiveSourceName***/
  const ACTIVE_SOURCE_NAME_LENGTH = 61;
  char gAudioSD_activeSourceName[ACTIVE_SOURCE_NAME_LENGTH];
  
  /***CurrentVolume***/
  byte gAudioSD_currentVolume_ChangingVolumeType = 0;
  byte gAudioSD_currentVolume_maxVolume = 0;
  byte gAudioSD_currentVolume_GenericVolume = 0;
  byte gAudioSD_currentVolume_MuteState = 0;
  byte gAudioSD_currentVolume_MuteState_Bit0 = 0;
  byte gAudioSD_currentVolume_Extension1 = 0;
  byte gAudioSD_currentVolume_Extension2 = 0;
  
  /***SourceState***/
  byte gAudioSD_SourceState_StateInfo = 0;
  char gAudioSD_SourceState_StateInfo_string[8][20] = {   "unknown",
            							                                "scan",
            							                                "mix",
            							                                "repeat",
                                                          "repeat/mix",
                                                          "manual tuning",
                                                          "seek",
                                                          "play more like this"};
  byte gAudioSD_SourceState_Scope = 0;
  char gAudioSD_SourceState_Scope_string[9][40] ={    "unknown scope /any scope",
                                                      "file/track",
                                                      "device",
                                                      "medium",
                                                      "directory without subdirectories",
                                                      "directory with subdirectories",
                                                      "all directories /all folders",
                                                      "playlist",
                                                      "all playlists"};
  byte gAudioSD_SourceState_Extension1 = 0;
  byte gAudioSD_SourceState_Extension2 = 0;
  byte gAudioSD_SourceState_Extension3 = 0;
  byte gAudioSD_SourceState_Extension4 = 0;
  
  /***CurrentStationInfo***/
  const PRIMARYINFORMATION_TEXTLENGTH = 73;
  char gAudioSD_CSI_PrimaryInformation[PRIMARYINFORMATION_TEXTLENGTH];
  byte gAudioSD_CSI_PI_Type = 0;
  word gAudioSD_CSI_PIID = 0;
  const SECONDARYINFORMATION_TEXTLENGTH = 73;
  char gAudioSD_CSI_SecondaryInformation[SECONDARYINFORMATION_TEXTLENGTH];
  byte gAudioSD_CSI_SI_Type = 0;
  const TERTIARYINFORMATION_TEXTLENGTH = 73;
  char gAudioSD_CSI_TertiaryInformation[TERTIARYINFORMATION_TEXTLENGTH];
  byte gAudioSD_CSI_TI_Type = 0;
  const QUATERNARYINFORMATION_TEXTLENGTH = 73;
  char gAudioSD_CSI_QuarternaryInformation[QUATERNARYINFORMATION_TEXTLENGTH];
  byte gAudioSD_CSI_QI_Type = 0;
  const INFORMATION5_TEXTLENGTH = 73;
  char gAudioSD_CSI_Information5[INFORMATION5_TEXTLENGTH];
  byte gAudioSD_CSI_I5_Type = 0;
  const INFORMATION6_TEXTLENGTH = 73;
  char gAudioSD_CSI_Information6[INFORMATION6_TEXTLENGTH];
  byte gAudioSD_CSI_I6_Type = 0;
  const INFORMATION7_TEXTLENGTH = 73;
  char gAudioSD_CSI_Information7[INFORMATION7_TEXTLENGTH];
  byte gAudioSD_CSI_I7_Type = 0;
  const INFORMATION8_TEXTLENGTH = 73;
  char gAudioSD_CSI_Information8[INFORMATION8_TEXTLENGTH];
  byte gAudioSD_CSI_I8_Type = 0;
  byte gAudioSD_CSI_StationInfoSwitches = 0;
  byte gAudioSD_CSI_TATP      = 0; //Bit0
  byte gAudioSD_CSI_TMC       = 0; //Bit1
  byte gAudioSD_CSI_VICS      = 0; //Bit2
  byte gAudioSD_CSI_IBOC      = 0; //Bit3
  byte gAudioSD_CSI_RadioText = 0; //Bit4
  byte gAudioSD_CSI_StationProperties = 0;
  byte gAudioSD_CSI_StationProperties_IBOC            = 0; //Bit0
  byte gAudioSD_CSI_StationProperties_BallGameMode    = 0; //Bit1
  byte gAudioSD_CSI_StationProperties_DABservice      = 0; //Bit2
  byte gAudioSD_CSI_StationProperties_OnlineBuffering = 0; //Bit3
  byte gAudioSD_CSI_StationProperties_SmartFavorite   = 0; //Bit4
  byte gAudioSD_CSI_StationLinkingState = 0;
  word gAudioSD_CSI_ChannelID = 0;
  byte gAudioSD_CSI_RadioCategory = 0;
  byte gAudioSD_CSI_Extension1 = 0;
  
  /***CurrentStation_Handle***/
  word gAudioSD_CSIhandle_FSGhandle = 0;
  word gAudioSD_CSIhandle_FSGhandle_absolutePos = 0;
  byte gAudioSD_CSIhandle_PresetListRef = 0;
  byte gAudioSD_CSIhandle_PresetListabsolutePos = 0;
  word gAudioSD_CSIhandle_PictureRef = 0;
  byte gAudioSD_CSIhandle_Extension1 = 0;
  byte gAudioSD_CSIhandle_Extension2 = 0;
  byte gAudioSD_CSIhandle_Extension3 = 0;
  byte gAudioSD_CSIhandle_Extension4 = 0;
  byte gAudioSD_CSIhandle_Extension5 = 0;
  byte gAudioSD_CSIhandle_Extension6 = 0;
  byte gAudioSD_CSIhandle_Extension7 = 0;
  byte gAudioSD_CSIhandle_Extension8 = 0;
  byte gAudioSD_CSIhandle_Extension9 = 0;
  byte gAudioSD_CSIhandle_Extension10 = 0;
  byte gAudioSD_CSIhandle_Extension11 = 0;
  byte gAudioSD_CSIhandle_Extension12 = 0;
  byte gAudioSD_CSIhandle_Extension13 = 0;
  byte gAudioSD_CSIhandle_Extension14 = 0;
  byte gAudioSD_CSIhandle_Extension15 = 0;
  
  /***PlayPosition***/
  word gAudioSD_PlayPosition_TimePosition = 0;
  word gAudioSD_PlayPosition_TotalPlayTime = 0;
  byte gAudioSD_PlayPosition_Attributes = 0;
  byte gAudioSD_PlayPosition_Attributes_Bit0 = 0;
  byte gAudioSD_PlayPosition_BufferLevel = 0;
  
  /***Station_Track_Switch***/
  byte gAudioSD_STS_Event = 0;
  byte gAudioSD_STS_Direction = 0;
  byte gAudioSD_STS_Extension1 = 0;
  byte gAudioSD_STS_Extension2 = 0;
  byte gAudioSD_STS_Extension3 = 0;
  byte gAudioSD_STS_Extension4 = 0;
  byte gAudioSD_STS_Extension5 = 0;
  
  /***AnnouncementInfo***/
  const ANNOUNCEMENT_TYPE_NO_MESSAGE          = 0x00;
  byte gAudioSD_AnnouncementInfo_Type = 0;
  const ANNOUNCEMENT_STATIONNAME_TEXTLENGTH = 49;
  char gAudioSD_AnnouncementInfo_StationName[ANNOUNCEMENT_STATIONNAME_TEXTLENGTH];
  
  /***AnnouncementEscape***/
  mstimer AnnouncementEscape_Timer;
  mstimer AnnouncementEscape_MethodHandling_Timer;
  const AnnouncementEscape_TimerTime              = 1000;
  byte gAudioSD_AnnouncementEscape_MethodHandling = 0;
  byte gAudioSD_AnnouncementEscape_status = 0;                    //flag for status of the method (0=not activ, 1=activ)
  byte gAudioSD_AnnouncementEscape_Reserve = 0;
  byte gAudioSD_AnnouncementEscape_Result = 0;
  const AUDIO_ANNOUNCEMENTESCAPE_SUCCESSFUL               = 0x00;
  const AUDIO_ANNOUNCEMENTESCAPE_NOTSUCCESSFUL            = 0x01;
  const AUDIO_ANNOUNCEMENTESCAPE_ABORTSUCCESSFUL          = 0x02;
  const AUDIO_ANNOUNCEMENTESCAPE_ABORTNOTSUCCESSFUL       = 0x03;
  const AUDIO_ANNOUNCEMENTESCAPE_ANNOUNCEMENTNOTACTIVE    = 0x04;
  byte gAudioSD_AnnouncementEscape_AsgId = 0;
  byte gAudioSD_AnnouncementEscape_Extension1 = 0;
  
  /***ReceptionList***/
  byte gReceptionList_ASGID = 0;
  byte gReceptionList_TAID = 0;
  word gReceptionList_TotalNumListElements = 0;
  const AUDIO_RECEPTIONLISTTYPE_ELEMENTTYPE_ENSEMBLES = 0x00;
  byte gReceptionList_ElementType = AUDIO_RECEPTIONLISTTYPE_ELEMENTTYPE_ENSEMBLES;
  word gReceptionList_ParentID = 0x0000;
  const AUDIO_RECEPTIONLIST_ENTRIES = 0xFF;
  word gReceptionList_Pos[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Waveband[AUDIO_RECEPTIONLIST_ENTRIES];     
  byte gReceptionList_Type[AUDIO_RECEPTIONLIST_ENTRIES];                                                 
  byte gReceptionList_Attributes1_Bit0[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit1[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit2[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit3[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit4[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit5[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit6[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1_Bit7[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes2_Bit0[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes2_Bit1[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes2_Bit2[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes2_Bit3[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes1[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Attributes2[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_PresetID[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_FmRegCode[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_Category[AUDIO_RECEPTIONLIST_ENTRIES];
  const AUDIO_RECEPTIONLIST_NAME_LENGTH = 49;
  char gReceptionList_Name[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_RECEPTIONLIST_NAME_LENGTH];
  const AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH = 31;
  char gReceptionList_Frequency[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH];  
  word gReceptionList_PicRef[AUDIO_RECEPTIONLIST_ENTRIES];
  byte gReceptionList_ListEntryValidInformation[AUDIO_RECEPTIONLIST_ENTRIES]; //indicates the existence of the "record element" 
  byte gReceptionList_sum = 0;
  char gReceptionList_CSV_filename[AUDIO_FILENAME_SIZE];
  
  /***RadioTV_PresetList***/
  byte gRadioTVPresetList_ASGID = 0;
  byte gRadioTVPresetList_TAID = 0;
  byte gRadioTVPresetList_TotalNumListElements = 0;
  const AUDIO_RADIOTVPRESETLIST_ENTRIES = 0xFF;
  byte gRadioTVPresetList_Pos[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_PresetIndex[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  const AUDIO_RADIOTVPRESETLIST_WB_UNKNOWN      = 0x00;
  const AUDIO_RADIOTVPRESETLIST_WB_FM           = 0x01;
  const AUDIO_RADIOTVPRESETLIST_WB_AM           = 0x02;
  const AUDIO_RADIOTVPRESETLIST_WB_DAB          = 0x03;
  const AUDIO_RADIOTVPRESETLIST_WB_DMB          = 0x04;
  const AUDIO_RADIOTVPRESETLIST_WB_DVB          = 0x05;
  const AUDIO_RADIOTVPRESETLIST_WB_TV           = 0x06;
  const AUDIO_RADIOTVPRESETLIST_WB_SDARS        = 0x07;
  const AUDIO_RADIOTVPRESETLIST_WB_OnlineRadio  = 0x08;
  const AUDIO_RADIOTVPRESETLIST_WB_OnlineTV     = 0x09;
  byte gRadioTVPresetList_Waveband[AUDIO_RADIOTVPRESETLIST_ENTRIES]; 
  byte gRadioTVPresetList_Attributes1_Bit0[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit1[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit2[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit3[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit4[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit5[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit6[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1_Bit7[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2_Bit0[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2_Bit1[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2_Bit2[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2_Bit3[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2_Bit4[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes1[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_Attributes2[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  const AUDIO_RADIOTVPRESETLIST_NAME_LENGTH = 49;
  char gRadioTVPresetList_Name[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_RADIOTVPRESETLIST_NAME_LENGTH];    
  const AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH = 31;
  char gRadioTVPresetList_Frequency[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH];  
  word gRadioTVPresetList_PicRef[AUDIO_RADIOTVPRESETLIST_ENTRIES];
  byte gRadioTVPresetList_ListEntryValidInformation[AUDIO_RADIOTVPRESETLIST_ENTRIES]; //indicates the existence of the "record element" 
  byte gRadioTVPresetList_sum = 0;
  char gRadioTVPresetList_CSV_filename[AUDIO_FILENAME_SIZE];
  
  /***ListSetup***/
  byte gAudioSD_ListSetup_PreferredList = 0;
  byte gAudioSD_ListSetup_ReceptionListType = 0;
  byte gAudioSD_ListSetup_Extension1 = 0;
  byte gAudioSD_ListSetup_Extension2 = 0;
  byte gAudioSD_ListSetup_Extension3 = 0;
  byte gAudioSD_ListSetup_Extension4 = 0;
  
  /***SourceList***/
  byte gSourceList_ASGID = 0;
  byte gSourceList_TAID = 0;
  word gSourceList_TotalNumListElements = 0;
  const AUDIO_SOURCELIST_ENTRIES = 0xFF;
  word gSourceList_Pos[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_SourceType[AUDIO_SOURCELIST_ENTRIES];   
  byte gSourceList_InstanceID[AUDIO_SOURCELIST_ENTRIES]; 
  byte gSourceList_Attributes_Bit0[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit1[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit2[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit3[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit4[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit5[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes_Bit6[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_Attributes[AUDIO_SOURCELIST_ENTRIES];
  const AUDIO_SOURCELIST_NAME_LENGTH = 61;
  char gSourceList_Name[AUDIO_SOURCELIST_ENTRIES][AUDIO_SOURCELIST_NAME_LENGTH];   
  word gSourceList_PicRef[AUDIO_SOURCELIST_ENTRIES];
  byte gSourceList_ListEntryValidInformation[AUDIO_SOURCELIST_ENTRIES]; //indicates the existence of the "record element" 
  byte gSourceList_sum = 0;
  char gSourceList_CSV_filename[AUDIO_FILENAME_SIZE];
  
  /***DedicatedAudioControl***/
  mstimer DAC_Timer;
  mstimer DAC_MethodHandling_Timer;
  word gAudioSD_DAC_TimerTime = 150;
  word gAudioSD_DAC_MethodHandling_Time = 100;
  byte gAudioSD_DAC_MethodHandling = 0;
  byte gAudioSD_DAC_Reserve = 0;
  byte gAudioSD_DAC_status = 0;                   //flag for status of the method (0=not activ, 1=activ)
  word gAudioSD_DAC_FSGHandle = 0;
  byte gAudioSD_DAC_AsgId = 0;
  byte gAudioSD_DAC_Extension1 = 0;
  byte gAudioSD_DAC_Result = 0;
  const AUDIO_DAC_SUCCESSFUL          = 0x00;
  const AUDIO_DAC_NOTSUCCESSFUL       = 0x01;
  const AUDIO_DAC_ABORTSUCCESSFUL     = 0x02;
  const AUDIO_DAC_ABORTNOTSUCCESSFUL  = 0x03;
  byte gAudioSD_DAC_ControlType = 0;
  const AUDIO_DAC_SELECT_LIST_ENTRY         = 0x00;
  const AUDIO_DAC_NEXT                      = 0x01;
  const AUDIO_DAC_PREVIOUS                  = 0x02;
  const AUDIO_DAC_FASTFORWARD               = 0x03;
  const AUDIO_DAC_FASTBACKWARD              = 0x04;
  word gAudioSD_DAC_AdditionalControlInfo = 0;
  byte gAudioSD_DAC_ListType = 0;
  const AUDIO_DAC_NOLIST            = 0x00;
  const AUDIO_DAC_RECEPTIONLIST     = 0x01;
  const AUDIO_DAC_RADIOTVPRESETLIST = 0x02;
  const AUDIO_DAC_MEDIABROWSER      = 0x03;
  
  /***SwitchSource***/
  mstimer SwitchSource_Timer;
  const SwitchSource_TimerTime      = 1000;
  byte gAudioSD_SwitchSource_status = 0;
  word gAudioSD_SwitchSource_Reference = 0;
  byte gAudioSD_SwitchSource_Reserve = 0;
  const AUDIO_SWITCHSOURCERESULT_SUCCESSFUL             = 0x00;
  const AUDIO_SWITCHSOURCERESULT_NOT_SUCCESSFUL         = 0x01;
  const AUDIO_SWITCHSOURCERESULT_ABORT_SUCCESSFUL       = 0x02;
  const AUDIO_SWITCHSOURCERESULT_ABORT_NOT_SUCCESSFUL   = 0x03;
  byte gAudioSD_SwitchSource_Result = AUDIO_SWITCHSOURCERESULT_SUCCESSFUL;
  byte gAudioSD_SwitchSource_AsgId = 0;
  byte gAudioSD_SwitchSource_Extension1 = 0;
  byte gAudioSD_SwitchSource_ControlType = 0;
  word gAudioSD_SwitchSource_SourceListRef = 0;
  
  /***Browser_FolderLevel***/
  byte gAudioSD_MediaBrowser_FL_FolderLevel = 0;
  word gAudioSD_MediaBrowser_FL_RefMediaBrowser = 0;
  word gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos = 0;
  byte gAudioSD_MediaBrowser_FL_Extension1 = 0;
  
  /***Browser***/
  byte gMediaBrowser_ASGID = 0;
  byte gMediaBrowser_TAID = 0;
  word gMediaBrowser_TotalNumListElements = 0;
  word gMediaBrowser_ActiveListPos = 0;
  const AUDIO_MEDIABROWSER_ENTRIES = 0xFF;
  word gMediaBrowser_Pos[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Type[AUDIO_MEDIABROWSER_ENTRIES];
  const AUDIO_MEDIABROWSER_NAME_LENGTH = 97;
  char gMediaBrowser_Name[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_MEDIABROWSER_NAME_LENGTH];
  byte gMediaBrowser_FileState_Bit0[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit1[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit2[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit3[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit4[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit5[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_FileState_Bit6[AUDIO_MEDIABROWSER_ENTRIES];
  word gMediaBrowser_FileState[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Waveband[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_RadioCategory[AUDIO_MEDIABROWSER_ENTRIES];
  const AUDIO_MEDIABROWSER_FREQUENCY_LENGTH = 31;
  char gMediaBrowser_Frequency[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_MEDIABROWSER_FREQUENCY_LENGTH];
  byte gMediaBrowser_FmRegCode[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_PresetID[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit0[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit1[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit2[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit3[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit4[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit5[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit6[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1_Bit7[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes1[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes2_Bit0[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes2_Bit1[AUDIO_MEDIABROWSER_ENTRIES];
  byte gMediaBrowser_Attributes2[AUDIO_MEDIABROWSER_ENTRIES];
  word gMediaBrowser_PicRef[AUDIO_MEDIABROWSER_ENTRIES];  
  byte gMediaBrowser_ListEntryValidInformation[AUDIO_MEDIABROWSER_ENTRIES]; //indicates the existence of the "record element" 
  byte gMediaBrowser_sum = 0;
  char gMediaBrowser_CSV_filename[AUDIO_FILENAME_SIZE];
  
  /***BrowserPath***/
  byte gAudioSD_MediaPath_FolderType = 0;
  const MEDIAPATH_PATH_TEXTLENGTH = 152;
  char gAudioSD_MediaPath_Path[MEDIAPATH_PATH_TEXTLENGTH];
  
  /***BrowserControl***/
  mstimer MediaBrowserControl_Timer;
  const MediaBrowserControl_TimerTime         = 1000;
  byte gAudioSD_MediaBrowserControl_status = FALSE;
  byte gAudioSD_MediaBrowserControl_Control = 0; 
  byte gAudioSD_MediaBrowserControl_Reserve = 0;
  word gAudioSD_MediaBrowserControl_Reference = 0;
  const AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL             = 0x00;
  const AUDIO_MEDIABROWSERCONTROL_NOT_SUCCESSFUL         = 0x01;
  const AUDIO_MEDIABROWSERCONTROL_ABORT_SUCCESSFUL       = 0x02;
  const AUDIO_MEDIABROWSERCONTROL_ABORT_NOT_SUCCESSFUL   = 0x03;
  byte gAudioSD_MediaBrowserControl_Result = AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL;
  byte gAudioSD_MediaBrowserControl_AsgId = 0;
  byte gAudioSD_MediaBrowserControl_Extension1 = 0;
  
  /***Picture***/  
  byte gPicture_ASGID    =0;
  byte gPicture_TAID     =0;
  byte gPicture_TotalNumListElements =0;
  const AUDIO_PICTURE_ENTRIES = 0xFF;
  word gPicture_Pos[AUDIO_PICTURE_ENTRIES];    
  byte gPicture_Type[AUDIO_PICTURE_ENTRIES];
  const AUDIO_PICTURE_TYPE_NOPIC              =0x00;
  const AUDIO_PICTURE_TYPE_STATIONART_NORMAL  =0x01;
  const AUDIO_PICTURE_TYPE_COVERART_NORMAL    =0x02;
  const AUDIO_PICTURE_TYPE_STATIONART_DEFAULT =0x03;
  const AUDIO_PICTURE_TYPE_COVERART_DEFAULT   =0x04;
  const AUDIO_PICTURE_TYPE_DYNAMIC            =0x05;
  const AUDIO_PICTURE_TYPE_UNKNOWNPIC         =0xFF;
  const AUDIO_PICTURE_IPADDRESS_LENGTH =17;
  char gPicture_IpAddress [AUDIO_PICTURE_ENTRIES][AUDIO_PICTURE_IPADDRESS_LENGTH];
  word gPicture_TcpPort[AUDIO_PICTURE_ENTRIES];
  const AUDIO_PICTURE_URI_LENGTH =602;
  char gPicture_Uri [AUDIO_PICTURE_ENTRIES][AUDIO_PICTURE_URI_LENGTH];
  byte gPicture_ListEntryValidInformation [AUDIO_PICTURE_ENTRIES]; //indicates the existence of the "record element"  
  byte gPicture_sum =0; 
  char gPicture_CSV_filename[AUDIO_FILENAME_SIZE];
  dword requestarrayPictureGlobal [BAP_BUFFER_SIZE];
  word offsetPictureGlobal;
  int tempPictureID =0;
  int gID_PictureAct;  
} /* end of variables section */

//*************************************************************************
//*****************PreStart************************************************
//*************************************************************************
on preStart
{
  char BAPVersion [200];
  char Path [255];

  // create write window for BAP communication
  gBAP_Trace  =writecreate("BAP-Trace AudioSD");
  //clear BAP-window in write-window
  writeclear(gBAP_Trace);
  //error-window for BAP-cummunication
  gError_Trace=writecreate("AudioSD Error");
  writeclear(gError_Trace);
  gReceptionList_writeWindow =writecreate("AudioSD ReceptionList_Array");
  writeclear(gReceptionList_writeWindow);
  gSourceList_writeWindow =writecreate("AudioSD SourceList_Array");
  writeclear(gSourceList_writeWindow);
  gRadioTVPresetList_writeWindow =writecreate("AudioSD RadioTV_PrestList_Array");
  writeclear(gRadioTVPresetList_writeWindow);
  gMediaBrowser_writeWindow =writecreate("AudioSD MediaBrowser_Array");
  writeclear(gMediaBrowser_writeWindow);
  gPicture_writeWindow =writecreate("AudioSD Picture_Array");
  writeclear(gPicture_writeWindow);
  //clear CAPL-window in write-window
  writeclear(1);

  //get version from Stack
  Bap180_GetVersions(BAPVersion, 200);
  write(" ");
  write("***************************************************");
  write(BAPVersion);
  write("***************************************************");
  write(" ");
  write("***************************************************");
  write("FSG function catalog: 'BAP-FC_Audio_P30DF50_v3.01_F.pdf'");
  write("FSG MSCs: 'BAP-MSCs_Audio-SD_P30DF41_v2.11_F.pdf'");
  write("BAP_simulation_AudioSD_BAPv1.8_v2.00_MIB");
  write("***************************************************");
  
  // create Node
  NODE_INDEX=Bap180_CreateNode();
  // Debug info
  // write("NODE_INDEX = 0x%x", NODE_INDEX);
  // Load DBC and XML files. 
  write("*********************************************************************************");

  //load dbc-file
  canEthernetDecider = prestartEthernetCanDecider();
  //canEthernetDecider = 2; //CAN only
  write("canEthernetDecider = %d",canEthernetDecider);

  switch(canEthernetDecider)
  {
    case 2: 
      write("CAN CAN CAN CAN CAN ");
      getAbsFilePath(dbc_path, Path, 255);
      write("AudioSD Load BAP_DBC-File: '%s'",Path);
      if(Bap180_LoadDBC(NODE_INDEX, 1, Path) != BAP_ERR_OK)		
        writelineEx(gError_Trace, 0, "FSG-AudioSD Fehler beim Laden: '%s', Path");
      //load xml-file 
      getAbsFilePath(xml_path, Path, 255);
      write("FSG-AudioSD: Load BAP-XML-File: '%s'", Path);
      if (Bap180_LoadConfig(NODE_INDEX, Path, "") != BAP_ERR_OK) 
        writelineEx(gError_Trace, 0, "FSG-AudioSD: Fehler beim Laden: '%s' !", Path);	   
      write("*********************************************************************************");
      write("");
    break;
    case 1:
      write("ETHERNET ETHERNET ETHERNET ETHERNET ETHERNET ETHERNET ");
      getAbsFilePath(dbce_path, Path, 255);
      write("AudioSD Load BAP_DBC-File: '%s'",Path);
      if(Bap180_LoadDB(NODE_INDEX, 20, 2, Path) != BAP_ERR_OK)		
        writelineEx(gError_Trace, 0, "FSG-AudioSD Fehler beim Laden: '%s', Path");
      //load xml-file 
      getAbsFilePath(xmle_path, Path, 255);
      write("FSG-AudioSD: Load BAP-XML-File: '%s'", Path);
      if (Bap180_LoadConfig(NODE_INDEX, Path, "") != BAP_ERR_OK) 
        writelineEx(gError_Trace, 0, "FSG-AudioSD: Fehler beim Laden: '%s' !", Path);	   
      write("*********************************************************************************");
      write("");
    break;
    case -1:
      write("Neither Ethernet nor CAN could be find in Configuration Name!");
    break;
    default:
      write("Not a possible Value");
    break;
  }

  // BAP DLL: Add CAN channel: BAP channel 1 is mapped to CAN card channel 1.
	if(canEthernetDecider==1)
	{
		Bap180_AddCanMap(NODE_INDEX, 20, 1);
		EthernetCreateSocket();
	} 
	else
	{
		Bap180_AddCanMap(NODE_INDEX, 1, 1);
	}
}   /* end of method 149318 */

int prestartEthernetCanDecider()
{ return 1;
//  char configNameBuffer[100];
//  
//  getConfigurationName(configNameBuffer,100);
//  if(strstr_regex(configNameBuffer, "Ethernet") > 0)
//  {
//    return 1;
//  }
//  else if(strstr_regex(configNameBuffer, "CAN") > 0)
//  {
//    return 2;
//  }
//  else
//  {
//    return -1;
//  }
}

//*************************************************************************
//*****************Start***************************************************
//*************************************************************************
on start
{
  //Power on//off
  gBAP_Init =0;
  gAudioSD_PowerOnOff =0;
  putvalue(env_AudioSD_PowerOnOff_s, gstring_PowerOnOff [gAudioSD_PowerOnOff]);

  //Panels
  closePanel("FSG_AudioSD_MainPanel");
  //properties
  closePanel("FSG_AudioSD_Properties_1");
  closePanel("FSG_AudioSD_Properties_2");
  closePanel("FSG_AudioSD_Properties_3");
  closePanel("FSG_AudioSD_Properties_4");
  closePanel("FSG_Property_DF41");
  closePanel("FSG_Property_DF48");
  //methods
  closePanel("FSG_AudioSD_Methods");
  closePanel("Method_2_AudioSD_FSG");
  //arrays
  closePanel("FSG_AudioSD_0x17 - ReceptionList_(array)");
  closePanel("FSG_AudioSD_0x17 - ReceptionList_delete");
  closePanel("FSG_AudioSD_0x20 - SourceList_(array)");
  closePanel("FSG_AudioSD_0x20 - SourceList_(array)_delete");
  closePanel("FSG_AudioSD_0x21 - RadioTV_PresetList_(array)");
  closePanel("FSG_AudioSD_0x21 - RadioTV_PresetList_(array)_delete");
  closePanel("FSG_AudioSD_0x24 - MediaBrowser_(array)");
  closePanel("FSG_AudioSD_0x24 - MediaBrowser_(array)_delete");
  closePanel("Picture_FSG2");
  /*
  closePanel("FSG_AudioSD_0x17 - ReceptionList_(array)");
  closePanel("FSG_AudioSD_0x17 - ReceptionList_delete");
  closePanel("FSG_AudioSD_0x1B - TpMemoList_(array)");
  closePanel("FSG_AudioSD_0x1B - TpMemoList_(array)_delete");
  closePanel("CommonList_FSG");
  closePanel("FSG_AudioSD_0x38_LastStationList_(array)");
  closePanel("FSG_AudioSD_0x32_SiriusAlertList_(array)");
  closePanel("FavoriteList_FSG2");
  */

  openPanel("AudioSD_MainPanel");
}

on stopMeasurement
{
  Bap180_Shutdown(NODE_INDEX,LSG_AudioSD);
}

//*************************************************************************
//*****************TaskTimer***********************************************
//*************************************************************************
on timer TaskTimer
{
  Bap180_Task(NODE_INDEX);	//DLL-Task
  BAP_DLL_Indication();
  BAP_DLL_Request();
  BAP_CAN_TX_Request();
  if(canEthernetDecider == 1) BAP_DLL_SetRxData();
  setTimer(TaskTimer, 10);	//restart real CAN-communication timer
}

//*************************************************************************
//*****************TaskTimer Functions*************************************
//*************************************************************************
void BAP_DLL_SetRxData()
{
  int i;
  byte gRxBuffer[1500];
  
  for(i=0;i<gUdpSocketCnt;i++)
  {
    UdpReceiveFrom(gUdpSockets[i].Handle, gRxBuffer, 0);
  }
}

void BAP_DLL_Request()
{
  int i, datalength;
  byte temp;
  byte Request_data[BAP_BUFFER_SIZE];	//Request data for DLL
  dword Request_header[6];	        //Request header for DLL
  byte error;                         //data-error-flag (Geräusch)

  //init lokal variables
  datalength = 0;
  temp = 0;
  error = 1;

  for (i = 0; i < 6; i++)
      Request_header[i] = 0;
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
      Request_data[i] = 0;
  //********************

  if (gBAP_Requestbuffer_status[gstatus_requestbuffer] > 0)                           //if ready to send
  {
    //	writelineEx(gBAP_Trace, 0, "DataTyp: %d", gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]);
    switch (gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer])
    {
      case Bap_Void:
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
        Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
        Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
        Request_header[3] = gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];   //BAP data type
        Request_header[4] = 0;                                                      //not used
        Request_header[5] = 0;                                                      //not used
      break;
      case Bap_UInt8:
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
        Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
        Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
        Request_header[3] = gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];   //BAP data type
        Request_header[4] = 0;                                                      //not used
        Request_header[5] = gBAP_Request[gstatus_requestbuffer][3];                 //unit8-value
      break;
      case Bap_UInt16:
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
        Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
        Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
        Request_header[3] = gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];       //BAP data type
        Request_header[4] = 0;                                                      //not used
        Request_header[5] = gBAP_Request[gstatus_requestbuffer][3];                 //unit16-value
      break;
      case Bap_UInt32:
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
        Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
        Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
        Request_header[3] = gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];   //BAP data type
        Request_header[4] = 0;                                                      //not used
        Request_header[5] = gBAP_Request[gstatus_requestbuffer][3];                 //unit32-value
      break;
      case Bap_ByteSequence:                  //BAP-data-type is byte sequence
        datalength = gBAP_Requestbuffer_status[gstatus_requestbuffer] - 3;
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
        Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
        Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
        Request_header[3] = Bap_ByteSequence;                                           //BAP data type
        Request_header[4] = datalength;                                             //length of date-array
        //data-array for BAP-DLL funcion 'BAP_Request'
        for (i = 0; i < datalength; i++)
            Request_data[i] = gBAP_Request[gstatus_requestbuffer][i + 3];
      break;
      case Bap_Acknowledge:// not used only BAP 3.1
      break;
      case Bap_Error:
        //request-array for BAP-DLL funcion 'BAP_Request'
        Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
        Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
        Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
        Request_header[3] = gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];   //BAP data type
        Request_header[4] = 0;                                                      //not used
        Request_header[5] = gBAP_Request[gstatus_requestbuffer][3];                 //error code
      break;
      default:
        writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer]);
        error = 0;
      break;
    }
    if (error)                                                                          //no data-error
    {
      temp = Bap180_Request(NODE_INDEX, Request_header, Request_data);                    //send data to BAP-DLL
      if (temp == 0)                                                                      //BAP-Request succesful											
      {
        /*
        writelineEx(gBAP_Trace, 0, "FSG-Request:    ");								//BAL-Trace		
	      for (i=0;i<gBAP_Requestbuffer_status [gstatus_requestbuffer];i++)			//BAL-Trace	
		      writeEX(gBAP_Trace, 0, " %x",gBAP_Request [gstatus_requestbuffer] [i]);	//BAL-Trace	
        //write("Send buffer-element %d to BAP-DLL", gstatus_requestbuffer); 			//debug
        */
      }
      else                                                                            //BAP-Request error
      {
        writelineEx(gBAP_Trace, 0, "FSG Error BAP_Request, errorcode: %x. FSG-Request:", temp);             //debug
        for (i = 0; i < gBAP_Requestbuffer_status[gstatus_requestbuffer]; i++)                                  //debug
          writeEX(gBAP_Trace, 0, " %x", gBAP_Request[gstatus_requestbuffer][i]);                          //debug
      }
    }
    gBAP_Requestbuffer_status[gstatus_requestbuffer] = 0;       //reset position status -> free position 
    gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer] = 0;   //reset BAP-datatyp of sendet buffer element
    //delete sendet request buffer elements
    for (i = 0; i < BAP_BUFFER_SIZE; i++)
      gBAP_Request[gstatus_requestbuffer][i] = 0;             //delete sended array
    if (gstatus_requestbuffer < (REQUESTBUFFER_LINES - 1))          //last element of buffer is not reached	
      gstatus_requestbuffer++;
    else                                                        //last element of buffer is reached
      gstatus_requestbuffer = 0;
  }
}

void BAP_CAN_TX_Request()
{
  int i;
  byte send_result;
  byte DestIp[16];
  byte TX_Data[1500];				//CAN-data
  dword TX_Header[13];			//CAN-header
  message 0x100 TX_Message;	//dummy-message
   
  if(canEthernetDecider == 2)
  {
    TX_Header[2] = 8; // max-Length of TX_Data
    while (Bap180_CAN_GetTxDat(NODE_INDEX,TX_Header,TX_Data) == 0) 	//get BAP-data in CAN-format from DLL
    {
      TX_Message.CAN = TX_Header[0]; 		//CAN channel
      TX_Message.ID =TX_Header[1]; 			//Can ID
      TX_Message.DLC = TX_Header[2]; 		//received length
      for (i=0; i<TX_Message.DLC; i++)		//CAN data-bytes
      {
        TX_Message.byte(i) = TX_Data[i];
      }
      output(TX_Message);					//send CAN message
      TX_Header[2] = 8; 					// max-Length of TX_Data
    } 
  }
  else
  {
    TX_Header[0] = 4; // /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
    TX_Header[2] = 1500; // max-Length of TX_Data
    while( BAP180_GetTxData( NODE_INDEX,TX_Header,TX_Data ) == 0 ) 
    {
      for(i=0; i<8;i++)
      {
        DestIp[2*i]   = (byte)(TX_Header[i+4]>>8);
        DestIp[2*i+1] = (byte)(TX_Header[i+4]&0xFF);
      }
      for (i=0; i<TX_Header[2]; i++) 
      {	//CAN data-bytes
        TX_Data.byte(i) = TX_Data[i];
      }
      send_result = UdpSendTo(gUdpSockets[TX_Header[3]-1].Handle, DestIp, TX_Header[12], TX_Data, TX_Header[2]);
      if (0 == send_result)
      {
       // write("123");
      }
      else
      {
        writeLineEx(0,3, "UdpSendTo failed, error code %d, last error %d", send_result, IpGetLastError());
      }
      TX_Header[2] = 1500; // max-Length of TX_Data
    }
  }
}

void BAP_DLL_Indication()
{
  int i, length, datalength, temp;
  byte Indication_data[BAP_BUFFER_SIZE];	//indication data from DLL
  dword Indication_header[6];				//indication header from DLL
  byte BAP_data_type;

  //init lokal variables
  length = 0;
  datalength = 0;
  temp = 0;
  BAP_data_type = 0;

  for (i = 0; i < 6; i++)
      Indication_header[i] = 0;
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
      Indication_data[i] = 0;
  //********************

  Indication_header[4] = BAP_BUFFER_SIZE;                                         //BAP-Stack needs this information for successful BAP_GetIndication 
  temp = Bap180_GetInd(NODE_INDEX, Indication_header, Indication_data);               //get BAP-Indication data from DLL
  if (temp == 0)
  {
    //read header
    gBAP_Indication[0] = Indication_header[0];                                  //LSG-ID
    gBAP_Indication[1] = Indication_header[1];                                  //Function-ID
    gBAP_Indication[2] = Indication_header[2];                                  //indication
    BAP_data_type = Indication_header[3];                                           //BAP data type
    write("data type=%x",BAP_data_type);
    switch (BAP_data_type)
    {
      case Bap_Void:
        datalength = 3;
        writelineEx(gBAP_Trace, 0, "FSG-Indication: ");                     //BAL-Trace
        for (i = 0; i < datalength; i++)                                            //BAL-Trace
          writeEX(gBAP_Trace, 0, " %x", gBAP_Indication[i]);              //BAL-Trace
        BAP_Indication(datalength);                                                 //evaluate BAP-Indication data
      break;
      case Bap_UInt8:
        gBAP_Indication[3] = Indication_header[5];                          //unit8-value
        datalength = 4;
        writelineEx(gBAP_Trace, 0, "FSG-Indication: ");                     //BAL-Trace
        for (i = 0; i < datalength; i++)                                            //BAL-Trace
          writeEX(gBAP_Trace, 0, " %x", gBAP_Indication[i]);              //BAL-Trace
        BAP_Indication(datalength);                                                 //evaluate BAP-Indication data
      break;
      case Bap_UInt16:
        gBAP_Indication[3] = Indication_header[5];                          //unit16-value
        datalength = 4;
        writelineEx(gBAP_Trace, 0, "FSG Indication: ");                     //BAL-Trace
        for (i = 0; i < datalength; i++)                                            //BAL-Trace
          writeEX(gBAP_Trace, 0, " %x", gBAP_Indication[i]);              //BAL-Trace
        BAP_Indication(datalength);                                                 //evaluate BAP-Indication data
      break;
      case Bap_UInt32:
        gBAP_Indication[3] = Indication_header[5];                          //unit32-value
        datalength = 4;
        writelineEx(gBAP_Trace, 0, "FSG Indication: ");                     //BAL-Trace
        for (i = 0; i < datalength; i++)                                            //BAL-Trace
          writeEX(gBAP_Trace, 0, " %x", gBAP_Indication[i]);              //BAL-Trace
        BAP_Indication(datalength);                                                 //evaluate BAP-Indication data
      break;
      case Bap_ByteSequence:                                                  //BAP-data-type is byte sequence                                                                     
        length = Indication_header[4];                                      //length of date-array
        datalength = length + 3;                                                //length of indication-array
        //read data-array
        for (i = 0; i < length; i++)
          gBAP_Indication[i + 3] = Indication_data[i];
        writelineEx(gBAP_Trace, 0, "FSG-Indication: ");                     //BAL-Trace
        for (i = 0; i < datalength; i++)                                            //BAL-Trace
        {
          writeEX(gBAP_Trace, 0, " %x", gBAP_Indication[i]);              //BAL-Trace
          if (i > 20)
          {
            i = datalength;
            writeEX(gBAP_Trace, 0, "...");
          }
        }
        BAP_Indication(datalength);                                                 //evaluate BAP-Indication data
      break;
      case Bap_Acknowledge: //not used, only at BAP 3.1
      break;
      case Bap_Error:
        gBAP_Indication[2] = Error_IND;                                     //internal indication-value for error
        gBAP_Indication[3] = Indication_header[5];                          //error-code
        datalength = 4;                                             //length of indication-array
        writelineEx(gBAP_Trace, 0, "FSG-Error-Indication: ");               //BAL-Trace
        writeEX(gBAP_Trace, 0, "LSG-ID: 0x%x   ", gBAP_Indication[0]);      //BAL-Trace
        writeEX(gBAP_Trace, 0, "Fct-ID: 0x%x   ", gBAP_Indication[1]);      //BAL-Trace
        writeEX(gBAP_Trace, 0, "Error-Code: 0x%x   ", gBAP_Indication[3]);  //BAL-Trace
        BAP_Indication(datalength);                                                 //evaluate BAP-Indication data
      break;
      default:
        writelineEx(gError_Trace, 0, "FSG BAP_DLL_Indication: invalid BAP-Data-Type: %d", BAP_data_type);
      break;
    }
  }
}

void BAP_Indication(int datalength)
{
  switch (gBAP_Indication[0])
  {
    case LSG_AudioSD:
      AudioSD_functions(datalength);
    break;
    default:
      write("error BAP_Indication: invalid/unhandled LSG-ID %x", gBAP_Indication[0]);
  }
}

void AudioSD_functions(int datalength)
{
    switch (gBAP_Indication[1]) // function-ID
    {
      case FctID_FSG_Control:
        FSG_Control_Indication(gBAP_Indication, datalength);
      break;
      case FctID_FSG_Setup:
        FSG_Setup_Indication(gBAP_Indication, datalength);
      break;
      case FctID_FSG_OperationState:
        FSG_OperationState_Indication(gBAP_Indication, datalength);
      break;
      case FctID_ASG_Capabilities:
        ASGCapabilities_Indication(gBAP_Indication, datalength);
      break;
      case FctID_InfoStates:
        InfoStates_Indication(gBAP_Indication, datalength);
      break;  
      case FctID_SDS_State:
        SDS_State_Indication(gBAP_Indication, datalength);
      break;  
      case FctID_GeneralInfoSwitches:
        GeneralInfoSwitches_Indication(gBAP_Indication, datalength);
      break;  
      case FctID_ActiveSource:
        activeSource_Indication(gBAP_Indication, datalength);
      break;
      case FctID_ActiveSourceName:
        activeSourceName_Indication(gBAP_Indication, datalength);
      break;  
      case FctID_CurrentVolume:
        currentVolume_Indication(gBAP_Indication, datalength);
      break;  
      case FctID_SourceState:
        SourceState_Indication(gBAP_Indication, datalength);
      break;  
      case FctID_CurrentStationInfo:
        CurrentStationInfo_Indication(gBAP_Indication, datalength);
      break;
      case FctID_CurrentStation_Handle:
        CurrentStationHandle_Indication(gBAP_Indication, datalength);
      break;
      case FctID_PlayPosition:
        PlayPosition_Indication(gBAP_Indication, datalength);
      break;
      case FctID_Station_Track_Switch:
        Station_Track_Switch_Indication(gBAP_Indication, datalength);
      break;
      case FctID_AnnouncementInfo:
        AnnouncementInfo_Indication(gBAP_Indication, datalength);
      break;
      case FctID_AnnouncementEscape:
        AnnouncementEscape_Indication(gBAP_Indication, datalength);
      break;  
      case FctID_ReceptionList:
        ReceptionList_Indication(gBAP_Indication, datalength);
      break;  
      case FctID_RadioTV_PresetList:
        RadioTVPresetList_Indication(gBAP_Indication, datalength);
      break;
      case FctID_ListSetup:
        ListSetup_Indication(gBAP_Indication, datalength);
      break;
      case FctID_SourceList:
        SourceList_Indication(gBAP_Indication, datalength);
      break;
      case FctID_DedicatedAudioControl:
        DedicatedAudioControl_Indication(gBAP_Indication, datalength);
      break; 
      case FctID_SwitchSource:
        SwitchSource_Indication(gBAP_Indication, datalength);
      break;  
      case FctID_Browser_FolderLevel:
        Browser_FolderLevel_Indication(gBAP_Indication, datalength);
      break;
      case FctID_Browser:
        Browser_Indication(gBAP_Indication, datalength);
      break;
      case FctID_BrowserPath:
        BrowserPath_Indication(gBAP_Indication, datalength);
      break;
      case FctID_BrowserControl:
        BrowserControl_Indication(gBAP_Indication, datalength);
      break;
      case FctID_Picture:
        Picture_Indication(gBAP_Indication, datalength);
      break;
      default:
        write("FSG_functions: unknown funcion-ID %x", gBAP_Indication[1]);
      break;
    }
}

//*************************************************************************
//*****************PowerOnOff Event****************************************
//*************************************************************************
on timer Powerontimer
{
	gAudioSD_PowerOnOff=1;
  settimer(TaskTimer, 10); //start BAP-DLL-Timer
}

on envVar env_AudioSD_PowerOnOff
{
  int length, error;

  putvalue(env_AudioSD_PowerOnOff_s, gstring_PowerOnOff[getvalue(this)]);	
	if(TRUE==getvalue(this))
	{
		//BAP-Init, FSG AudioSD
    if(gBAP_Init ==FALSE)
		{
			gBAP_Init =TRUE;
			error = Bap180_Init(NODE_INDEX, LSG_AudioSD);
      // Check for initialisation error.
      if(error ==BAP_ERR_OK) write("FSG-AudioSD BAP_Init successful");
			else writelineEx(gError_Trace, 0,"FSG-AudioSD error BAP_Init: %d", error);
		}
    //initialize variables
    init_variables();
    //initialize arrays
    ReceptionList_init_static();
    SourceList_init_static();
    RadioTVPresetList_init_static();
    Browser_init_static();
    Picture_init_static();
    //initialize Cache
    BAP_Set_Cache();
    //BAP-Start FSG
    error =Bap180_Start(NODE_INDEX, LSG_AudioSD);
    if(error==BAP_ERR_OK)
    {
      write("FSG-AudioSD BAP_Start successful");  
    }
    else
    {
      write("FSG-AudioSD error BAP_Start: %d", error);
    }
    settimer(Powerontimer, 20);
    settimer(StartFSG_Timer,1000);
  }
	else
	{
    Bap180_Shutdown(NODE_INDEX, LSG_AudioSD);
    gAudioSD_PowerOnOff=getvalue(env_AudioSD_PowerOnOff);
    Shutdown_AudioSD();
	}
}

void EthernetCreateSocket()
{ 
  int index;
  dword i, j, Header[200], val, VlanId, VlanPrio, ifIndex;
  byte ipv6_adapter_adresses[5][16];
  byte ipv6_temp[16] = {0};
  byte ipv6_zero[16] = {0}; 
  int ii;

  gUdpSocketCnt = 0;
  Header[0] = 1;
  //write("HIER : %d", BAP180_GetEthConfig(NODE_INDEX, Header));
  if(BAP180_GetEthConfig(NODE_INDEX, Header) == 0)
  {
    for(i=1;i<=3;i++)
    {
      if(IpGetAdapterAddress(i, ipv6_adapter_adresses, 5) == 0)
      {
        val = IpGetAdapterAddressCount(i, 28);
        for(j=0;j<val;j++)
        {
          IpRemoveAdapterAddress(i, ipv6_adapter_adresses[j], 64);
        }
      }
      else
      {
        break;
      }
    }
    index=0;
    ifIndex = 1;
    VlanId = Header[index++];
    VlanPrio = Header[index++];
    writelineex(0, 1, "VLAN ID: %d", VlanId);
    writelineex(0, 1, "VLAN Prio: %d", VlanPrio);
    if(VlanId != 0xFFFF)
      ifIndex = 2;
    gUdpSocketCnt = Header[index++];
    for(i=0; i<gUdpSocketCnt;i++)
    {
      gUdpSockets[i].Id = Header[index++];
      for(j=0;j<8;j++)
      {
        ipv6_temp[j*2]   = Header[index]>>8;
        ipv6_temp[j*2+1] = Header[index++]&0xFF;
      }
      IpAddAdapterAddress(ifIndex, ipv6_temp, 64);
      write("%d", gUdpSockets[i].Handle);
      if(ipv6_temp[0] == 0xFF)
      {
        gUdpSockets[i].Handle = UdpOpen( ipv6_zero, Header[index++]);
        write("ipv6 temp 0 : 0xFF");
      }
      else
      {
        gUdpSockets[i].Handle = UdpOpen( ipv6_temp, Header[index++]);
      }
      if (gUdpSockets[i].Handle == ~0)
      {
        writelineex(0, 3, "Error: could not create Udp socket! %d", IpGetLastError());
      }
      else
      {
        writelineex(0, 1, "Udp socket is opened successfully.");
        if(ipv6_temp[0] == 0xFF)
        {
          if(IpJoinMulticastGroup(gUdpSockets[i].Handle, ifIndex, ipv6_temp) != 0)
            writelineex(0, 3, "IpJoinMulticastGroup failed.");
        }
        if(IpSetMulticastInterface ( gUdpSockets[i].Handle, ifIndex) != 0)
          writelineex(0, 3, "IpSetMulticastInterface failed");
      }
    }
  }
  else
  {
    writelineex(0, 3, "Error: BAP180_GetEthConfig failed!");
  }
  for(ii = 0; ii < 70; ii++)
  {
    //write("HEADER[%d] : %d", ii, Header[ii]);
  }
}

on timer StartFSG_Timer
{
    gAudioSD_FSGOperationState_OpState =FSGOPERATIONSTATE_NORMALOPERATION;
    putvalue(env_AudioSD_FSGOpState_OpState, gAudioSD_FSGOperationState_OpState);
    FSG_OperationState_Request(Data_REQ, 0);    //send status
}

//*************************************************************************
//*****************init/shutdown functions*********************************
//*************************************************************************
void init_variables()	//initialize/reset all global variables
{
  dword i, j;

  //BAP communication
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
      gBAP_Indication[i] = 0;
  //RGB-Values for background colors	
  gRGB_red = MakeRGB(255, 0, 0);
  gRGB_yellow = MakeRGB(255, 255, 0);
  gRGB_green = MakeRGB(0, 255, 0);
  gRGB_grey = MakeRGB(192, 192, 192);
  gRGB_white = MakeRGB(255, 255, 255);
  for (j = 0; j < REQUESTBUFFER_LINES; j++)
  {
    gBAP_Requestbuffer_status[j] = 0;
    gBAP_Requestbuffer_BAPDataTyp[j] = 0;
    for (i = 0; i < BAP_BUFFER_SIZE; i++)
      gBAP_Request[j][i] = 0;
  }
  gwrite_requestbuffer_line = 0;
  gstatus_requestbuffer = 0;
  putvalue(env_AudioSD_Config_SWConfig, xml_path);
  putvalue(env_AudioSD_Config_DBC, dbc_path);

  //FunctionList
  for (i = 0; i < 8; i++)
    gFunctionList[i] = 0;
  //Byte0
  gFunctionList[0] += (getvalue(env_AudioSD_FctList_0x01) * 0x40);   //Bit1 - GetAll
  gFunctionList[0] += (getvalue(env_AudioSD_FctList_0x02) * 0x20);   //Bit2 - BAPConfig
  gFunctionList[0] += (getvalue(env_AudioSD_FctList_0x03) * 0x10);   //Bit3 - FunctionList
  gFunctionList[0] += (getvalue(env_AudioSD_FctList_0x04) * 0x08);   //Bit4 - Heartbeat
  //Byte1
  gFunctionList[1] += (getvalue(env_AudioSD_FctList_0x0D) * 0x04);   //Bit13 - FSG_Control
  gFunctionList[1] += (getvalue(env_AudioSD_FctList_0x0E) * 0x02);   //Bit14 - FSG_Setup
  gFunctionList[1] += (getvalue(env_AudioSD_FctList_0x0F) * 0x01);   //Bit15 - FSG_OperationState
  //Byte2
  gFunctionList[2] += (getvalue(env_AudioSD_FctList_0x10) * 0x80);   //Bit16 - ASG_Capabilities
  gFunctionList[2] += (getvalue(env_AudioSD_FctList_0x11) * 0x40);   //Bit17 - InfoStates
  gFunctionList[2] += (getvalue(env_AudioSD_FctList_0x12) * 0x20);   //Bit18 - SDS_State
  gFunctionList[2] += (getvalue(env_AudioSD_FctList_0x13) * 0x10);   //Bit19 - GeneralInfoSwitches
  gFunctionList[2] += (getvalue(env_AudioSD_FctList_0x14) * 0x08);   //Bit20 - ActiveSource
  gFunctionList[2] += (getvalue(env_AudioSD_FctList_0x15) * 0x04);   //Bit21 - ActiveSourceName
  gFunctionList[2] += (getvalue(env_AudioSD_FctList_0x16) * 0x02);   //Bit22 - CurrentVolume
  gFunctionList[2] += (getvalue(env_AudioSD_FctList_0x17) * 0x01);   //Bit23 - SourceState
  //Byte3
  gFunctionList[3] += (getvalue(env_AudioSD_FctList_0x18) * 0x80);   //Bit24 - CurrentStationInfo
  gFunctionList[3] += (getvalue(env_AudioSD_FctList_0x19) * 0x40);   //Bit25 - CurrentStation_Handle
  gFunctionList[3] += (getvalue(env_AudioSD_FctList_0x1A) * 0x20);   //Bit26 - PlayPosition
  gFunctionList[3] += (getvalue(env_AudioSD_FctList_0x1B) * 0x10);   //Bit27 - Station_Track_Switch
  gFunctionList[3] += (getvalue(env_AudioSD_FctList_0x1C) * 0x08);   //Bit28 - AnnouncementInfo
  gFunctionList[3] += (getvalue(env_AudioSD_FctList_0x1D) * 0x04);   //Bit29 - AnnouncementEscape
  gFunctionList[3] += (getvalue(env_AudioSD_FctList_0x1E) * 0x02);   //Bit30 - ReceptionList
  gFunctionList[3] += (getvalue(env_AudioSD_FctList_0x1F) * 0x01);   //Bit31 - RadioTV_PresetList
  //Byte4
  gFunctionList[4] += (getvalue(env_AudioSD_FctList_0x20) * 0x80);   //Bit32 - ListSetup
  gFunctionList[4] += (getvalue(env_AudioSD_FctList_0x21) * 0x40);   //Bit33 - SourceList
  gFunctionList[4] += (getvalue(env_AudioSD_FctList_0x22) * 0x20);   //Bit34 - DedicatedAudioControl
  gFunctionList[4] += (getvalue(env_AudioSD_FctList_0x23) * 0x10);   //Bit35 - SwitchSource
  gFunctionList[4] += (getvalue(env_AudioSD_FctList_0x24) * 0x08);   //Bit36 - Browser_FolderLevel
  gFunctionList[4] += (getvalue(env_AudioSD_FctList_0x25) * 0x04);   //Bit37 - Browser
  gFunctionList[4] += (getvalue(env_AudioSD_FctList_0x26) * 0x02);   //Bit38 - BrowserPath
  gFunctionList[4] += (getvalue(env_AudioSD_FctList_0x27) * 0x01);   //Bit39 - BrowserControl
  //Byte5
  gFunctionList[5] += (getvalue(env_AudioSD_FctList_0x28) * 0x80);   //Bit40 - Picture
  //deactivate FctList-Elements
  enableControl("FSG_AudioSD_MainPanel", "FSG_0x03_FctList", FALSE);
  //Panel
  if (getvalue(env_AudioSD_FctList_0x0D))
  {
      SetControlBackColor("FSG_AudioSD_Properties_1", "FSG_0x0D", gRGB_white);
      enableControl("FSG_AudioSD_Properties_1", "FSG_0x0D_PanelElement", TRUE);
  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_1", "FSG_0x0D", gRGB_red);
      enableControl("FSG_AudioSD_Properties_1", "FSG_0x0D_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x0E))
  {
      SetControlBackColor("FSG_AudioSD_Properties_1", "FSG_0x0E", gRGB_white);
      enableControl("FSG_AudioSD_Properties_1", "FSG_0x0E_PanelElement", TRUE);
  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_1", "FSG_0x0E", gRGB_red);
      enableControl("FSG_AudioSD_Properties_1", "FSG_0x0E_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x0F))
  {
      SetControlBackColor("FSG_AudioSD_Properties_1", "FSG_0x0F", gRGB_white);
      enableControl("FSG_AudioSD_Properties_1", "FSG_0x0F_PanelElement", TRUE);
  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_1", "FSG_0x0F", gRGB_red);
      enableControl("FSG_AudioSD_Properties_1", "FSG_0x0F_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x10))
  {
      SetControlBackColor("FSG_AudioSD_Properties_2", "FSG_0x10", gRGB_white);
      enableControl("FSG_AudioSD_Properties_2", "FSG_0x10_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_2", "FSG_0x10", gRGB_red);
      enableControl("FSG_AudioSD_Properties_2", "FSG_0x10_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x11))
  {
      SetControlBackColor("FSG_AudioSD_Properties_2", "FSG_0x11", gRGB_white);
      enableControl("FSG_AudioSD_Properties_2", "FSG_0x11_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_2", "FSG_0x11", gRGB_red);
      enableControl("FSG_AudioSD_Properties_2", "FSG_0x11_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x12))
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x12", gRGB_white);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x12_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x12", gRGB_red);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x12_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x13))
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x13", gRGB_white);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x13_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x13", gRGB_red);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x13_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x14))
  {
      SetControlBackColor("FSG_AudioSD_Properties_2", "FSG_0x14", gRGB_white);
      enableControl("FSG_AudioSD_Properties_2", "FSG_0x14_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_2", "FSG_0x14", gRGB_red);
      enableControl("FSG_AudioSD_Properties_2", "FSG_0x14_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x15))
  {
      SetControlBackColor("FSG_AudioSD_Properties_2", "FSG_0x15", gRGB_white);
      enableControl("FSG_AudioSD_Properties_2", "FSG_0x15_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_2", "FSG_0x15", gRGB_red);
      enableControl("FSG_AudioSD_Properties_2", "FSG_0x15_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x16))
  {
      SetControlBackColor("FSG_AudioSD_Properties_2", "FSG_0x16", gRGB_white);
      enableControl("FSG_AudioSD_Properties_2", "FSG_0x16_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_2", "FSG_0x16", gRGB_red);
      enableControl("FSG_AudioSD_Properties_2", "FSG_0x16_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x17))
  {
      SetControlBackColor("FSG_AudioSD_0x17 - ReceptionList_(array)", "FSG_0x17", gRGB_white);
      enableControl("FSG_AudioSD_0x17 - ReceptionList_(array)", "FSG_0x17_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_0x17 - ReceptionList_(array)", "FSG_0x17", gRGB_red);
      enableControl("FSG_AudioSD_0x17 - ReceptionList_(array)", "FSG_0x17_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x18))
  {
      SetControlBackColor("FSG_AudioSD_Methods", "FSG_0x18", gRGB_white);
      enableControl("FSG_AudioSD_Methods", "FSG_0x18_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Methods", "FSG_0x18", gRGB_red);
      enableControl("FSG_AudioSD_Methods", "FSG_0x18_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x19))
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x19", gRGB_white);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x19_PanelElement", TRUE);
  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x19", gRGB_red);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x19_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x1A))
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x1A", gRGB_white);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x1A_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x1A", gRGB_red);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x1A_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x1B))
  {
      SetControlBackColor("FSG_AudioSD_0x1B - TpMemoList_(array)", "FSG_0x1B", gRGB_white);
      enableControl("FSG_AudioSD_0x1B - TpMemoList_(array)", "FSG_0x1B_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_0x1B - TpMemoList_(array)", "FSG_0x1B", gRGB_red);
      enableControl("FSG_AudioSD_0x1B - TpMemoList_(array)", "FSG_0x1B_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x1C))
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x1C", gRGB_white);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x1C_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x1C", gRGB_red);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x1C_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x1D))
  {
      SetControlBackColor("FSG_AudioSD_Methods", "FSG_0x1D", gRGB_white);
      enableControl("FSG_AudioSD_Methods", "FSG_0x1D_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Methods", "FSG_0x1D", gRGB_red);
      enableControl("FSG_AudioSD_Methods", "FSG_0x1D_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x1E))
  {
      SetControlBackColor("FSG_AudioSD_Properties_1", "FSG_0x1E", gRGB_white);
      enableControl("FSG_AudioSD_Properties_1", "FSG_0x1E_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_1", "FSG_0x1E", gRGB_red);
      enableControl("FSG_AudioSD_Properties_1", "FSG_0x1E_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x1F))
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x1F", gRGB_white);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x1F_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x1F", gRGB_red);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x1F_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x20))
  {
      SetControlBackColor("FSG_AudioSD_0x20 - SourceList_(array)", "FSG_0x20", gRGB_white);
      enableControl("FSG_AudioSD_0x20 - SourceList_(array)", "FSG_0x20_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_0x20 - SourceList_(array)", "FSG_0x20", gRGB_red);
      enableControl("FSG_AudioSD_0x20 - SourceList_(array)", "FSG_0x20_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x21))
  {
      SetControlBackColor("FSG_AudioSD_0x21 - RadioTV_PresetList_(array)", "FSG_0x21", gRGB_white);
      enableControl("FSG_AudioSD_0x21 - RadioTV_PresetList_(array)", "FSG_0x21_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_0x21 - RadioTV_PresetList_(array)", "FSG_0x21", gRGB_red);
      enableControl("FSG_AudioSD_0x21 - RadioTV_PresetList_(array)", "FSG_0x21_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x22))
  {
      SetControlBackColor("FSG_AudioSD_Methods", "FSG_0x22", gRGB_white);
      enableControl("FSG_AudioSD_Methods", "FSG_0x22_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Methods", "FSG_0x22", gRGB_red);
      enableControl("FSG_AudioSD_Methods", "FSG_0x22_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x23))
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x23", gRGB_white);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x23_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x23", gRGB_red);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x23_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x24))
  {
      SetControlBackColor("FSG_AudioSD_0x24 - MediaBrowser_(array)", "FSG_0x24", gRGB_white);
      enableControl("FSG_AudioSD_0x24 - MediaBrowser_(array)", "FSG_0x24_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_0x24 - MediaBrowser_(array)", "FSG_0x24", gRGB_red);
      enableControl("FSG_AudioSD_0x24 - MediaBrowser_(array)", "FSG_0x24_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x25))
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x25", gRGB_white);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x25_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x25", gRGB_red);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x25_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x26))
  {
      SetControlBackColor("FSG_AudioSD_Methods", "FSG_0x26", gRGB_white);
      enableControl("FSG_AudioSD_Methods", "FSG_0x26_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Methods", "FSG_0x26", gRGB_red);
      enableControl("FSG_AudioSD_Methods", "FSG_0x26_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x27))
  {
      SetControlBackColor("FSG_AudioSD_Methods", "FSG_0x27", gRGB_white);
      enableControl("FSG_AudioSD_Methods", "FSG_0x27_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Methods", "FSG_0x27", gRGB_red);
      enableControl("FSG_AudioSD_Methods", "FSG_0x27_PanelElement", FALSE);
  }
  if (getvalue(env_AudioSD_FctList_0x28))
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x28", gRGB_white);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x28_PanelElement", TRUE);

  }
  else
  {
      SetControlBackColor("FSG_AudioSD_Properties_3", "FSG_0x28", gRGB_red);
      enableControl("FSG_AudioSD_Properties_3", "FSG_0x28_PanelElement", FALSE);
  }  
  
  //0x0D FSG-Control
  gAudioSD_FSGControl_Extension1 = 0;
  gAudioSD_FSGControl_Extension2 = 0;
  gAudioSD_FSGControl_Extension3 = 0;
  gAudioSD_FSGControl_Extension4 = 0;
  gAudioSD_FSGControl_Extension5 = 0;
  gAudioSD_FSGControl_Extension6 = 0;
  putvalue(env_AudioSD_FSGCtrl_Extension1, gAudioSD_FSGControl_Extension1);
  putvalue(env_AudioSD_FSGCtrl_Extension2, gAudioSD_FSGControl_Extension2);
  putvalue(env_AudioSD_FSGCtrl_Extension3, gAudioSD_FSGControl_Extension3);
  putvalue(env_AudioSD_FSGCtrl_Extension4, gAudioSD_FSGControl_Extension4);
  putvalue(env_AudioSD_FSGCtrl_Extension5, gAudioSD_FSGControl_Extension5);
  putvalue(env_AudioSD_FSGCtrl_Extension6, gAudioSD_FSGControl_Extension6);
  
  //0x0E FSG-Setup
  gAudioSD_FSGSetup_FunctionSupport = 0;
  gAudioSD_FSGSetup_FunctionSupport_Bit0 = 0;
  gAudioSD_FSGSetup_FunctionSupport_Bit1 = 0;
  gAudioSD_FSGSetup_FunctionProtection = 0;
  gAudioSD_FSGSetup_FunctionProtection_Bit0 = 0;
  gAudioSD_FSGSetup_WebAppState = 0;
  gAudioSD_FSGSetup_WebAppState_Bit0 = 0; 
  gAudioSD_FSGSetup_Extension1 = 0;
  gAudioSD_FSGSetup_Extension2 = 0;
  gAudioSD_FSGSetup_Extension3 = 0;
  gAudioSD_FSGSetup_Extension4 = 0;
  putvalue(env_AudioSD_FSGSetup_FctSupp_0, gAudioSD_FSGSetup_FunctionSupport_Bit0);
  putvalue(env_AudioSD_FSGSetup_FctSupp_1, gAudioSD_FSGSetup_FunctionSupport_Bit1);
  putvalue(env_AudioSD_FSGSetup_FctProt_0, gAudioSD_FSGSetup_FunctionProtection_Bit0);
  putvalue(env_AudioSD_FSGSetup_WAS_0, gAudioSD_FSGSetup_WebAppState_Bit0);
  putvalue(env_AudioSD_FSGSetup_Extension1, gAudioSD_FSGSetup_Extension1);
  putvalue(env_AudioSD_FSGSetup_Extension2, gAudioSD_FSGSetup_Extension2);
  putvalue(env_AudioSD_FSGSetup_Extension3, gAudioSD_FSGSetup_Extension3);
  putvalue(env_AudioSD_FSGSetup_Extension4, gAudioSD_FSGSetup_Extension4);

  //0x0F FSG-OperationState
  gAudioSD_FSGOperationState_OpState = FSGOPERATIONSTATE_INITIALIZING;
  gAudioSD_FSGOperationState_Extension1 = 0;
  gAudioSD_FSGOperationState_Extension2 = 0;
  gAudioSD_FSGOperationState_Extension3 = 0;
  gAudioSD_FSGOperationState_Extension4 = 0;
  gAudioSD_FSGOperationState_Extension5 = 0;
  putvalue(env_AudioSD_FSGOpState_OpState, gAudioSD_FSGOperationState_OpState);
  putvalue(env_AudioSD_FSGOpSt_Extension1, gAudioSD_FSGOperationState_Extension1);
  putvalue(env_AudioSD_FSGOpSt_Extension2, gAudioSD_FSGOperationState_Extension2);
  putvalue(env_AudioSD_FSGOpSt_Extension3, gAudioSD_FSGOperationState_Extension3);
  putvalue(env_AudioSD_FSGOpSt_Extension4, gAudioSD_FSGOperationState_Extension4);
  putvalue(env_AudioSD_FSGOpSt_Extension5, gAudioSD_FSGOperationState_Extension5);
  
  //0x10 ASG_Capabilities
  gAudioSD_ASGCapabilities_PresentationCapabilities = 0;
  gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 = 0;
  gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 = 0;
  gAudioSD_ASGCapabilities_Extension1 = 0;
  gAudioSD_ASGCapabilities_Extension2 = 0;
  gAudioSD_ASGCapabilities_Extension3 = 0;
  gAudioSD_ASGCapabilities_Extension4 = 0;
  gAudioSD_ASGCapabilities_Extension5 = 0;
  putvalue(env_AudioSD_ASGCapa_PresCa_DAB, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0);
  putvalue(env_AudioSD_ASGCapa_PresCa_SDARS, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1);
  putvalue(env_AudioSD_ASGCapa_Extension1, gAudioSD_ASGCapabilities_Extension1);
  putvalue(env_AudioSD_ASGCapa_Extension2, gAudioSD_ASGCapabilities_Extension2);
  putvalue(env_AudioSD_ASGCapa_Extension3, gAudioSD_ASGCapabilities_Extension3);
  putvalue(env_AudioSD_ASGCapa_Extension4, gAudioSD_ASGCapabilities_Extension4);
  putvalue(env_AudioSD_ASGCapa_Extension5, gAudioSD_ASGCapabilities_Extension5);
  
  //0x11 InfoStates
  gAudioSD_InfoStates_States = 0;
  gAudioSD_InfoStates_AdditionalStateInfo_Bit0 = 0;
  gAudioSD_InfoStates_AdditionalStateInfo = gAudioSD_InfoStates_AdditionalStateInfo_Bit0;
  gAudioSD_InfoStates_Extension1 = 0;
  gAudioSD_InfoStates_Extension2 = 0;
  gAudioSD_InfoStates_Extension3 = 0;
  gAudioSD_InfoStates_Extension4 = 0;
  putvalue(env_AudioSD_InfoStates_states, gAudioSD_InfoStates_States);
  putvalue(env_AudioSD_InfoStates_AddStInfo, gAudioSD_InfoStates_AdditionalStateInfo);
  putvalue(env_AudioSD_InfoStates_Ext1, gAudioSD_InfoStates_Extension1);
  putvalue(env_AudioSD_InfoStates_Ext2, gAudioSD_InfoStates_Extension2);
  putvalue(env_AudioSD_InfoStates_Ext3, gAudioSD_InfoStates_Extension3);
  putvalue(env_AudioSD_InfoStates_Ext4, gAudioSD_InfoStates_Extension4);
  
  //0x12 SDS_State
  gAudioSD_SDSState_State = 0;
  gAudioSD_SDSState_Extension1 = 0;
  gAudioSD_SDSState_Extension2 = 0;
  gAudioSD_SDSState_Extension3 = 0;
  gAudioSD_SDSState_Extension4 = 0;
  gAudioSD_SDSState_Extension5 = 0;
  putvalue(env_AudioSD_SDSState_State, gAudioSD_SDSState_State);
  putvalue(env_AudioSD_SDSState_Extension1, gAudioSD_SDSState_Extension1);
  putvalue(env_AudioSD_SDSState_Extension2, gAudioSD_SDSState_Extension2);
  putvalue(env_AudioSD_SDSState_Extension3, gAudioSD_SDSState_Extension3);
  putvalue(env_AudioSD_SDSState_Extension4, gAudioSD_SDSState_Extension4);
  putvalue(env_AudioSD_SDSState_Extension5, gAudioSD_SDSState_Extension5);
  
  //0x13 GeneralInfoSwitches
  gAudioSD_GeneralInfoSwitches_OnOffSwitches = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC = 0;
  gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS = 0;
  gAudioSD_GeneralInfoSwitches_Extension1 = 0;
  gAudioSD_GeneralInfoSwitches_Extension2 = 0;
  gAudioSD_GeneralInfoSwitches_Extension3 = 0;
  gAudioSD_GeneralInfoSwitches_Extension4 = 0;
  gAudioSD_GeneralInfoSwitches_Extension5 = 0;
  putvalue(env_AudioSD_GIS_OnOff_TPTA, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA);
  putvalue(env_AudioSD_GIS_OnOff_RDS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS);
  putvalue(env_AudioSD_GIS_OnOff_JPtraffic, gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic);
  putvalue(env_AudioSD_GIS_OnOff_TMC, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC);
  putvalue(env_AudioSD_GIS_OnOff_VICS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS);
  putvalue(env_AudioSD_GIS_Extension1, gAudioSD_GeneralInfoSwitches_Extension1);
  putvalue(env_AudioSD_GIS_Extension2, gAudioSD_GeneralInfoSwitches_Extension2);
  putvalue(env_AudioSD_GIS_Extension3, gAudioSD_GeneralInfoSwitches_Extension3);
  putvalue(env_AudioSD_GIS_Extension4, gAudioSD_GeneralInfoSwitches_Extension4);
  putvalue(env_AudioSD_GIS_Extension5, gAudioSD_GeneralInfoSwitches_Extension5);
  
  //0x14 ActiveSource
  gAudioSD_activeSource_SourceType = ACTIVESOURCE_SOURCETYPE_FM;
  gAudioSD_activeSource_SourceList_Reference = 0;
  gAudioSD_activeSource_ListAvailable_Bit0 = 0;
  gAudioSD_activeSource_ListAvailable_Bit1 = 0;
  gAudioSD_activeSource_ListAvailable_Bit2 = 0;
  gAudioSD_activeSource_ListAvailable = (gAudioSD_activeSource_ListAvailable_Bit2*0x04) + (gAudioSD_activeSource_ListAvailable_Bit1*0x02) + (gAudioSD_activeSource_ListAvailable_Bit0&0x01);
  gAudioSD_activeSource_ListState = ACTIVESOURCE_LISTSTATE_COMPLETELY_LOADED;
  gAudioSD_activeSource_Number = 0;
  gAudioSD_activeSource_Extension1 = 0;
  putvalue(env_AudioSD_activeSrc_Type, gAudioSD_activeSource_SourceType);
  putvalue(env_AudioSD_activeSrc_SLRef, gAudioSD_activeSource_SourceList_Reference);
  putvalue(env_AudioSD_activeSrc_ReceptList, gAudioSD_activeSource_ListAvailable_Bit0);
  putvalue(env_AudioSD_activeSrc_PresetList, gAudioSD_activeSource_ListAvailable_Bit1);
  putvalue(env_AudioSD_activeSrc_MedBrList, gAudioSD_activeSource_ListAvailable_Bit2);
  putvalue(env_AudioSD_activeSrc_ListState, gAudioSD_activeSource_ListState);
  putvalue(env_AudioSD_activeSrc_number, gAudioSD_activeSource_Number);
  putvalue(env_AudioSD_activeSrc_Extension1, gAudioSD_activeSource_Extension1);
  
  //0x15 ActiveSourceName
  for (i = 0; i < ACTIVE_SOURCE_NAME_LENGTH; i++)
      gAudioSD_activeSourceName[i] = 0;
  strncpy(gAudioSD_activeSourceName, "'activeSourceName'", elcount(gAudioSD_activeSourceName));
  putvalue(env_AudioSD_activeSourceName, gAudioSD_activeSourceName);
  
  //0x16 CurrentVolume
  gAudioSD_currentVolume_ChangingVolumeType = 0;
  gAudioSD_currentVolume_maxVolume = 0;
  gAudioSD_currentVolume_GenericVolume = 0;
  gAudioSD_currentVolume_MuteState = 0;
  gAudioSD_currentVolume_Extension1 = 0;
  gAudioSD_currentVolume_Extension2 = 0;
  putvalue(env_AudioSD_currentVolume_Change, gAudioSD_currentVolume_ChangingVolumeType);
  putvalue(env_AudioSD_currentVolume_MaxVol, gAudioSD_currentVolume_maxVolume);
  putvalue(env_AudioSD_currentVolume_GenVol, gAudioSD_currentVolume_GenericVolume);
  putvalue(env_AudioSD_Mute_Mute, gAudioSD_currentVolume_MuteState);
  putvalue(env_AudioSD_currentVolume_Ext1, gAudioSD_currentVolume_Extension1);
  putvalue(env_AudioSD_currentVolume_Ext2, gAudioSD_currentVolume_Extension2);
  
  //0x17 SourceState
  gAudioSD_SourceState_StateInfo = 0;
  gAudioSD_SourceState_Scope = 0;
  gAudioSD_SourceState_Extension1 = 0;
  gAudioSD_SourceState_Extension2 = 0;
  gAudioSD_SourceState_Extension3 = 0;
  gAudioSD_SourceState_Extension4 = 0;
  putvalue(env_AudioSD_SourceState_StInfo, gAudioSD_SourceState_StateInfo);
  putvalue(env_AudioSD_SourceState_Scope, gAudioSD_SourceState_Scope);
  putvalue(env_AudioSD_SourceState_Ext1, gAudioSD_SourceState_Extension1);
  putvalue(env_AudioSD_SourceState_Ext2, gAudioSD_SourceState_Extension2);
  putvalue(env_AudioSD_SourceState_Ext3, gAudioSD_SourceState_Extension3);
  putvalue(env_AudioSD_SourceState_Ext4, gAudioSD_SourceState_Extension4);
  
  //0x18 CurrentStationInfo
  gAudioSD_CSI_PI_Type = 0;
  gAudioSD_CSI_PIID = 0;
  gAudioSD_CSI_SI_Type = 0;
  gAudioSD_CSI_TI_Type = 0;
  gAudioSD_CSI_QI_Type = 0;
  gAudioSD_CSI_I5_Type = 0;
  gAudioSD_CSI_I6_Type = 0;
  gAudioSD_CSI_I7_Type = 0;
  gAudioSD_CSI_I8_Type = 0;
  gAudioSD_CSI_ChannelID = 0;
  gAudioSD_CSI_RadioCategory = 0;
  gAudioSD_CSI_Extension1 = 0;
  gAudioSD_CSI_TATP = TRUE;
  gAudioSD_CSI_TMC = 0;
  gAudioSD_CSI_VICS = 0;
  gAudioSD_CSI_IBOC = 0;
  gAudioSD_CSI_RadioText = 0;
  gAudioSD_CSI_StationInfoSwitches = gAudioSD_CSI_TATP + (gAudioSD_CSI_TMC * 0x02) + (gAudioSD_CSI_VICS * 0x04) 
                                  + (gAudioSD_CSI_IBOC * 0x08) + (gAudioSD_CSI_RadioText * 0x10);
  gAudioSD_CSI_StationProperties_IBOC = 0;
  gAudioSD_CSI_StationProperties_BallGameMode = 0;
  gAudioSD_CSI_StationProperties_DABservice = 0;
  gAudioSD_CSI_StationProperties_OnlineBuffering = 0;
  gAudioSD_CSI_StationProperties_SmartFavorite = 0;
  gAudioSD_CSI_StationProperties = gAudioSD_CSI_StationProperties_IBOC + (gAudioSD_CSI_StationProperties_BallGameMode * 0x02) 
                                + (gAudioSD_CSI_StationProperties_DABservice * 0x04) + (gAudioSD_CSI_StationProperties_OnlineBuffering * 0x08)
                                + (gAudioSD_CSI_StationProperties_SmartFavorite * 0x10);
  for (i = 0; i < PRIMARYINFORMATION_TEXTLENGTH; i++)
    gAudioSD_CSI_PrimaryInformation[i] = 0;
  strncpy(gAudioSD_CSI_PrimaryInformation, "'CSI_PrimaryInformation'", elcount(gAudioSD_CSI_PrimaryInformation));

  for (i = 0; i < SECONDARYINFORMATION_TEXTLENGTH; i++)
    gAudioSD_CSI_SecondaryInformation[i] = 0;
  strncpy(gAudioSD_CSI_SecondaryInformation, "'CSI_SecondaryInformation'", elcount(gAudioSD_CSI_SecondaryInformation));

  for (i = 0; i < TERTIARYINFORMATION_TEXTLENGTH; i++)
    gAudioSD_CSI_TertiaryInformation[i] = 0;
  strncpy(gAudioSD_CSI_TertiaryInformation, "'CSI_TertiaryInformation'", elcount(gAudioSD_CSI_TertiaryInformation));

  for (i = 0; i < QUATERNARYINFORMATION_TEXTLENGTH; i++)
  {
    gAudioSD_CSI_QuarternaryInformation[i] = 0;
    gAudioSD_CSI_Information5[i] = 0;
    gAudioSD_CSI_Information6[i] = 0;
    gAudioSD_CSI_Information7[i] = 0;
    gAudioSD_CSI_Information8[i] = 0;
  }
  strncpy(gAudioSD_CSI_QuarternaryInformation, "'CSI_QuarternaryInformation'", elcount(gAudioSD_CSI_QuarternaryInformation));

  putvalue(Env_FSG_CSI2_I1, gAudioSD_CSI_PrimaryInformation);
  putvalue(Env_FSG_CSI2_IT1, gAudioSD_CSI_PI_Type);
  putvalue(Env_FSG_CSI2_ID1, gAudioSD_CSI_PIID);
  putvalue(Env_FSG_CSI2_I2, gAudioSD_CSI_SecondaryInformation);
  putvalue(Env_FSG_CSI2_IT2, gAudioSD_CSI_SI_Type);
  putvalue(Env_FSG_CSI2_I3, gAudioSD_CSI_TertiaryInformation);
  putvalue(Env_FSG_CSI2_IT3, gAudioSD_CSI_TI_Type);
  putvalue(Env_FSG_CSI2_I4, gAudioSD_CSI_QuarternaryInformation);
  putvalue(Env_FSG_CSI2_IT4, gAudioSD_CSI_QI_Type);
  putvalue(Env_FSG_CSI2_I5, gAudioSD_CSI_Information5);
  putvalue(Env_FSG_CSI2_IT5, gAudioSD_CSI_I5_Type);
  putvalue(Env_FSG_CSI2_I6, gAudioSD_CSI_Information6);
  putvalue(Env_FSG_CSI2_IT6, gAudioSD_CSI_I6_Type);
  putvalue(Env_FSG_CSI2_I7, gAudioSD_CSI_Information7);
  putvalue(Env_FSG_CSI2_IT7, gAudioSD_CSI_I7_Type);
  putvalue(Env_FSG_CSI2_I8, gAudioSD_CSI_Information8);
  putvalue(Env_FSG_CSI2_IT8, gAudioSD_CSI_I8_Type);
  putvalue(Env_FSG_CSI2_STS_TA, gAudioSD_CSI_TATP);
  putvalue(Env_FSG_CSI2_STS_TMC, gAudioSD_CSI_TMC);
  putvalue(Env_FSG_CSI2_STS_VICS, gAudioSD_CSI_VICS);
  putvalue(Env_FSG_CSI2_STS_IBOC, gAudioSD_CSI_IBOC);
  putvalue(Env_FSG_CSI2_STS_Radio, gAudioSD_CSI_RadioText);
  putvalue(Env_FSG_CSI2_SP_IBOC, gAudioSD_CSI_StationProperties_IBOC);
  putvalue(Env_FSG_CSI2_SP_Ball, gAudioSD_CSI_StationProperties_BallGameMode);
  putvalue(Env_FSG_CSI2_SP_DAB, gAudioSD_CSI_StationProperties_DABservice);
  putvalue(Env_FSG_CSI2_SP_Online, gAudioSD_CSI_StationProperties_OnlineBuffering);
  putvalue(Env_FSG_CSI2_SP_Smart, gAudioSD_CSI_StationProperties_SmartFavorite);
  putvalue(Env_FSG_CSI2_SLS, gAudioSD_CSI_StationLinkingState);
  putvalue(Env_FSG_CSI2_CID, gAudioSD_CSI_ChannelID);
  putvalue(Env_FSG_CSI2_RadioCat, gAudioSD_CSI_RadioCategory);
  putvalue(Env_FSG_CSI2_Extension1, gAudioSD_CSI_Extension1);  
  
  //0x19 CurrentStation_Handle
  gAudioSD_CSIhandle_FSGhandle = 0x10;
  gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;
  gAudioSD_CSIhandle_PresetListRef = 0;
  gAudioSD_CSIhandle_PresetListabsolutePos = 0;
  gAudioSD_CSIhandle_PictureRef = 0;
  gAudioSD_CSIhandle_Extension1 = 0;
  gAudioSD_CSIhandle_Extension2 = 0;
  gAudioSD_CSIhandle_Extension3 = 0;
  gAudioSD_CSIhandle_Extension4 = 0;
  gAudioSD_CSIhandle_Extension5 = 0;
  gAudioSD_CSIhandle_Extension6 = 0;
  gAudioSD_CSIhandle_Extension7 = 0;
  gAudioSD_CSIhandle_Extension8 = 0;
  gAudioSD_CSIhandle_Extension9 = 0;
  gAudioSD_CSIhandle_Extension10 = 0;
  gAudioSD_CSIhandle_Extension11 = 0;
  gAudioSD_CSIhandle_Extension12 = 0;
  gAudioSD_CSIhandle_Extension13 = 0;
  gAudioSD_CSIhandle_Extension14 = 0;
  gAudioSD_CSIhandle_Extension15 = 0;

  putvalue(env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle);
  putvalue(env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos);
  putvalue(env_AudioSD_CSH_PresetListRef, gAudioSD_CSIhandle_PresetListRef);
  putvalue(env_AudioSD_CSH_PresetListAbsPos, gAudioSD_CSIhandle_PresetListabsolutePos);
  putvalue(env_AudioSD_CSH_PicRef, gAudioSD_CSIhandle_PictureRef);
  putvalue(env_AudioSD_CSH_Extension01, gAudioSD_CSIhandle_Extension1);
  putvalue(env_AudioSD_CSH_Extension02, gAudioSD_CSIhandle_Extension2);
  putvalue(env_AudioSD_CSH_Extension03, gAudioSD_CSIhandle_Extension3);
  putvalue(env_AudioSD_CSH_Extension04, gAudioSD_CSIhandle_Extension4);
  putvalue(env_AudioSD_CSH_Extension05, gAudioSD_CSIhandle_Extension5);
  putvalue(env_AudioSD_CSH_Extension06, gAudioSD_CSIhandle_Extension6);
  putvalue(env_AudioSD_CSH_Extension07, gAudioSD_CSIhandle_Extension7);
  putvalue(env_AudioSD_CSH_Extension08, gAudioSD_CSIhandle_Extension8);
  putvalue(env_AudioSD_CSH_Extension09, gAudioSD_CSIhandle_Extension9);
  putvalue(env_AudioSD_CSH_Extension10, gAudioSD_CSIhandle_Extension10);
  putvalue(env_AudioSD_CSH_Extension11, gAudioSD_CSIhandle_Extension11);
  putvalue(env_AudioSD_CSH_Extension12, gAudioSD_CSIhandle_Extension12);
  putvalue(env_AudioSD_CSH_Extension13, gAudioSD_CSIhandle_Extension13);
  putvalue(env_AudioSD_CSH_Extension14, gAudioSD_CSIhandle_Extension14);
  putvalue(env_AudioSD_CSH_Extension15, gAudioSD_CSIhandle_Extension15);
  
  //0x1A PlayPosition
  gAudioSD_PlayPosition_TimePosition = 0;
  gAudioSD_PlayPosition_TotalPlayTime = 0;
  gAudioSD_PlayPosition_Attributes_Bit0 = 0;
  gAudioSD_PlayPosition_Attributes = gAudioSD_PlayPosition_Attributes_Bit0;
  gAudioSD_PlayPosition_BufferLevel = 0;
  putvalue(Env_FSG_PP_TP, gAudioSD_PlayPosition_TimePosition);
  putvalue(Env_FSG_PP_TPT, gAudioSD_PlayPosition_TotalPlayTime);
  putvalue(Env_FSG_PP_A, gAudioSD_PlayPosition_Attributes);
  putvalue(Env_FSG_PP_BL, gAudioSD_PlayPosition_BufferLevel);
  
  //0x1B Station_Track_Switch
  gAudioSD_STS_Event = 0;
  gAudioSD_STS_Direction = 0;
  gAudioSD_STS_Extension1 = 0;
  gAudioSD_STS_Extension2 = 0;
  gAudioSD_STS_Extension3 = 0;
  gAudioSD_STS_Extension4 = 0;
  gAudioSD_STS_Extension5 = 0;
  putvalue(Env_FSG_STS_Event, gAudioSD_STS_Event);
  putvalue(Env_FSG_STS_Direction, gAudioSD_STS_Direction);
  putvalue(Env_FSG_STS_Extension1, gAudioSD_STS_Extension1);
  putvalue(Env_FSG_STS_Extension2, gAudioSD_STS_Extension2);
  putvalue(Env_FSG_STS_Extension3, gAudioSD_STS_Extension3);
  putvalue(Env_FSG_STS_Extension4, gAudioSD_STS_Extension4);
  putvalue(Env_FSG_STS_Extension5, gAudioSD_STS_Extension5);
  
  //0x1C AnnouncementInfo
  gAudioSD_AnnouncementInfo_Type = ANNOUNCEMENT_TYPE_NO_MESSAGE;
  for (i = 0; i < ANNOUNCEMENT_STATIONNAME_TEXTLENGTH; i++)
      gAudioSD_AnnouncementInfo_StationName[i] = 0;
  strncpy(gAudioSD_AnnouncementInfo_StationName, "'Announcement_StationName'", elcount(gAudioSD_AnnouncementInfo_StationName));
  putvalue(env_AudioSD_AnInfo_Type, 0);
  putvalue(env_AudioSD_AnInfo_StationName, gAudioSD_AnnouncementInfo_StationName);
  
  //0x1D AnnouncementEscape
  gAudioSD_AnnouncementEscape_AsgId = 0;
  gAudioSD_AnnouncementEscape_Extension1 = 0;
  gAudioSD_AnnouncementEscape_Reserve = 0;
  gAudioSD_AnnouncementEscape_Result = 0;
  putvalue(env_AudioSD_AnE_AsgId, gAudioSD_AnnouncementEscape_AsgId);
  putvalue(env_AudioSD_AnE_Extension1, gAudioSD_AnnouncementEscape_Extension1);
  putvalue(env_AudioSD_AnE_Res, gAudioSD_AnnouncementEscape_Result);
  
  //0x1E ReceptionList
  gReceptionList_ASGID = 0;
  gReceptionList_TAID = 0;
  gReceptionList_TotalNumListElements = 0;
  gReceptionList_ElementType = AUDIO_RECEPTIONLISTTYPE_ELEMENTTYPE_ENSEMBLES;
  gReceptionList_ParentID = 0;
  gReceptionList_sum = 0;
  for (j = 0; j < AUDIO_RECEPTIONLIST_ENTRIES; j++)
  {
      gReceptionList_ListEntryValidInformation[j] = 0;
      gReceptionList_Pos[j] = 0;
      gReceptionList_Waveband[j] = 0;
      gReceptionList_Type[j] = 0;
      gReceptionList_Attributes1_Bit0[j] = 0;
      gReceptionList_Attributes1_Bit1[j] = 0;
      gReceptionList_Attributes1_Bit2[j] = 0;
      gReceptionList_Attributes1_Bit3[j] = 0;
      gReceptionList_Attributes1_Bit4[j] = 0;
      gReceptionList_Attributes1_Bit5[j] = 0;
      gReceptionList_Attributes1_Bit6[j] = 0;
      gReceptionList_Attributes1_Bit7[j] = 0;
      gReceptionList_Attributes1[j] = 0;
      gReceptionList_Attributes2_Bit0[j] = 0;
      gReceptionList_Attributes2_Bit1[j] = 0;
      gReceptionList_Attributes2_Bit2[j] = 0;
      gReceptionList_Attributes2_Bit3[j] = 0;
      gReceptionList_Attributes2[j] = 0;
      gReceptionList_PresetID[j] = 0;
      gReceptionList_FmRegCode[j] = 0;
      gReceptionList_Category[j] = 0;
      for (i = 0; i < AUDIO_RECEPTIONLIST_NAME_LENGTH; i++)
          gReceptionList_Name[j][i] = 0;
      for (i = 0; i < AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH; i++)
          gReceptionList_Frequency[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gReceptionList_CSV_filename[i] = 0;
  putvalue(env_AudioSD_RL_ASGID, gReceptionList_ASGID);
  putvalue(env_AudioSD_RL_TAID, gReceptionList_TAID);
  putvalue(env_AudioSD_RL_ParentID, gReceptionList_ParentID);
  putvalue(env_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements);
  putvalue(env_AudioSD_RL_ElementType, gReceptionList_ElementType);
  putvalue(env_AudioSD_RL_AH_shift, FALSE);
  putvalue(env_AudioSD_RL_AH_dir, FORWARD);
  putvalue(env_AudioSD_RL_AH_POS, TRUE);
  putvalue(env_AudioSD_RL_AH_IS, TRUE);
  putvalue(env_AudioSD_RL_AH_RA, 0);
  putvalue(env_AudioSD_RL_AH_start, 0);
  putvalue(env_AudioSD_RL_AH_elements, 3);
  putvalue(env_AudioSD_RL_DataSource, 0);
  putvalue(env_AudioSD_RL_CSVPath, empty_string);
  putvalue(env_AudioSD_RL_DataSource_result, empty_string);
  putvalue(env_AudioSD_RL_DataSource_file, empty_string);
  putvalue(env_AudioSD_RL_CA_switch, FALSE);
  putvalue(env_AudioSD_RL_Error_on, FALSE);
  putvalue(env_AudioSD_RL_ErrorCode, 0);
  
  //0x1F RadioTV_PresetList
  gRadioTVPresetList_ASGID = 0;
  gRadioTVPresetList_TAID = 0;
  gRadioTVPresetList_TotalNumListElements = 0;
  gRadioTVPresetList_sum = 0;
  for (j = 0; j < AUDIO_RADIOTVPRESETLIST_ENTRIES; j++)
  {
      gRadioTVPresetList_ListEntryValidInformation[j] = 0;
      gRadioTVPresetList_Pos[j] = 0;
      gRadioTVPresetList_PresetIndex[j] = 0;
      gRadioTVPresetList_Waveband[j] = 0;
      gRadioTVPresetList_Attributes1_Bit0[j] = 0;
      gRadioTVPresetList_Attributes1_Bit1[j] = 0;
      gRadioTVPresetList_Attributes1_Bit2[j] = 0;
      gRadioTVPresetList_Attributes1_Bit3[j] = 0;
      gRadioTVPresetList_Attributes1_Bit4[j] = 0;
      gRadioTVPresetList_Attributes1_Bit5[j] = 0;
      gRadioTVPresetList_Attributes1_Bit6[j] = 0;
      gRadioTVPresetList_Attributes1_Bit7[j] = 0;
      gRadioTVPresetList_Attributes1[j] = 0;
      gRadioTVPresetList_Attributes2_Bit0[j] = 0;
      gRadioTVPresetList_Attributes2_Bit1[j] = 0;
      gRadioTVPresetList_Attributes2_Bit2[j] = 0;
      gRadioTVPresetList_Attributes2_Bit3[j] = 0;
      gRadioTVPresetList_Attributes2_Bit4[j] = 0;
      gRadioTVPresetList_Attributes2[j] = 0;
      gRadioTVPresetList_PicRef[j] = 0;
      for (i = 0; i < AUDIO_RADIOTVPRESETLIST_NAME_LENGTH; i++)
          gRadioTVPresetList_Name[j][i] = 0;
      for (i = 0; i < AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH; i++)
          gRadioTVPresetList_Frequency[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gRadioTVPresetList_CSV_filename[i] = 0;
  putvalue(env_AudioSD_RTPL_ASGID, gRadioTVPresetList_ASGID);
  putvalue(env_AudioSD_RTPL_TAID, gRadioTVPresetList_TAID);
  putvalue(env_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements);
  putvalue(env_AudioSD_RTPL_AH_shift, FALSE);
  putvalue(env_AudioSD_RTPL_AH_dir, FORWARD);
  putvalue(env_AudioSD_RTPL_AH_POS, TRUE);
  putvalue(env_AudioSD_RTPL_AH_IS, TRUE);
  putvalue(env_AudioSD_RTPL_AH_RA, 0);
  putvalue(env_AudioSD_RTPL_AH_start, 0);
  putvalue(env_AudioSD_RTPL_AH_elements, 3);
  putvalue(env_AudioSD_RTPL_DataSource, 0);
  putvalue(env_AudioSD_RTPL_CSVPath, empty_string);
  putvalue(env_AudioSD_RTPL_DataSource_res, empty_string);
  putvalue(env_AudioSD_RTPL_DataSource_file, empty_string);
  putvalue(env_AudioSD_RTPL_CA_switch, FALSE);
  putvalue(env_AudioSD_RTPL_Error_on, FALSE);
  putvalue(env_AudioSD_RTPL_ErrorCode, 0);
  
  //0x20 ListSetup
  gAudioSD_ListSetup_PreferredList = 0;
  gAudioSD_ListSetup_ReceptionListType = 0;
  gAudioSD_ListSetup_Extension1 = 0;
  gAudioSD_ListSetup_Extension2 = 0;
  gAudioSD_ListSetup_Extension3 = 0;
  gAudioSD_ListSetup_Extension4 = 0;
  putvalue(env_AudioSD_ListSetup_PrefList, gAudioSD_ListSetup_PreferredList);
  putvalue(env_AudioSD_ListSetup_RListType, gAudioSD_ListSetup_ReceptionListType);
  putvalue(env_AudioSD_ListSetup_Ext1, gAudioSD_ListSetup_Extension1);
  putvalue(env_AudioSD_ListSetup_Ext2, gAudioSD_ListSetup_Extension2);
  putvalue(env_AudioSD_ListSetup_Ext3, gAudioSD_ListSetup_Extension3);
  putvalue(env_AudioSD_ListSetup_Ext4, gAudioSD_ListSetup_Extension4);
  
  //0x21 SourceList
  gSourceList_ASGID = 0;
  gSourceList_TAID = 0;
  gSourceList_TotalNumListElements = 0;
  gSourceList_sum = 0;
  for (j = 0; j < AUDIO_SOURCELIST_ENTRIES; j++)
  {
      gSourceList_ListEntryValidInformation[j] = 0;
      gSourceList_Pos[j] = 0;
      gSourceList_SourceType[j] = 0;
      gSourceList_InstanceID[j] = 0;
      gSourceList_PicRef[j] = 0;
      gSourceList_Attributes_Bit0[j] = 0;
      gSourceList_Attributes_Bit1[j] = 0;
      gSourceList_Attributes_Bit2[j] = 0;
      gSourceList_Attributes_Bit3[j] = 0;
      gSourceList_Attributes_Bit4[j] = 0;
      gSourceList_Attributes_Bit5[j] = 0;
      gSourceList_Attributes_Bit6[j] = 0;
      gSourceList_Attributes[j] = 0;
      for (i = 0; i < AUDIO_SOURCELIST_NAME_LENGTH; i++)
          gSourceList_Name[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gSourceList_CSV_filename[i] = 0;
  putvalue(env_AudioSD_SL_ASGID, gSourceList_ASGID);
  putvalue(env_AudioSD_SL_TAID, gSourceList_TAID);
  putvalue(env_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements);
  putvalue(env_AudioSD_SL_AH_shift, FALSE);
  putvalue(env_AudioSD_SL_AH_dir, FORWARD);
  putvalue(env_AudioSD_SL_AH_POS, TRUE);
  putvalue(env_AudioSD_SL_AH_IS, TRUE);
  putvalue(env_AudioSD_SL_AH_RA, 0);
  putvalue(env_AudioSD_SL_AH_start, 0);
  putvalue(env_AudioSD_SL_AH_elements, 3);
  putvalue(env_AudioSD_SL_DataSource, 0);
  putvalue(env_AudioSD_SL_CSVPath, empty_string);
  putvalue(env_AudioSD_SL_DataSource_result, empty_string);
  putvalue(env_AudioSD_SL_DataSource_file, empty_string);
  putvalue(env_AudioSD_SL_CA_switch, FALSE);
  putvalue(env_AudioSD_SL_Error_on, FALSE);
  putvalue(env_AudioSD_SL_ErrorCode, 0);
  
  //0x22 DedicatedAudioControl
  gAudioSD_DAC_AsgId = 0;
  gAudioSD_DAC_Extension1 = 0;
  gAudioSD_DAC_status = FALSE;
  gAudioSD_DAC_FSGHandle = 0;
  gAudioSD_DAC_Result = AUDIO_DAC_SUCCESSFUL;
  gAudioSD_DAC_ControlType = AUDIO_DAC_SELECT_LIST_ENTRY;
  gAudioSD_DAC_ListType = AUDIO_DAC_NOLIST;
  putvalue(env_AudioSD_DAC_AsgId, gAudioSD_DAC_AsgId);
  putvalue(env_AudioSD_DAC_Extension1, gAudioSD_DAC_Extension1);
  putvalue(env_AudioSD_DAC_Res, gAudioSD_DAC_Result);
  putvalue(env_AudioSD_DAC_Abort, AUDIO_DAC_ABORTSUCCESSFUL);
  putvalue(env_AudioSD_DAC_CT, gAudioSD_DAC_ControlType);
  putvalue(env_AudioSD_DAC_FSGHandle, gAudioSD_DAC_FSGHandle);
  putvalue(env_AudioSD_DAC_LT, gAudioSD_DAC_ListType);
  putvalue(env_AudioSD_DAC_Error_on, FALSE);
  putvalue(env_AudioSD_DAC_ErrorCode, 0);
  
  //0x23 SwitchSource
  gAudioSD_SwitchSource_status = FALSE;
  gAudioSD_SwitchSource_AsgId = 0;
  gAudioSD_SwitchSource_Extension1 = 0;
  gAudioSD_SwitchSource_ControlType = 0;
  gAudioSD_SwitchSource_Reference = 0;
  gAudioSD_SwitchSource_Reserve = 0;
  gAudioSD_SwitchSource_Result = AUDIO_SWITCHSOURCERESULT_SUCCESSFUL;
  putvalue(env_AudioSD_SwitchSource_AsgID, gAudioSD_SwitchSource_AsgId);
  putvalue(env_AudioSD_SwitchSource_Ext1, gAudioSD_SwitchSource_Extension1);
  putvalue(env_AudioSD_SwitchSource_CT, gAudioSD_SwitchSource_ControlType);
  putvalue(env_AudioSD_SwitchSource_Ref, gAudioSD_SwitchSource_Reference);
  putvalue(env_AudioSD_SwitchSource_Result, gAudioSD_SwitchSource_Result);
  putvalue(env_AudioSD_SwitchSource_Abort, AUDIO_SWITCHSOURCERESULT_ABORT_SUCCESSFUL);
  putvalue(env_AudioSD_SwitchSource_ErrorON, FALSE);
  putvalue(env_AudioSD_SwitchSource_ErrorC, 0);  
  
  //0x24 Browser_FolderLevel
  gAudioSD_MediaBrowser_FL_FolderLevel = 0;
  gAudioSD_MediaBrowser_FL_RefMediaBrowser = 0;
  gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos = 0;
  gAudioSD_MediaBrowser_FL_Extension1 = 0;
  putvalue(env_AudioSD_MedBrFoLev_FolLev, gAudioSD_MediaBrowser_FL_FolderLevel);
  putvalue(env_AudioSD_MedBrFoLev_Ref, gAudioSD_MediaBrowser_FL_RefMediaBrowser);
  putvalue(env_AudioSD_MedBrFoLev_Ref_abs, gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos);
  putvalue(env_AudioSD_MedBrFoLev_Ext1, gAudioSD_MediaBrowser_FL_Extension1);
  
  //0x25 Browser
  gMediaBrowser_ASGID = 0;
  gMediaBrowser_TAID = 0;
  gMediaBrowser_TotalNumListElements = 0;
  gMediaBrowser_ActiveListPos = 0;
  gMediaBrowser_sum = 0;
  for (j = 0; j < AUDIO_MEDIABROWSER_ENTRIES; j++)
  {
      gMediaBrowser_ListEntryValidInformation[j] = 0;
      gMediaBrowser_Pos[j] = 0;
      gMediaBrowser_Type[j] = 0;
      gMediaBrowser_FileState_Bit0[j] = 0;
      gMediaBrowser_FileState_Bit1[j] = 0;
      gMediaBrowser_FileState_Bit2[j] = 0;
      gMediaBrowser_FileState_Bit3[j] = 0;
      gMediaBrowser_FileState_Bit4[j] = 0;
      gMediaBrowser_FileState_Bit5[j] = 0;
      gMediaBrowser_FileState_Bit6[j] = 0;
      gMediaBrowser_FileState[j] = 0;
      gMediaBrowser_Waveband[j] = 0;
      gMediaBrowser_RadioCategory[j] = 0;
      gMediaBrowser_FmRegCode[j] = 0;
      gMediaBrowser_PresetID[j] = 0;
      gMediaBrowser_PicRef[j] = 0;
      gMediaBrowser_Attributes1_Bit0[j] = 0;
      gMediaBrowser_Attributes1_Bit1[j] = 0;
      gMediaBrowser_Attributes1_Bit2[j] = 0;
      gMediaBrowser_Attributes1_Bit3[j] = 0;
      gMediaBrowser_Attributes1_Bit4[j] = 0;
      gMediaBrowser_Attributes1_Bit5[j] = 0;
      gMediaBrowser_Attributes1_Bit6[j] = 0;
      gMediaBrowser_Attributes1_Bit7[j] = 0;
      gMediaBrowser_Attributes1[j] = 0;
      gMediaBrowser_Attributes2_Bit0[j] = 0;
      gMediaBrowser_Attributes2_Bit1[j] = 0;
      gMediaBrowser_Attributes2[j] = 0;
      for (i = 0; i < AUDIO_MEDIABROWSER_NAME_LENGTH; i++)
          gMediaBrowser_Name[j][i] = 0;
      for (i = 0; i < AUDIO_MEDIABROWSER_FREQUENCY_LENGTH; i++)
          gMediaBrowser_Frequency[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gMediaBrowser_CSV_filename[i] = 0;
  putvalue(env_AudioSD_MB_ASGID, gMediaBrowser_ASGID);
  putvalue(env_AudioSD_MB_TAID, gMediaBrowser_TAID);
  putvalue(env_AudioSD_MB_ActiveListPos, gMediaBrowser_ActiveListPos);
  putvalue(env_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements);
  putvalue(env_AudioSD_MB_AH_shift, FALSE);
  putvalue(env_AudioSD_MB_AH_dir, FORWARD);
  putvalue(env_AudioSD_MB_AH_POS, TRUE);
  putvalue(env_AudioSD_MB_AH_IS, TRUE);
  putvalue(env_AudioSD_MB_AH_RA, 0);
  putvalue(env_AudioSD_MB_AH_start, 0);
  putvalue(env_AudioSD_MB_AH_elements, 3);
  putvalue(env_AudioSD_MB_DataSource, 0);
  putvalue(env_AudioSD_MB_CSVPath, empty_string);
  putvalue(env_AudioSD_MB_DataSource_result, empty_string);
  putvalue(env_AudioSD_MB_DataSource_file, empty_string);
  putvalue(env_AudioSD_MB_CA_switch, FALSE);
  putvalue(env_AudioSD_MB_Error_on, FALSE);
  putvalue(env_AudioSD_MB_ErrorCode, 0);
  
  //0x26 BrowserPath
  gAudioSD_MediaPath_FolderType = 0;
  for (i = 0; i < MEDIAPATH_PATH_TEXTLENGTH; i++)
      gAudioSD_MediaPath_Path[i] = 0;
  strncpy(gAudioSD_MediaPath_Path, "'MediaPath'", elcount(gAudioSD_MediaPath_Path));
  putvalue(env_AudioSD_MedPath_Type, gAudioSD_MediaPath_FolderType);
  putvalue(env_AudioSD_MedPath_Path_s, gAudioSD_MediaPath_Path);
  
  //0x27 BrowserControl
  gAudioSD_MediaBrowserControl_status = FALSE;
  gAudioSD_MediaBrowserControl_AsgId = 0;
  gAudioSD_MediaBrowserControl_Extension1 = 0;
  gAudioSD_MediaBrowserControl_Control = 0;
  gAudioSD_MediaBrowserControl_Reference = 0;
  gAudioSD_MediaBrowserControl_Reserve = 0;
  gAudioSD_MediaBrowserControl_Result = AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL;
  putvalue(env_AudioSD_MBrC_AsgId, gAudioSD_MediaBrowserControl_AsgId);
  putvalue(env_AudioSD_MBrC_Ext1, gAudioSD_MediaBrowserControl_Extension1);
  putvalue(env_AudioSD_MBrC_Ref, gAudioSD_MediaBrowserControl_Reference);
  putvalue(env_AudioSD_MBrC_Control, gAudioSD_MediaBrowserControl_Control);
  putvalue(env_AudioSD_MBrC_Res, gAudioSD_MediaBrowserControl_Result);
  putvalue(env_AudioSD_MBrC_Abort, AUDIO_MEDIABROWSERCONTROL_ABORT_SUCCESSFUL);
  putvalue(env_AudioSD_MBrC_Error_on, FALSE);
  putvalue(env_AudioSD_MBrC_ErrorCode, 0);
  
  //0x28 Picture
  gPicture_ASGID = 0;
  gPicture_TAID = 0;
  gPicture_TotalNumListElements = 0;
  gPicture_sum = 0;
  for (j = 0; j < AUDIO_PICTURE_ENTRIES; j++)
  {
      gPicture_ListEntryValidInformation[j] = 0;
      gPicture_Pos[j] = 0;
      gPicture_Type[j] = 0;
      gPicture_TcpPort[j] = 0;
      for (i = 0; i < AUDIO_PICTURE_IPADDRESS_LENGTH; i++)
          gPicture_IpAddress[j][i] = 0;
      for (i = 0; i < AUDIO_PICTURE_URI_LENGTH; i++)
          gPicture_Uri[j][i] = 0;
  }
  for (i = 0; i < AUDIO_FILENAME_SIZE; i++)
      gPicture_CSV_filename[i] = 0;
  putvalue(env_AudioSD_Pic_AsgId, gPicture_ASGID);
  putvalue(env_AudioSD_Pic_TAID, gPicture_TAID);
  putvalue(env_AudioSD_Pic_TNLE, gPicture_TotalNumListElements);
  putvalue(env_AudioSD_Pic_AH_Shift, FALSE);
  putvalue(env_AudioSD_Pic_AH_Dir, FORWARD);
  putvalue(env_AudioSD_Pic_AH_TransPos, TRUE);
  putvalue(env_AudioSD_Pic_AH_IndexSize, TRUE);
  putvalue(env_AudioSD_Pic_AH_RecordAdd, 0);
  putvalue(env_AudioSD_Pic_AH_Start, 0);
  putvalue(env_AudioSD_Pic_AH_Elements, 3);
  putvalue(env_AudioSD_Pic_CSV_Default, 0);
  putvalue(env_AudioSD_Pic_CSV_Path, empty_string);
  putvalue(env_AudioSD_Pic_CSV_Result, empty_string);
  putvalue(env_AudioSD_Pic_CSV_Current, empty_string);
  //putvalue(env_AudioSD_Pic_CA_switch, FALSE);
  putvalue(env_AudioSD_Pic_Error_Status, FALSE);
  putvalue(env_AudioSD_Pic_ErrorCode, 0);
}

void Shutdown_AudioSD()
{
  canceltimer(TaskTimer);
  putvalue(env_AudioSD_Config_SWConfig, empty_string);
  putvalue(env_AudioSD_Config_DBC, empty_string);
  //activate FctList-Elements
  enableControl("FSG_AudioSD_MainPanel", "FSG_0x03_FctList", TRUE);

  //Panel elements...
  //FSG_Control ( 13, 0xD )
  putvalue(env_AudioSD_FSGCtrl_Extension1, 0);
  putvalue(env_AudioSD_FSGCtrl_Extension2, 0);
  putvalue(env_AudioSD_FSGCtrl_Extension3, 0);
  putvalue(env_AudioSD_FSGCtrl_Extension4, 0);
  putvalue(env_AudioSD_FSGCtrl_Extension5, 0);
  putvalue(env_AudioSD_FSGCtrl_Extension6, 0);
  //FSG_Setup ( 14, 0xE )
  putvalue(env_AudioSD_FSGSetup_FctSupp_0, 0);
  putvalue(env_AudioSD_FSGSetup_FctSupp_1, 0);
  putvalue(env_AudioSD_FSGSetup_FctProt_0, 0);
  putvalue(env_AudioSD_FSGSetup_WAS_0, 0);
  putvalue(env_AudioSD_FSGSetup_Extension1, 0);
  putvalue(env_AudioSD_FSGSetup_Extension2, 0);
  putvalue(env_AudioSD_FSGSetup_Extension3, 0);
  putvalue(env_AudioSD_FSGSetup_Extension4, 0);
  //FSG_OperationState ( 15, 0xF )
  putvalue(env_AudioSD_FSGOpState_OpState, 0);
  putvalue(env_AudioSD_FSGOpSt_Extension1, 0);
  putvalue(env_AudioSD_FSGOpSt_Extension2, 0);
  putvalue(env_AudioSD_FSGOpSt_Extension3, 0);
  putvalue(env_AudioSD_FSGOpSt_Extension4, 0);
  putvalue(env_AudioSD_FSGOpSt_Extension5, 0);
  //ASG_Capabilities ( 16, 0x10 )
  putvalue(env_AudioSD_ASGCapa_PresCa_DAB, 0);
  putvalue(env_AudioSD_ASGCapa_PresCa_SDARS, 0);
  putvalue(env_AudioSD_ASGCapa_Extension1, 0);
  putvalue(env_AudioSD_ASGCapa_Extension2, 0);
  putvalue(env_AudioSD_ASGCapa_Extension3, 0);
  putvalue(env_AudioSD_ASGCapa_Extension4, 0);
  putvalue(env_AudioSD_ASGCapa_Extension5, 0);
  //InfoStates ( 17, 0x11 )
  putvalue(env_AudioSD_InfoStates_states, 0);
  putvalue(env_AudioSD_InfoStates_AddStInfo, 0);
  putvalue(env_AudioSD_InfoStates_Ext1, 0);
  putvalue(env_AudioSD_InfoStates_Ext2, 0);
  putvalue(env_AudioSD_InfoStates_Ext3, 0);
  putvalue(env_AudioSD_InfoStates_Ext4, 0);
  //SDS_State ( 18, 0x12 )
  putvalue(env_AudioSD_SDSState_State, 0);
  putvalue(env_AudioSD_SDSState_Extension1, 0);
  putvalue(env_AudioSD_SDSState_Extension2, 0);
  putvalue(env_AudioSD_SDSState_Extension3, 0);
  putvalue(env_AudioSD_SDSState_Extension4, 0);
  putvalue(env_AudioSD_SDSState_Extension5, 0);
  //GeneralInfoSwitches ( 19, 0x13 )
  putvalue(env_AudioSD_GIS_OnOff_TPTA, 0);
  putvalue(env_AudioSD_GIS_OnOff_RDS, 0);
  putvalue(env_AudioSD_GIS_OnOff_JPtraffic, 0);
  putvalue(env_AudioSD_GIS_OnOff_TMC, 0);
  putvalue(env_AudioSD_GIS_OnOff_VICS, 0);
  putvalue(env_AudioSD_GIS_OnOff_ON, 0);
  putvalue(env_AudioSD_GIS_OnOff_DAB, 0);
  putvalue(env_AudioSD_GIS_Extension1, 0);
  putvalue(env_AudioSD_GIS_Extension2, 0);
  putvalue(env_AudioSD_GIS_Extension3, 0);
  putvalue(env_AudioSD_GIS_Extension4, 0);
  putvalue(env_AudioSD_GIS_Extension5, 0);
  //ActiveSource ( 20, 0x14 )
  putvalue(env_AudioSD_activeSrc_Type, 0);
  putvalue(env_AudioSD_activeSrc_SLRef, 0);
  putvalue(env_AudioSD_activeSrc_ReceptList, 0);
  putvalue(env_AudioSD_activeSrc_PresetList, 0);
  putvalue(env_AudioSD_activeSrc_MedBrList, 0);
  putvalue(env_AudioSD_activeSrc_ListState, 0);
  putvalue(env_AudioSD_activeSrc_Extension1, 0);
  putvalue(env_AudioSD_activeSrc_number, 0);
  //ActiveSourceName ( 21, 0x15 )
  putvalue(env_AudioSD_activeSourceName, "");
  //CurrentVolume ( 22, 0x16 )
  putvalue(env_AudioSD_currentVolume_Change, 0);
  putvalue(env_AudioSD_currentVolume_MaxVol, 0);
  putvalue(env_AudioSD_currentVolume_GenVol, 0);
  putvalue(env_AudioSD_Mute_Mute, 0);
  putvalue(env_AudioSD_Mute_DAB, 0);
  putvalue(env_AudioSD_Mute_DVB, 0);
  putvalue(env_AudioSD_Mute_SDARS, 0);
  putvalue(env_AudioSD_Mute_sync_IBOC, 0);
  putvalue(env_AudioSD_Mute_PhoneCall, 0);
  putvalue(env_AudioSD_Mute_IBOC, 0);
  putvalue(env_AudioSD_Mute_OnRad, 0);
  putvalue(env_AudioSD_currentVolume_Ext1, 0);
  putvalue(env_AudioSD_currentVolume_Ext2, 0);
  //SourceState ( 23, 0x17 )
  putvalue(env_AudioSD_SourceState_StInfo, 0);
  putvalue(env_AudioSD_SourceState_Scope, 0);
  putvalue(env_AudioSD_SourceState_Ext1, 0);
  putvalue(env_AudioSD_SourceState_Ext2, 0);
  putvalue(env_AudioSD_SourceState_Ext3, 0);
  putvalue(env_AudioSD_SourceState_Ext4, 0);
  //CurrentStationInfo ( 24, 0x18 )
  putvalue(Env_FSG_CSI2_I1, "");
  putvalue(Env_FSG_CSI2_I2, "");
  putvalue(Env_FSG_CSI2_I3, "");
  putvalue(Env_FSG_CSI2_I4, "");
  putvalue(Env_FSG_CSI2_I5, "");
  putvalue(Env_FSG_CSI2_I6, "");
  putvalue(Env_FSG_CSI2_I7, "");
  putvalue(Env_FSG_CSI2_I8, "");
  putvalue(Env_FSG_CSI2_ID1, 0);
  putvalue(Env_FSG_CSI2_IT1, 0);
  putvalue(Env_FSG_CSI2_IT2, 0);
  putvalue(Env_FSG_CSI2_IT3, 0);
  putvalue(Env_FSG_CSI2_IT4, 0);
  putvalue(Env_FSG_CSI2_IT5, 0);
  putvalue(Env_FSG_CSI2_IT6, 0);
  putvalue(Env_FSG_CSI2_IT7, 0);
  putvalue(Env_FSG_CSI2_IT8, 0);
  putvalue(Env_FSG_CSI2_STS_TA, 0);
  putvalue(Env_FSG_CSI2_STS_TMC, 0);
  putvalue(Env_FSG_CSI2_STS_VICS, 0);
  putvalue(Env_FSG_CSI2_STS_IBOC, 0);
  putvalue(Env_FSG_CSI2_STS_Radio, 0);
  putvalue(Env_FSG_CSI2_SP_IBOC, 0);
  putvalue(Env_FSG_CSI2_SP_Ball, 0);
  putvalue(Env_FSG_CSI2_SP_DAB, 0);
  putvalue(Env_FSG_CSI2_SP_Online, 0);
  putvalue(Env_FSG_CSI2_SP_Smart, 0);
  putvalue(Env_FSG_CSI2_SLS, 0);
  putvalue(Env_FSG_CSI2_CID, 0);
  putvalue(Env_FSG_CSI2_RadioCat, 0);
  putvalue(Env_FSG_CSI2_Extension1, 0);
  //CurrentStation_Handle ( 25, 0x19 )
  putvalue(env_AudioSD_CSH_FSGhandle, 0);
  putvalue(env_AudioSD_CSH_FSGAbsPos, 0);
  putvalue(env_AudioSD_CSH_PresetListRef, 0);
  putvalue(env_AudioSD_CSH_PresetListAbsPos, 0);
  putvalue(env_AudioSD_CSH_PicRef, 0);
  putvalue(env_AudioSD_CSH_Extension01, 0);
  putvalue(env_AudioSD_CSH_Extension02, 0);
  putvalue(env_AudioSD_CSH_Extension03, 0);
  putvalue(env_AudioSD_CSH_Extension04, 0);
  putvalue(env_AudioSD_CSH_Extension05, 0);
  putvalue(env_AudioSD_CSH_Extension06, 0);
  putvalue(env_AudioSD_CSH_Extension07, 0);
  putvalue(env_AudioSD_CSH_Extension08, 0);
  putvalue(env_AudioSD_CSH_Extension09, 0);
  putvalue(env_AudioSD_CSH_Extension10, 0);
  putvalue(env_AudioSD_CSH_Extension11, 0);
  putvalue(env_AudioSD_CSH_Extension12, 0);
  putvalue(env_AudioSD_CSH_Extension13, 0);
  putvalue(env_AudioSD_CSH_Extension14, 0);
  putvalue(env_AudioSD_CSH_Extension15, 0);
  //PlayPosition ( 26, 0x1A )
  putvalue(Env_FSG_PP_TP, 0);
  putvalue(Env_FSG_PP_TPT, 0);
  putvalue(Env_FSG_PP_A, 0);
  putvalue(Env_FSG_PP_BL, 0);
  //Station_Track_Switch ( 27, 0x1B )
  putvalue(Env_FSG_STS_Event, 0);
  putvalue(Env_FSG_STS_Direction, 0);
  putvalue(Env_FSG_STS_Extension1, 0);
  putvalue(Env_FSG_STS_Extension2, 0);
  putvalue(Env_FSG_STS_Extension3, 0);
  putvalue(Env_FSG_STS_Extension4, 0);
  putvalue(Env_FSG_STS_Extension5, 0);
  //AnnouncementInfo ( 28, 0x1C )
  putvalue(env_AudioSD_AnInfo_Type, 0);
  putvalue(env_AudioSD_AnInfo_StationName, "");
  //AnnouncementEscape ( 29, 0x1D )
  putvalue(env_AudioSD_AnE_AsgId, 0);
  putvalue(env_AudioSD_AnE_Extension1, 0);
  putvalue(env_AudioSD_AnE_Res, 0);
  //ReceptionList ( 30, 0x1E )
  putvalue(env_AudioSD_RL_ASGID, 0);
  putvalue(env_AudioSD_RL_TAID, 0);
  putvalue(env_AudioSD_RL_ElementType, 0);
  putvalue(env_AudioSD_RL_ParentID, 0);
  putvalue(env_AudioSD_RL_TotalNumLE, 0);
  putvalue(env_AudioSD_RL_AH_shift, 0);
  putvalue(env_AudioSD_RL_AH_dir, 0);
  putvalue(env_AudioSD_RL_AH_POS, 0);
  putvalue(env_AudioSD_RL_AH_IS, 0);
  putvalue(env_AudioSD_RL_AH_RA, 0);
  putvalue(env_AudioSD_RL_AH_start, 0);
  putvalue(env_AudioSD_RL_AH_elements, 0);
  //RadioTV_PresetList ( 31, 0x1F )
  putvalue(env_AudioSD_RTPL_ASGID, 0);
  putvalue(env_AudioSD_RTPL_TAID, 0);
  putvalue(env_AudioSD_RTPL_TotalNumLE, 0);
  putvalue(env_AudioSD_RTPL_AH_shift, 0);
  putvalue(env_AudioSD_RTPL_AH_dir, 0);
  putvalue(env_AudioSD_RTPL_AH_POS, 0);
  putvalue(env_AudioSD_RTPL_AH_IS, 0);
  putvalue(env_AudioSD_RTPL_AH_RA, 0);
  putvalue(env_AudioSD_RTPL_AH_start, 0);
  putvalue(env_AudioSD_RTPL_AH_elements, 0);
  //ListSetup ( 32, 0x20 )
  putvalue(env_AudioSD_ListSetup_PrefList, 0);
  putvalue(env_AudioSD_ListSetup_RListType, 0);
  putvalue(env_AudioSD_ListSetup_Ext1, 0);
  putvalue(env_AudioSD_ListSetup_Ext2, 0);
  putvalue(env_AudioSD_ListSetup_Ext3, 0);
  putvalue(env_AudioSD_ListSetup_Ext4, 0);
  //SourceList ( 33, 0x21 )
  putvalue(env_AudioSD_SL_ASGID, 0);
  putvalue(env_AudioSD_SL_TAID, 0);
  putvalue(env_AudioSD_SL_TotalNumLE, 0);
  putvalue(env_AudioSD_SL_AH_shift, 0);
  putvalue(env_AudioSD_SL_AH_dir, 0);
  putvalue(env_AudioSD_SL_AH_POS, 0);
  putvalue(env_AudioSD_SL_AH_IS, 0);
  putvalue(env_AudioSD_SL_AH_RA, 0);
  putvalue(env_AudioSD_SL_AH_start, 0);
  putvalue(env_AudioSD_SL_AH_elements, 0);
  //DedicatedAudioControl ( 34, 0x22 )
  putvalue(env_AudioSD_DAC_AsgId, 0);
  putvalue(env_AudioSD_DAC_Extension1, 0);
  putvalue(env_AudioSD_DAC_CT, 0);
  putvalue(env_AudioSD_DAC_Res, 0);
  putvalue(env_AudioSD_DAC_FSGHandle, 0);
  putvalue(env_AudioSD_DAC_LT, 0);
  //SwitchSource ( 35, 0x23 )
  putvalue(env_AudioSD_SwitchSource_AsgID, 0);
  putvalue(env_AudioSD_SwitchSource_Ext1, 0);
  putvalue(env_AudioSD_SwitchSource_CT, 0);
  putvalue(env_AudioSD_SwitchSource_Ref, 0);
  putvalue(env_AudioSD_SwitchSource_Result, 0);
  //Browser_FolderLevel ( 36, 0x24 )
  putvalue(env_AudioSD_MedBrFoLev_FolLev, 0);
  putvalue(env_AudioSD_MedBrFoLev_Ref, 0);
  putvalue(env_AudioSD_MedBrFoLev_Ref_abs, 0);
  putvalue(env_AudioSD_MedBrFoLev_Ext1, 0);
  //Browser ( 37, 0x25 )
  putvalue(env_AudioSD_MB_ASGID, 0);
  putvalue(env_AudioSD_MB_TAID, 0);
  putvalue(env_AudioSD_MB_TotalNumLE, 0);
  putvalue(env_AudioSD_MB_ActiveListPos, 0);
  putvalue(env_AudioSD_MB_AH_shift, 0);
  putvalue(env_AudioSD_MB_AH_dir, 0);
  putvalue(env_AudioSD_MB_AH_POS, 0);
  putvalue(env_AudioSD_MB_AH_IS, 0);
  putvalue(env_AudioSD_MB_AH_RA, 0);
  putvalue(env_AudioSD_MB_AH_start, 0);
  putvalue(env_AudioSD_MB_AH_elements, 0);
  //BrowserPath ( 38, 0x26 )
  putvalue(env_AudioSD_MedPath_Type, 0);
  putvalue(env_AudioSD_MedPath_Path_s, "");
  //BrowserControl ( 39, 0x27 )
  putvalue(env_AudioSD_MBrC_AsgId, 0);
  putvalue(env_AudioSD_MBrC_Ext1, 0);
  putvalue(env_AudioSD_MBrC_Control, 0);
  putvalue(env_AudioSD_MBrC_Res, 0);
  putvalue(env_AudioSD_MBrC_Ref, 0);
  //Picture ( 40, 0x28 )
  putvalue(env_AudioSD_Pic_AsgId, 0);
  putvalue(env_AudioSD_Pic_TAID, 0);
  putvalue(env_AudioSD_Pic_TNLE, 0);
  putvalue(env_AudioSD_Pic_AH_Shift, 0);
  putvalue(env_AudioSD_Pic_AH_Dir, 0);
  putvalue(env_AudioSD_Pic_AH_TransPos, 0);
  putvalue(env_AudioSD_Pic_AH_IndexSize, 0);
  putvalue(env_AudioSD_Pic_AH_RecordAdd, 0);
  putvalue(env_AudioSD_Pic_AH_Start, 0);
  putvalue(env_AudioSD_Pic_AH_Elements, 0);
}

void BAP_Set_Cache()	//initialize BAP-FSG-Cache
{
  int Offset;
  dword Cache_Request_Header[6];
  byte Cache_Request_Data[255];
  byte i, error = 0;
  word wTemp;

  /***FctID_FunctionList***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
  Cache_Request_Header[1] = FctID_FunctionList;   //Fct-ID
  Cache_Request_Header[2] = 0;                        //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
  Cache_Request_Header[4] = 8;                        //length
  Cache_Request_Header[5] = 0;		                //ignored
  for (i = 0; i < 8; i++)
    Cache_Request_Data[i] = gFunctionList[i];
  Fct_initSendBuf("FunctionList", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;

  /***FSG-Control***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
  Cache_Request_Header[1] = FctID_FSG_Control;      //Fct-ID
  Cache_Request_Header[2] = 0;                        //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
  Cache_Request_Header[4] = 6;                        //length
  Cache_Request_Header[5] = 0;		                //ignored
  Cache_Request_Data[0] = gAudioSD_FSGControl_Extension1;
  Cache_Request_Data[1] = gAudioSD_FSGControl_Extension2;
  Cache_Request_Data[2] = gAudioSD_FSGControl_Extension3;
  Cache_Request_Data[3] = gAudioSD_FSGControl_Extension4;
  Cache_Request_Data[4] = gAudioSD_FSGControl_Extension5;
  Cache_Request_Data[5] = gAudioSD_FSGControl_Extension6;
  Fct_initSendBuf("FSG_Control", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
      Cache_Request_Data[i] = 0;
  
  /***FSG-Setup***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
  Cache_Request_Header[1] = FctID_FSG_Setup;      //Fct-ID
  Cache_Request_Header[2] = 0;                        //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
  Cache_Request_Header[4] = 6;                        //length
  Cache_Request_Header[5] = 0;		                //ignored
  Cache_Request_Data[0] = gAudioSD_FSGSetup_FunctionSupport;
  Cache_Request_Data[1] = gAudioSD_FSGSetup_FunctionProtection;
  Cache_Request_Data[2] = (gAudioSD_FSGSetup_WebAppState*0x10)+(gAudioSD_FSGSetup_Extension1&0x0f);
  Cache_Request_Data[3] = gAudioSD_FSGSetup_Extension2;
  Cache_Request_Data[4] = gAudioSD_FSGSetup_Extension3;
  Cache_Request_Data[5] = gAudioSD_FSGSetup_Extension4;
  Fct_initSendBuf("FSG_Setup", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;

  /***FSG-OperationState***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;              //LSG-ID
  Cache_Request_Header[1] = FctID_FSG_OperationState; //Fct-ID
  Cache_Request_Header[2] = 0;                            //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;         //data-type
  Cache_Request_Header[4] = 6;                            //length 
  Cache_Request_Header[5] = 0;                         //ignored
  Cache_Request_Data[0] = gAudioSD_FSGOperationState_OpState;
  Cache_Request_Data[1] = gAudioSD_FSGOperationState_Extension1;
  Cache_Request_Data[2] = gAudioSD_FSGOperationState_Extension2;
  Cache_Request_Data[3] = gAudioSD_FSGOperationState_Extension3;
  Cache_Request_Data[4] = gAudioSD_FSGOperationState_Extension4;
  Cache_Request_Data[5] = gAudioSD_FSGOperationState_Extension5;
  Fct_initSendBuf("FSG_OperationState", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;

  /***ASG_Capabilities***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;                                          //LSG-ID
  Cache_Request_Header[1] = FctID_ASG_Capabilities;                               //Fct-ID
  Cache_Request_Header[2] = 0;                                                    //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;                                     //data-type
  Cache_Request_Header[4] = 6;                            //length 
  Cache_Request_Header[5] = 0;                         //ignored
  Cache_Request_Data[0] = gAudioSD_ASGCapabilities_PresentationCapabilities;
  Cache_Request_Data[1] = gAudioSD_ASGCapabilities_Extension1;
  Cache_Request_Data[2] = gAudioSD_ASGCapabilities_Extension2;
  Cache_Request_Data[3] = gAudioSD_ASGCapabilities_Extension3;
  Cache_Request_Data[4] = gAudioSD_ASGCapabilities_Extension4;
  Cache_Request_Data[5] = gAudioSD_ASGCapabilities_Extension5;
  Fct_initSendBuf("ASG_Capabilities", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;

  /***InfoStates***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;               //LSG-ID
  Cache_Request_Header[1] = FctID_InfoStates;          //Fct-ID
  Cache_Request_Header[2] = 0;                             //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;              //data-type
  Cache_Request_Header[4] = 6;                            //length 
  Cache_Request_Header[5] = 0;                         //ignored
  Cache_Request_Data[0] = gAudioSD_InfoStates_States;
  Cache_Request_Data[1] = gAudioSD_InfoStates_AdditionalStateInfo;
  Cache_Request_Data[2] = gAudioSD_InfoStates_Extension1;
  Cache_Request_Data[3] = gAudioSD_InfoStates_Extension2;
  Cache_Request_Data[4] = gAudioSD_InfoStates_Extension3;
  Cache_Request_Data[5] = gAudioSD_InfoStates_Extension4;
  Fct_initSendBuf("InfoStates", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;
  
  /***SDS_State***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;                  //LSG-ID
  Cache_Request_Header[1] = FctID_SDS_State;              //Fct-ID
  Cache_Request_Header[2] = 0;                            //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;              //data-type
  Cache_Request_Header[4] = 6;                            //length 
  Cache_Request_Header[5] = 0;                         //ignored
  Cache_Request_Data[0] = gAudioSD_SDSState_State;
  Cache_Request_Data[1] = gAudioSD_SDSState_Extension1;
  Cache_Request_Data[2] = gAudioSD_SDSState_Extension2;
  Cache_Request_Data[3] = gAudioSD_SDSState_Extension3;
  Cache_Request_Data[4] = gAudioSD_SDSState_Extension4;
  Cache_Request_Data[5] = gAudioSD_SDSState_Extension5;
  Fct_initSendBuf("SDS_State", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;
  
  /***GeneralInfoSwitches***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;              //LSG-ID
  Cache_Request_Header[1] = FctID_GeneralInfoSwitches; //Fct-ID
  Cache_Request_Header[2] = 0;                            //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;         //data-type
  Cache_Request_Header[4] = 6;                            //length
  Cache_Request_Header[5] = 0;		                    //ignored
  Cache_Request_Data[0] = gAudioSD_GeneralInfoSwitches_OnOffSwitches;
  Cache_Request_Data[1] = gAudioSD_GeneralInfoSwitches_Extension1;
  Cache_Request_Data[2] = gAudioSD_GeneralInfoSwitches_Extension2;
  Cache_Request_Data[3] = gAudioSD_GeneralInfoSwitches_Extension3;
  Cache_Request_Data[4] = gAudioSD_GeneralInfoSwitches_Extension4;
  Cache_Request_Data[5] = gAudioSD_GeneralInfoSwitches_Extension5;
  Fct_initSendBuf("GeneralInfoSwitches", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;
  
  /***activeSource***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;              //LSG-ID
  Cache_Request_Header[1] = FctID_ActiveSource;       //Fct-ID
  Cache_Request_Header[2] = 0;                            //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;         //data-type
  Cache_Request_Header[4] = 6;                            //length
  Cache_Request_Header[5] = 0;                            //ignored
  Cache_Request_Data[0] = gAudioSD_activeSource_SourceType;
  Cache_Request_Data[1] = gAudioSD_activeSource_SourceList_Reference & 0xff;
  Cache_Request_Data[2] = (gAudioSD_activeSource_SourceList_Reference & 0xff00) / 0x100;
  Cache_Request_Data[3] = gAudioSD_activeSource_ListAvailable;
  Cache_Request_Data[4] = (gAudioSD_activeSource_ListState * 0x10) + (gAudioSD_activeSource_Extension1 & 0x0f);
  Cache_Request_Data[5] = gAudioSD_activeSource_Number;
  Fct_initSendBuf("activeSource", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;
  
  /***activeSourceName***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;                          //LSG-ID
  Cache_Request_Header[1] = FctID_ActiveSourceName;               //Fct-ID
  Cache_Request_Header[2] = 0;                                        //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;                     //data-type
  Cache_Request_Header[4] = strlen(gAudioSD_activeSourceName) + 1;   //length
  Cache_Request_Header[5] = 0;                                        //ignored
  Cache_Request_Data[0] = strlen(gAudioSD_activeSourceName);
  Offset = 1;
  for (i = 0; i < strlen(gAudioSD_activeSourceName); i++)
  {
    Cache_Request_Data[Offset] = gAudioSD_activeSourceName[i];
    Offset++;
  }
  Fct_initSendBuf("activeSourceName", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;
  
  /***currentVolume***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;              //LSG-ID
  Cache_Request_Header[1] = FctID_CurrentVolume;      //Fct-ID
  Cache_Request_Header[2] = 0;                            //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;         //data-type
  Cache_Request_Header[4] = 6;                            //length
  Cache_Request_Header[5] = 0;                            //ignored
  Cache_Request_Data[0] = gAudioSD_currentVolume_ChangingVolumeType;
  Cache_Request_Data[1] = gAudioSD_currentVolume_maxVolume;
  Cache_Request_Data[2] = gAudioSD_currentVolume_GenericVolume;
  Cache_Request_Data[3] = gAudioSD_currentVolume_MuteState;
  Cache_Request_Data[4] = gAudioSD_currentVolume_Extension1;
  Cache_Request_Data[5] = gAudioSD_currentVolume_Extension2;
  Fct_initSendBuf("currentVolume", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;
  
  /***SourceState***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
  Cache_Request_Header[1] = FctID_SourceState;        //Fct-ID
  Cache_Request_Header[2] = 0;                        //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
  Cache_Request_Header[4] = 6;                        //length
  Cache_Request_Header[5] = 0;				        //ignored
  Cache_Request_Data[0] = gAudioSD_SourceState_StateInfo;
  Cache_Request_Data[1] = gAudioSD_SourceState_Scope;
  Cache_Request_Data[2] = gAudioSD_SourceState_Extension1;
  Cache_Request_Data[3] = gAudioSD_SourceState_Extension2;
  Cache_Request_Data[4] = gAudioSD_SourceState_Extension3;
  Cache_Request_Data[5] = gAudioSD_SourceState_Extension4;
  Fct_initSendBuf("SourceState", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;
  
  /***CurrentStationInfo***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;                  //LSG-ID
  Cache_Request_Header[1] = FctID_CurrentStationInfo;     //Fct-ID
  Cache_Request_Header[2] = 0;                                //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;             //data-type
  Cache_Request_Header[4] = strlen(gAudioSD_CSI_PrimaryInformation) 
                          + strlen(gAudioSD_CSI_SecondaryInformation) 
                          + strlen(gAudioSD_CSI_TertiaryInformation) 
                          + strlen(gAudioSD_CSI_QuarternaryInformation) 
                          + strlen(gAudioSD_CSI_Information5) 
                          + strlen(gAudioSD_CSI_Information6) 
                          + strlen(gAudioSD_CSI_Information7) 
                          + strlen(gAudioSD_CSI_Information8) + 8 + 17;//length  
  Cache_Request_Header[5] = 0;                                //ignored
  //data
  Cache_Request_Data[0] = strlen(gAudioSD_CSI_PrimaryInformation);
  Offset = 1;
  for (i = 0; i < strlen(gAudioSD_CSI_PrimaryInformation); i++)
  {
    Cache_Request_Data[Offset] = gAudioSD_CSI_PrimaryInformation[i];
    Offset++;
  }
  Cache_Request_Data[Offset] = gAudioSD_CSI_PI_Type;
  Offset++;
  Cache_Request_Data[Offset] = gAudioSD_CSI_PIID & 0xff;
  Offset++;
  Cache_Request_Data[Offset] = (gAudioSD_CSI_PIID & 0xff00) / 0x100;
  Offset++;
  //SecondaryInformation
  Cache_Request_Data[Offset] = strlen(gAudioSD_CSI_SecondaryInformation);
  Offset++;
  for (i = 0; i < strlen(gAudioSD_CSI_SecondaryInformation); i++)
  {
    Cache_Request_Data[Offset] = gAudioSD_CSI_SecondaryInformation[i];
    Offset++;
  }
  Cache_Request_Data[Offset] = gAudioSD_CSI_SI_Type;
  Offset++;
  //TertiaryInformation
  Cache_Request_Data[Offset] = strlen(gAudioSD_CSI_TertiaryInformation);
  Offset++;
  for (i = 0; i < strlen(gAudioSD_CSI_TertiaryInformation); i++)
  {
    Cache_Request_Data[Offset] = gAudioSD_CSI_TertiaryInformation[i];
    Offset++;
  }
  Cache_Request_Data[Offset] = gAudioSD_CSI_TI_Type;
  Offset++;
  //QuaternaryInformation
  Cache_Request_Data[Offset] = strlen(gAudioSD_CSI_QuarternaryInformation);
  Offset++;
  for (i = 0; i < strlen(gAudioSD_CSI_QuarternaryInformation); i++)
  {
    Cache_Request_Data[Offset] = gAudioSD_CSI_QuarternaryInformation[i];
    Offset++;
  }
  Cache_Request_Data[Offset] = gAudioSD_CSI_QI_Type;
  Offset++;
  //Information5
  Cache_Request_Data[Offset] = strlen(gAudioSD_CSI_Information5);
  Offset++;
  for (i = 0; i < strlen(gAudioSD_CSI_Information5); i++)
  {
    Cache_Request_Data[Offset] = gAudioSD_CSI_Information5[i];
    Offset++;
  }
  Cache_Request_Data[Offset] = gAudioSD_CSI_I5_Type;
  Offset++;
  //Information6
  Cache_Request_Data[Offset] = strlen(gAudioSD_CSI_Information6);
  Offset++;
  for (i = 0; i < strlen(gAudioSD_CSI_Information6); i++)
  {
    Cache_Request_Data[Offset] = gAudioSD_CSI_Information6[i];
    Offset++;
  }
  Cache_Request_Data[Offset] = gAudioSD_CSI_I6_Type;
  Offset++;
  //Information7
  Cache_Request_Data[Offset] = strlen(gAudioSD_CSI_Information7);
  Offset++;
  for (i = 0; i < strlen(gAudioSD_CSI_Information7); i++)
  {
    Cache_Request_Data[Offset] = gAudioSD_CSI_Information7[i];
    Offset++;
  }
  Cache_Request_Data[Offset] = gAudioSD_CSI_I7_Type;
  Offset++;
  //Information8
  Cache_Request_Data[Offset] = strlen(gAudioSD_CSI_Information8);
  Offset++;
  for (i = 0; i < strlen(gAudioSD_CSI_Information8); i++)
  {
    Cache_Request_Data[Offset] = gAudioSD_CSI_Information8[i];
    Offset++;
  }
  Cache_Request_Data[Offset] = gAudioSD_CSI_I8_Type;
  Offset++;
  //StationInfoSwitches
  Cache_Request_Data[Offset] = gAudioSD_CSI_StationInfoSwitches;
  Offset++;
  //StationProperties
  Cache_Request_Data[Offset] = gAudioSD_CSI_StationProperties;
  Offset++;
  //StationLinkingState
  Cache_Request_Data[Offset] = gAudioSD_CSI_StationLinkingState;
  Offset++;
  //Channel_ID
  Cache_Request_Data[Offset] = gAudioSD_CSI_ChannelID & 0xff;
  Offset++;
  Cache_Request_Data[Offset] = (gAudioSD_CSI_ChannelID & 0xff00) / 0x100;
  Offset++;
  //RadioCategory
  Cache_Request_Data[Offset] = gAudioSD_CSI_RadioCategory;
  Offset++;
  //Extension1
  Cache_Request_Data[Offset] = gAudioSD_CSI_Extension1;
  Offset++;
  Fct_initSendBuf("CurrentStationInfo", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
      Cache_Request_Data[i] = 0;
  
  /***CurrentStation_Handle***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;                  //LSG-ID
  Cache_Request_Header[1] = FctID_CurrentStation_Handle;  //Fct-ID
  Cache_Request_Header[2] = 0;                                //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;             //data-type
  Cache_Request_Header[4] = 23;                            //length
  Cache_Request_Header[5] = 0;							    //ignored
  Cache_Request_Data[0]  = gAudioSD_CSIhandle_FSGhandle & 0xff;
  Cache_Request_Data[1]  = (gAudioSD_CSIhandle_FSGhandle & 0xff00) / 0x100;
  Cache_Request_Data[2]  = gAudioSD_CSIhandle_FSGhandle_absolutePos & 0xff;
  Cache_Request_Data[3]  = (gAudioSD_CSIhandle_FSGhandle_absolutePos & 0xff00) / 0x100;
  Cache_Request_Data[4]  = gAudioSD_CSIhandle_PresetListRef;
  Cache_Request_Data[5]  = gAudioSD_CSIhandle_PresetListabsolutePos;
  Cache_Request_Data[6]  = gAudioSD_CSIhandle_PictureRef & 0xff;
  Cache_Request_Data[7]  = (gAudioSD_CSIhandle_PictureRef & 0xff00) / 0x100;
  Cache_Request_Data[8]  = gAudioSD_CSIhandle_Extension1;
  Cache_Request_Data[9]  = gAudioSD_CSIhandle_Extension2;
  Cache_Request_Data[10] = gAudioSD_CSIhandle_Extension3;
  Cache_Request_Data[11] = gAudioSD_CSIhandle_Extension4;
  Cache_Request_Data[12] = gAudioSD_CSIhandle_Extension5;
  Cache_Request_Data[13] = gAudioSD_CSIhandle_Extension6;
  Cache_Request_Data[14] = gAudioSD_CSIhandle_Extension7;
  Cache_Request_Data[15] = gAudioSD_CSIhandle_Extension8;
  Cache_Request_Data[16] = gAudioSD_CSIhandle_Extension9;
  Cache_Request_Data[17] = gAudioSD_CSIhandle_Extension10;
  Cache_Request_Data[18] = gAudioSD_CSIhandle_Extension11;
  Cache_Request_Data[19] = gAudioSD_CSIhandle_Extension12;
  Cache_Request_Data[20] = gAudioSD_CSIhandle_Extension13;
  Cache_Request_Data[21] = gAudioSD_CSIhandle_Extension14;
  Cache_Request_Data[22] = gAudioSD_CSIhandle_Extension15;
  Fct_initSendBuf("CurrentStation_Handle", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;
  
  /***PlayPosition***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
  Cache_Request_Header[1] = FctID_PlayPosition;//Fct-ID
  Cache_Request_Header[2] = 0;                        //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
  Cache_Request_Header[4] = 6;                        //length
  Cache_Request_Header[5] = 0;		                //ignored
  Cache_Request_Data[0] = gAudioSD_PlayPosition_TimePosition & 0xff;
  Cache_Request_Data[1] = (gAudioSD_PlayPosition_TimePosition & 0xff00) / 0x100;
  Cache_Request_Data[2] = gAudioSD_PlayPosition_TotalPlayTime & 0xff;
  Cache_Request_Data[3] = (gAudioSD_PlayPosition_TotalPlayTime & 0xff00) / 0x100;
  Cache_Request_Data[4] = gAudioSD_PlayPosition_Attributes;
  Cache_Request_Data[5] = gAudioSD_PlayPosition_BufferLevel;
  Fct_initSendBuf("PlayPosition", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++) 
    Cache_Request_Data[i] = 0;
    
  /***Station_Track_Switch***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
  Cache_Request_Header[1] = FctID_Station_Track_Switch;//Fct-ID
  Cache_Request_Header[2] = 0;                        //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
  Cache_Request_Header[4] = 6;                        //length
  Cache_Request_Header[5] = 0;		                //ignored
  Cache_Request_Data[0] = (gAudioSD_STS_Event * 0x10) + (gAudioSD_STS_Direction & 0x0f);
  Cache_Request_Data[1] = gAudioSD_STS_Extension1;
  Cache_Request_Data[2] = gAudioSD_STS_Extension2;
  Cache_Request_Data[3] = gAudioSD_STS_Extension3;
  Cache_Request_Data[4] = gAudioSD_STS_Extension4;
  Cache_Request_Data[5] = gAudioSD_STS_Extension5;
  Fct_initSendBuf("Station_Track_Switch", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++) 
    Cache_Request_Data[i] = 0;
  
  /***AnnouncementInfo***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;                                      //LSG-ID
  Cache_Request_Header[1] = FctID_AnnouncementInfo;                           //Fct-ID
  Cache_Request_Header[2] = 0;                                                    //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;                                 //data-type
  Cache_Request_Header[4] = 2 + strlen(gAudioSD_AnnouncementInfo_StationName);    //length
  Cache_Request_Header[5] = 0;                                                    //ignored
  Cache_Request_Data[0] = gAudioSD_AnnouncementInfo_Type;
  Cache_Request_Data[1] = strlen(gAudioSD_AnnouncementInfo_StationName);
  Offset = 2;
  for (i = 0; i < strlen(gAudioSD_AnnouncementInfo_StationName); i++)
  {
    Cache_Request_Data[Offset] = gAudioSD_AnnouncementInfo_StationName[i];
    Offset++;
  }
  Fct_initSendBuf("AnnouncementInfo", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;
  
  /***ListSetup***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
  Cache_Request_Header[1] = FctID_ListSetup;      //Fct-ID
  Cache_Request_Header[2] = 0;                        //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
  Cache_Request_Header[4] = 6;                        //length
  Cache_Request_Header[5] = 0;		                //ignored
  Cache_Request_Data[0] = gAudioSD_ListSetup_PreferredList;
  Cache_Request_Data[1] = gAudioSD_ListSetup_ReceptionListType;
  Cache_Request_Data[2] = gAudioSD_ListSetup_Extension1;
  Cache_Request_Data[3] = gAudioSD_ListSetup_Extension2;
  Cache_Request_Data[4] = gAudioSD_ListSetup_Extension3;
  Cache_Request_Data[5] = gAudioSD_ListSetup_Extension4;
  Fct_initSendBuf("ListSetup", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++) 
    Cache_Request_Data[i] = 0;
  
  /***Browser_FolderLevel***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
  Cache_Request_Header[1] = FctID_Browser_FolderLevel;       //Fct-ID
  Cache_Request_Header[2] = 0;                        //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
  Cache_Request_Header[4] = 6;                        //length
  Cache_Request_Header[5] = 0;						//ignored
  Cache_Request_Data[0] = gAudioSD_MediaBrowser_FL_FolderLevel;
  Cache_Request_Data[1] = gAudioSD_MediaBrowser_FL_RefMediaBrowser & 0xff;
  Cache_Request_Data[2] = (gAudioSD_MediaBrowser_FL_RefMediaBrowser & 0xff00) / 0x100;
  Cache_Request_Data[3] = gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos & 0xff;
  Cache_Request_Data[4] = (gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos & 0xff00) / 0x100;
  Cache_Request_Data[5] = gAudioSD_MediaBrowser_FL_Extension1;
  Fct_initSendBuf("Browser_FolderLevel", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;
  
  /***BrowserPath***/
  //header
  Cache_Request_Header[0] = LSG_AudioSD;                      //LSG-ID
  Cache_Request_Header[1] = FctID_BrowserPath;                  //Fct-ID
  Cache_Request_Header[2] = 0;                                    //ignored
  Cache_Request_Header[3] = Bap_ByteSequence;                 //data-type
  Cache_Request_Header[4] = strlen(gAudioSD_MediaPath_Path) + 2; //length
  Cache_Request_Header[5] = 0;						            //ignored
  Cache_Request_Data[0] = gAudioSD_MediaPath_FolderType;
  Cache_Request_Data[1] = strlen(gAudioSD_MediaPath_Path);
  Offset = 2;
  for (i = 0; i < strlen(gAudioSD_MediaPath_Path); i++)
  {
    Cache_Request_Data[Offset] = gAudioSD_MediaPath_Path[i];
    Offset++;
  }
  Fct_initSendBuf("BrowserPath", Cache_Request_Header, Cache_Request_Data);
  for (i = 0; i < 255; i++)
    Cache_Request_Data[i] = 0;
}

void ReceptionList_init_static()
{
  byte j, i, ReceptionListLine;

  //clear
  ReceptionListLine = 0;
  gReceptionList_sum = 0;
  for (j = 0; j < AUDIO_RECEPTIONLIST_ENTRIES; j++)
  {
    gReceptionList_Pos[j] = 0;
    gReceptionList_Waveband[j] = 0;
    gReceptionList_Type[j] = 0;
    gReceptionList_Attributes1_Bit0[j] = 0;
    gReceptionList_Attributes1_Bit1[j] = 0;
    gReceptionList_Attributes1_Bit2[j] = 0;
    gReceptionList_Attributes1_Bit3[j] = 0;
    gReceptionList_Attributes1_Bit4[j] = 0;
    gReceptionList_Attributes1_Bit5[j] = 0;
    gReceptionList_Attributes1_Bit6[j] = 0;
    gReceptionList_Attributes1_Bit7[j] = 0;
    gReceptionList_Attributes1[j] = 0;
    gReceptionList_Attributes2_Bit0[j] = 0;
    gReceptionList_Attributes2_Bit1[j] = 0;
    gReceptionList_Attributes2_Bit2[j] = 0;
    gReceptionList_Attributes2_Bit3[j] = 0;
    gReceptionList_Attributes2[j] = 0;
    gReceptionList_PresetID[j] = 0;
    gReceptionList_FmRegCode[j] = 0;
    gReceptionList_Category[j] = 0;
    for (i = 0; i < AUDIO_RECEPTIONLIST_NAME_LENGTH; i++)
      gReceptionList_Name[j][i] = 0;
    for (i = 0; i < AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH; i++)
      gReceptionList_Frequency[j][i] = 0;
    gReceptionList_PicRef[j] = 0;
    gReceptionList_ListEntryValidInformation[j] = 0;
  }
  //entry 0
  gReceptionList_ListEntryValidInformation[ReceptionListLine] = TRUE;
  gReceptionList_Pos[ReceptionListLine] = 0x10;
  gReceptionList_Waveband[ReceptionListLine] = 3;
  gReceptionList_Type[ReceptionListLine] = 4;
  gReceptionList_Attributes1_Bit0[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1_Bit1[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1_Bit2[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1_Bit3[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1_Bit4[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1_Bit5[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1_Bit6[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1_Bit7[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1[ReceptionListLine] = 
    gReceptionList_Attributes1_Bit0[ReceptionListLine] + 
    (gReceptionList_Attributes1_Bit1[ReceptionListLine] * 0x02) + 
    (gReceptionList_Attributes1_Bit2[ReceptionListLine] * 0x04) + 
    (gReceptionList_Attributes1_Bit3[ReceptionListLine] * 0x08) + 
    (gReceptionList_Attributes1_Bit4[ReceptionListLine] * 0x10) + 
    (gReceptionList_Attributes1_Bit5[ReceptionListLine] * 0x20) + 
    (gReceptionList_Attributes1_Bit6[ReceptionListLine] * 0x40) + 
    (gReceptionList_Attributes1_Bit7[ReceptionListLine] * 0x80);
  gReceptionList_Attributes2_Bit0[ReceptionListLine] = TRUE;
  gReceptionList_Attributes2_Bit1[ReceptionListLine] = TRUE;
  gReceptionList_Attributes2_Bit2[ReceptionListLine] = TRUE;
  gReceptionList_Attributes2_Bit3[ReceptionListLine] = TRUE;
  gReceptionList_Attributes2[ReceptionListLine] = 
    gReceptionList_Attributes2_Bit0[ReceptionListLine] + 
    (gReceptionList_Attributes2_Bit1[ReceptionListLine] * 0x02) + 
    (gReceptionList_Attributes2_Bit2[ReceptionListLine] * 0x04) + 
    (gReceptionList_Attributes2_Bit3[ReceptionListLine] * 0x08);
  gReceptionList_PresetID[ReceptionListLine] = 0x32;
  gReceptionList_FmRegCode[ReceptionListLine] = 0x74;
  gReceptionList_Category[ReceptionListLine] = 8;
  strncpy(gReceptionList_Name[ReceptionListLine], "Name_0", AUDIO_RECEPTIONLIST_NAME_LENGTH);
  strncpy(gReceptionList_Frequency[ReceptionListLine], "Frequency_0", AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH);
  ReceptionListLine++;
  //entry 1
  gReceptionList_ListEntryValidInformation[ReceptionListLine] = TRUE;
  gReceptionList_Pos[ReceptionListLine] = 0x74;
  gReceptionList_Type[ReceptionListLine] = 5;
  gReceptionList_Attributes1_Bit0[ReceptionListLine] = FALSE;
  gReceptionList_Attributes1_Bit1[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1_Bit2[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1_Bit3[ReceptionListLine] = FALSE;
  gReceptionList_Attributes1_Bit4[ReceptionListLine] = FALSE;
  gReceptionList_Attributes1_Bit5[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1_Bit6[ReceptionListLine] = TRUE;
  gReceptionList_Attributes1_Bit7[ReceptionListLine] = FALSE;
  gReceptionList_Attributes1[ReceptionListLine] = 
    gReceptionList_Attributes1_Bit0[ReceptionListLine] + 
    (gReceptionList_Attributes1_Bit1[ReceptionListLine] * 0x02) + 
    (gReceptionList_Attributes1_Bit2[ReceptionListLine] * 0x04) + 
    (gReceptionList_Attributes1_Bit3[ReceptionListLine] * 0x08) + 
    (gReceptionList_Attributes1_Bit4[ReceptionListLine] * 0x10) + 
    (gReceptionList_Attributes1_Bit5[ReceptionListLine] * 0x20) + 
    (gReceptionList_Attributes1_Bit6[ReceptionListLine] * 0x40) + 
    (gReceptionList_Attributes1_Bit7[ReceptionListLine] * 0x80);
  gReceptionList_Attributes2_Bit0[ReceptionListLine] = TRUE;
  gReceptionList_Attributes2_Bit1[ReceptionListLine] = FALSE;
  gReceptionList_Attributes2_Bit2[ReceptionListLine] = TRUE;
  gReceptionList_Attributes2_Bit3[ReceptionListLine] = FALSE;
  gReceptionList_Attributes2[ReceptionListLine] = 
    gReceptionList_Attributes2_Bit0[ReceptionListLine] + 
    (gReceptionList_Attributes2_Bit1[ReceptionListLine] * 0x02) + 
    (gReceptionList_Attributes2_Bit2[ReceptionListLine] * 0x04) + 
    (gReceptionList_Attributes2_Bit3[ReceptionListLine] * 0x08);
  gReceptionList_PresetID[ReceptionListLine] = 0x71;
  gReceptionList_FmRegCode[ReceptionListLine] = 0x62;
  gReceptionList_Category[ReceptionListLine] = 0x24;
  strncpy(gReceptionList_Name[ReceptionListLine], "Name_1", AUDIO_RECEPTIONLIST_NAME_LENGTH);
  strncpy(gReceptionList_Frequency[ReceptionListLine], "Frequency_1", AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH);
  ReceptionListLine++;
  gReceptionList_sum = ReceptionListLine;
  gReceptionList_TotalNumListElements = gReceptionList_sum;
  writelineEx(gReceptionList_writeWindow, 0, "Anzahl der Listenelemente: %d", gReceptionList_sum);
  putvalue(env_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements);
  gAudioSD_CSIhandle_FSGhandle = gReceptionList_Pos[0];
  putvalue(env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle);
}

void RadioTVPresetList_init_static()
{
  byte j, i, RadioTVPresetListLine;

  //clear
  RadioTVPresetListLine = 0;
  gRadioTVPresetList_sum = 0;
  for (j = 0; j < AUDIO_RADIOTVPRESETLIST_ENTRIES; j++)
  {
    gRadioTVPresetList_Pos[j] = 0;
    gRadioTVPresetList_PresetIndex[j] = 0;
    gRadioTVPresetList_Waveband[j] = 0;
    gRadioTVPresetList_Attributes1_Bit0[j] = 0;
    gRadioTVPresetList_Attributes1_Bit1[j] = 0;
    gRadioTVPresetList_Attributes1_Bit2[j] = 0;
    gRadioTVPresetList_Attributes1_Bit3[j] = 0;
    gRadioTVPresetList_Attributes1_Bit4[j] = 0;
    gRadioTVPresetList_Attributes1_Bit5[j] = 0;
    gRadioTVPresetList_Attributes1_Bit6[j] = 0;
    gRadioTVPresetList_Attributes1_Bit7[j] = 0;
    gRadioTVPresetList_Attributes1[j] = 0;
    gRadioTVPresetList_Attributes2_Bit0[j] = 0;
    gRadioTVPresetList_Attributes2_Bit1[j] = 0;
    gRadioTVPresetList_Attributes2_Bit2[j] = 0;
    gRadioTVPresetList_Attributes2_Bit3[j] = 0;
    gRadioTVPresetList_Attributes2_Bit4[j] = 0;
    gRadioTVPresetList_Attributes2[j] = 0;
    for (i = 0; i < AUDIO_RADIOTVPRESETLIST_NAME_LENGTH; i++)
      gRadioTVPresetList_Name[j][i] = 0;
    for (i = 0; i < AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH; i++)
      gRadioTVPresetList_Frequency[j][i] = 0;
    gRadioTVPresetList_PicRef[j] = 0;
    gRadioTVPresetList_ListEntryValidInformation[j] = 0;
  }
  //entry 0
  gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0x52;
  gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 2;
  gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_FM;
  gRadioTVPresetList_Attributes1_Bit0[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes1_Bit1[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes1_Bit2[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes1_Bit3[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes1_Bit4[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes1_Bit5[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes1_Bit6[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes1_Bit7[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes1[RadioTVPresetListLine] = 
    gRadioTVPresetList_Attributes1_Bit0[RadioTVPresetListLine] + 
    (gRadioTVPresetList_Attributes1_Bit1[RadioTVPresetListLine] * 0x02) + 
    (gRadioTVPresetList_Attributes1_Bit2[RadioTVPresetListLine] * 0x04) + 
    (gRadioTVPresetList_Attributes1_Bit3[RadioTVPresetListLine] * 0x08) + 
    (gRadioTVPresetList_Attributes1_Bit4[RadioTVPresetListLine] * 0x10) + 
    (gRadioTVPresetList_Attributes1_Bit5[RadioTVPresetListLine] * 0x20) + 
    (gRadioTVPresetList_Attributes1_Bit6[RadioTVPresetListLine] * 0x40) + 
    (gRadioTVPresetList_Attributes1_Bit7[RadioTVPresetListLine] * 0x80);
  gRadioTVPresetList_Attributes2_Bit0[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes2_Bit1[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes2_Bit2[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes2_Bit3[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes2_Bit4[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Attributes2[RadioTVPresetListLine] = 
    gRadioTVPresetList_Attributes2_Bit0[RadioTVPresetListLine] + 
    (gRadioTVPresetList_Attributes2_Bit1[RadioTVPresetListLine] * 0x02) + 
    (gRadioTVPresetList_Attributes2_Bit2[RadioTVPresetListLine] * 0x04) + 
    (gRadioTVPresetList_Attributes2_Bit3[RadioTVPresetListLine] * 0x08) + 
    (gRadioTVPresetList_Attributes2_Bit4[RadioTVPresetListLine] * 0x10);
  strncpy(gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_0", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
  strncpy(gRadioTVPresetList_Frequency[RadioTVPresetListLine], "Frequency_0", AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH);
  gRadioTVPresetList_PicRef[RadioTVPresetListLine] = 1;
  RadioTVPresetListLine++;
  //entry 1
  gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
  gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0x03;
  gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 9;
  gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_SDARS;
  gRadioTVPresetList_Attributes1_Bit0[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes1_Bit1[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes1_Bit2[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes1_Bit3[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes1_Bit4[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes1_Bit5[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes1_Bit6[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes1_Bit7[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes1[RadioTVPresetListLine] = 
    gRadioTVPresetList_Attributes1_Bit0[RadioTVPresetListLine] + 
    (gRadioTVPresetList_Attributes1_Bit1[RadioTVPresetListLine] * 0x02) + 
    (gRadioTVPresetList_Attributes1_Bit2[RadioTVPresetListLine] * 0x04) + 
    (gRadioTVPresetList_Attributes1_Bit3[RadioTVPresetListLine] * 0x08) + 
    (gRadioTVPresetList_Attributes1_Bit4[RadioTVPresetListLine] * 0x10) + 
    (gRadioTVPresetList_Attributes1_Bit5[RadioTVPresetListLine] * 0x20) + 
    (gRadioTVPresetList_Attributes1_Bit6[RadioTVPresetListLine] * 0x40) + 
    (gRadioTVPresetList_Attributes1_Bit7[RadioTVPresetListLine] * 0x80);
  gRadioTVPresetList_Attributes2_Bit0[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes2_Bit1[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes2_Bit2[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes2_Bit3[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes2_Bit4[RadioTVPresetListLine] = FALSE;
  gRadioTVPresetList_Attributes2[RadioTVPresetListLine] = 
    gRadioTVPresetList_Attributes2_Bit0[RadioTVPresetListLine] + 
    (gRadioTVPresetList_Attributes2_Bit1[RadioTVPresetListLine] * 0x02) + 
    (gRadioTVPresetList_Attributes2_Bit2[RadioTVPresetListLine] * 0x04) + 
    (gRadioTVPresetList_Attributes2_Bit3[RadioTVPresetListLine] * 0x08) + 
    (gRadioTVPresetList_Attributes2_Bit4[RadioTVPresetListLine] * 0x10);
  strncpy(gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_1", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
  strncpy(gRadioTVPresetList_Frequency[RadioTVPresetListLine], "Frequency_1", AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH);
  gRadioTVPresetList_PicRef[RadioTVPresetListLine] = 2;
  RadioTVPresetListLine++;
  gRadioTVPresetList_sum = RadioTVPresetListLine;
  gRadioTVPresetList_TotalNumListElements = gRadioTVPresetList_sum;
  writelineEx(gRadioTVPresetList_writeWindow, 0, "Anzahl der Listenelemente: %d", gRadioTVPresetList_sum);
  putvalue(env_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements);
}

void SourceList_init_static()
{
  byte j, i, SourceListLine;

  //clear
  SourceListLine = 0;
  gSourceList_sum = 0;
  for (j = 0; j < AUDIO_SOURCELIST_ENTRIES; j++)
  {
    gSourceList_Pos[j] = 0;
    gSourceList_SourceType[j] = 0;
    gSourceList_InstanceID[j] = 0;
    gSourceList_Attributes_Bit0[j] = 0;
    gSourceList_Attributes_Bit1[j] = 0;
    gSourceList_Attributes_Bit2[j] = 0;
    gSourceList_Attributes_Bit3[j] = 0;
    gSourceList_Attributes_Bit4[j] = 0;
    gSourceList_Attributes_Bit5[j] = 0;
    gSourceList_Attributes_Bit6[j] = 0;
    gSourceList_Attributes[j] = 0;
    for (i = 0; i < AUDIO_SOURCELIST_NAME_LENGTH; i++)
      gSourceList_Name[j][i] = 0;
    gSourceList_PicRef[j] = 0;
    gSourceList_ListEntryValidInformation[j] = 0;
  }
  //entry 0
  gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
  gSourceList_Pos[SourceListLine] = 0x7214;
  gSourceList_SourceType[SourceListLine] = 0x08;
  gSourceList_InstanceID[SourceListLine] = 5;
  gSourceList_Attributes_Bit0[SourceListLine] = TRUE;
  gSourceList_Attributes_Bit1[SourceListLine] = TRUE;
  gSourceList_Attributes_Bit2[SourceListLine] = TRUE;
  gSourceList_Attributes_Bit3[SourceListLine] = TRUE;
  gSourceList_Attributes_Bit4[SourceListLine] = TRUE;
  gSourceList_Attributes_Bit5[SourceListLine] = TRUE;
  gSourceList_Attributes_Bit6[SourceListLine] = TRUE;
  gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_Bit0[SourceListLine] 
    + (gSourceList_Attributes_Bit1[SourceListLine] * 0x02) 
    + (gSourceList_Attributes_Bit2[SourceListLine] * 0x04) 
    + (gSourceList_Attributes_Bit3[SourceListLine] * 0x08) 
    + (gSourceList_Attributes_Bit4[SourceListLine] * 0x10) 
    + (gSourceList_Attributes_Bit5[SourceListLine] * 0x20) 
    + (gSourceList_Attributes_Bit6[SourceListLine] * 0x40);
  strncpy(gSourceList_Name[SourceListLine], "Name_0", AUDIO_SOURCELIST_NAME_LENGTH);
  gSourceList_PicRef[SourceListLine] = 1;
  SourceListLine++;
  //entry 1
  gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
  gSourceList_Pos[SourceListLine] = 0x01;
  gSourceList_SourceType[SourceListLine] = 0x11;
  gSourceList_InstanceID[SourceListLine] = 0;
  gSourceList_Attributes_Bit0[SourceListLine] = FALSE;
  gSourceList_Attributes_Bit1[SourceListLine] = FALSE;
  gSourceList_Attributes_Bit2[SourceListLine] = FALSE;
  gSourceList_Attributes_Bit3[SourceListLine] = FALSE;
  gSourceList_Attributes_Bit4[SourceListLine] = FALSE;
  gSourceList_Attributes_Bit5[SourceListLine] = FALSE;
  gSourceList_Attributes_Bit6[SourceListLine] = FALSE;
  gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_Bit0[SourceListLine] 
    + (gSourceList_Attributes_Bit1[SourceListLine] * 0x02) 
    + (gSourceList_Attributes_Bit2[SourceListLine] * 0x04) 
    + (gSourceList_Attributes_Bit3[SourceListLine] * 0x08) 
    + (gSourceList_Attributes_Bit4[SourceListLine] * 0x10) 
    + (gSourceList_Attributes_Bit5[SourceListLine] * 0x20) 
    + (gSourceList_Attributes_Bit6[SourceListLine] * 0x40);
  strncpy(gSourceList_Name[SourceListLine], "Name_1", AUDIO_SOURCELIST_NAME_LENGTH);
  gSourceList_PicRef[SourceListLine] = 2;
  SourceListLine++;
  gSourceList_sum = SourceListLine;
  gSourceList_TotalNumListElements = gSourceList_sum;
  writelineEx(gSourceList_writeWindow, 0, "Anzahl der Listenelemente: %d", gSourceList_sum);
  putvalue(env_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements);
}

void Browser_init_static()
{
  byte j, i, MediaBrowserLine;

  //clear
  MediaBrowserLine = 0;
  gMediaBrowser_sum = 0;
  for (j = 0; j < AUDIO_MEDIABROWSER_ENTRIES; j++)
  {
    gMediaBrowser_Pos[j] = 0;
    gMediaBrowser_Type[j] = 0;
    gMediaBrowser_FileState_Bit0[j] = 0;
    gMediaBrowser_FileState_Bit1[j] = 0;
    gMediaBrowser_FileState_Bit2[j] = 0;
    gMediaBrowser_FileState_Bit3[j] = 0;
    gMediaBrowser_FileState_Bit4[j] = 0;
    gMediaBrowser_FileState_Bit5[j] = 0;
    gMediaBrowser_FileState_Bit6[j] = 0;
    gMediaBrowser_FileState[j] = 0;
    gMediaBrowser_Waveband[j] = 0;
    gMediaBrowser_RadioCategory[j] = 0;
    gMediaBrowser_FmRegCode[j] = 0;
    gMediaBrowser_PresetID[j] = 0;
    gMediaBrowser_Attributes1_Bit0[j] = 0;
    gMediaBrowser_Attributes1_Bit1[j] = 0;
    gMediaBrowser_Attributes1_Bit2[j] = 0;
    gMediaBrowser_Attributes1_Bit3[j] = 0;
    gMediaBrowser_Attributes1_Bit4[j] = 0;
    gMediaBrowser_Attributes1_Bit5[j] = 0;
    gMediaBrowser_Attributes1_Bit6[j] = 0;
    gMediaBrowser_Attributes1_Bit7[j] = 0;
    gMediaBrowser_Attributes1[j] = 0;
    gMediaBrowser_Attributes2_Bit0[j] = 0;
    gMediaBrowser_Attributes2_Bit1[j] = 0;
    gMediaBrowser_Attributes2[j] = 0;
    gMediaBrowser_PicRef[j] = 0;
    gMediaBrowser_ListEntryValidInformation[j] = 0;
    for (i = 0; i < AUDIO_MEDIABROWSER_NAME_LENGTH; i++)
      gMediaBrowser_Name[j][i] = 0;
    for (i = 0; i < AUDIO_MEDIABROWSER_FREQUENCY_LENGTH; i++)
      gMediaBrowser_Frequency[j][i] = 0;
  }
  //entry 0
  gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
  gMediaBrowser_Pos[MediaBrowserLine] = 0x10FE;
  gMediaBrowser_Type[MediaBrowserLine] = 2;
  gMediaBrowser_FileState_Bit0[MediaBrowserLine] = TRUE;
  gMediaBrowser_FileState_Bit1[MediaBrowserLine] = TRUE;
  gMediaBrowser_FileState_Bit2[MediaBrowserLine] = TRUE;
  gMediaBrowser_FileState_Bit3[MediaBrowserLine] = TRUE;
  gMediaBrowser_FileState_Bit4[MediaBrowserLine] = TRUE;
  gMediaBrowser_FileState_Bit5[MediaBrowserLine] = TRUE;
  gMediaBrowser_FileState_Bit6[MediaBrowserLine] = TRUE;
  gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_Bit0[MediaBrowserLine] 
    + (gMediaBrowser_FileState_Bit1[MediaBrowserLine] * 0x02) 
    + (gMediaBrowser_FileState_Bit2[MediaBrowserLine] * 0x04) 
    + (gMediaBrowser_FileState_Bit3[MediaBrowserLine] * 0x08) 
    + (gMediaBrowser_FileState_Bit4[MediaBrowserLine] * 0x10) 
    + (gMediaBrowser_FileState_Bit5[MediaBrowserLine] * 0x20) 
    + (gMediaBrowser_FileState_Bit6[MediaBrowserLine] * 0x40);
  gMediaBrowser_Waveband[MediaBrowserLine] = 3;
  gMediaBrowser_RadioCategory[MediaBrowserLine] = 5;
  gMediaBrowser_FmRegCode[MediaBrowserLine] = 0;
  gMediaBrowser_PresetID[MediaBrowserLine] = 1;
  gMediaBrowser_Attributes1_Bit0[MediaBrowserLine] = FALSE;
  gMediaBrowser_Attributes1_Bit1[MediaBrowserLine] = FALSE;
  gMediaBrowser_Attributes1_Bit2[MediaBrowserLine] = FALSE;
  gMediaBrowser_Attributes1_Bit3[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes1_Bit4[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes1_Bit5[MediaBrowserLine] = FALSE;
  gMediaBrowser_Attributes1_Bit6[MediaBrowserLine] = FALSE;
  gMediaBrowser_Attributes1_Bit7[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes1[MediaBrowserLine] = gMediaBrowser_Attributes1_Bit0[MediaBrowserLine] 
    + (gMediaBrowser_Attributes1_Bit1[MediaBrowserLine] * 0x02) 
    + (gMediaBrowser_Attributes1_Bit2[MediaBrowserLine] * 0x04) 
    + (gMediaBrowser_Attributes1_Bit3[MediaBrowserLine] * 0x08) 
    + (gMediaBrowser_Attributes1_Bit4[MediaBrowserLine] * 0x10) 
    + (gMediaBrowser_Attributes1_Bit5[MediaBrowserLine] * 0x20) 
    + (gMediaBrowser_Attributes1_Bit6[MediaBrowserLine] * 0x40)
    + (gMediaBrowser_Attributes1_Bit7[MediaBrowserLine] * 0x80);
  gMediaBrowser_Attributes2_Bit0[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes2_Bit1[MediaBrowserLine] = FALSE;
  gMediaBrowser_Attributes2[MediaBrowserLine] = gMediaBrowser_Attributes2_Bit0[MediaBrowserLine] 
    + (gMediaBrowser_Attributes2_Bit1[MediaBrowserLine] * 0x02); 
  gMediaBrowser_PicRef[MediaBrowserLine] = 1;
  strncpy(gMediaBrowser_Name[MediaBrowserLine], "FileName_0", AUDIO_MEDIABROWSER_NAME_LENGTH);
  strncpy(gMediaBrowser_Frequency[MediaBrowserLine], "Frequency_0", AUDIO_MEDIABROWSER_FREQUENCY_LENGTH);
  MediaBrowserLine++;
  //entry 1
  gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
  gMediaBrowser_Pos[MediaBrowserLine] = 0xD0AB;
  gMediaBrowser_Type[MediaBrowserLine] = 0x46;
  gMediaBrowser_FileState_Bit0[MediaBrowserLine] = TRUE;
  gMediaBrowser_FileState_Bit1[MediaBrowserLine] = FALSE;
  gMediaBrowser_FileState_Bit2[MediaBrowserLine] = FALSE;
  gMediaBrowser_FileState_Bit3[MediaBrowserLine] = TRUE;
  gMediaBrowser_FileState_Bit4[MediaBrowserLine] = TRUE;
  gMediaBrowser_FileState_Bit5[MediaBrowserLine] = FALSE;
  gMediaBrowser_FileState_Bit6[MediaBrowserLine] = TRUE;
  gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_Bit0[MediaBrowserLine] 
    + (gMediaBrowser_FileState_Bit1[MediaBrowserLine] * 0x02) 
    + (gMediaBrowser_FileState_Bit2[MediaBrowserLine] * 0x04) 
    + (gMediaBrowser_FileState_Bit3[MediaBrowserLine] * 0x08) 
    + (gMediaBrowser_FileState_Bit4[MediaBrowserLine] * 0x10) 
    + (gMediaBrowser_FileState_Bit5[MediaBrowserLine] * 0x20) 
    + (gMediaBrowser_FileState_Bit6[MediaBrowserLine] * 0x40);
  gMediaBrowser_Waveband[MediaBrowserLine] = 8;
  gMediaBrowser_RadioCategory[MediaBrowserLine] = 0x18;
  gMediaBrowser_FmRegCode[MediaBrowserLine] = 0;
  gMediaBrowser_PresetID[MediaBrowserLine] = 2;
  gMediaBrowser_Attributes1_Bit0[MediaBrowserLine] = FALSE;
  gMediaBrowser_Attributes1_Bit1[MediaBrowserLine] = FALSE;
  gMediaBrowser_Attributes1_Bit2[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes1_Bit3[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes1_Bit4[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes1_Bit5[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes1_Bit6[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes1_Bit7[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes1[MediaBrowserLine] = gMediaBrowser_Attributes1_Bit0[MediaBrowserLine] 
    + (gMediaBrowser_Attributes1_Bit1[MediaBrowserLine] * 0x02) 
    + (gMediaBrowser_Attributes1_Bit2[MediaBrowserLine] * 0x04) 
    + (gMediaBrowser_Attributes1_Bit3[MediaBrowserLine] * 0x08) 
    + (gMediaBrowser_Attributes1_Bit4[MediaBrowserLine] * 0x10) 
    + (gMediaBrowser_Attributes1_Bit5[MediaBrowserLine] * 0x20) 
    + (gMediaBrowser_Attributes1_Bit6[MediaBrowserLine] * 0x40)
    + (gMediaBrowser_Attributes1_Bit7[MediaBrowserLine] * 0x80);
  gMediaBrowser_Attributes2_Bit0[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes2_Bit1[MediaBrowserLine] = TRUE;
  gMediaBrowser_Attributes2[MediaBrowserLine] = gMediaBrowser_Attributes2_Bit0[MediaBrowserLine] 
    + (gMediaBrowser_Attributes2_Bit1[MediaBrowserLine] * 0x02); 
  gMediaBrowser_PicRef[MediaBrowserLine] = 2;
  strncpy(gMediaBrowser_Name[MediaBrowserLine], "FileName_1", AUDIO_MEDIABROWSER_NAME_LENGTH);
  strncpy(gMediaBrowser_Frequency[MediaBrowserLine], "Frequency_1", AUDIO_MEDIABROWSER_FREQUENCY_LENGTH);
  MediaBrowserLine++;
  gMediaBrowser_sum = MediaBrowserLine;
  gMediaBrowser_TotalNumListElements = gMediaBrowser_sum;
  writelineEx(gMediaBrowser_writeWindow, 0, "Anzahl der Listenelemente: %d", gMediaBrowser_sum);
  putvalue(env_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements);
}

void Picture_init_static()
{
  byte j, i, PictureLine;
	j =0;
  i =0;
  //clear
  PictureLine         =0;
  gPicture_sum    =0;
  
	for(j=0;j<AUDIO_PICTURE_ENTRIES;j++) //clear "Picture Array"
	{
    gPicture_ListEntryValidInformation[j]  =FALSE;
    gPicture_Pos[j]          =0;
    gPicture_Type[j]         =0;
    gPicture_TcpPort[j]         =0;
    //reset IP-Address
    for(i=0;i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++)
    {
		  gPicture_IpAddress[j][i]=0;
    }
    //reset URI
    strncpy(gPicture_Uri[j], "",AUDIO_PICTURE_URI_LENGTH);
  }        
  //entry 0
	gPicture_ListEntryValidInformation[PictureLine] =TRUE;
  gPicture_Pos[PictureLine]                    =0x01;
  gPicture_Type[PictureLine]                   =AUDIO_PICTURE_TYPE_STATIONART_NORMAL;
	gPicture_IpAddress[PictureLine][00]=0x20;
  gPicture_IpAddress[PictureLine][01]=0x01;
  gPicture_IpAddress[PictureLine][02]=0x0D;
  gPicture_IpAddress[PictureLine][03]=0xB8;
  gPicture_IpAddress[PictureLine][04]=0x85;
  gPicture_IpAddress[PictureLine][05]=0xA3;
  gPicture_IpAddress[PictureLine][06]=0x08;
  gPicture_IpAddress[PictureLine][07]=0xD3;
  gPicture_IpAddress[PictureLine][08]=0x13;
  gPicture_IpAddress[PictureLine][09]=0x19;
  gPicture_IpAddress[PictureLine][10]=0x8A;
  gPicture_IpAddress[PictureLine][11]=0x2E;
  gPicture_IpAddress[PictureLine][12]=0x03;
  gPicture_IpAddress[PictureLine][13]=0x70;
  gPicture_IpAddress[PictureLine][14]=0x73;
  gPicture_IpAddress[PictureLine][15]=0x44;
  gPicture_TcpPort[PictureLine]                 =69;
  strncpy(gPicture_Uri[PictureLine], "/URI_0",AUDIO_PICTURE_URI_LENGTH);
  PictureLine++;    
  gPicture_sum++;
  //entry 1
	gPicture_ListEntryValidInformation[PictureLine] =TRUE;
  gPicture_Pos[PictureLine]                    =0x02;
  gPicture_Type[PictureLine]                   =AUDIO_PICTURE_TYPE_COVERART_NORMAL;
  gPicture_IpAddress[PictureLine][00]=0x20;
  gPicture_IpAddress[PictureLine][01]=0x01;
  gPicture_IpAddress[PictureLine][02]=0x0D;
  gPicture_IpAddress[PictureLine][03]=0xB8;
  gPicture_IpAddress[PictureLine][04]=0x85;
  gPicture_IpAddress[PictureLine][05]=0xA3;
  gPicture_IpAddress[PictureLine][06]=0x08;
  gPicture_IpAddress[PictureLine][07]=0xD3;
  gPicture_IpAddress[PictureLine][08]=0x13;
  gPicture_IpAddress[PictureLine][09]=0x19;
  gPicture_IpAddress[PictureLine][10]=0x8A;
  gPicture_IpAddress[PictureLine][11]=0x2E;
  gPicture_IpAddress[PictureLine][12]=0x03;
  gPicture_IpAddress[PictureLine][13]=0x70;
  gPicture_IpAddress[PictureLine][14]=0x73;
  gPicture_IpAddress[PictureLine][15]=0x47;
  gPicture_TcpPort[PictureLine]                 =69;
  strncpy(gPicture_Uri[PictureLine], "/URI_1",AUDIO_PICTURE_URI_LENGTH);
  PictureLine++;    
  gPicture_sum++;
  gPicture_sum               = PictureLine;
  gPicture_TotalNumListElements  = gPicture_sum;
  putvalue(env_AudioSD_Pic_TNLE,gPicture_TotalNumListElements);
}

//*************************************************************************
//*****************BAP helper functions************************************
//*************************************************************************
void set_status_requestbuffer(dword Request_array [], int length, byte BAPDataType)
{
  int bufferline = 0, i;

  bufferline = get_requestbuffer_line();
  for (i = 0; i < length; i++)
      gBAP_Request[bufferline][i] = Request_array[i];
  gBAP_Requestbuffer_status[bufferline] = length;
  gBAP_Requestbuffer_BAPDataTyp[bufferline] = BAPDataType;
}

byte get_requestbuffer_line()	//function to reserve memory in request-ring-buffer
{
  int line;

  //init lokal variables
  line = 0;
  //********************	
  line = gwrite_requestbuffer_line;                           //next free element in ring-buffer
  if (gwrite_requestbuffer_line < (REQUESTBUFFER_LINES - 1))  //last element of ring-buffer is not reached
    gwrite_requestbuffer_line++;
  else                                                    //last element of ring-buffer is reached
    gwrite_requestbuffer_line = 0;
  return (line);											//return position of free ring-buffer element
}

void Fct_initSendBuf(char description[], dword Cache_Request_Header[], byte Cache_Request_Data[])
{
  byte error = BAP_ERR_OK;

  error = Bap180_InitSendBuf(NODE_INDEX, Cache_Request_Header, Cache_Request_Data);
  if (error != BAP_ERR_OK)
  {
    write("Fct_initSendBuf %s errorcode: 0x%x", description, error);
  }
}

//*************************************************************************
//*****************Helper functions****************************************
//*************************************************************************
//build bitfield for station properties (in panel every variable has his specifical bit)
int buildCSI2_SP()
{
  int buffer;
  
  buffer = 0;
  buffer += @Env_FSG_CSI2_SP_Ball;
  buffer += @Env_FSG_CSI2_SP_DAB;
  buffer += @Env_FSG_CSI2_SP_DAB2;
  buffer += @Env_FSG_CSI2_SP_IBOC;
  buffer += @Env_FSG_CSI2_SP_Online;
  buffer += @Env_FSG_CSI2_SP_Smart;
  buffer += @Env_FSG_CSI2_SP_station;
  return buffer;
}

//build bitfield for station info switches (in panel every variable has his specifical bit)
int buildCSI2_STS()
{
  int buffer;
  
  buffer = 0;
  buffer += @Env_FSG_CSI2_STS_IBOC;
  buffer += @Env_FSG_CSI2_STS_Radio;
  buffer += @Env_FSG_CSI2_STS_TA;
  buffer += @Env_FSG_CSI2_STS_TMC;
  buffer += @Env_FSG_CSI2_STS_VICS; 
  return buffer;
}


//*************************************************************************
//*****************On BAP Messages****************************************
//*************************************************************************
on message BAP_Audio_ASG_01 //BAP-message
{
  int i, error;
  byte RX_Data[8];        //received CAN-DATA
  dword RX_Header[3];     //received CAN-Header

  RX_Header[0]=this.CAN; 
  RX_Header[1]= this.ID; 
  RX_Header[2]= this.DLC; // received length	
	// extract CAN data    																	
	for (i= 0; i<this.DLC; i++)
  {
    RX_Data [i]=this.byte(i);  
  }
  //send recieved CAN-data with CAN-header to BAP-DLL
  error =Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
  if(error !=0)
  {
    write("FSG-AudioSD: BAP_CAN_SetRxData: %d", error);  
  }
}

on message BAP_Audio_ASG_02	//BAP-message
{
  int i, error;
  byte RX_Data[8];        //received CAN-DATA
  dword RX_Header[3];     //received CAN-Header

  RX_Header[0]=this.CAN; 
  RX_Header[1]= this.ID; 
  RX_Header[2]= this.DLC; // received length	
	// extract CAN data    																	
  for (i= 0; i<this.DLC; i++) 
  {
    RX_Data[i]=this.byte(i);
  }
  //send recieved CAN-data with CAN-header to BAP-DLL
  error =Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
  if(error !=0) 
  {
    write("FSG-AudioSD: BAP_CAN_SetRxData: %d", error);
  }
}

void OnUdpReceiveFrom( dword socket, long result, byte ipv6Address[], dword port, byte buffer[], dword size)
{
  int i;
  dword Header[13];
  byte Ipv6_temp[16];
  const long  INVALID_SOCKET = ~0;

  if(socket != INVALID_SOCKET)
  {
    if(result == 0)
    {
      Header[0] = 4; // /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
      Header[1] = 1;
      Header[2] = size;

      for(i=0;i<gUdpSocketCnt;i++)
      {
        if(gUdpSockets[i].Handle == socket)
        {
          Header[3] = gUdpSockets[i].Id;
          for(i=0; i<8; i++)
          {
            Header[i+4] = ((dword)ipv6Address[2*i]) << 8;
            Header[i+4] |= ((dword)ipv6Address[2*i+1]) ;
          }
          Header[12] = port;
          BAP180_SetRxData(NODE_INDEX, Header, buffer);
          break;
        }
      }
    }
  }
}

//*************************************************************************
//*****************Fct-IDs Events******************************************
//*************************************************************************

//*****************FSG_Control*********************************************
on envVar env_AudioSD_FSGCtrl_update
{
	if(gAudioSD_PowerOnOff ==POWER_ON && getvalue(this))
	{
		gAudioSD_FSGControl_Extension1 =getvalue(env_AudioSD_FSGCtrl_Extension1);
    gAudioSD_FSGControl_Extension2 =getvalue(env_AudioSD_FSGCtrl_Extension2);
    gAudioSD_FSGControl_Extension3 =getvalue(env_AudioSD_FSGCtrl_Extension3);
    gAudioSD_FSGControl_Extension4 =getvalue(env_AudioSD_FSGCtrl_Extension4);
    gAudioSD_FSGControl_Extension5 =getvalue(env_AudioSD_FSGCtrl_Extension5);
    gAudioSD_FSGControl_Extension6 =getvalue(env_AudioSD_FSGCtrl_Extension6);  
    FSG_Control_Request(Data_REQ, 0);
	}
}

void FSG_Control_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      FSG_Control_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD FSG_Control_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void FSG_Control_Request(byte request, byte errorcode)
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables. 
    for (i = 0; i < BAP_BUFFER_SIZE; i++)
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;      //LSG-ID
    requestarray[1] = FctID_FSG_Control;   //Fct.-ID
    requestarray[2] = request;           //request type
    switch (request)
    {
      case Data_REQ:
        requestarray[3] = gAudioSD_FSGControl_Extension1;
        requestarray[4] = gAudioSD_FSGControl_Extension2;
        requestarray[5] = gAudioSD_FSGControl_Extension3;
        requestarray[6] = gAudioSD_FSGControl_Extension4;
        requestarray[7] = gAudioSD_FSGControl_Extension5;
        requestarray[8] = gAudioSD_FSGControl_Extension6;
        set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
      break;
      case Error_REQ:
        requestarray[3] = errorcode;
        set_status_requestbuffer(requestarray, 4, Bap_Error);
      break;
      default:
        writelineEx(gError_Trace, 0, "FSG_AudioSD FSG_Control_Request: invalid request %d", request);
      break;
    }
}

//*************************************************************************
//*****************FSG_Setup***********************************************
on envVar env_AudioSD_FSGSetup_update
{
	if(gAudioSD_PowerOnOff ==POWER_ON && getvalue(this))
	{
		gAudioSD_FSGSetup_FunctionSupport_Bit0    =getvalue(env_AudioSD_FSGSetup_FctSupp_0);
    gAudioSD_FSGSetup_FunctionSupport_Bit1    =getvalue(env_AudioSD_FSGSetup_FctSupp_1);
    gAudioSD_FSGSetup_FunctionSupport         =gAudioSD_FSGSetup_FunctionSupport_Bit0 + (gAudioSD_FSGSetup_FunctionSupport_Bit1*0x02);
    gAudioSD_FSGSetup_FunctionProtection_Bit0 =getvalue(env_AudioSD_FSGSetup_FctProt_0);
    gAudioSD_FSGSetup_FunctionProtection      =gAudioSD_FSGSetup_FunctionProtection_Bit0;
    gAudioSD_FSGSetup_WebAppState_Bit0        =getvalue(env_AudioSD_FSGSetup_WAS_0);
    gAudioSD_FSGSetup_WebAppState             =gAudioSD_FSGSetup_WebAppState_Bit0;
    gAudioSD_FSGSetup_Extension1              =getvalue(env_AudioSD_FSGSetup_Extension1);
    gAudioSD_FSGSetup_Extension2              =getvalue(env_AudioSD_FSGSetup_Extension2);
    gAudioSD_FSGSetup_Extension3              =getvalue(env_AudioSD_FSGSetup_Extension3);
    gAudioSD_FSGSetup_Extension4              =getvalue(env_AudioSD_FSGSetup_Extension4);

    FSG_Setup_Request(Data_REQ, 0);
	}
}

void FSG_Setup_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      FSG_Setup_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD FSG_Setup_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void FSG_Setup_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
      requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;      //LSG-ID
  requestarray[1] = FctID_FSG_Setup;   //Fct.-ID
  requestarray[2] = request;           //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_FSGSetup_FunctionSupport;
      requestarray[4] = gAudioSD_FSGSetup_FunctionProtection;
      requestarray[5] = (gAudioSD_FSGSetup_WebAppState*0x10) + (gAudioSD_FSGSetup_Extension1&0x0F);
      requestarray[6] = gAudioSD_FSGSetup_Extension2;
      requestarray[7] = gAudioSD_FSGSetup_Extension3;
      requestarray[8] = gAudioSD_FSGSetup_Extension4;
      set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD FSG_Setup_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************FSG_OperationState**************************************
on envVar env_AudioSD_FSGOpState_update
{
	if(gAudioSD_PowerOnOff ==gAudioSD_PowerOnOff && getvalue(this))
	{
		gAudioSD_FSGOperationState_OpState    =getvalue(env_AudioSD_FSGOpState_OpState);
    gAudioSD_FSGOperationState_Extension1 =getvalue(env_AudioSD_FSGOpSt_Extension1);
    gAudioSD_FSGOperationState_Extension2 =getvalue(env_AudioSD_FSGOpSt_Extension2);
    gAudioSD_FSGOperationState_Extension3 =getvalue(env_AudioSD_FSGOpSt_Extension3);
    gAudioSD_FSGOperationState_Extension4 =getvalue(env_AudioSD_FSGOpSt_Extension4);
    gAudioSD_FSGOperationState_Extension5 =getvalue(env_AudioSD_FSGOpSt_Extension5);
    FSG_OperationState_Request(Data_REQ, 0);
  }
}

void FSG_OperationState_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      FSG_OperationState_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD FSG_OperationState_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

FSG_OperationState_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;              //LSG-ID
  requestarray[1] = FctID_FSG_OperationState; //Fct.-ID
  requestarray[2] = request;                   //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_FSGOperationState_OpState;
      requestarray[4] = gAudioSD_FSGOperationState_Extension1;
      requestarray[5] = gAudioSD_FSGOperationState_Extension2;
      requestarray[6] = gAudioSD_FSGOperationState_Extension3;
      requestarray[7] = gAudioSD_FSGOperationState_Extension4;
      requestarray[8] = gAudioSD_FSGOperationState_Extension5;
      set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD FSG_OperationState_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************ASG_Capabilities****************************************
on envVar env_AudioSD_ASGCapa_update
{
  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 =getvalue(env_AudioSD_ASGCapa_PresCa_DAB);
    gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 =getvalue(env_AudioSD_ASGCapa_PresCa_SDARS);
    gAudioSD_ASGCapabilities_PresentationCapabilities =0;
    gAudioSD_ASGCapabilities_PresentationCapabilities =gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 + gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1*0x02;
    gAudioSD_ASGCapabilities_Extension1 =getvalue(env_AudioSD_ASGCapa_Extension1);
    gAudioSD_ASGCapabilities_Extension2 =getvalue(env_AudioSD_ASGCapa_Extension2);
    gAudioSD_ASGCapabilities_Extension3 =getvalue(env_AudioSD_ASGCapa_Extension3);
    gAudioSD_ASGCapabilities_Extension4 =getvalue(env_AudioSD_ASGCapa_Extension4);
    gAudioSD_ASGCapabilities_Extension5 =getvalue(env_AudioSD_ASGCapa_Extension5);
    
    ASGCapabilities_Request(Data_REQ, 0);
  }
}

void ASGCapabilities_Indication(dword Indication_array [], int datalength)
{
  int i = 0;
  switch (Indication_array[2]) // indication
  {
    case DataSetGet_IND:
      //get data
      gAudioSD_ASGCapabilities_PresentationCapabilities = Indication_array[3];
      gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 = gAudioSD_ASGCapabilities_PresentationCapabilities & 0x01;
      gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 = (gAudioSD_ASGCapabilities_PresentationCapabilities & 0x02) / 0x02;
      gAudioSD_ASGCapabilities_Extension1 = Indication_array[4];
      gAudioSD_ASGCapabilities_Extension2 = Indication_array[5];
      gAudioSD_ASGCapabilities_Extension3 = Indication_array[6];
      gAudioSD_ASGCapabilities_Extension4 = Indication_array[7];
      gAudioSD_ASGCapabilities_Extension5 = Indication_array[8];
      if (getvalue(env_AudioSD_ASGCapa_Error_on))
        ASGCapabilities_Request(Error_REQ, getvalue(env_AudioSD_ASGCapa_ErrorCode));
      else
        ASGCapabilities_Request(Data_REQ, 0);
      //Panel
      putvalue(env_AudioSD_ASGCapa_PresCa_DAB, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0);
      putvalue(env_AudioSD_ASGCapa_PresCa_SDARS, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1);
      putvalue(env_AudioSD_ASGCapa_Extension1,gAudioSD_ASGCapabilities_Extension1);
      putvalue(env_AudioSD_ASGCapa_Extension2,gAudioSD_ASGCapabilities_Extension2);
      putvalue(env_AudioSD_ASGCapa_Extension3,gAudioSD_ASGCapabilities_Extension3);
      putvalue(env_AudioSD_ASGCapa_Extension4,gAudioSD_ASGCapabilities_Extension4);
      putvalue(env_AudioSD_ASGCapa_Extension5,gAudioSD_ASGCapabilities_Extension5);
    break;
    case DataGet_IND:
      ASGCapabilities_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD ASGCapabilities_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void ASGCapabilities_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
      requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;              //LSG-ID
  requestarray[1] = FctID_ASG_Capabilities;   //Fct.-ID
  requestarray[2] = request;                  //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_ASGCapabilities_PresentationCapabilities;
      requestarray[4] = gAudioSD_ASGCapabilities_Extension1;
      requestarray[5] = gAudioSD_ASGCapabilities_Extension2;
      requestarray[6] = gAudioSD_ASGCapabilities_Extension3;
      requestarray[7] = gAudioSD_ASGCapabilities_Extension4;
      requestarray[8] = gAudioSD_ASGCapabilities_Extension5;
      set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD ASGCapabilities_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************InfoStates**********************************************
on envVar env_AudioSD_InfoStates_update
{
  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
  {
    gAudioSD_InfoStates_States =getvalue(env_AudioSD_InfoStates_states);
    gAudioSD_InfoStates_AdditionalStateInfo_Bit0 =getvalue(env_AudioSD_InfoStates_AddStInfo);
    gAudioSD_InfoStates_AdditionalStateInfo =getvalue(env_AudioSD_InfoStates_AddStInfo);
    gAudioSD_InfoStates_Extension1 =getvalue(env_AudioSD_InfoStates_Ext1);
    gAudioSD_InfoStates_Extension2 =getvalue(env_AudioSD_InfoStates_Ext2);
    gAudioSD_InfoStates_Extension3 =getvalue(env_AudioSD_InfoStates_Ext3);
    gAudioSD_InfoStates_Extension4 =getvalue(env_AudioSD_InfoStates_Ext4);
    
    InfoStates_Request(Data_REQ, 0);
  }
}

void InfoStates_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      InfoStates_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD InfoStates_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void InfoStates_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;              //LSG-ID
  requestarray[1] = FctID_InfoStates; //Fct.-ID
  requestarray[2] = request;                   //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_InfoStates_States;
      requestarray[4] = gAudioSD_InfoStates_AdditionalStateInfo;
      requestarray[5] = gAudioSD_InfoStates_Extension1;
      requestarray[6] = gAudioSD_InfoStates_Extension2;
      requestarray[7] = gAudioSD_InfoStates_Extension3;
      requestarray[8] = gAudioSD_InfoStates_Extension4;
      set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD InfoStates_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************SDS_State***********************************************
on envVar env_AudioSD_SDSState_update
{
  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    gAudioSD_SDSState_State =getvalue(env_AudioSD_SDSState_State);
    gAudioSD_SDSState_Extension1 =getvalue(env_AudioSD_SDSState_Extension1);
    gAudioSD_SDSState_Extension2 =getvalue(env_AudioSD_SDSState_Extension2);
    gAudioSD_SDSState_Extension3 =getvalue(env_AudioSD_SDSState_Extension3);
    gAudioSD_SDSState_Extension4 =getvalue(env_AudioSD_SDSState_Extension4);
    gAudioSD_SDSState_Extension5 =getvalue(env_AudioSD_SDSState_Extension5);

    SDS_State_Request(Data_REQ, 0);
  }
}

void SDS_State_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      SDS_State_Request(Data_REQ, 0);    //send status
    break;
    case DataSetGet_IND:
      //get data
      gAudioSD_SDSState_State = Indication_array[3];
      gAudioSD_SDSState_Extension1 = Indication_array[4];
      gAudioSD_SDSState_Extension2 = Indication_array[5];
      gAudioSD_SDSState_Extension3 = Indication_array[6];
      gAudioSD_SDSState_Extension4 = Indication_array[7];
      gAudioSD_SDSState_Extension5 = Indication_array[8];
      //panel
      putvalue(env_AudioSD_SDSState_State, gAudioSD_SDSState_State);
      putvalue(env_AudioSD_SDSState_Extension1, gAudioSD_SDSState_Extension1);
      putvalue(env_AudioSD_SDSState_Extension2, gAudioSD_SDSState_Extension2);
      putvalue(env_AudioSD_SDSState_Extension3, gAudioSD_SDSState_Extension3);
      putvalue(env_AudioSD_SDSState_Extension4, gAudioSD_SDSState_Extension4);
      putvalue(env_AudioSD_SDSState_Extension5, gAudioSD_SDSState_Extension5);
      SDS_State_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD SDS_State_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void SDS_State_Request(byte request, byte errorcode)
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables. 
    for (i = 0; i < BAP_BUFFER_SIZE; i++)
      requestarray[i] = 0;
    
    // Handle request.
    requestarray[0] = LSG_AudioSD;      //LSG-ID
    requestarray[1] = FctID_SDS_State;  //Fct.-ID
    requestarray[2] = request;           //request type
    switch (request)
    {
      case Data_REQ:
        requestarray[3] = gAudioSD_SDSState_State;
        requestarray[4] = gAudioSD_SDSState_Extension1;
        requestarray[5] = gAudioSD_SDSState_Extension2;
        requestarray[6] = gAudioSD_SDSState_Extension3;
        requestarray[7] = gAudioSD_SDSState_Extension4;
        requestarray[8] = gAudioSD_SDSState_Extension5;
        set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
      break;
      case Error_REQ:
        requestarray[3] = errorcode;
        set_status_requestbuffer(requestarray, 4, Bap_Error);
      break;
      default:
        writelineEx(gError_Trace, 0, "FSG_AudioSD SDS_State_Request: invalid request %d", request);
      break;
    }
}

//*************************************************************************
//*****************GeneralInfoSwitches*************************************
on envVar env_AudioSD_GIS_update
{
	if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
		gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA         =getvalue(env_AudioSD_GIS_OnOff_TPTA);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS          =getvalue(env_AudioSD_GIS_OnOff_RDS);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic    =getvalue(env_AudioSD_GIS_OnOff_JPtraffic);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC          =getvalue(env_AudioSD_GIS_OnOff_TMC);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS         =getvalue(env_AudioSD_GIS_OnOff_VICS);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online       =getvalue(env_AudioSD_GIS_OnOff_ON);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB          =getvalue(env_AudioSD_GIS_OnOff_DAB);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches  = gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA 
                                                  +gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS*0x02 
                                                  +gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic*0x04 
                                                  +gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC*0x08 
                                                  +gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS*0x10
                                                  +gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online*0x20
                                                  +gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB*0x40;
    gAudioSD_GeneralInfoSwitches_Extension1 =getvalue(env_AudioSD_GIS_Extension1);
    gAudioSD_GeneralInfoSwitches_Extension2 =getvalue(env_AudioSD_GIS_Extension2);
    gAudioSD_GeneralInfoSwitches_Extension3 =getvalue(env_AudioSD_GIS_Extension3);
    gAudioSD_GeneralInfoSwitches_Extension4 =getvalue(env_AudioSD_GIS_Extension4);
    gAudioSD_GeneralInfoSwitches_Extension5 =getvalue(env_AudioSD_GIS_Extension5);
		
    GeneralInfoSwitches_Request(Data_REQ, 0);
	}
}

void GeneralInfoSwitches_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      GeneralInfoSwitches_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD GeneralInfoSwitches_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void GeneralInfoSwitches_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;              //LSG-ID
  requestarray[1] = FctID_GeneralInfoSwitches;    //Fct.-ID
  requestarray[2] = request;                   //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_GeneralInfoSwitches_OnOffSwitches;
      requestarray[4] = gAudioSD_GeneralInfoSwitches_Extension1;
      requestarray[5] = gAudioSD_GeneralInfoSwitches_Extension2;
      requestarray[6] = gAudioSD_GeneralInfoSwitches_Extension3;
      requestarray[7] = gAudioSD_GeneralInfoSwitches_Extension4;
      requestarray[8] = gAudioSD_GeneralInfoSwitches_Extension5;
      set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD GeneralInfoSwitches_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************ActiveSource********************************************
on envVar env_AudioSD_activeSrc_update
{
	if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
		gAudioSD_activeSource_SourceType            =getvalue(env_AudioSD_activeSrc_Type);
    gAudioSD_activeSource_SourceList_Reference  =getvalue(env_AudioSD_activeSrc_SLRef);
    gAudioSD_activeSource_ListAvailable_Bit0    =getvalue(env_AudioSD_activeSrc_ReceptList);
    gAudioSD_activeSource_ListAvailable_Bit1    =getvalue(env_AudioSD_activeSrc_PresetList);
    gAudioSD_activeSource_ListAvailable_Bit2    =getvalue(env_AudioSD_activeSrc_MedBrList);
    gAudioSD_activeSource_ListAvailable         =gAudioSD_activeSource_ListAvailable_Bit0
                                                +gAudioSD_activeSource_ListAvailable_Bit1*0x02
                                                +gAudioSD_activeSource_ListAvailable_Bit2*0x04;
    gAudioSD_activeSource_ListState             =getvalue(env_AudioSD_activeSrc_ListState);
    gAudioSD_activeSource_Extension1            =getvalue(env_AudioSD_activeSrc_Extension1);
    gAudioSD_activeSource_Number                =getvalue(env_AudioSD_activeSrc_number);
    
    ActiveSource_Request(Data_REQ, 0);
	}
}

void ActiveSource_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      ActiveSource_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD ActiveSource_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void ActiveSource_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;         //LSG-ID
  requestarray[1] = FctID_ActiveSource;   //Fct.-ID
  requestarray[2] = request;              //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_activeSource_SourceType;
      requestarray[4] = gAudioSD_activeSource_SourceList_Reference & 0x00ff;
      requestarray[5] = (gAudioSD_activeSource_SourceList_Reference & 0xff00) / 0x100;
      requestarray[6] = gAudioSD_activeSource_ListAvailable;
      requestarray[7] = (gAudioSD_activeSource_ListState * 0x10) + gAudioSD_activeSource_Extension1;
      requestarray[8] = gAudioSD_activeSource_Number;
      set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD ActiveSource_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************ActiveSourceName****************************************
on envVar env_AudioSD_activeSourceName_up
{
	if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    getvalue(env_AudioSD_activeSourceName, gAudioSD_activeSourceName);
    ActiveSourceName_Request(Data_REQ, 0);
	}
}

void ActiveSourceName_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      ActiveSourceName_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD ActiveSourceName_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void ActiveSourceName_Request(byte request, byte errorcode)
{
  int i, Offset = 0;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;              //LSG-ID
  requestarray[1] = FctID_ActiveSourceName;    //Fct.-ID
  requestarray[2] = request;                   //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = strlen(gAudioSD_activeSourceName);
      Offset = 4;
      for (i = 0; i < strlen(gAudioSD_activeSourceName); i++)
      {
          requestarray[Offset] = gAudioSD_activeSourceName[i];
          Offset++;
      }
      set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD ActiveSourceName_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************CurrentVolume*******************************************
on envVar env_AudioSD_currentVolume_update
{
	if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    gAudioSD_currentVolume_ChangingVolumeType =getvalue(env_AudioSD_currentVolume_Change);
    gAudioSD_currentVolume_maxVolume          =getvalue(env_AudioSD_currentVolume_MaxVol);
    gAudioSD_currentVolume_GenericVolume      =getvalue(env_AudioSD_currentVolume_GenVol);
    gAudioSD_currentVolume_MuteState =getvalue(env_AudioSD_Mute_Mute)
                                      +getvalue(env_AudioSD_Mute_DAB)*0x02;
                                      +getvalue(env_AudioSD_Mute_DVB)*0x04;
                                      +getvalue(env_AudioSD_Mute_SDARS)*0x08;
                                      +getvalue(env_AudioSD_Mute_sync_IBOC)*0x10;
                                      +getvalue(env_AudioSD_Mute_PhoneCall)*0x20;
                                      +getvalue(env_AudioSD_Mute_IBOC)*0x40;
                                      +getvalue(env_AudioSD_Mute_OnRad)*0x80;
    gAudioSD_currentVolume_Extension1 =getvalue(env_AudioSD_currentVolume_Ext1);
    gAudioSD_currentVolume_Extension2 =getvalue(env_AudioSD_currentVolume_Ext2);

    CurrentVolume_Request(Data_REQ, 0);
	}
}

void CurrentVolume_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      currentVolume_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD CurrentVolume_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void CurrentVolume_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;          //LSG-ID
  requestarray[1] = FctID_CurrentVolume;   //Fct.-ID
  requestarray[2] = request;               //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_currentVolume_ChangingVolumeType;
      requestarray[4] = gAudioSD_currentVolume_maxVolume;
      requestarray[5] = gAudioSD_currentVolume_GenericVolume;
      requestarray[6] = gAudioSD_currentVolume_MuteState;
      requestarray[7] = gAudioSD_currentVolume_Extension1;
      requestarray[8] = gAudioSD_currentVolume_Extension2;
      set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD CurrentVolume_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************SourceState*********************************************
on envVar env_AudioSD_SourceState_update
{
	if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
		gAudioSD_SourceState_StateInfo  =getvalue(env_AudioSD_SourceState_StInfo);
    gAudioSD_SourceState_Scope      =getvalue(env_AudioSD_SourceState_Scope);  
    gAudioSD_SourceState_Extension1 =getvalue(env_AudioSD_SourceState_Ext1);  
    gAudioSD_SourceState_Extension2 =getvalue(env_AudioSD_SourceState_Ext2);  
    gAudioSD_SourceState_Extension3 =getvalue(env_AudioSD_SourceState_Ext3);  
    gAudioSD_SourceState_Extension4 =getvalue(env_AudioSD_SourceState_Ext4);  
    SourceState_Request(Data_REQ, 0);
	}
}

void SourceState_Indication(dword Indication_array [], int datalength)
{
  byte errorcode = 0;

  errorcode = 0;
  switch (Indication_array[2]) // indication
  {
      case DataGet_IND:
        SourceState_Request(Data_REQ, 0);    //send status
      break;
      default:
        writelineEx(gError_Trace, 0, "FSG_AudioSD SourceState_Indication: invalid indication %d", Indication_array[2]);
      break;
  }
}

void SourceState_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;      //LSG-ID
  requestarray[1] = FctID_SourceState;    //Fct.-ID
  requestarray[2] = request;           //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_SourceState_StateInfo;
      requestarray[4] = gAudioSD_SourceState_Scope;
      requestarray[5] = gAudioSD_SourceState_Extension1;
      requestarray[6] = gAudioSD_SourceState_Extension2;
      requestarray[7] = gAudioSD_SourceState_Extension3;
      requestarray[8] = gAudioSD_SourceState_Extension4;
      set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD SourceState_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************CurrentStationInfo**************************************
on envVar env_AudioSD_CSI_update
{
	if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    getvalue(Env_FSG_CSI2_I1, gAudioSD_CSI_PrimaryInformation);
    getvalue(Env_FSG_CSI2_I2, gAudioSD_CSI_SecondaryInformation);
    getvalue(Env_FSG_CSI2_I3, gAudioSD_CSI_TertiaryInformation);
    getvalue(Env_FSG_CSI2_I4, gAudioSD_CSI_QuarternaryInformation);
    getvalue(Env_FSG_CSI2_I5, gAudioSD_CSI_Information5);
    getvalue(Env_FSG_CSI2_I6, gAudioSD_CSI_Information6);
    getvalue(Env_FSG_CSI2_I7, gAudioSD_CSI_Information7);
    getvalue(Env_FSG_CSI2_I8, gAudioSD_CSI_Information8);
    gAudioSD_CSI_PI_Type                        =getvalue(Env_FSG_CSI2_IT1);
    gAudioSD_CSI_SI_Type                        =getvalue(Env_FSG_CSI2_IT2);
    gAudioSD_CSI_TI_Type                        =getvalue(Env_FSG_CSI2_IT3);
    gAudioSD_CSI_QI_Type                        =getvalue(Env_FSG_CSI2_IT4);
    gAudioSD_CSI_I5_Type                        =getvalue(Env_FSG_CSI2_IT5);
    gAudioSD_CSI_I6_Type                        =getvalue(Env_FSG_CSI2_IT6);
    gAudioSD_CSI_I7_Type                        =getvalue(Env_FSG_CSI2_IT7);
    gAudioSD_CSI_I8_Type                        =getvalue(Env_FSG_CSI2_IT8);
    gAudioSD_CSI_PIID                           =getvalue(Env_FSG_CSI2_ID1);
    gAudioSD_CSI_StationLinkingState            =getvalue(Env_FSG_CSI2_SLS);
    gAudioSD_CSI_ChannelID                      =getvalue(Env_FSG_CSI2_CID);
    gAudioSD_CSI_RadioCategory                  =getvalue(Env_FSG_CSI2_RadioCat);
    gAudioSD_CSI_Extension1                     =getvalue(Env_FSG_CSI2_Extension1);
    gAudioSD_CSI_TATP                           =getvalue(Env_FSG_CSI2_STS_TA);
    gAudioSD_CSI_TMC                            =getvalue(Env_FSG_CSI2_STS_TMC);
    gAudioSD_CSI_VICS                           =getvalue(Env_FSG_CSI2_STS_VICS);
    gAudioSD_CSI_IBOC                           =getvalue(Env_FSG_CSI2_STS_IBOC);
    gAudioSD_CSI_RadioCategory                  =getvalue(Env_FSG_CSI2_STS_Radio);
    gAudioSD_CSI_StationInfoSwitches =gAudioSD_CSI_TATP
                                      +gAudioSD_CSI_TMC*0x02
                                      +gAudioSD_CSI_VICS*0x04
                                      +gAudioSD_CSI_IBOC*0x08
                                      +gAudioSD_CSI_RadioCategory*0x10;
    gAudioSD_CSI_StationProperties_IBOC           =getvalue(Env_FSG_CSI2_SP_IBOC);
    gAudioSD_CSI_StationProperties_BallGameMode   =getvalue(Env_FSG_CSI2_SP_Ball);
    gAudioSD_CSI_StationProperties_DABservice     =getvalue(Env_FSG_CSI2_SP_DAB);
    gAudioSD_CSI_StationProperties_OnlineBuffering=getvalue(Env_FSG_CSI2_SP_Online);
    gAudioSD_CSI_StationProperties_SmartFavorite  =getvalue(Env_FSG_CSI2_SP_Smart);
    gAudioSD_CSI_StationProperties    =gAudioSD_CSI_StationProperties_IBOC
                                      +gAudioSD_CSI_StationProperties_BallGameMode*0x02
                                      +gAudioSD_CSI_StationProperties_DABservice*0x04
                                      +gAudioSD_CSI_StationProperties_OnlineBuffering*0x08
                                      +gAudioSD_CSI_StationProperties_SmartFavorite*0x10;    

    CurrentStationInfo_Request(Data_REQ, 0);  
  }
}

void CurrentStationInfo_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      CurrentStationInfo_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD CurrentStationInfo_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void CurrentStationInfo_Request(byte request, byte errorcode)
{
  int i, Offset;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;              //LSG-ID
  requestarray[1] = FctID_CurrentStationInfo; //Fct.-ID
  requestarray[2] = request;                   //request type
  Offset=3;
  switch (request)
  {
    case Data_REQ:
      //PrimaryInformation
      requestarray[Offset] = strlen(gAudioSD_CSI_PrimaryInformation);
      Offset++;
      for (i = 0; i < strlen(gAudioSD_CSI_PrimaryInformation); i++)
      {
        requestarray[Offset] = gAudioSD_CSI_PrimaryInformation[i];
        Offset++;
      }
      //PI_Type
      requestarray[Offset] = gAudioSD_CSI_PI_Type;
      Offset++;
      //PI_ID
      requestarray[Offset] = gAudioSD_CSI_PIID & 0xff;
      Offset++;
      requestarray[Offset] = (gAudioSD_CSI_PIID & 0xff00) / 0x100;
      Offset++;
      //SecondaryInformation
      requestarray[Offset] = strlen(gAudioSD_CSI_SecondaryInformation);
      Offset++;
      for (i = 0; i < strlen(gAudioSD_CSI_SecondaryInformation); i++)
      {
        requestarray[Offset] = gAudioSD_CSI_SecondaryInformation[i];
        Offset++;
      }
      //SI_Type
      requestarray[Offset] = gAudioSD_CSI_SI_Type;
      Offset++;
      //TertiaryInformation
      requestarray[Offset] = strlen(gAudioSD_CSI_TertiaryInformation);
      Offset++;
      for (i = 0; i < strlen(gAudioSD_CSI_TertiaryInformation); i++)
      {
        requestarray[Offset] = gAudioSD_CSI_TertiaryInformation[i];
        Offset++;
      }
      //TI_Type
      requestarray[Offset] = gAudioSD_CSI_TI_Type;
      Offset++;
      //QuaternaryInformation
      requestarray[Offset] = strlen(gAudioSD_CSI_QuarternaryInformation);
      Offset++;
      for (i = 0; i < strlen(gAudioSD_CSI_QuarternaryInformation); i++)
      {
        requestarray[Offset] = gAudioSD_CSI_QuarternaryInformation[i];
        Offset++;
      }
      //QI_Type
      requestarray[Offset] = gAudioSD_CSI_QI_Type;
      Offset++;
      //Information5
      requestarray[Offset] = strlen(gAudioSD_CSI_Information5);
      Offset++;
      for (i = 0; i < strlen(gAudioSD_CSI_Information5); i++)
      {
        requestarray[Offset] = gAudioSD_CSI_Information5[i];
        Offset++;
      }
      //I5_Type
      requestarray[Offset] = gAudioSD_CSI_I5_Type;
      Offset++;
      //Information6
      requestarray[Offset] = strlen(gAudioSD_CSI_Information6);
      Offset++;
      for (i = 0; i < strlen(gAudioSD_CSI_Information6); i++)
      {
        requestarray[Offset] = gAudioSD_CSI_Information6[i];
        Offset++;
      }
      //I6_Type
      requestarray[Offset] = gAudioSD_CSI_I6_Type;
      Offset++;
      //Information7
      requestarray[Offset] = strlen(gAudioSD_CSI_Information7);
      Offset++;
      for (i = 0; i < strlen(gAudioSD_CSI_Information7); i++)
      {
        requestarray[Offset] = gAudioSD_CSI_Information7[i];
        Offset++;
      }
      //I7_Type
      requestarray[Offset] = gAudioSD_CSI_I7_Type;
      Offset++;
      //Information8
      requestarray[Offset] = strlen(gAudioSD_CSI_Information8);
      Offset++;
      for (i = 0; i < strlen(gAudioSD_CSI_Information8); i++)
      {
        requestarray[Offset] = gAudioSD_CSI_Information8[i];
        Offset++;
      }
      //I8_Type
      requestarray[Offset] = gAudioSD_CSI_I8_Type;
      Offset++;
      //StationInfoSwitches
      requestarray[Offset] = gAudioSD_CSI_StationInfoSwitches;
      Offset++;
      //StationProperties
      requestarray[Offset] = gAudioSD_CSI_StationProperties;
      Offset++;
      //StationLinkingState
      requestarray[Offset] = gAudioSD_CSI_StationLinkingState;
      Offset++;
      //Channel_ID
      requestarray[Offset] = gAudioSD_CSI_ChannelID & 0xff;
      Offset++;
      requestarray[Offset] = (gAudioSD_CSI_ChannelID & 0xff00) / 0x100;
      Offset++;
      //RadioCategory
      requestarray[Offset] = gAudioSD_CSI_RadioCategory;
      Offset++;
      //Extension1
      requestarray[Offset] = gAudioSD_CSI_Extension1;
      Offset++;
      set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD CurrentStationInfo_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************CurrentStation_Handle***********************************
on envVar env_AudioSD_CSH_update
{
  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
		gAudioSD_CSIhandle_FSGhandle                =getvalue(env_AudioSD_CSH_FSGhandle);
    gAudioSD_CSIhandle_FSGhandle_absolutePos    =getvalue(env_AudioSD_CSH_FSGAbsPos);
    gAudioSD_CSIhandle_PresetListRef            =getvalue(env_AudioSD_CSH_PresetListRef);
    gAudioSD_CSIhandle_PresetListabsolutePos    =getvalue(env_AudioSD_CSH_PresetListAbsPos);
    gAudioSD_CSIhandle_PictureRef               =getvalue(env_AudioSD_CSH_PicRef);
    gAudioSD_CSIhandle_Extension1               =getvalue(env_AudioSD_CSH_Extension01);
    gAudioSD_CSIhandle_Extension2               =getvalue(env_AudioSD_CSH_Extension02);
    gAudioSD_CSIhandle_Extension3               =getvalue(env_AudioSD_CSH_Extension03);
    gAudioSD_CSIhandle_Extension4               =getvalue(env_AudioSD_CSH_Extension04);
    gAudioSD_CSIhandle_Extension5               =getvalue(env_AudioSD_CSH_Extension05);
    gAudioSD_CSIhandle_Extension6               =getvalue(env_AudioSD_CSH_Extension06);
    gAudioSD_CSIhandle_Extension7               =getvalue(env_AudioSD_CSH_Extension07);
    gAudioSD_CSIhandle_Extension8               =getvalue(env_AudioSD_CSH_Extension08);
    gAudioSD_CSIhandle_Extension9               =getvalue(env_AudioSD_CSH_Extension09);
    gAudioSD_CSIhandle_Extension10              =getvalue(env_AudioSD_CSH_Extension10);
    gAudioSD_CSIhandle_Extension11              =getvalue(env_AudioSD_CSH_Extension11);
    gAudioSD_CSIhandle_Extension12              =getvalue(env_AudioSD_CSH_Extension12);
    gAudioSD_CSIhandle_Extension13              =getvalue(env_AudioSD_CSH_Extension13);
    gAudioSD_CSIhandle_Extension14              =getvalue(env_AudioSD_CSH_Extension14);
    gAudioSD_CSIhandle_Extension15              =getvalue(env_AudioSD_CSH_Extension15);
    CurrentStationHandle_Request(Data_REQ, 0);
	}
}

void CurrentStationHandle_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      CurrentStationHandle_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD CurrentStationHandle_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void CurrentStationHandle_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;                  //LSG-ID
  requestarray[1] = FctID_CurrentStation_Handle;  //Fct.-ID
  requestarray[2] = request;                       //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_CSIhandle_FSGhandle & 0xff;
      requestarray[4] = (gAudioSD_CSIhandle_FSGhandle & 0xff00) / 0x100;
      requestarray[5] = gAudioSD_CSIhandle_FSGhandle_absolutePos & 0xff;
      requestarray[6] = (gAudioSD_CSIhandle_FSGhandle_absolutePos & 0xff00) / 0x100;
      requestarray[7] = gAudioSD_CSIhandle_PresetListRef;
      requestarray[8] = gAudioSD_CSIhandle_PresetListabsolutePos;
      requestarray[9] = gAudioSD_CSIhandle_PictureRef & 0xff;
      requestarray[10] = (gAudioSD_CSIhandle_PictureRef & 0xff00) / 0x100;
      requestarray[11] = gAudioSD_CSIhandle_Extension1;
      requestarray[12] = gAudioSD_CSIhandle_Extension2;
      requestarray[13] = gAudioSD_CSIhandle_Extension3;
      requestarray[14] = gAudioSD_CSIhandle_Extension4;
      requestarray[15] = gAudioSD_CSIhandle_Extension5;
      requestarray[16] = gAudioSD_CSIhandle_Extension6;
      requestarray[17] = gAudioSD_CSIhandle_Extension7;
      requestarray[18] = gAudioSD_CSIhandle_Extension8;
      requestarray[19] = gAudioSD_CSIhandle_Extension9;
      requestarray[20] = gAudioSD_CSIhandle_Extension10;
      requestarray[21] = gAudioSD_CSIhandle_Extension11;
      requestarray[22] = gAudioSD_CSIhandle_Extension12;
      requestarray[23] = gAudioSD_CSIhandle_Extension13;
      requestarray[24] = gAudioSD_CSIhandle_Extension14;
      requestarray[25] = gAudioSD_CSIhandle_Extension15;
      set_status_requestbuffer(requestarray, 26, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD CurrentStationHandle_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************PlayPosition********************************************
on envVar Env_FSG_Update_PP
{
  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
		gAudioSD_PlayPosition_TimePosition    =getvalue(Env_FSG_PP_TP);
    gAudioSD_PlayPosition_TotalPlayTime   =getvalue(Env_FSG_PP_TPT);
    gAudioSD_PlayPosition_Attributes_Bit0 =getvalue(Env_FSG_PP_A);
    gAudioSD_PlayPosition_Attributes      =getvalue(Env_FSG_PP_A);
    gAudioSD_PlayPosition_BufferLevel     =getvalue(Env_FSG_PP_BL);
    PlayPosition_Request(Data_REQ, 0);
	}
}

void PlayPosition_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      PlayPosition_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD PlayPosition_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void PlayPosition_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;                  //LSG-ID
  requestarray[1] = FctID_PlayPosition;  //Fct.-ID
  requestarray[2] = request;                       //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_PlayPosition_TimePosition & 0xff;
      requestarray[4] = (gAudioSD_PlayPosition_TimePosition & 0xff00) / 0x100;
      requestarray[5] = gAudioSD_PlayPosition_TotalPlayTime & 0xff;
      requestarray[6] = (gAudioSD_PlayPosition_TotalPlayTime & 0xff00) / 0x100;
      requestarray[7] = gAudioSD_PlayPosition_Attributes;
      requestarray[8] = gAudioSD_PlayPosition_BufferLevel;
      set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD PlayPosition_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************Station_Track_Switch************************************
on envVar Env_FSG_Update_STS
{
  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    gAudioSD_STS_Event = getvalue(Env_FSG_STS_Event);
    gAudioSD_STS_Direction = getvalue(Env_FSG_STS_Direction);
    gAudioSD_STS_Extension1 = getvalue(Env_FSG_STS_Extension1);
    gAudioSD_STS_Extension2 = getvalue(Env_FSG_STS_Extension2);
    gAudioSD_STS_Extension3 = getvalue(Env_FSG_STS_Extension3);
    gAudioSD_STS_Extension4 = getvalue(Env_FSG_STS_Extension4);
    gAudioSD_STS_Extension5 = getvalue(Env_FSG_STS_Extension5);
    Station_Track_Switch_Request(Data_REQ, 0);
  }  
}

void Station_Track_Switch_Indication(dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {
      case DataGet_IND:
        Station_Track_Switch_Request(Data_REQ, 0);    //send status
      break;
      default:
        writelineEx(gError_Trace, 0, "FSG_AudioSD Station_Track_Switch_Indication: invalid indication %d", Indication_array[2]);
      break;
    }
}

void Station_Track_Switch_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++) 
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;          //LSG-ID
  requestarray[1] = FctID_Station_Track_Switch;   //Fct.-ID
  requestarray[2] = request;               //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = (gAudioSD_STS_Event*0x10) + (gAudioSD_STS_Direction&0x0f);
      requestarray[4] = gAudioSD_STS_Extension1;
      requestarray[5] = gAudioSD_STS_Extension2;
      requestarray[6] = gAudioSD_STS_Extension3;
      requestarray[7] = gAudioSD_STS_Extension4;
      requestarray[8] = gAudioSD_STS_Extension5;
      set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD Station_Track_Switch_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************AnnouncementInfo****************************************
on envVar env_AudioSD_AnInfo_update
{
  int i;

	if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this)) 
	{
		gAudioSD_AnnouncementInfo_Type =getvalue(env_AudioSD_AnInfo_Type);
    getvalue(env_AudioSD_AnInfo_StationName, gAudioSD_AnnouncementInfo_StationName);
    AnnouncementInfo_Request(Data_REQ, 0);
	}
}

void AnnouncementInfo_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      AnnouncementInfo_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD AnnouncementInfo_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

AnnouncementInfo_Request(byte request, byte errorcode)
{
  int i, Offset = 0;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;              //LSG-ID
  requestarray[1] = FctID_AnnouncementInfo;   //Fct.-ID
  requestarray[2] = request;                   //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_AnnouncementInfo_Type;
      requestarray[4] = strlen(gAudioSD_AnnouncementInfo_StationName);
      Offset = 5;
      for (i = 0; i < strlen(gAudioSD_AnnouncementInfo_StationName); i++)
      {
        requestarray[Offset] = gAudioSD_AnnouncementInfo_StationName[i];
        Offset++;
      }
      set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD AnnouncementInfo_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************AnnouncementEscape**************************************
on envVar env_AudioSD_AnE_ResButton
{
	if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this)) 
	{
		gAudioSD_AnnouncementEscape_AsgId =getvalue(env_AudioSD_AnE_AsgId);
    gAudioSD_AnnouncementEscape_Extension1 =getvalue(env_AudioSD_AnE_Extension1);
    gAudioSD_AnnouncementEscape_Result =getvalue(env_AudioSD_AnE_Res);
    AnnouncementEscape_Request(Result_REQ, 0);
	}
}

void AnnouncementEscape_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2])
  {
    case Processing_CNF:
      AnnouncementEscape_Request(Processing_REQ, 0);          //send Processing
    break;
    case StartResult_IND:
      if (getvalue(env_AudioSD_AnE_Error_on))
        AnnouncementEscape_Request(Error_REQ, getvalue(env_AudioSD_AnE_ErrorCode));
      else if (FALSE == gAudioSD_AnnouncementEscape_status)
      {
        if (getvalue(env_AudioSD_AnE_NotActive))
        {
          gAudioSD_AnnouncementEscape_AsgId = Indication_array[3]/0x10;
          gAudioSD_AnnouncementEscape_Extension1 = Indication_array[3]&0x0F;
          putvalue(env_AudioSD_AnE_AsgId,gAudioSD_AnnouncementEscape_AsgId);
          putvalue(env_AudioSD_AnE_Extension1,gAudioSD_AnnouncementEscape_Extension1);
          gAudioSD_AnnouncementEscape_Result = 0x04;
          AnnouncementEscape_Request(Result_REQ, 0);
        }
        else
        {
          gAudioSD_AnnouncementEscape_AsgId = Indication_array[3]/0x10;
          gAudioSD_AnnouncementEscape_Extension1 = Indication_array[3]&0x0F;
          putvalue(env_AudioSD_AnE_AsgId,gAudioSD_AnnouncementEscape_AsgId);
          putvalue(env_AudioSD_AnE_Extension1,gAudioSD_AnnouncementEscape_Extension1);
          gAudioSD_AnnouncementEscape_status = TRUE;                          //method active
          settimer(AnnouncementEscape_Timer, AnnouncementEscape_TimerTime);
        }
      }
    break;
    case Abort_IND:
      if (getvalue(env_AudioSD_AnE_Error_on))
        AnnouncementEscape_Request(Error_REQ, getvalue(env_AudioSD_AnE_ErrorCode));
      else
      {
        if (FALSE == gAudioSD_AnnouncementEscape_status)                             //method not active 								
          AnnouncementEscape_Request(Error_REQ, 0x50);                            //send error-message
        else if (TRUE == gAudioSD_AnnouncementEscape_status)                            //method still active
        {
          gAudioSD_AnnouncementEscape_Result = getvalue(env_AudioSD_AnE_Abort);
          if (AUDIO_ANNOUNCEMENTESCAPE_ABORTSUCCESSFUL == gAudioSD_AnnouncementEscape_Result)     //only, if abort is successful
          {
            canceltimer(AnnouncementEscape_Timer);                              //abort method
            gAudioSD_AnnouncementEscape_status = FALSE;                         //method finished
          }
          AnnouncementEscape_Request(Result_REQ, 0);  //send result-message				
        }
      }
    break;
    default:
      writelineEx(gError_Trace, 0, "AudioSD AnnouncementEscape_Indication: unknown indication %d", Indication_array[2]);
    break;
  }
}

AnnouncementEscape_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;                  //LSG-ID
  requestarray[1] = FctID_AnnouncementEscape;   //Fct.-ID
  requestarray[2] = request;
  switch (request)
  {
    case Processing_REQ:
      requestarray[3] = (gAudioSD_AnnouncementEscape_AsgId*0x10) + (gAudioSD_AnnouncementEscape_Extension1&0x0F);
      requestarray[4] = gAudioSD_AnnouncementEscape_Reserve;
      set_status_requestbuffer(requestarray, 5, Bap_ByteSequence);
    break;
    case Result_REQ:
      requestarray[3] = (gAudioSD_AnnouncementEscape_AsgId*0x10) + (gAudioSD_AnnouncementEscape_Extension1&0x0F);
      requestarray[4] = gAudioSD_AnnouncementEscape_Result;
      set_status_requestbuffer(requestarray, 5, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:    //error
      writelineEx(gError_Trace, 0, "AudioSD AnnouncementEscape_Request: unknown request %d", request);
    break;
  }
}

on timer AnnouncementEscape_Timer
{
  if(getvalue(env_AudioSD_AnE_NotActive))
    gAudioSD_AnnouncementEscape_Result =0x04;
  else     
    gAudioSD_AnnouncementEscape_Result =getvalue(env_AudioSD_AnE_Res);
  AnnouncementEscape_Request(Result_REQ, 0); //send Result
  gAudioSD_AnnouncementEscape_status =FALSE; //method not active 
  if(gAudioSD_AnnouncementEscape_Result ==AUDIO_DAC_SUCCESSFUL)
  {
    gAudioSD_AnnouncementEscape_MethodHandling =1;
    settimer(AnnouncementEscape_MethodHandling_Timer,100);
  }        
}

on timer AnnouncementEscape_MethodHandling_Timer
{
  switch (gAudioSD_AnnouncementEscape_MethodHandling)
  {
    case 1:
      gAudioSD_AnnouncementInfo_Type =ANNOUNCEMENT_TYPE_NO_MESSAGE;
      putvalue(env_AudioSD_AnInfo_Type, gAudioSD_AnnouncementInfo_Type);
      AnnouncementInfo_Request(Data_REQ, 0);    //send status
      gAudioSD_AnnouncementEscape_MethodHandling =0;
    break;
    default:
    break;
  }   
}


//*************************************************************************
//*****************ReceptionList*******************************************
on envVar env_AudioSD_RL_CA
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;

  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    if(getvalue(env_AudioSD_RL_AH_start)>255 && getvalue(env_AudioSD_RL_AH_IS) ==0)// check if 8 or 16 bit
      putvalue(env_AudioSD_RL_AH_IS,1);

    //get data from Panel
    gReceptionList_ElementType  =getvalue(env_AudioSD_RL_ElementType);
    gReceptionList_ParentID     =getvalue(env_AudioSD_RL_ParentID);

    recordaddress   =getvalue(env_AudioSD_RL_AH_RA);
    shift           =getvalue(env_AudioSD_RL_AH_shift);
    direction       =getvalue(env_AudioSD_RL_AH_dir);
    transmitpos     =getvalue(env_AudioSD_RL_AH_POS);
    indexsize       =getvalue(env_AudioSD_RL_AH_IS);
    startelement    =getvalue(env_AudioSD_RL_AH_start);
    elements        =getvalue(env_AudioSD_RL_AH_elements);

    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
    requested_startelement =startelement;

        
    /***Startelement=0***/
    if (getvalue(env_AudioSD_RL_CA_switch)) //ArrayData
    {
      if(0==startelement) //Startelement-ID =0 -> start at first array-entry
	    {
        if(FORWARD==direction)  //forward-start
		    {
          valid_startelement =0;				       									
          if(AUDIO_RECEPTIONLIST_ENTRIES <=elements) //1. more elements requested, than in array
			    {
            if (shift ==FALSE)  
            {
              for(i=0;i<AUDIO_RECEPTIONLIST_ENTRIES;i++)
					    {
				        if(0 !=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
				        else												//no valid element, loop finished
					        i =AUDIO_RECEPTIONLIST_ENTRIES;
				      }
            }
            else if (shift ==TRUE)
            {   
              valid_startelement  =startelement;
	            valid_elements      =0;
            }
			    }   
          else    //2. number of requested elements < elements in array
				  {
            if (shift ==FALSE)
            {
				      for(i=0;i<elements;i++)
					    {
				        if(0!=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
				        else												//no valid element, loop finished
					        i =AUDIO_RECEPTIONLIST_ENTRIES;
				      }
            }
            else if (shift ==TRUE)
            {
              valid_startelement  =startelement;
              valid_elements      =0;
            }
				  }
        }              //forward ends
        else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
		    {   
		      //searching for valid startelement
			    for(i=(AUDIO_RECEPTIONLIST_ENTRIES-1);i>=0;i--)
			    {
			      if(0!=gReceptionList_ListEntryValidInformation[i])		//found valid startelement
				    {
				      valid_startelement =i;								
					    i =0;												
				    }
			    }       
          //searching for valid elements
			    if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
			    {
			      valid_startelement  =startelement;
				    valid_elements      =0;
			    }
			    else if(0==valid_startelement)								
			      valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
			    else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
			    {
			      for(i=valid_startelement;i>=0;i--)
				    {
			        if(0!=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
				        valid_elements++;								//increment elements
					    else												//no valid element, loop finished
					      i=0;
			      }
			    }
          else														//enougth array-elements available
			    {
			      for(i=valid_startelement;i>(valid_startelement-elements);i--)
				    {
			        if(0!=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
				        valid_elements++;								//increment elements
					    else												//no valid element, loop finished
						    i=0;
				    }                   
			    }															
	      }                                                               //backward-end
      }                                                                   //startelement ==0 -end
      /***Startelement!=0***/
      else																//searching for Startelement-ID				
	    {
	      //searching for valid startelement
		    for(i=0;i<AUDIO_RECEPTIONLIST_ENTRIES;i++)
		    {
			    if(gReceptionList_Pos[i] ==startelement)					    //found a valid element
			    {                                       
            if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
				    {
			        if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
				        valid_startelement =i+1-2* direction;    							
              else if(i==0 && BACKWARD==direction) 
                valid_startelement =gReceptionList_sum;     //valid element is last element in Array                                                 
              else if(i==0 && FORWARD==direction) 
                valid_startelement =0;                          //valid element is first element in Array
            }
            else
              valid_startelement =i;                              //found element is valid_startelement
					  i =AUDIO_RECEPTIONLIST_ENTRIES;
				  }
          else
            valid_startelement =0xff;
			  }
		    if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
		    {   
			    valid_startelement  =startelement;
			    valid_elements      =0;
		    }
		    else																//found valid entry for startelement in array
		    {
		      //verify number of valid elements
			    if(BACKWARD==direction)											//backward-start
			    {
		        if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
			        valid_elements=1;
				    else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
		        {
				      for(i=valid_startelement;i>=0;i--)
					    {
				        if(0!=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
                else												//no valid element, loop finished
						      i=0;
					    }
			      }
				    else														//enougth array-elements available
				    {
				      for(i=valid_startelement;i>(valid_startelement-elements);i--)
					    {
				        if(0!=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i=0;
					    }
					  }
				  }																//backward-end
			    else															//forward-start
			    {
			      if((valid_startelement+elements)>=AUDIO_RECEPTIONLIST_ENTRIES)
				    {
				      for(i=valid_startelement;i<AUDIO_RECEPTIONLIST_ENTRIES;i++)
					    {
				        if(0!=gReceptionList_Pos[i])							//if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						      i=AUDIO_RECEPTIONLIST_ENTRIES;
						  }
					  }
				    else
				    {
				      for(i=valid_startelement;i<(valid_startelement+elements);i++)
					    {
				        if(0!=gReceptionList_Pos[i])						    //if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						      i=AUDIO_RECEPTIONLIST_ENTRIES;
						  }
					  }
				  }
			  }
		  }
      putvalue(env_AudioSD_RL_AH_elements, valid_elements);
      //send ChangedArray
      ReceptionList_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
    else
    {
      //send ChangedArray
      ReceptionList_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
    }
  }
}

on envVar env_AudioSD_RL_DataSource
{
  if (getvalue(this) ==AUDIO_DEFAULT_LIST)
  {
    ReceptionList_init_static();
    putvalue(env_AudioSD_RL_DataSource_file, empty_string);
    putvalue(env_AudioSD_RL_DataSource_result, empty_string);
  }
}

on envVar env_AudioSD_RL_reload //load external ReceptionList from *.csv
{
  if(getvalue(this) && getvalue(env_AudioSD_RL_DataSource) ==AUDIO_EXTERNAL_LIST)
    ReceptionList_init_CSV();
  else if(getvalue(env_AudioSD_RL_DataSource) != AUDIO_EXTERNAL_LIST)
    putvalue(env_AudioSD_RL_DataSource_result,"not successful, select 'external *.csv'");
}

on envVar env_AudioSD_RL_StatusArray
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i, transSuppression;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0xff;
  i                       =0;
  valid_elements          =0;
  transSuppression        = getvalue(env_AudioSD_RL_noStatusArray);

  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    if(getvalue(env_AudioSD_RL_AH_start) >255 && getvalue(env_AudioSD_RL_AH_IS) ==0)// check if 8 or 16 bit
      putvalue(env_AudioSD_RL_AH_IS,1);

    //get data from Panel
    gReceptionList_ASGID                =getvalue(env_AudioSD_RL_ASGID);
    gReceptionList_TAID                 =getvalue(env_AudioSD_RL_TAID);
    gReceptionList_ElementType          =getvalue(env_AudioSD_RL_ElementType);
    gReceptionList_ParentID             =getvalue(env_AudioSD_RL_ParentID);

    gReceptionList_TotalNumListElements  =getvalue(env_AudioSD_RL_TotalNumLE);

    recordaddress   =getvalue(env_AudioSD_RL_AH_RA);
    shift           =getvalue(env_AudioSD_RL_AH_shift);
    direction       =getvalue(env_AudioSD_RL_AH_dir);
    transmitpos     =getvalue(env_AudioSD_RL_AH_POS);
    indexsize       =getvalue(env_AudioSD_RL_AH_IS);
    startelement    =getvalue(env_AudioSD_RL_AH_start);
    elements        =getvalue(env_AudioSD_RL_AH_elements);

    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    requested_startelement =startelement;
        
    /***Startelement=0***/
    if(0==startelement) //Startelement-ID =0 -> start at first array-entry
		{
      if(FORWARD==direction)  //forward-start
			{
        valid_startelement =0;				       									
        if(AUDIO_RECEPTIONLIST_ENTRIES <=elements) //1. more elements requested, than in array
				{
          if (shift ==FALSE)  
          {
            for(i=0;i<AUDIO_RECEPTIONLIST_ENTRIES;i++)
						{
					    if(0 !=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
					    else												//no valid element, loop finished
						    i =AUDIO_RECEPTIONLIST_ENTRIES;
					  }
          }
          else if (shift ==TRUE)
          {   
            valid_startelement  =startelement;
		        valid_elements      =0;
          }
			  }
        else    //2. number of requested elements < elements in array
				{
          if (shift ==FALSE)
          {
					  for(i=0;i<elements;i++)
						{
					    if(0!=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
					    else												//no valid element, loop finished
					       i =AUDIO_RECEPTIONLIST_ENTRIES;
					  }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =startelement;
		        valid_elements      =0;
          }
				}
      }                                                               //forward ends
      else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
			{   
			  //searching for valid startelement
				for(i=(AUDIO_RECEPTIONLIST_ENTRIES-1);i>=0;i--)
				{
				  if(0!=gReceptionList_ListEntryValidInformation[i])		//found valid startelement
					{
					  valid_startelement =i;								
						i =0;												
					}
				}               
        //searching for valid elements
				if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
				{
				  valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(0==valid_startelement)								
				  valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				  for(i=valid_startelement;i>=0;i--)
					{
				    if(0!=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
					    valid_elements++;								//increment elements
						else												//no valid element, loop finished
						  i=0;
				  }
				}
        else														//enougth array-elements available
				{
				  for(i=valid_startelement;i>(valid_startelement-elements);i--)
					{
  			    if(0!=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
  				    valid_elements++;								//increment elements
  					else												//no valid element, loop finished
  						i=0;
					}                   
				}															
	    }                                                               //backward-end
    }                                                                   //startelement ==0 -end
    /***Startelement!=0***/
    else																//searching for Startelement-ID				
		{
		  //searching for valid startelement
			for(i=0;i<AUDIO_RECEPTIONLIST_ENTRIES;i++)
			{
				if(gReceptionList_Pos[i] ==startelement)					    //found a valid element
				{                                       
          if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
					{
				    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
					    valid_startelement =i+1-2* direction;         							
            else if(i==0 && BACKWARD==direction) 
              valid_startelement =gReceptionList_sum;     //valid element is last element in Array                                                
            else if(i==0 && FORWARD==direction) 
              valid_startelement =0;                          //valid element is first element in Array
          }
          else
            valid_startelement =i;                              //found element is valid_startelement
					i =AUDIO_RECEPTIONLIST_ENTRIES;
				}
        else
          valid_startelement =0xff;
			}
			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			  //verify number of valid elements
				if(BACKWARD==direction)											//backward-start
				{
			    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
				    valid_elements=1;
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
			    {
				    for(i=valid_startelement;i>=0;i--)
						{
					    if(0!=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
              else												//no valid element, loop finished
							  i=0;
						}
				  }
					else														//enougth array-elements available
					{
					  for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
					    if(0!=gReceptionList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
							else												//no valid element, loop finished
								i=0;
						}
					}
				}																//backward-end
				else															//forward-start
				{
				  if((valid_startelement+elements)>=AUDIO_RECEPTIONLIST_ENTRIES)
					{
					  for(i=valid_startelement;i<AUDIO_RECEPTIONLIST_ENTRIES;i++)
						{
					    if(0!=gReceptionList_Pos[i])							//if there is an valid element
						    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							  i=AUDIO_RECEPTIONLIST_ENTRIES;
						}
					}
					else
					{
					  for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
					    if(0!=gReceptionList_Pos[i])						    //if there is an valid element
						    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							  i=AUDIO_RECEPTIONLIST_ENTRIES;
						}
					}
				}
			}
		}
    putvalue(env_AudioSD_RL_AH_elements, valid_elements);

    //send StatusArray
    if(!transSuppression)
      ReceptionList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
  }
}

void ReceptionList_init_CSV() //Byte & file selection
{
  dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0,
        element = 0, current_CSV_line = 0, count1 = 0, count2 = 0;
  char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], 
        Path_Config[AUDIO_BUFFERSIZE];
  byte ReceptionListLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
  char ReceptionList_Pos_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
  char ReceptionList_Waveband_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];       //help value ->"Type" is stored in the ASCII(UTF-8) code in the *.csv   
  char ReceptionList_Type_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];       //help value ->"Type" is stored in the ASCII(UTF-8) code in the *.csv 
  char ReceptionList_Attributes1_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Attributes" is stored in the ASCII(UTF-8) code in the *.csv 
  char ReceptionList_Attributes2_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Attributes" is stored in the ASCII(UTF-8) code in the *.csv 
  char ReceptionList_PresetID_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"PresetID" is stored in the ASCII(UTF-8) code in the *.csv 
  char ReceptionList_FmRegCode_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];  //help value ->"FmREGCode" is stored in the ASCII(UTF-8) code in the *.csv 
  char ReceptionList_Category_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Category" is stored in the ASCII(UTF-8) code in the *.csv 
  char ReceptionList_PicRef_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Category" is stored in the ASCII(UTF-8) code in the *.csv 
    
  if(getvalue(env_AudioSD_RL_DataSource) == AUDIO_EXTERNAL_LIST) //output data in write window "FSGReceptionList"  
  {
    writeClear(gReceptionList_writeWindow);
    writelineEx(gReceptionList_writeWindow, 0,"*******External ReceptionList*******");
    writelineEx(gReceptionList_writeWindow, 0, "");
    writelineEx(gReceptionList_writeWindow, 0, "**********************Start load new ReceptionList**********************");   
    //clear  
    for(j=0;j<AUDIO_RECEPTIONLIST_ENTRIES;j++) 
    {
	    gReceptionList_Pos[j]                       =0;
	    gReceptionList_Waveband[j]                  =0;
      gReceptionList_Type[j]                      =0;
      gReceptionList_Attributes1_Bit0[j]          =0;
      gReceptionList_Attributes1_Bit1[j]          =0;
      gReceptionList_Attributes1_Bit2[j]          =0;
      gReceptionList_Attributes1_Bit3[j]          =0;
      gReceptionList_Attributes1_Bit4[j]          =0;
      gReceptionList_Attributes1_Bit5[j]          =0;
      gReceptionList_Attributes1_Bit6[j]          =0;
      gReceptionList_Attributes1_Bit7[j]          =0;
      gReceptionList_Attributes2_Bit0[j]          =0;
      gReceptionList_Attributes2_Bit1[j]          =0;
      gReceptionList_Attributes2_Bit2[j]          =0;
      gReceptionList_Attributes2_Bit3[j]          =0;
      gReceptionList_Attributes1[j]               =0;
      gReceptionList_Attributes2[j]               =0;
      gReceptionList_PresetID[j]                  =0;
      gReceptionList_FmRegCode[j]                 =0;
      gReceptionList_Category[j]                  =0;
      gReceptionList_PicRef[j]                    =0;
      gReceptionList_ListEntryValidInformation[j] =0;
	    for(i=0;i<AUDIO_RECEPTIONLIST_NAME_LENGTH;i++)
		    gReceptionList_Name[j][i] =0;
      for(i=0;i<AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH;i++)
		    gReceptionList_Frequency[j][i] =0;
	  }
    for(i=0;i<AUDIO_FILENAME_SIZE; i++) //clear "filename"
      gReceptionList_CSV_filename[i] =0;       
    for(j=0;j<AUDIO_RECEPTIONLIST_ENTRIES; j++) //clear "buffer"
    {
      buffer_string[j]    =0;
      buffer_byte[j]      =0;
      for(i=0;i<AUDIO_TEXTLENGTH;i++) //clear help value
	    {
        ReceptionList_Pos_string[j][i]          =0;
        ReceptionList_Waveband_string[j][i]     =0;
        ReceptionList_Type_string[j][i]         =0;
        ReceptionList_Attributes1_string[j][i]  =0;
        ReceptionList_Attributes2_string[j][i]  =0;
        ReceptionList_PresetID_string[j][i]     =0;
        ReceptionList_FmRegCode_string[j][i]    =0;
        ReceptionList_Category_string[j][i]     =0;
        ReceptionList_PicRef_string[j][i]       =0;
      }
    }        
    i =0; j =0; ReceptionListLine =0; current_CSV_line =0; //reset values 
    getvalue(env_AudioSD_RL_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
    //write("complete path *.csv: %s", Path_CSV); //debug
    i =0;
    while (Path_CSV[i] !=0) //scan "path"
    {
      if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
        count1++;
      //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
      i++;
    }    
    i =0; j =0; //reset values
    while (Path_CSV[i] !=0) //seperate "path" and "filename"
    {
      if(count2==count1) //get filename after last "\"
      {              
        gReceptionList_CSV_filename[j] =Path_CSV[i];
        j++;
        Path_CSV[i] =0;              
      }
      if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
        count2++;                   
      i++;
    }
    writelineEx(gReceptionList_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 
    writelineEx(gReceptionList_writeWindow, 0,"filename of *.csv: '%s'", gReceptionList_CSV_filename);  //output filename 
    putvalue(env_AudioSD_RL_DataSource_file, gReceptionList_CSV_filename); //output current loaded *.csv-file on panel
    setFilePath(Path_CSV, 0); //set path for *.csv file
    CSVfileHandle =openFileRead(gReceptionList_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        
    if (CSVfileHandle!=0) //*.csv file access successful
    {
      writelineEx(gReceptionList_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gReceptionList_CSV_filename);    //output result  
      putvalue(env_AudioSD_RL_DataSource_result, "successful");   //output result on panel                      
      Num_of_csv_byte =fileGetBinaryBlock(buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
      for (i=0; i<Num_of_csv_byte; i++) //copy data into "ReceptionList"
      {      
        if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
        {
          if(buffer_byte[i] ==0x0D && buffer_byte[i + 1] ==0x0A) //nextline in *.csv (next "record element" in ReceptionList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
          {
            if(current_CSV_line>0 && ReceptionListLine<AUDIO_RECEPTIONLIST_ENTRIES) //ignore first line in *.csv file
            {   
              writelineEx(gReceptionList_writeWindow, 0, "");
              writelineEx(gReceptionList_writeWindow, 0,"*******Element %d*******", ReceptionListLine);
              //transform 'string' to 'long' for "POS", "Type", "Attributes", "PresetID", "FmREG_CODE" and Category
              gReceptionList_Pos[ReceptionListLine]           =atol(ReceptionList_Pos_string[ReceptionListLine]);
              gReceptionList_Waveband[ReceptionListLine]      =atol(ReceptionList_Waveband_string[ReceptionListLine]);
              gReceptionList_Type[ReceptionListLine]          =atol(ReceptionList_Type_string[ReceptionListLine]);
              gReceptionList_Attributes1[ReceptionListLine]   =atol(ReceptionList_Attributes1_string[ReceptionListLine]);
              gReceptionList_Attributes2[ReceptionListLine]   =atol(ReceptionList_Attributes2_string[ReceptionListLine]);
              gReceptionList_PresetID[ReceptionListLine]      =atol(ReceptionList_PresetID_string[ReceptionListLine]);
              gReceptionList_FmRegCode[ReceptionListLine]     =atol(ReceptionList_FmRegCode_string[ReceptionListLine]);
              gReceptionList_Category[ReceptionListLine]      =atol(ReceptionList_Category_string[ReceptionListLine]);
              gReceptionList_PicRef[ReceptionListLine]        =atol(ReceptionList_PicRef_string[ReceptionListLine]);
              writelineEx(gReceptionList_writeWindow, 0,"Pos[%d]: 0x%x", ReceptionListLine, gReceptionList_Pos[ReceptionListLine]);
              writelineEx(gReceptionList_writeWindow, 0,"Waveband[%d]: 0x%x", ReceptionListLine, gReceptionList_Waveband[ReceptionListLine]);
              writelineEx(gReceptionList_writeWindow, 0,"Type[%d]: 0x%x", ReceptionListLine, gReceptionList_Type[ReceptionListLine]);
              writelineEx(gReceptionList_writeWindow, 0,"Attributes1[%d]: 0x%x", ReceptionListLine, gReceptionList_Attributes1[ReceptionListLine]);
              writelineEx(gReceptionList_writeWindow, 0,"Attributes2[%d]: 0x%x", ReceptionListLine, gReceptionList_Attributes2[ReceptionListLine]);
              writelineEx(gReceptionList_writeWindow, 0,"PresetID[%d]: 0x%x", ReceptionListLine, gReceptionList_PresetID[ReceptionListLine]);
              writelineEx(gReceptionList_writeWindow, 0,"FmREG_Code[%d]: 0x%x", ReceptionListLine, gReceptionList_FmRegCode[ReceptionListLine]);
              writelineEx(gReceptionList_writeWindow, 0,"Category[%d]: 0x%x", ReceptionListLine, gReceptionList_Category[ReceptionListLine]);
              writelineEx(gReceptionList_writeWindow, 0,"Name[%d]: %s", ReceptionListLine, gReceptionList_Name[ReceptionListLine]);
              writelineEx(gReceptionList_writeWindow, 0,"Frequency[%d]: %s", ReceptionListLine, gReceptionList_Frequency[ReceptionListLine]);
              writelineEx(gReceptionList_writeWindow, 0,"PictureRefenrence[%d]: 0x%x", ReceptionListLine, gReceptionList_PicRef[ReceptionListLine]);
              gReceptionList_ListEntryValidInformation[ReceptionListLine]  =TRUE;
              ReceptionListLine++; // -> next line in *.csv (next record element)
            }
            current_CSV_line++; //next line in *.csv file
            element =0; //start at 'POS' (first record element of "array data")
            j=0; //reset value
          }
          else if(current_CSV_line>0 && ReceptionListLine<AUDIO_RECEPTIONLIST_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
          {
            switch (element)
            {
              case 0: //POS
                      ReceptionList_Pos_string[ReceptionListLine][j] =buffer_byte[i];
                      j++;
              break;
              case 1: //Waveband
                      ReceptionList_Waveband_string[ReceptionListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 2: //Type
                      ReceptionList_Type_string[ReceptionListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 3: //Attributes1
                      ReceptionList_Attributes1_string[ReceptionListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 4: //Attributes2
                      ReceptionList_Attributes2_string[ReceptionListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 5: //PresetID
                      ReceptionList_PresetID_string[ReceptionListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 6: //FmREG_Code
                      ReceptionList_FmRegCode_string[ReceptionListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 7: //Category
                      ReceptionList_Category_string[ReceptionListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 8: //Name
                      gReceptionList_Name[ReceptionListLine][j] =buffer_byte[i];
                      j++;                                
              break;
              case 9: //Frequency
                      gReceptionList_Frequency[ReceptionListLine][j] =buffer_byte[i];
                      j++;                                
              break;
              case 10: //PictureReference
                      ReceptionList_PicRef_string[ReceptionListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              default:
              break;
            }
          }                               
        }
        else  // ";" is detected ->next record element of "array data"
        {                                          
          element++;
          j=0; //reset value  
        }                                              
      }         
      gReceptionList_TotalNumListElements =gReceptionList_sum =ReceptionListLine; //get "total number of list elements"
      putvalue(env_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements);
      writelineEx(gReceptionList_writeWindow, 0, "");
      writelineEx(gReceptionList_writeWindow, 0,"Anzahl der Listenelemente: %d", gReceptionList_sum); //output total number of list elements
      writelineEx(gReceptionList_writeWindow, 0, "");
      if(fileClose(CSVfileHandle) !=0) //close *.csv file
        writelineEx(gReceptionList_writeWindow, 0,"Datei '%s' geschlossen", gReceptionList_CSV_filename); //output result
      else
        writelineEx(gReceptionList_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gReceptionList_CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
      writelineEx(gReceptionList_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'", gReceptionList_CSV_filename); //output result
      putvalue(env_AudioSD_RL_DataSource_result,"not successful"); //output result
    }
    gAudioSD_CSIhandle_FSGhandle =gReceptionList_Pos[0];
    putvalue(env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle);
  }
}

byte ReceptionList_nextvalidLine(byte current_ReceptionListLine, byte direction)
{
  byte next_ReceptionListLine;
  int i;

  //init lokal variables
  next_ReceptionListLine = 0;
  i = 0;
  //search next "list entry"
  if (((gReceptionList_sum - 1) == current_ReceptionListLine && FORWARD == direction) || (0 == current_ReceptionListLine && BACKWARD == direction))   //last-/fist-element of array reached
    next_ReceptionListLine = 0xFF;
  else
  {
    next_ReceptionListLine = current_ReceptionListLine + 1 - 2 * direction;       //increment or decrement array-line (depends on direction);
    if (0 == gReceptionList_ListEntryValidInformation[next_ReceptionListLine])  // check if next element is "valid"
      next_ReceptionListLine = 0xff;
  }
  return (next_ReceptionListLine);
}

void ReceptionList_Indication(dword Indication_array [], int datalength)
{
  byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
  word valid_startelement, requested_startelement, startelement, elements;
  int i = 0, transSuppression;

  // Init local variables. 
  mode = 0;
  shift = 0;
  direction = 0;
  transmitpos = 0;
  indexsize = 0;
  recordaddress = 0;
  requested_startelement = 0;
  startelement = 0;
  elements = 0;
  valid_startelement = 0xff;
  i = 0;
  valid_elements = 0;
  transSuppression = getvalue(env_AudioSD_RL_noStatusArray);

  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      if (getvalue(env_AudioSD_RL_Error_on))
        ReceptionList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue(env_AudioSD_RL_ErrorCode));
      else
      {
        //get Data
        gReceptionList_ASGID = (gBAP_Indication[3] & 0xF0) / 0x10;
        gReceptionList_TAID = gBAP_Indication[3] & 0x0F;
        gReceptionList_ElementType = gBAP_Indication[4];
        gReceptionList_ParentID = gBAP_Indication[5] + (gBAP_Indication[6] * 0x100);
        //decode BAP-ArrayHeader
        mode = (gBAP_Indication[7] & 0xF0) / 0x10;
        // decode "mode-byte"
        shift = mode & 0x01;
        direction = (mode & 0x02) / 0x02;
        transmitpos = (mode & 0x04) / 0x04;
        indexsize = (mode & 0x08) / 0x08;
        recordaddress = gBAP_Indication[7] & 0x0F;
        if (indexsize)
        {
          startelement = gBAP_Indication[8];
          startelement += gBAP_Indication[9] * 0x100;
          elements = gBAP_Indication[10];
          elements += gBAP_Indication[11] * 0x100;
        }
        else
        {
          startelement = gBAP_Indication[8];
          elements = gBAP_Indication[9];
        }
        requested_startelement = startelement;
        transmitpos = TRUE; //Position must always be sent in the case of *.GetArray.  
        /***Startelement=0***/
        if (0 == startelement) //Startelement-ID =0 -> start at first array-entry
        {
          if (FORWARD == direction)  //forward-start
          {
            valid_startelement = 0;
            if (AUDIO_RECEPTIONLIST_ENTRIES <= elements) //1. more elements requested, than in array
            {
              if (shift == FALSE)
              {
                for (i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++)
                {
                  if (0 != gReceptionList_ListEntryValidInformation[i])   //if there is an valid element
                  {
                    if (gReceptionList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                //no valid element, loop finished
                    i = AUDIO_RECEPTIONLIST_ENTRIES;
                }
              }
              else if (shift == TRUE)
              {
                valid_startelement = startelement;
                valid_elements = 0;
              }
            }
            else    //2. number of requested elements < elements in array
            {
              if (shift == FALSE)
              {
                for (i = 0; i < elements; i++)
                {
                  if (0 != gReceptionList_ListEntryValidInformation[i])   //if there is an valid element
                  {
                    if (gReceptionList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                //no valid element, loop finished
                    i = AUDIO_RECEPTIONLIST_ENTRIES;
                }
              }
              else if (shift == TRUE)
              {
                valid_startelement = startelement;
                valid_elements = 0;
              }
            }
          }                                                               //forward ends
          else if (BACKWARD == direction && TRUE == shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
          {
            //searching for valid startelement
            for (i = (AUDIO_RECEPTIONLIST_ENTRIES - 1); i >= 0; i--)
            {
              if (0 != gReceptionList_ListEntryValidInformation[i])       //found valid startelement
              {
                valid_startelement = i;
                i = 0;
              }
            }
            //searching for valid elements
            if (0xff == valid_startelement)                             //Startelement-ID doesn't exist in SMSReceived-array
            {
              valid_startelement = startelement;
              valid_elements = 0;
            }
            else if (0 == valid_startelement)
              valid_elements = 1;                                       //only 1 element because valid startelement is on position 0	
            else if (elements > (valid_startelement + 1))                   //not enougth array-elements available, because array endet at array-position 0
            {
              for (i = valid_startelement; i >= 0; i--)
              {
                if (0 != gReceptionList_ListEntryValidInformation[i])   //if there is an valid element
                {
                  if (gReceptionList_Pos[i] > 0xFF) //check indexsize
                    indexsize = TRUE;
                  valid_elements++;                               //increment elements
                }
                else                                                //no valid element, loop finished
                  i = 0;
              }
            }
            else                                                        //enougth array-elements available
            {
              for (i = valid_startelement; i > (valid_startelement - elements); i--)
              {
                if (0 != gReceptionList_ListEntryValidInformation[i])   //if there is an valid element
                {
                  if (gReceptionList_Pos[i] > 0xFF) //check indexsize
                    indexsize = TRUE;
                  valid_elements++;                               //increment elements
                }
                else                                                //no valid element, loop finished
                  i = 0;
              }
            }
          }                                                               //backward-end
        }                                                                   //startelement ==0 -end
        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID				
        {
          //searching for valid startelement
          for (i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++)
          {
            if (gReceptionList_Pos[i] == startelement)                      //found a valid element
            {
              if (shift == TRUE)                                          //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
              {
                if (i != 0 || BACKWARD != direction)                        //if valid_startelement is not the first array element or direction is not backwards
                  valid_startelement = i + 1 - 2 * direction;
                else if (i == 0 && BACKWARD == direction)
                  valid_startelement = gReceptionList_sum;     //valid element is last element in Array                                                
                else if (i == 0 && FORWARD == direction)
                  valid_startelement = 0;                          //valid element is first element in Array
              }
              else
                valid_startelement = i;                              //found element is valid_startelement
              i = AUDIO_RECEPTIONLIST_ENTRIES;
            }
          }
          if (0xff == valid_startelement)                                     //Startelement-ID doesn't exist in array
          {
            valid_startelement = startelement;
            valid_elements = 0;
          }
          else                                                                //found valid entry for startelement in array
          {
            //verify number of valid elements
            if (BACKWARD == direction)                                          //backward-start
            {
              if (valid_startelement == 0)                                    //only 1 element because valid startelement is on position 0
                valid_elements = 1;
              else if (elements > (valid_startelement + 1))                   //not enougth array-elements available, because array endet at array-position 0
              {
                for (i = valid_startelement; i >= 0; i--)
                {
                  if (0 != gReceptionList_ListEntryValidInformation[i])   //if there is an valid element
                  {
                    if (gReceptionList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                //no valid element, loop finished
                    i = 0;
                }
              }
              else                                                        //enougth array-elements available
              {
                for (i = valid_startelement; i > (valid_startelement - elements); i--)
                {
                  if (0 != gReceptionList_ListEntryValidInformation[i])   //if there is an valid element
                  {
                    if (gReceptionList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                //no valid element, loop finished
                    i = 0;
                }
              }
            }                                                               //backward-end
            else                                                            //forward-start
            {
              if ((valid_startelement + elements) >= AUDIO_RECEPTIONLIST_ENTRIES)
              {
                for (i = valid_startelement; i < AUDIO_RECEPTIONLIST_ENTRIES; i++)
                {
                  if (0 != gReceptionList_Pos[i])                     //if there is an valid element
                  {
                    if (gReceptionList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                //no valid element, loop finished
                    i = AUDIO_RECEPTIONLIST_ENTRIES;
                }
              }
              else
              {
                for (i = valid_startelement; i < (valid_startelement + elements); i++)
                {
                  if (0 != gReceptionList_Pos[i])                         //if there is an valid element
                  {
                    if (gReceptionList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                    //no valid element, loop finished
                    i = AUDIO_RECEPTIONLIST_ENTRIES;
                }
              }
            }
          }
        }
        if ((valid_startelement > 0xFF) || (requested_startelement > 0xFF)) //check indexsize
          indexsize = TRUE;
        mode = shift + (direction * 0x02) + (transmitpos * 0x04) + indexsize * 0x08;
        //send StatusArray
        if (!transSuppression)
          ReceptionList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
        //Panel
        putvalue(env_AudioSD_RL_ASGID, gReceptionList_ASGID);
        putvalue(env_AudioSD_RL_TAID, gReceptionList_TAID);
        if (gReceptionList_ElementType < 0x06)
          putvalue(env_AudioSD_RL_ElementType, gReceptionList_ElementType);
          putvalue(env_AudioSD_RL_ParentID, gReceptionList_ParentID);
      }
    break;
    case Error_IND:
      writelineEx(gError_Trace, 0, "FSG_AudioSD ReceptionList_Indication: received error, errorcode:0x%x", Indication_array[3]);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD ReceptionList_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void ReceptionList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements, byte errorcode)
{
    int i;
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word ReceptionListLine;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables. 
    for (i = 0; i < BAP_BUFFER_SIZE; i++)
        requestarray[i] = 0;

    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    ReceptionListLine = 0;
    current_element = 0;
    Offset = 0;

    // decode "mode-byte"
    shift = mode & 0x01;
    direction = (mode & 0x02) / 0x02;
    transmitpos = (mode & 0x04) / 0x04;
    indexsize = (mode & 0x08) / 0x08;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_ReceptionList;      //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;

    switch (request)
    {
        case Changed_REQ:
            requestarray[Offset] = gReceptionList_ElementType;
            Offset++;
            requestarray[Offset] = gReceptionList_ParentID & 0xff;
            Offset++;
            requestarray[Offset] = (gReceptionList_ParentID & 0xff00) / 0x100;
            Offset++;
            /***ArrayHeader***/
            requestarray[Offset] = ((mode * 0x10) & 0xF0) + (recordaddress & 0x0F);
            Offset++;
            if (indexsize)
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = (requested_startelement & 0xff00) / 0x100;
                Offset++;
                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = (elements & 0xff00) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }
            ReceptionListLine = startelement;
            if (getvalue(env_AudioSD_RL_CA_switch)) //ArrayData
            {
                //copy data
                switch (recordaddress)
                {
                    case 0: //complete record (FRU)
                        while (current_element < elements)
                        {
                            if (ReceptionListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                                //Waveband
                                requestarray[Offset] = gReceptionList_Waveband[ReceptionListLine];
                                Offset++;
                                //Type
                                requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                Offset++;
                                //Attributes1 & 2
                                requestarray[Offset] = gReceptionList_Attributes1[ReceptionListLine];
                                Offset++;
                                requestarray[Offset] = gReceptionList_Attributes2[ReceptionListLine];
                                Offset++;
                                //PresetID
                                requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                                Offset++;
                                //FmREG_Code
                                requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                                Offset++;
                                //Category
                                requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                                {
                                    requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                    Offset++;
                                }
                                //Frequency
                                requestarray[Offset] = strlen(gReceptionList_Frequency[ReceptionListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gReceptionList_Frequency[ReceptionListLine]); i++)
                                {
                                    requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                    Offset++;
                                }
                                //PictureReference
                                requestarray[Offset] = (gReceptionList_PicRef[ReceptionListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gReceptionList_PicRef[ReceptionListLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                        }//end while
                        set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                    break;
                    case 1: //complete record
                        while (current_element < elements)
                        {
                            if (ReceptionListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                                //Waveband
                                requestarray[Offset] = gReceptionList_Waveband[ReceptionListLine];
                                Offset++;
                                //Type
                                requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                Offset++;
                                //Attributes1 & 2
                                requestarray[Offset] = gReceptionList_Attributes1[ReceptionListLine];
                                Offset++;
                                requestarray[Offset] = gReceptionList_Attributes2[ReceptionListLine];
                                Offset++;
                                //PresetID
                                requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                                Offset++;
                                //FmREG_Code
                                requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                                Offset++;
                                //Category
                                requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                                {
                                    requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                    Offset++;
                                }
                                //Frequency
                                requestarray[Offset] = strlen(gReceptionList_Frequency[ReceptionListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gReceptionList_Frequency[ReceptionListLine]); i++)
                                {
                                    requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                    Offset++;
                                }
                                //PictureReference
                                requestarray[Offset] = (gReceptionList_PicRef[ReceptionListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gReceptionList_PicRef[ReceptionListLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                        }//end while
                        set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                    break;
                    case 2: //Waveband, Type, Attributes1 & 2, PresetID, FmREG_Code, Category, Name, Frequency
                        while (current_element < elements)
                        {
                            if (ReceptionListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                                //Waveband
                                requestarray[Offset] = gReceptionList_Waveband[ReceptionListLine];
                                Offset++;
                                //Type
                                requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                Offset++;
                                //Attributes1 & 2
                                requestarray[Offset] = gReceptionList_Attributes1[ReceptionListLine];
                                Offset++;
                                requestarray[Offset] = gReceptionList_Attributes2[ReceptionListLine];
                                Offset++;
                                //PresetID
                                requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                                Offset++;
                                //FmREG_Code
                                requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                                Offset++;
                                //Category
                                requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                                {
                                    requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                    Offset++;
                                }
                                //Frequency
                                requestarray[Offset] = strlen(gReceptionList_Frequency[ReceptionListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gReceptionList_Frequency[ReceptionListLine]); i++)
                                {
                                    requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                        }//end while
                        set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                    break;    
                    case 3: //Waveband, Type, Attribute1 & 2, Category, Name
                        while (current_element < elements)
                        {
                            if (ReceptionListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                                //Waveband
                                requestarray[Offset] = gReceptionList_Waveband[ReceptionListLine];
                                Offset++;
                                //Type
                                requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                Offset++;
                                //Attributes1 & 2
                                requestarray[Offset] = gReceptionList_Attributes1[ReceptionListLine];
                                Offset++;
                                requestarray[Offset] = gReceptionList_Attributes2[ReceptionListLine];
                                Offset++;
                                //Category
                                requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                                {
                                    requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                        }//end while
                        set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                    break;    
                    case 4: //Waveband, Type, Attribute1 & 2
                        while (current_element < elements)
                        {
                            if (ReceptionListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                                //Waveband
                                requestarray[Offset] = gReceptionList_Waveband[ReceptionListLine];
                                Offset++;
                                //Type
                                requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                Offset++;
                                //Attributes1 & 2
                                requestarray[Offset] = gReceptionList_Attributes1[ReceptionListLine];
                                Offset++;
                                requestarray[Offset] = gReceptionList_Attributes2[ReceptionListLine];
                                Offset++;
                            }
                            current_element++;
                            ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                        }//end while
                        set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                    break; 
                    case 5: //PresetID, FmREG_Code, Category, Name
                        while (current_element < elements)
                        {
                            if (ReceptionListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                                //PresetID
                                requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                                Offset++;
                                //FmREG_Code
                                requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                                Offset++;
                                //Category
                                requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                                {
                                    requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                        }//end while
                        set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                    break;
                    case 6: //Name
                        while (current_element < elements)
                        {
                            if (ReceptionListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                                //Name
                                requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                                {
                                    requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                        }//end while
                        set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                    break;    
                    case 7: //Frequency
                        while (current_element < elements)
                        {
                            if (ReceptionListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                                //Frequency
                                requestarray[Offset] = strlen(gReceptionList_Frequency[ReceptionListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gReceptionList_Frequency[ReceptionListLine]); i++)
                                {
                                    requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                        }//end while
                        set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                    break;    
                    case 8: //PictureReference
                        while (current_element < elements)
                        {
                            if (ReceptionListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                                //PictureReference
                                requestarray[Offset] = (gReceptionList_PicRef[ReceptionListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gReceptionList_PicRef[ReceptionListLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                        }//end while
                        set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                    break;     
                    case 15: //Pos
                        while (current_element < elements)
                        {
                            if (ReceptionListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0x00FF);
                                        Offset++;
                                        requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                        }//end while
                    break;
                    default:
                        write("AudioSD ReceptionList_Request: invalid recordaddress %d", recordaddress);
                    break;
                } //end switch "recordaddress"
            }//end ArrayData   
            set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
        break; //end Changed_REQ
        case Data_REQ:
            requestarray[Offset] = ((gReceptionList_ASGID * 0x10) & 0xF0) + (gReceptionList_TAID & 0x0F);
            Offset++;
            requestarray[Offset] = gReceptionList_ElementType;
            Offset++;
            requestarray[Offset] = gReceptionList_ParentID & 0xff;
            Offset++;
            requestarray[Offset] = (gReceptionList_ParentID & 0xff00) / 0x100;
            Offset++;
            requestarray[Offset] = gReceptionList_TotalNumListElements & 0xff;
            Offset++;
            requestarray[Offset] = (gReceptionList_TotalNumListElements & 0xff00) / 0x100;
            Offset++;
            /***ArrayHeader***/
            requestarray[Offset] = ((mode * 0x10) & 0xF0) + (recordaddress & 0x0F);
            Offset++;
            if (indexsize)
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = (requested_startelement & 0xff00) / 0x100;
                Offset++;
                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = (elements & 0xff00) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }
            ReceptionListLine = startelement;
            //copy data
            switch (recordaddress)
            {
                case 0: //complete record (FRU)
                    while (current_element < elements)
                    {
                        if (ReceptionListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                    Offset++;
                                }
                            }
                            //Waveband
                            requestarray[Offset] = gReceptionList_Waveband[ReceptionListLine];
                            Offset++;
                            //Type
                            requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                            Offset++;
                            //Attributes1 & 2
                            requestarray[Offset] = gReceptionList_Attributes1[ReceptionListLine];
                            Offset++;
                            requestarray[Offset] = gReceptionList_Attributes2[ReceptionListLine];
                            Offset++;
                            //PresetID
                            requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                            Offset++;
                            //FmREG_Code
                            requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                            Offset++;
                            //Category
                            requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                            {
                                requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                Offset++;
                            }
                            //Frequency
                            requestarray[Offset] = strlen(gReceptionList_Frequency[ReceptionListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gReceptionList_Frequency[ReceptionListLine]); i++)
                            {
                                requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                Offset++;
                            }
                            //PictureReference
                                requestarray[Offset] = (gReceptionList_PicRef[ReceptionListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gReceptionList_PicRef[ReceptionListLine] & 0xFF00) / 0x100);
                                Offset++;
                        }
                        current_element++;
                        ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                case 1: //complete record
                    while (current_element < elements)
                    {
                        if (ReceptionListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                    Offset++;
                                }
                            }
                            //Waveband
                            requestarray[Offset] = gReceptionList_Waveband[ReceptionListLine];
                            Offset++;
                            //Type
                            requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                            Offset++;
                            //Attributes1 & 2
                            requestarray[Offset] = gReceptionList_Attributes1[ReceptionListLine];
                            Offset++;
                            requestarray[Offset] = gReceptionList_Attributes2[ReceptionListLine];
                            Offset++;
                            //PresetID
                            requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                            Offset++;
                            //FmREG_Code
                            requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                            Offset++;
                            //Category
                            requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                            {
                                requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                Offset++;
                            }
                            //Frequency
                            requestarray[Offset] = strlen(gReceptionList_Frequency[ReceptionListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gReceptionList_Frequency[ReceptionListLine]); i++)
                            {
                                requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                Offset++;
                            }
                            //PictureReference
                                requestarray[Offset] = (gReceptionList_PicRef[ReceptionListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gReceptionList_PicRef[ReceptionListLine] & 0xFF00) / 0x100);
                                Offset++;
                        }
                        current_element++;
                        ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                case 2: //WB, Type, Attr1&2, PresetID, FmREGCode, Category, Name, Frequency
                    while (current_element < elements)
                    {
                        if (ReceptionListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                    Offset++;
                                }
                            }
                            //Waveband
                            requestarray[Offset] = gReceptionList_Waveband[ReceptionListLine];
                            Offset++;
                            //Type
                            requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                            Offset++;
                            //Attributes1 & 2
                            requestarray[Offset] = gReceptionList_Attributes1[ReceptionListLine];
                            Offset++;
                            requestarray[Offset] = gReceptionList_Attributes2[ReceptionListLine];
                            Offset++;
                            //PresetID
                            requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                            Offset++;
                            //FmREG_Code
                            requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                            Offset++;
                            //Category
                            requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                            {
                                requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                Offset++;
                            }
                            //Frequency
                            requestarray[Offset] = strlen(gReceptionList_Frequency[ReceptionListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gReceptionList_Frequency[ReceptionListLine]); i++)
                            {
                                requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                case 3: //WB, Type, Attr1&2, Category, Name
                    while (current_element < elements)
                    {
                        if (ReceptionListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                    Offset++;
                                }
                            }
                            //Waveband
                            requestarray[Offset] = gReceptionList_Waveband[ReceptionListLine];
                            Offset++;
                            //Type
                            requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                            Offset++;
                            //Attributes1 & 2
                            requestarray[Offset] = gReceptionList_Attributes1[ReceptionListLine];
                            Offset++;
                            requestarray[Offset] = gReceptionList_Attributes2[ReceptionListLine];
                            Offset++;
                            //Category
                            requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                            {
                                requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                case 4: //WB, Type, Attr1&2
                    while (current_element < elements)
                    {
                        if (ReceptionListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                    Offset++;
                                }
                            }
                            //Waveband
                            requestarray[Offset] = gReceptionList_Waveband[ReceptionListLine];
                            Offset++;
                            //Type
                            requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                            Offset++;
                            //Attributes1 & 2
                            requestarray[Offset] = gReceptionList_Attributes1[ReceptionListLine];
                            Offset++;
                            requestarray[Offset] = gReceptionList_Attributes2[ReceptionListLine];
                            Offset++;
                        }
                        current_element++;
                        ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;    
                case 5: //PresetID, FmREGCode, Category, Name
                    while (current_element < elements)
                    {
                        if (ReceptionListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                    Offset++;
                                }
                            }
                            //PresetID
                            requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                            Offset++;
                            //FmREG_Code
                            requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                            Offset++;
                            //Category
                            requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                            {
                                requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;    
                case 6: //Name
                    while (current_element < elements)
                    {
                        if (ReceptionListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                    Offset++;
                                }
                            }
                            //Name
                            requestarray[Offset] = strlen(gReceptionList_Name[ReceptionListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gReceptionList_Name[ReceptionListLine]); i++)
                            {
                                requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;    
                case 7: //Frequency
                    while (current_element < elements)
                    {
                        if (ReceptionListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                    Offset++;
                                }
                            }
                            //Frequency
                            requestarray[Offset] = strlen(gReceptionList_Frequency[ReceptionListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gReceptionList_Frequency[ReceptionListLine]); i++)
                            {
                                requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;    
                case 8: //PictureReference
                    while (current_element < elements)
                    {
                        if (ReceptionListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                    Offset++;
                                }
                            }
                            //PictureReference
                                requestarray[Offset] = (gReceptionList_PicRef[ReceptionListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gReceptionList_PicRef[ReceptionListLine] & 0xFF00) / 0x100);
                                Offset++;
                        }
                        current_element++;
                        ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                case 15: //Pos
                    while (current_element < elements)
                    {
                        if (ReceptionListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD ReceptionList_Request: invalid ReceptionListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gReceptionList_Pos[ReceptionListLine] & 0x00FF);
                                    Offset++;
                                    requestarray[Offset] = ((gReceptionList_Pos[ReceptionListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                    Offset++;
                                }
                            }
                        }
                        current_element++;
                        ReceptionListLine = ReceptionList_nextvalidLine(ReceptionListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                default:
                    write("AudioSD ReceptionList_Request: invalid recordaddress %d", recordaddress);
                break;
            } //end switch "recordaddress"
        break; //end Data_REQ
        case Error_REQ:
            requestarray[3] = errorcode;
            set_status_requestbuffer(requestarray, 4, Bap_Error);
        break; //end Error_REQ
    } //end switch "request"   
}

//*************************************************************************
//*****************RadioTV_PresetList**************************************
on envVar env_AudioSD_RTPL_CA
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;

  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
  {
    recordaddress   =getvalue(env_AudioSD_RTPL_AH_RA);
    shift           =getvalue(env_AudioSD_RTPL_AH_shift);
    direction       =getvalue(env_AudioSD_RTPL_AH_dir);
    transmitpos     =getvalue(env_AudioSD_RTPL_AH_POS);
    indexsize       =getvalue(env_AudioSD_RTPL_AH_IS);
    startelement    =getvalue(env_AudioSD_RTPL_AH_start);
    elements        =getvalue(env_AudioSD_RTPL_AH_elements);
    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    requested_startelement =startelement;
    /***Startelement=0***/
    if (getvalue(env_AudioSD_RTPL_CA_switch)) //ArrayData
    {
      if(0==startelement) //Startelement-ID =0 -> start at first array-entry
      {
        if(FORWARD==direction)  //forward-start
        {
          valid_startelement =0;				       									
          if(AUDIO_RADIOTVPRESETLIST_ENTRIES <=elements) //1. more elements requested, than in array
          {
            if (shift ==FALSE)  
            {
              for(i=0;i<AUDIO_RADIOTVPRESETLIST_ENTRIES;i++)
				      {
  			        if(0 !=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
  				        valid_elements++;								//increment elements
  			        else												//no valid element, loop finished
  				        i =AUDIO_RADIOTVPRESETLIST_ENTRIES;
              }
            }
            else if (shift ==TRUE)
            {   
              valid_startelement  =startelement;
			        valid_elements      =0;
            }
	        }
          else    //2. number of requested elements < elements in array
			    {
            if (shift ==FALSE)
            {
				      for(i=0;i<elements;i++)
					    {
				        if(0!=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
				        else												//no valid element, loop finished
				          i =AUDIO_RADIOTVPRESETLIST_ENTRIES;
			        }
            }
            else if (shift ==TRUE)
            {
              valid_startelement  =startelement;
			        valid_elements      =0; 
            }
				  }
        }                                                               //forward ends
        else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
		    {     
		      //searching for valid startelement
			    for(i=(AUDIO_RADIOTVPRESETLIST_ENTRIES-1);i>=0;i--)
			    {
			      if(0!=gRadioTVPresetList_ListEntryValidInformation[i])		//found valid startelement
				    {
				      valid_startelement =i;								
					    i =0;												
				    }
			    } 
          //searching for valid elements
			    if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
			    {
			      valid_startelement  =startelement;
				    valid_elements      =0;
			    }
		    	else if(0==valid_startelement)								
			      valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
			    else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
			    {
			      for(i=valid_startelement;i>=0;i--)
				    {
			        if(0!=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
				        valid_elements++;								//increment elements
					    else												//no valid element, loop finished
					      i=0;
		        }
			    }
          else														//enougth array-elements available
			    {
		        for(i=valid_startelement;i>(valid_startelement-elements);i--)
		        {
			        if(0!=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
				        valid_elements++;								//increment elements
  				    else												//no valid element, loop finished
  					    i=0;
				    }                   
			    }															
        }                                                               //backward-end
      }                                                                   //startelement ==0 -end
      /***Startelement!=0***/
      else																//searching for Startelement-ID				
	    {
	      //searching for valid startelement
		    for(i=0;i<AUDIO_RADIOTVPRESETLIST_ENTRIES;i++)
		    {
			    if(gRadioTVPresetList_Pos[i] ==startelement)					    //found a valid element
			    {                                       
            if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
				    {
			        if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
				        valid_startelement =i+1-2* direction;
              else if(i==0 && BACKWARD==direction) 
                valid_startelement =gRadioTVPresetList_sum;     //valid element is last element in Array                                                
              else if(i==0 && FORWARD==direction) 
                valid_startelement =0;                          //valid element is first element in Array
            }
            else
              valid_startelement =i;                              //found element is valid_startelement
					  i =AUDIO_RADIOTVPRESETLIST_ENTRIES;
				  }
          else
            valid_startelement =0xff;
			  }
		    if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
		    {   
			    valid_startelement  =startelement;
			    valid_elements      =0;
		    }
		    else																//found valid entry for startelement in array
		    {
		      //verify number of valid elements
			    if(BACKWARD==direction)											//backward-start
			    {
		        if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
			        valid_elements=1;
				    else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
			      {
			        for(i=valid_startelement;i>=0;i--)
					    {
				        if(0!=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
                else												//no valid element, loop finished
					        i=0;
						  }
				    }
				    else														//enougth array-elements available
				    {
				      for(i=valid_startelement;i>(valid_startelement-elements);i--)
					    {
				        if(0!=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i=0;
					    }
				    }
			    }																//backward-end
			    else															//forward-start
			    {
			      if((valid_startelement+elements)>=AUDIO_RADIOTVPRESETLIST_ENTRIES)
				    {
				      for(i=valid_startelement;i<AUDIO_RADIOTVPRESETLIST_ENTRIES;i++)
					    {
				        if(0!=gRadioTVPresetList_Pos[i])							//if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						      i=AUDIO_RADIOTVPRESETLIST_ENTRIES;
					    }
				    }
  			    else
  			    {
				      for(i=valid_startelement;i<(valid_startelement+elements);i++)
					    {
				        if(0!=gRadioTVPresetList_Pos[i])						    //if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						      i=AUDIO_RADIOTVPRESETLIST_ENTRIES;
					    }
				    }
			    }
		    }
	    }
      putvalue(env_AudioSD_RTPL_AH_elements, valid_elements);
      //send ChangedArray
      RadioTVPresetList_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
    else
    {
      //send ChangedArray
      RadioTVPresetList_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
    }
  }
}

on envVar env_AudioSD_RTPL_DataSource
{
  if (getvalue(this) ==AUDIO_DEFAULT_LIST)
  {
    RadioTVPresetList_init_static();
    putvalue(env_AudioSD_RTPL_DataSource_file, empty_string);
    putvalue(env_AudioSD_RTPL_DataSource_res, empty_string);
  }
}

on envVar env_AudioSD_RTPL_reload //load external RadioTVPresetList from *.csv
{
  if(getvalue(this) && getvalue(env_AudioSD_RTPL_DataSource) ==AUDIO_EXTERNAL_LIST)
    RadioTVPresetList_init_CSV();
  else if(getvalue(env_AudioSD_RTPL_DataSource) != AUDIO_EXTERNAL_LIST)
    putvalue(env_AudioSD_RTPL_DataSource_res,"not successful, select 'external *.csv'");
}

on envVar env_AudioSD_RTPL_StatusArray
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i, transSuppression;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0xff;
  i                       =0;
  valid_elements          =0;
  transSuppression        = getvalue(env_AudioSD_PL_noStatusArray);
  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    //get data from Panel
    gRadioTVPresetList_ASGID                =getvalue(env_AudioSD_RTPL_ASGID);
    gRadioTVPresetList_TAID                 =getvalue(env_AudioSD_RTPL_TAID);
    gRadioTVPresetList_TotalNumListElements =getvalue(env_AudioSD_RTPL_TotalNumLE);
    recordaddress   =getvalue(env_AudioSD_RTPL_AH_RA);
    shift           =getvalue(env_AudioSD_RTPL_AH_shift);
    direction       =getvalue(env_AudioSD_RTPL_AH_dir);
    transmitpos     =getvalue(env_AudioSD_RTPL_AH_POS);
    indexsize       =getvalue(env_AudioSD_RTPL_AH_IS);
    startelement    =getvalue(env_AudioSD_RTPL_AH_start);
    elements        =getvalue(env_AudioSD_RTPL_AH_elements);
    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    requested_startelement =startelement;  
    /***Startelement=0***/
    if(0==startelement) //Startelement-ID =0 -> start at first array-entry
		{
      if(FORWARD==direction)  //forward-start
			{
        valid_startelement =0;				       									
        if(AUDIO_RADIOTVPRESETLIST_ENTRIES <=elements) //1. more elements requested, than in array
				{
          if (shift ==FALSE)  
          {   
            for(i=0;i<AUDIO_RADIOTVPRESETLIST_ENTRIES;i++)
						{
					    if(0 !=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
					    else												//no valid element, loop finished
						    i =AUDIO_RADIOTVPRESETLIST_ENTRIES;
					  }    
          }
          else if (shift ==TRUE)
          {   
            valid_startelement  =startelement;
				    valid_elements      =0;
          }
			  }
        else    //2. number of requested elements < elements in array
				{
          if (shift ==FALSE)
          {   
					  for(i=0;i<elements;i++)
						{
					    if(0!=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
					    else												//no valid element, loop finished
					       i =AUDIO_RADIOTVPRESETLIST_ENTRIES;
					  }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =startelement;
				    valid_elements      =0;   
          }
				}
      }                                                               //forward ends
      else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
			{   
			  //searching for valid startelement
				for(i=(AUDIO_RADIOTVPRESETLIST_ENTRIES-1);i>=0;i--)
				{
				  if(0!=gRadioTVPresetList_ListEntryValidInformation[i])		//found valid startelement
					{
					  valid_startelement =i;								
						i =0;												
					}
				}
        //searching for valid elements
				if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
				{
				  valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(0==valid_startelement)								
				  valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				  for(i=valid_startelement;i>=0;i--)
					{
				    if(0!=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
					    valid_elements++;								//increment elements
						else												//no valid element, loop finished
						  i=0;
				  }
				}
        else														//enougth array-elements available
				{
				  for(i=valid_startelement;i>(valid_startelement-elements);i--)
					{
				    if(0!=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
					    valid_elements++;								//increment elements
						else												//no valid element, loop finished
							i=0;
					}                   
				}															
	    }                                                               //backward-end
    }                                                                   //startelement ==0 -end
    /***Startelement!=0***/
    else																//searching for Startelement-ID				
		{
		  //searching for valid startelement
			for(i=0;i<AUDIO_RADIOTVPRESETLIST_ENTRIES;i++)
			{
				if(gRadioTVPresetList_Pos[i] ==startelement)					    //found a valid element
				{                                       
          if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
					{
				    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
					    valid_startelement =i+1-2* direction;
            else if(i==0 && BACKWARD==direction) 
              valid_startelement =gRadioTVPresetList_sum;     //valid element is last element in Array                                                
            else if(i==0 && FORWARD==direction) 
              valid_startelement =0;                          //valid element is first element in Array
          }
          else
            valid_startelement =i;                              //found element is valid_startelement
					i =AUDIO_RADIOTVPRESETLIST_ENTRIES;
				}
        else
          valid_startelement =0xff;
			}
			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			  //verify number of valid elements
				if(BACKWARD==direction)											//backward-start
				{
			    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
				    valid_elements=1;
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				  {
					  for(i=valid_startelement;i>=0;i--)
						{
					    if(0!=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
              else												//no valid element, loop finished
							  i=0;
						}
				  }
					else														//enougth array-elements available
					{
					  for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
					    if(0!=gRadioTVPresetList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
							else												//no valid element, loop finished
								i=0;
						}
					}
				}																//backward-end
				else															//forward-start
				{
				  if((valid_startelement+elements)>=AUDIO_RADIOTVPRESETLIST_ENTRIES)
					{
					  for(i=valid_startelement;i<AUDIO_RADIOTVPRESETLIST_ENTRIES;i++)
						{
					    if(0!=gRadioTVPresetList_Pos[i])							//if there is an valid element
						    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							  i=AUDIO_RADIOTVPRESETLIST_ENTRIES;
						}
					}
					else
					{
					  for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
					    if(0!=gRadioTVPresetList_Pos[i])						    //if there is an valid element
						    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							  i=AUDIO_RADIOTVPRESETLIST_ENTRIES;
						}
					}
				}
			}
		}
    putvalue(env_AudioSD_RTPL_AH_elements, valid_elements);
    //send StatusArray
    if(!transSuppression)
      RadioTVPresetList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
  }
}

void RadioTVPresetList_init_CSV() //Byte & file selection
{
  dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, 
        current_CSV_line = 0, count1 = 0, count2 = 0;
  char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
  byte RadioTVPresetListLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
  char RadioTVPresetList_Pos_string[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
  char RadioTVPresetList_PresetIndex_string[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_TEXTLENGTH];//help value ->"PresetIndex" is stored in the ASCII(UTF-8) code in the *.csv 
  char RadioTVPresetList_Waveband_string[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Waveband" is stored in the ASCII(UTF-8) code in the *.csv 
  char RadioTVPresetList_Attributes1_string[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Attributes" is stored in the ASCII(UTF-8) code in the *.csv 
  char RadioTVPresetList_Attributes2_string[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Attributes" is stored in the ASCII(UTF-8) code in the *.csv 
  char RadioTVPresetList_PicRef_string[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Attributes" is stored in the ASCII(UTF-8) code in the *.csv 
  if(getvalue(env_AudioSD_RTPL_DataSource) == AUDIO_EXTERNAL_LIST) //output data in write window "FSGRadioTVPresetList"  
  {
    writeClear(gRadioTVPresetList_writeWindow);
    writelineEx(gRadioTVPresetList_writeWindow, 0,"*******External RadioTVPresetList*******");
    writelineEx(gRadioTVPresetList_writeWindow, 0, "");
    writelineEx(gRadioTVPresetList_writeWindow, 0, "**********************Start load new RadioTVPresetList**********************");   
    //clear  
    for(j=0;j<AUDIO_RADIOTVPRESETLIST_ENTRIES;j++) 
    {
	    gRadioTVPresetList_Pos[j]               =0;
	    gRadioTVPresetList_PresetIndex[j]       =0;
      gRadioTVPresetList_Waveband[j]          =0;
      gRadioTVPresetList_Attributes1_Bit0[j]  =0;
      gRadioTVPresetList_Attributes1_Bit1[j]  =0;
      gRadioTVPresetList_Attributes1_Bit2[j]  =0;
      gRadioTVPresetList_Attributes1_Bit3[j]  =0;
      gRadioTVPresetList_Attributes1_Bit4[j]  =0;
      gRadioTVPresetList_Attributes1_Bit5[j]  =0;
      gRadioTVPresetList_Attributes1_Bit6[j]  =0;
      gRadioTVPresetList_Attributes1_Bit7[j]  =0;
      gRadioTVPresetList_Attributes2_Bit0[j]  =0;
      gRadioTVPresetList_Attributes2_Bit1[j]  =0;
      gRadioTVPresetList_Attributes2_Bit2[j]  =0;
      gRadioTVPresetList_Attributes2_Bit3[j]  =0;
      gRadioTVPresetList_Attributes2_Bit4[j]  =0;
      gRadioTVPresetList_Attributes1[j]       =0;
      gRadioTVPresetList_Attributes2[j]       =0;
      gRadioTVPresetList_PicRef[j]            =0;
      gRadioTVPresetList_ListEntryValidInformation[j] =0;
	    for(i=0;i<AUDIO_RADIOTVPRESETLIST_NAME_LENGTH;i++)
		    gRadioTVPresetList_Name[j][i] =0;
      for(i=0;i<AUDIO_RADIOTVPRESETLIST_FREQUENCY_LENGTH;i++)
		    gRadioTVPresetList_Frequency[j][i] =0;
	  }
    for(i=0;i<AUDIO_FILENAME_SIZE; i++) //clear "filename"
      gRadioTVPresetList_CSV_filename[i] =0;       
    for(j=0;j<AUDIO_RADIOTVPRESETLIST_ENTRIES; j++) //clear "buffer"
    {
      buffer_string[j]    =0;
      buffer_byte[j]      =0;
      for(i=0;i<AUDIO_TEXTLENGTH;i++) //clear help value
      {
        RadioTVPresetList_Pos_string[j][i]          =0;
        RadioTVPresetList_PresetIndex_string[j][i]  =0;
        RadioTVPresetList_Waveband_string[j][i]     =0;
        RadioTVPresetList_Attributes1_string[j][i]  =0;
        RadioTVPresetList_Attributes2_string[j][i]  =0;
        RadioTVPresetList_PicRef_string[j][i]       =0;
      }
    }        
    i =0; j =0; RadioTVPresetListLine =0; current_CSV_line =0; //reset values 
    getvalue(env_AudioSD_RTPL_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
    //write("complete path *.csv: %s", Path_CSV); //debug
    i =0;
    while (Path_CSV[i] !=0) //scan "path"
    {
      if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
        count1++;                
      //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
      i++;
    }  
    i =0; j =0; //reset values
    while (Path_CSV[i] !=0) //seperate "path" and "filename"
    {
      if(count2==count1) //get filename after last "\"
      {              
        gRadioTVPresetList_CSV_filename[j] =Path_CSV[i];
        j++;
        Path_CSV[i] =0;              
      }
      if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
        count2++;
      i++;
    }
    writelineEx(gRadioTVPresetList_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 
    writelineEx(gRadioTVPresetList_writeWindow, 0,"filename of *.csv: '%s'", gRadioTVPresetList_CSV_filename);  //output filename 
    putvalue(env_AudioSD_RTPL_DataSource_file, gRadioTVPresetList_CSV_filename); //output current loaded *.csv-file on panel
    setFilePath(Path_CSV, 0); //set path for *.csv file
    CSVfileHandle =openFileRead(gRadioTVPresetList_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        
    if (CSVfileHandle!=0) //*.csv file access successful
    {
      writelineEx(gRadioTVPresetList_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gRadioTVPresetList_CSV_filename);    //output result  
      putvalue(env_AudioSD_RTPL_DataSource_res, "successful");   //output result on panel                      
      Num_of_csv_byte =fileGetBinaryBlock(buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file                          
      for (i=0; i<Num_of_csv_byte; i++) //copy data into "RadioTVPresetList"
      {      
        if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
        {
          if(buffer_byte[i] ==0x0D && buffer_byte[i + 1] ==0x0A) //nextline in *.csv (next "record element" in RadioTVPresetList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
          {
            if(current_CSV_line>0 && RadioTVPresetListLine<AUDIO_RADIOTVPRESETLIST_ENTRIES) //ignore first line in *.csv file
            {   
              writelineEx(gRadioTVPresetList_writeWindow, 0, "");
              writelineEx(gRadioTVPresetList_writeWindow, 0,"*******Element %d*******", RadioTVPresetListLine);
              //transform 'string' to 'long' for "POS", "SourceType", "Waveband" and "Attributes"
              gRadioTVPresetList_Pos[RadioTVPresetListLine]           =atol(RadioTVPresetList_Pos_string[RadioTVPresetListLine]);
              gRadioTVPresetList_PresetIndex[RadioTVPresetListLine]   =atol(RadioTVPresetList_PresetIndex_string[RadioTVPresetListLine]);
              gRadioTVPresetList_Waveband[RadioTVPresetListLine]      =atol(RadioTVPresetList_Waveband_string[RadioTVPresetListLine]);
              gRadioTVPresetList_Attributes1[RadioTVPresetListLine]   =atol(RadioTVPresetList_Attributes1_string[RadioTVPresetListLine]);
              gRadioTVPresetList_Attributes2[RadioTVPresetListLine]   =atol(RadioTVPresetList_Attributes2_string[RadioTVPresetListLine]);
              gRadioTVPresetList_PicRef[RadioTVPresetListLine]        =atol(RadioTVPresetList_PicRef_string[RadioTVPresetListLine]);
              writelineEx(gRadioTVPresetList_writeWindow, 0,"Pos[%d]: 0x%x", RadioTVPresetListLine, gRadioTVPresetList_Pos[RadioTVPresetListLine]);
              writelineEx(gRadioTVPresetList_writeWindow, 0,"PresetIndex[%d]: 0x%x", RadioTVPresetListLine, gRadioTVPresetList_PresetIndex[RadioTVPresetListLine]);
              writelineEx(gRadioTVPresetList_writeWindow, 0,"Waveband[%d]: 0x%x", RadioTVPresetListLine, gRadioTVPresetList_Waveband[RadioTVPresetListLine]);                           
              writelineEx(gRadioTVPresetList_writeWindow, 0,"Attributes1[%d]: 0x%x", RadioTVPresetListLine, gRadioTVPresetList_Attributes1[RadioTVPresetListLine]); 
              writelineEx(gRadioTVPresetList_writeWindow, 0,"Attributes2[%d]: 0x%x", RadioTVPresetListLine, gRadioTVPresetList_Attributes2[RadioTVPresetListLine]); 
              writelineEx(gRadioTVPresetList_writeWindow, 0,"Name[%d]: %s", RadioTVPresetListLine, gRadioTVPresetList_Name[RadioTVPresetListLine]);
              writelineEx(gRadioTVPresetList_writeWindow, 0,"Frequency[%d]: %s", RadioTVPresetListLine, gRadioTVPresetList_Frequency[RadioTVPresetListLine]);
              writelineEx(gRadioTVPresetList_writeWindow, 0,"PictureReference[%d]: 0x%x", RadioTVPresetListLine, gRadioTVPresetList_PicRef[RadioTVPresetListLine]); 
              gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine]  =TRUE;
              RadioTVPresetListLine++; // -> next line in *.csv (next record element)
            }
            current_CSV_line++; //next line in *.csv file
            element =0; //start at 'POS' (first record element of "array data")
            j=0; //reset value
          }
          else if(current_CSV_line>0 && RadioTVPresetListLine<AUDIO_RADIOTVPRESETLIST_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
          {
            switch (element)
            {
              case 0: //POS
                      RadioTVPresetList_Pos_string[RadioTVPresetListLine][j] =buffer_byte[i];
                      j++;
              break;
              case 1: //PresetIndex
                      RadioTVPresetList_PresetIndex_string[RadioTVPresetListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 2: //Waveband
                      RadioTVPresetList_Waveband_string[RadioTVPresetListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 3: //Attributes1
                      RadioTVPresetList_Attributes1_string[RadioTVPresetListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 4: //Attributes2
                      RadioTVPresetList_Attributes2_string[RadioTVPresetListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 5: //Name
                      gRadioTVPresetList_Name[RadioTVPresetListLine][j] =buffer_byte[i];
                      j++; 
              break;
              case 6: //Frequency
                      gRadioTVPresetList_Frequency[RadioTVPresetListLine][j] =buffer_byte[i];
                      j++; 
              break;
              case 7: //PictureReference
                      RadioTVPresetList_PicRef_string[RadioTVPresetListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              default:
              break;
            }
          }                               
        }
        else  // ";" is detected ->next record element of "array data"
        {                                          
          element++;
          j=0; //reset value  
        }                                              
      }         
      gRadioTVPresetList_TotalNumListElements =gRadioTVPresetList_sum =RadioTVPresetListLine; //get "total number of list elements"
      putvalue(env_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements);
      writelineEx(gRadioTVPresetList_writeWindow, 0, "");
      writelineEx(gRadioTVPresetList_writeWindow, 0,"Anzahl der Listenelemente: %d", gRadioTVPresetList_sum); //output total number of list elements
      writelineEx(gRadioTVPresetList_writeWindow, 0, "");
      if(fileClose(CSVfileHandle) !=0) //close *.csv file
        writelineEx(gRadioTVPresetList_writeWindow, 0,"Datei '%s' geschlossen", gRadioTVPresetList_CSV_filename); //output result
      else
        writelineEx(gRadioTVPresetList_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gRadioTVPresetList_CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
      writelineEx(gRadioTVPresetList_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'", gRadioTVPresetList_CSV_filename); //output result
      putvalue(env_AudioSD_RTPL_DataSource_res,"not successful"); //output result
    }
  }
}

byte RadioTVPresetList_nextvalidLine(byte current_RadioTVPresetListLine, byte direction)
{
  byte next_RadioTVPresetListLine;
  int i;

  //init lokal variables
  next_RadioTVPresetListLine = 0;
  i = 0;
  //search next "list entry"
  if (((gRadioTVPresetList_sum - 1) == current_RadioTVPresetListLine && FORWARD == direction) || (0 == current_RadioTVPresetListLine && BACKWARD == direction))   //last-/fist-element of array reached
    next_RadioTVPresetListLine = 0xFF;
  else
  {
    next_RadioTVPresetListLine = current_RadioTVPresetListLine + 1 - 2 * direction;       //increment or decrement array-line (depends on direction);
    if (0 == gRadioTVPresetList_ListEntryValidInformation[next_RadioTVPresetListLine])  // check if next element is "valid"
      next_RadioTVPresetListLine = 0xff;
  }
  return (next_RadioTVPresetListLine);
}

void RadioTVPresetList_Indication(dword Indication_array [], int datalength)
{
  byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
  word valid_startelement, requested_startelement, startelement, elements;
  int i = 0, transSuppression;

  // Init local variables. 
  mode = 0;
  shift = 0;
  direction = 0;
  transmitpos = 0;
  indexsize = 0;
  recordaddress = 0;
  requested_startelement = 0;
  startelement = 0;
  elements = 0;
  valid_startelement = 0xff;
  i = 0;
  valid_elements = 0;
  transSuppression = getvalue(env_AudioSD_PL_noStatusArray);
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      if (getvalue(env_AudioSD_RTPL_Error_on))
        RadioTVPresetList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue(env_AudioSD_RTPL_ErrorCode));
      else
      {
        //getData
        gRadioTVPresetList_ASGID = (gBAP_Indication[3] & 0xF0) / 0x10;
        gRadioTVPresetList_TAID = gBAP_Indication[3] & 0x0F;
        //decode BAP-ArrayHeader
        mode = (gBAP_Indication[4] & 0xF0) / 0x10;
        // decode "mode-byte"
        shift = mode & 0x01;
        direction = (mode & 0x02) / 0x02;
        transmitpos = (mode & 0x04) / 0x04;
        indexsize = (mode & 0x08) / 0x08;
        recordaddress = gBAP_Indication[4] & 0x0F;
        if (indexsize)
        {
            startelement = gBAP_Indication[5];
            startelement += gBAP_Indication[6] * 0x100;
            elements = gBAP_Indication[7];
            elements += gBAP_Indication[8] * 0x100;
        }
        else
        {
            startelement = gBAP_Indication[5];
            elements = gBAP_Indication[6];
        }
        requested_startelement = startelement;
        transmitpos = TRUE; //Position must always be sent in the case of *.GetArray.  
        mode = shift + (direction * 0x02) + (transmitpos * 0x04) + indexsize * 0x08;
        /***Startelement=0***/
        if (0 == startelement) //Startelement-ID =0 -> start at first array-entry
        {
          if (FORWARD == direction)  //forward-start
          {
            valid_startelement = 0;

            if (AUDIO_RADIOTVPRESETLIST_ENTRIES <= elements) //1. more elements requested, than in array
            {
              if (shift == FALSE)
              {
                for (i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES; i++)
                {
                  if (0 != gRadioTVPresetList_ListEntryValidInformation[i])   //if there is an valid element
                      valid_elements++;                               //increment elements
                  else                                                //no valid element, loop finished
                      i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                }
              }
              else if (shift == TRUE)
              {
                  valid_startelement = startelement;
                  valid_elements = 0;
              }
            }
            else    //2. number of requested elements < elements in array
            {
              if (shift == FALSE)
              {
                for (i = 0; i < elements; i++)
                {
                    if (0 != gRadioTVPresetList_ListEntryValidInformation[i])       //if there is an valid element
                        valid_elements++;                               //increment elements
                    else                                                //no valid element, loop finished
                        i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                }
              }
              else if (shift == TRUE)
              {
                  valid_startelement = startelement;
                  valid_elements = 0;
              }
            }
          }                                                               //forward ends
          else if (BACKWARD == direction && TRUE == shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
          {
            //searching for valid startelement
            for (i = (AUDIO_RADIOTVPRESETLIST_ENTRIES - 1); i >= 0; i--)
            {
              if (0 != gRadioTVPresetList_ListEntryValidInformation[i])       //found valid startelement
              {
                  valid_startelement = i;
                  i = 0;
              }
            }
            //searching for valid elements
            if (0xff == valid_startelement)                             //Startelement-ID doesn't exist in SMSReceived-array
            {
                valid_startelement = startelement;
                valid_elements = 0;
            }
            else if (0 == valid_startelement)
                valid_elements = 1;                                       //only 1 element because valid startelement is on position 0	
            else if (elements > (valid_startelement + 1))                   //not enougth array-elements available, because array endet at array-position 0
            {
                for (i = valid_startelement; i >= 0; i--)
                {
                    if (0 != gRadioTVPresetList_ListEntryValidInformation[i])   //if there is an valid element
                        valid_elements++;                               //increment elements
                    else                                                //no valid element, loop finished
                        i = 0;
                }
            }
            else                                                        //enougth array-elements available
            {
              for (i = valid_startelement; i > (valid_startelement - elements); i--)
              {
                  if (0 != gRadioTVPresetList_ListEntryValidInformation[i])   //if there is an valid element
                      valid_elements++;                               //increment elements
                  else                                                //no valid element, loop finished
                      i = 0;
              }
            }
          }                                                               //backward-end
        }                                                                   //startelement ==0 -end
        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID				
        {
          //searching for valid startelement
          for (i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES; i++)
          {
            if (gRadioTVPresetList_Pos[i] == startelement)                      //found a valid element
            {
              if (shift == TRUE)                                          //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
              {
                if (i != 0 || BACKWARD != direction)                        //if valid_startelement is not the first array element or direction is not backwards
                    valid_startelement = i + 1 - 2 * direction;
                else if (i == 0 && BACKWARD == direction)
                    valid_startelement = gRadioTVPresetList_sum;        //valid element is last element in Array                                                
                else if (i == 0 && FORWARD == direction)
                    valid_startelement = 0;                          //valid element is first element in Array
              }
              else
                  valid_startelement = i;                              //found element is valid_startelement
              i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
            }
          }
          if (0xff == valid_startelement)                                     //Startelement-ID doesn't exist in array
          {
              valid_startelement = startelement;
              valid_elements = 0;
          }
          else                                                                //found valid entry for startelement in array
          {
            //verify number of valid elements
            if (BACKWARD == direction)                                          //backward-start
            {
              if (valid_startelement == 0)                                    //only 1 element because valid startelement is on position 0
                  valid_elements = 1;
              else if (elements > (valid_startelement + 1))                   //not enougth array-elements available, because array endet at array-position 0
              {
                for (i = valid_startelement; i >= 0; i--)
                {
                    if (0 != gRadioTVPresetList_ListEntryValidInformation[i])   //if there is an valid element
                        valid_elements++;                               //increment elements
                    else                                                //no valid element, loop finished
                        i = 0;
                }
              }
              else                                                        //enougth array-elements available
              {
                for (i = valid_startelement; i > (valid_startelement - elements); i--)
                {
                    if (0 != gRadioTVPresetList_ListEntryValidInformation[i])   //if there is an valid element
                        valid_elements++;                               //increment elements
                    else                                                //no valid element, loop finished
                        i = 0;
                }
              }
            }                                                               //backward-end
            else                                                            //forward-start
            {
              if ((valid_startelement + elements) >= AUDIO_RADIOTVPRESETLIST_ENTRIES)
              {
                for (i = valid_startelement; i < AUDIO_RADIOTVPRESETLIST_ENTRIES; i++)
                {
                    if (0 != gRadioTVPresetList_Pos[i])                     //if there is an valid element
                        valid_elements++;                               //increment elements
                    else                                                //no valid element, loop finished
                        i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                }
              }
              else
              {
                for (i = valid_startelement; i < (valid_startelement + elements); i++)
                {
                    if (0 != gRadioTVPresetList_Pos[i])                         //if there is an valid element
                        valid_elements++;                               //increment elements
                    else                                                //no valid element, loop finished
                        i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                }
              }
            }
          }
        }
        //send StatusArray
        if (!transSuppression)
          RadioTVPresetList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
      }
      //Panel
      putvalue(env_AudioSD_RTPL_ASGID, gRadioTVPresetList_ASGID);
      putvalue(env_AudioSD_RTPL_TAID, gRadioTVPresetList_TAID);
    break;
    case Error_IND:
      writelineEx(gError_Trace, 0, "FSG_AudioSD RadioTVPresetList_Indication: received error, errorcode:0x%x", Indication_array[3]);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD RadioTVPresetList_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void RadioTVPresetList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements, byte errorcode)
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word RadioTVPresetListLine;

    // Init local variables. 
    for (i = 0; i < BAP_BUFFER_SIZE; i++)
        requestarray[i] = 0;
    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    RadioTVPresetListLine = 0;
    current_element = 0;
    Offset = 0;
    // decode "mode-byte"
    shift = mode & 0x01;
    direction = (mode & 0x02) / 0x02;
    transmitpos = (mode & 0x04) / 0x04;
    indexsize = (mode & 0x08) / 0x08;
    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_RadioTV_PresetList; //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;
    switch (request)
    {
        case Changed_REQ:
            /***ArrayHeader***/
            requestarray[Offset] = ((mode * 0x10) & 0xF0) + (recordaddress & 0x0F);
            Offset++;
            if (indexsize)
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = (requested_startelement & 0xff00) / 0x100;
                Offset++;
                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = (elements & 0xff00) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }
            RadioTVPresetListLine = startelement;
            if (getvalue(env_AudioSD_RTPL_CA_switch)) //ArrayData
            {
                //copy data
                switch (recordaddress)
                {
                    case 0: //complete record (FRU)
                        while (current_element < elements)
                        {
                            if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                        Offset++;
                                    }
                                }
                                //PresetIndex
                                requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                                Offset++;
                                //Waveband
                                requestarray[Offset] = gRadioTVPresetList_Waveband[RadioTVPresetListLine];
                                Offset++;
                                //Attributes1&2
                                requestarray[Offset] = gRadioTVPresetList_Attributes1[RadioTVPresetListLine];
                                Offset++;
                                requestarray[Offset] = gRadioTVPresetList_Attributes2[RadioTVPresetListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]); i++)
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                    Offset++;
                                }
                                //Frequency
                                requestarray[Offset] = strlen(gRadioTVPresetList_Frequency[RadioTVPresetListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gRadioTVPresetList_Frequency[RadioTVPresetListLine]); i++)
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Frequency[RadioTVPresetListLine][i];
                                    Offset++;
                                }
                                //PictureReference
                                requestarray[Offset] = (gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);
                        }//end while
                    break;
                    case 1: //complete record
                        while (current_element < elements)
                        {
                            if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                        Offset++;
                                    }
                                }
                                //PresetIndex
                                requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                                Offset++;
                                //Waveband
                                requestarray[Offset] = gRadioTVPresetList_Waveband[RadioTVPresetListLine];
                                Offset++;
                                //Attributes1&2
                                requestarray[Offset] = gRadioTVPresetList_Attributes1[RadioTVPresetListLine];
                                Offset++;
                                requestarray[Offset] = gRadioTVPresetList_Attributes2[RadioTVPresetListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]); i++)
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                    Offset++;
                                }
                                //Frequency
                                requestarray[Offset] = strlen(gRadioTVPresetList_Frequency[RadioTVPresetListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gRadioTVPresetList_Frequency[RadioTVPresetListLine]); i++)
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Frequency[RadioTVPresetListLine][i];
                                    Offset++;
                                }
                                //PictureReference
                                requestarray[Offset] = (gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);
                        }//end while
                    break;
                    case 2: //PresetID, WB, Name
                        while (current_element < elements)
                        {
                            if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                        Offset++;
                                    }
                                }
                                //PresetIndex
                                requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                                Offset++;
                                //Waveband
                                requestarray[Offset] = gRadioTVPresetList_Waveband[RadioTVPresetListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]); i++)
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);
                        }//end while
                    break;  
                    case 3: //PresetID, Name
                        while (current_element < elements)
                        {
                            if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                        Offset++;
                                    }
                                }
                                //PresetIndex
                                requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]); i++)
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);
                        }//end while
                    break; 
                    case 4: //PictureReference
                        while (current_element < elements)
                        {
                            if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                        Offset++;
                                    }
                                }
                                //PictureReference
                                requestarray[Offset] = (gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);
                        }//end while
                    break;    
                    case 15: //Pos
                        while (current_element < elements)
                        {
                            if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);

                        }//end while
                    break;
                    default:
                        write("AudioSD RadioTVPresetList_Request: invalid recordaddress %d", recordaddress);
                    break;
                } //end switch "recordaddress"
            }// end 'ArrayData'
            set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
        break; //end Changed_REQ
        case Data_REQ:
            requestarray[Offset] = ((gRadioTVPresetList_ASGID * 0x10) & 0xF0) + (gRadioTVPresetList_TAID & 0x0F);
            Offset++;
            requestarray[Offset] = gRadioTVPresetList_TotalNumListElements;
            Offset++;
            /***ArrayHeader***/
            requestarray[Offset] = ((mode * 0x10) & 0xF0) + (recordaddress & 0x0F);
            Offset++;
            if (indexsize)
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = (requested_startelement & 0xff00) / 0x100;
                Offset++;
                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = (elements & 0xff00) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }
            RadioTVPresetListLine = startelement;
            //copy data
            switch (recordaddress)
            {
                case 0: //complete record (FRU)
                    while (current_element < elements)
                    {
                        if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                    Offset++;
                                }
                            }
                            //PresetIndex
                            requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                            Offset++;
                            //Waveband
                            requestarray[Offset] = gRadioTVPresetList_Waveband[RadioTVPresetListLine];
                            Offset++;
                            //Attributes1&2
                            requestarray[Offset] = gRadioTVPresetList_Attributes1[RadioTVPresetListLine];
                            Offset++;
                            requestarray[Offset] = gRadioTVPresetList_Attributes2[RadioTVPresetListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]); i++)
                            {
                                requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                Offset++;
                            }
                            //Frequency
                            requestarray[Offset] = strlen(gRadioTVPresetList_Frequency[RadioTVPresetListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gRadioTVPresetList_Frequency[RadioTVPresetListLine]); i++)
                            {
                                requestarray[Offset] = gRadioTVPresetList_Frequency[RadioTVPresetListLine][i];
                                Offset++;
                            }
                            //PictureReference
                                requestarray[Offset] = (gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                Offset++;
                        }
                        current_element++;
                        RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
              case 1: //complete record
                    while (current_element < elements)
                    {
                        if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                    Offset++;
                                }
                            }
                            //PresetIndex
                            requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                            Offset++;
                            //Waveband
                            requestarray[Offset] = gRadioTVPresetList_Waveband[RadioTVPresetListLine];
                            Offset++;
                            //Attributes1&2
                            requestarray[Offset] = gRadioTVPresetList_Attributes1[RadioTVPresetListLine];
                            Offset++;
                            requestarray[Offset] = gRadioTVPresetList_Attributes2[RadioTVPresetListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]); i++)
                            {
                                requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                Offset++;
                            }
                            //Frequency
                            requestarray[Offset] = strlen(gRadioTVPresetList_Frequency[RadioTVPresetListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gRadioTVPresetList_Frequency[RadioTVPresetListLine]); i++)
                            {
                                requestarray[Offset] = gRadioTVPresetList_Frequency[RadioTVPresetListLine][i];
                                Offset++;
                            }
                            //PictureReference
                                requestarray[Offset] = (gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                Offset++;
                        }
                        current_element++;
                        RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;                
                case 2: //PresetID, WB, Name
                    while (current_element < elements)
                    {
                        if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                    Offset++;
                                }
                            }
                            //PresetIndex
                            requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                            Offset++;
                            //Waveband
                            requestarray[Offset] = gRadioTVPresetList_Waveband[RadioTVPresetListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]); i++)
                            {
                                requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                case 3: //PresetID, Name
                    while (current_element < elements)
                    {
                        if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                    Offset++;
                                }
                            }
                            //PresetIndex
                            requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gRadioTVPresetList_Name[RadioTVPresetListLine]); i++)
                            {
                                requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                case 4: //PictureReference
                    while (current_element < elements)
                    {
                        if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                    Offset++;
                                }
                            }
                            //PictureReference
                                requestarray[Offset] = (gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gRadioTVPresetList_PicRef[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                Offset++;
                        }
                        current_element++;
                        RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                case 15: //Pos
                    while (current_element < elements)
                    {
                        if (RadioTVPresetListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                    Offset++;
                                }
                            }
                        }
                        current_element++;
                        RadioTVPresetListLine = RadioTVPresetList_nextvalidLine(RadioTVPresetListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                default:
                    write("AudioSD RadioTVPresetList_Request: invalid recordaddress %d", recordaddress);
                break;
            } //end switch "recordaddress"
        break; //end Data_REQ
        case Error_REQ:
            requestarray[3] = errorcode;
            set_status_requestbuffer(requestarray, 4, Bap_Error);
        break; //end Error_REQ
    } //end switch "request"   
}

//*************************************************************************
//*****************ListSetup***********************************************
on envVar env_AudioSD_ListSetup_Update
{
	if(gAudioSD_PowerOnOff ==POWER_ON && getvalue(this))
	{
		gAudioSD_ListSetup_PreferredList =getvalue(env_AudioSD_ListSetup_PrefList);
    gAudioSD_ListSetup_ReceptionListType =getvalue(env_AudioSD_ListSetup_RListType);
    gAudioSD_ListSetup_Extension1 =getvalue(env_AudioSD_ListSetup_Ext1);
    gAudioSD_ListSetup_Extension2 =getvalue(env_AudioSD_ListSetup_Ext2);
    gAudioSD_ListSetup_Extension3 =getvalue(env_AudioSD_ListSetup_Ext3);
    gAudioSD_ListSetup_Extension4 =getvalue(env_AudioSD_ListSetup_Ext4);
    ListSetup_Request(Data_REQ, 0);
	}
}

void ListSetup_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataSetGet_IND:
      //get data
      gAudioSD_ListSetup_PreferredList = Indication_array[3];
      gAudioSD_ListSetup_Extension1 = Indication_array[5];
      gAudioSD_ListSetup_Extension2 = Indication_array[6];
      gAudioSD_ListSetup_Extension3 = Indication_array[7];
      gAudioSD_ListSetup_Extension4 = Indication_array[8];
      //Panel
      putvalue(env_AudioSD_ListSetup_PrefList, gAudioSD_ListSetup_PreferredList);
      putvalue(env_AudioSD_ListSetup_Ext1, gAudioSD_ListSetup_Extension1);
      putvalue(env_AudioSD_ListSetup_Ext2, gAudioSD_ListSetup_Extension2);
      putvalue(env_AudioSD_ListSetup_Ext3, gAudioSD_ListSetup_Extension3);
      putvalue(env_AudioSD_ListSetup_Ext4, gAudioSD_ListSetup_Extension4);
      ListSetup_Request(Data_REQ, 0);
    break;
    case DataGet_IND:
      ListSetup_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD ListSetup_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void ListSetup_Request(byte request, byte errorcode)
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables. 
    for (i = 0; i < BAP_BUFFER_SIZE; i++)
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;      //LSG-ID
    requestarray[1] = FctID_ListSetup;   //Fct.-ID
    requestarray[2] = request;           //request type
    switch (request)
    {
      case Data_REQ:
        requestarray[3] = gAudioSD_ListSetup_PreferredList;
        requestarray[4] = gAudioSD_ListSetup_ReceptionListType;
        requestarray[5] = gAudioSD_ListSetup_Extension1;
        requestarray[6] = gAudioSD_ListSetup_Extension2;
        requestarray[7] = gAudioSD_ListSetup_Extension3;
        requestarray[8] = gAudioSD_ListSetup_Extension4;
        set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
      break;
      case Error_REQ:
        requestarray[3] = errorcode;
        set_status_requestbuffer(requestarray, 4, Bap_Error);
      break;
      default:
        writelineEx(gError_Trace, 0, "FSG_AudioSD ListSetup_Request: invalid request %d", request);
      break;
    }
}

//*************************************************************************
//*****************SourceList**********************************************
on envVar env_AudioSD_SL_DataSource
{
  if (getvalue(this) ==AUDIO_DEFAULT_LIST)
  {
    SourceList_init_static();
    putvalue(env_AudioSD_SL_DataSource_file, empty_string);
    putvalue(env_AudioSD_SL_DataSource_result, empty_string);
  }
}

on envVar env_AudioSD_SL_reload //load external SourceList from *.csv
{
  if(getvalue(this) && getvalue(env_AudioSD_SL_DataSource) ==AUDIO_EXTERNAL_LIST)
    SourceList_init_CSV();
  else if(getvalue(env_AudioSD_SL_DataSource) != AUDIO_EXTERNAL_LIST)
    putvalue(env_AudioSD_SL_DataSource_result,"not successful, select 'external *.csv'");
}

on envVar env_AudioSD_SL_CA
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;

  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    if(getvalue(env_AudioSD_SL_AH_start) >255 && getvalue(env_AudioSD_SL_AH_IS) ==0)// check if 8 or 16 bit
      putvalue(env_AudioSD_SL_AH_IS,1);
    recordaddress   =getvalue(env_AudioSD_SL_AH_RA);
    shift           =getvalue(env_AudioSD_SL_AH_shift);
    direction       =getvalue(env_AudioSD_SL_AH_dir);
    transmitpos     =getvalue(env_AudioSD_SL_AH_POS);
    indexsize       =getvalue(env_AudioSD_SL_AH_IS);
    startelement    =getvalue(env_AudioSD_SL_AH_start);
    elements        =getvalue(env_AudioSD_SL_AH_elements);
    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;  
    requested_startelement =startelement;
    /***Startelement=0***/
    if (getvalue(env_AudioSD_SL_CA_switch)) //ArrayData
    {
      if(0==startelement) //Startelement-ID =0 -> start at first array-entry
	    {
        if(FORWARD==direction)  //forward-start
		    {
          valid_startelement =0;				       									
          if(AUDIO_SOURCELIST_ENTRIES <=elements) //1. more elements requested, than in array
			    {
            if (shift ==FALSE)  
            {
              for(i=0;i<AUDIO_SOURCELIST_ENTRIES;i++)
					    {
				        if(0 !=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
				        else												//no valid element, loop finished
					        i =AUDIO_SOURCELIST_ENTRIES;
					    }
            }
            else if (shift ==TRUE)
            {   
              valid_startelement  =startelement;
			        valid_elements      =0;
            }
	        }
          else    //2. number of requested elements < elements in array
			    {
            if (shift ==FALSE)
            {
				      for(i=0;i<elements;i++)
					    {
				        if(0!=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
				        else												//no valid element, loop finished
				          i =AUDIO_SOURCELIST_ENTRIES;
					    }
            }
            else if (shift ==TRUE)
            {
              valid_startelement  =startelement;
			        valid_elements      =0;
            }
				  }
        }                                                               //forward ends
        else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
		    {   
		      //searching for valid startelement
			    for(i=(AUDIO_SOURCELIST_ENTRIES-1);i>=0;i--)
			    {
			      if(0!=gSourceList_ListEntryValidInformation[i])		//found valid startelement
				    {
				      valid_startelement =i;								
					    i =0;												
				    }
			    }
          //searching for valid elements
			    if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
			    {
			      valid_startelement  =startelement;
				    valid_elements      =0;
			    }
			    else if(0==valid_startelement)								
			      valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
			    else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
			    {
			      for(i=valid_startelement;i>=0;i--)
				    {
			        if(0!=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
				        valid_elements++;								//increment elements
					    else												//no valid element, loop finished
					      i=0;
			      }
				  }
          else														//enougth array-elements available
			    {
			      for(i=valid_startelement;i>(valid_startelement-elements);i--)
				    {
			        if(0!=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
				        valid_elements++;								//increment elements
					    else												//no valid element, loop finished
						    i=0;
				    }                   
			    }															
        }                                                               //backward-end
      }                                                                   //startelement ==0 -end
      /***Startelement!=0***/
      else																//searching for Startelement-ID				
	    {
	      //searching for valid startelement
		    for(i=0;i<AUDIO_SOURCELIST_ENTRIES;i++)
		    {
			    if(gSourceList_Pos[i] ==startelement)					    //found a valid element
			    {                                       
            if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
				    {
			        if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
				        valid_startelement =i+1-2* direction;
              else if(i==0 && BACKWARD==direction) 
                valid_startelement =gSourceList_sum;     //valid element is last element in Array                                                
              else if(i==0 && FORWARD==direction) 
                valid_startelement =0;                          //valid element is first element in Array
            }
            else
              valid_startelement =i;                              //found element is valid_startelement
					  i =AUDIO_SOURCELIST_ENTRIES;
				  }
          else
            valid_startelement =0xff;
			  }
		    if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
		    {   
			    valid_startelement  =startelement;
			    valid_elements      =0;
		    }
		    else																//found valid entry for startelement in array
		    {
		      //verify number of valid elements
			    if(BACKWARD==direction)											//backward-start
			    {
		        if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
			        valid_elements=1;
					  else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				    {
				      for(i=valid_startelement;i>=0;i--)
					    {
				        if(0!=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
                else												//no valid element, loop finished
					        i=0;
						  }
				    }
  			    else														//enougth array-elements available
  			    {
				      for(i=valid_startelement;i>(valid_startelement-elements);i--)
					    {   
				        if(0!=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i=0;
						  }
					  }
				  }																//backward-end
			    else															//forward-start
			    {
			      if((valid_startelement+elements)>=AUDIO_SOURCELIST_ENTRIES)
				    {
				      for(i=valid_startelement;i<AUDIO_SOURCELIST_ENTRIES;i++)
					    {
				        if(0!=gSourceList_Pos[i])							//if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						      i=AUDIO_SOURCELIST_ENTRIES;
					    }
				    }
				    else
				    {
				      for(i=valid_startelement;i<(valid_startelement+elements);i++)
					    {
				        if(0!=gSourceList_Pos[i])						    //if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						      i=AUDIO_SOURCELIST_ENTRIES;
					    }
				    }
			    }
		    }
	    }
      putvalue(env_AudioSD_SL_AH_elements, valid_elements);
      //send ChangedArray
      SourceList_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
    else
    {
      //send ChangedArray
      SourceList_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
    }
  }
}

on envVar env_AudioSD_SL_StatusArray
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i, transSuppression;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0xff;
  i                       =0;
  valid_elements          =0;
  transSuppression        = getvalue(env_AudioSD_SL_noStatusArray);
  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    if(getvalue(env_AudioSD_SL_AH_start) >255 && getvalue(env_AudioSD_SL_AH_IS) ==0)// check if 8 or 16 bit
      putvalue(env_AudioSD_SL_AH_IS,1);
    //get data from Panel
    gSourceList_ASGID                =getvalue(env_AudioSD_SL_ASGID);
    gSourceList_TAID                 =getvalue(env_AudioSD_SL_TAID);
    gSourceList_TotalNumListElements  =getvalue(env_AudioSD_SL_TotalNumLE);
    recordaddress   =getvalue(env_AudioSD_SL_AH_RA);
    shift           =getvalue(env_AudioSD_SL_AH_shift);
    direction       =getvalue(env_AudioSD_SL_AH_dir);
    transmitpos     =getvalue(env_AudioSD_SL_AH_POS);
    indexsize       =getvalue(env_AudioSD_SL_AH_IS);
    startelement    =getvalue(env_AudioSD_SL_AH_start);
    elements        =getvalue(env_AudioSD_SL_AH_elements);
    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    requested_startelement =startelement;
    /***Startelement=0***/
    if(0==startelement) //Startelement-ID =0 -> start at first array-entry
		{
      if(FORWARD==direction)  //forward-start
			{
        valid_startelement =0;				       									
        if(AUDIO_SOURCELIST_ENTRIES <=elements) //1. more elements requested, than in array
				{
          if (shift ==FALSE)  
          {
            for(i=0;i<AUDIO_SOURCELIST_ENTRIES;i++)
						{
					    if(0 !=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
					    else												//no valid element, loop finished
						    i =AUDIO_SOURCELIST_ENTRIES;
				    }
          }
          else if (shift ==TRUE)
          {   
            valid_startelement  =startelement;
		        valid_elements      =0;
          }
			  }
        else    //2. number of requested elements < elements in array
				{
          if (shift ==FALSE)
          {
					  for(i=0;i<elements;i++)
						{
					    if(0!=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
					    else												//no valid element, loop finished
					      i =AUDIO_SOURCELIST_ENTRIES;
					  }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =startelement;
		        valid_elements      =0;   
          }
				}
      }                                                               //forward ends
      else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
			{   
			  //searching for valid startelement
				for(i=(AUDIO_SOURCELIST_ENTRIES-1);i>=0;i--)
				{
				  if(0!=gSourceList_ListEntryValidInformation[i])		//found valid startelement
					{
					  valid_startelement =i;								
						i =0;												
					}
				}
        //searching for valid elements
				if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
				{
				  valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(0==valid_startelement)								
				  valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				  for(i=valid_startelement;i>=0;i--)
					{
				    if(0!=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
					    valid_elements++;								//increment elements
						else												//no valid element, loop finished
						  i=0;
				  }
				}
        else														//enougth array-elements available
				{
				  for(i=valid_startelement;i>(valid_startelement-elements);i--)
					{
				    if(0!=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
					    valid_elements++;								//increment elements
						else												//no valid element, loop finished
							i=0;
					}                   
				}															
      }                                                               //backward-end
    }                                                                   //startelement ==0 -end
    /***Startelement!=0***/
    else																//searching for Startelement-ID				
		{
		  //searching for valid startelement
			for(i=0;i<AUDIO_SOURCELIST_ENTRIES;i++)
			{
				if(gSourceList_Pos[i] ==startelement)					    //found a valid element
				{                                       
          if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
					{
				    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
					    valid_startelement =i+1-2* direction;
            else if(i==0 && BACKWARD==direction) 
              valid_startelement =gSourceList_sum;     //valid element is last element in Array                                                
            else if(i==0 && FORWARD==direction) 
              valid_startelement =0;                          //valid element is first element in Array
          }
          else
            valid_startelement =i;                              //found element is valid_startelement
					i =AUDIO_SOURCELIST_ENTRIES;
				}
        else
          valid_startelement =0xff;
			}
			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			  //verify number of valid elements
				if(BACKWARD==direction)											//backward-start
				{
			    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
				    valid_elements=1;
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				  {
					  for(i=valid_startelement;i>=0;i--)
						{
					    if(0!=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
              else												//no valid element, loop finished
						    i=0;
						}
				  }
					else														//enougth array-elements available
					{
					  for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
					    if(0!=gSourceList_ListEntryValidInformation[i])	//if there is an valid element
						    valid_elements++;								//increment elements
							else												//no valid element, loop finished
								i=0;
						}
					}
				}																//backward-end
				else															//forward-start
				{
				  if((valid_startelement+elements)>=AUDIO_SOURCELIST_ENTRIES)
					{
					  for(i=valid_startelement;i<AUDIO_SOURCELIST_ENTRIES;i++)
						{
					    if(0!=gSourceList_Pos[i])							//if there is an valid element
						    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							  i=AUDIO_SOURCELIST_ENTRIES;
						}
					}
					else
					{
					  for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
					    if(0!=gSourceList_Pos[i])						    //if there is an valid element
						    valid_elements++;								//increment elements
							else												//no valid element, loop finished
							  i=AUDIO_SOURCELIST_ENTRIES;
						}
					}
				}
			}
		}
    putvalue(env_AudioSD_SL_AH_elements, valid_elements);
    //send StatusArray
    if(!transSuppression)
      SourceList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
  }
}

void SourceList_init_CSV() //Byte & file selection
{
  dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, current_CSV_line = 0, count1 = 0, count2 = 0;
  char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
  byte SourceListLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
  char SourceList_Pos_string[AUDIO_SOURCELIST_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
  char SourceList_SourceType_string[AUDIO_SOURCELIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"SourceType" is stored in the ASCII(UTF-8) code in the *.csv 
  char SourceList_InstanceID_string[AUDIO_SOURCELIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"InstanceID" is stored in the ASCII(UTF-8) code in the *.csv 
  char SourceList_PicRef_string[AUDIO_SOURCELIST_ENTRIES][AUDIO_TEXTLENGTH];  //help value ->"PicRef" is stored in the ASCII(UTF-8) code in the *.csv 
  char SourceList_Attributes_string[AUDIO_SOURCELIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Attributes" is stored in the ASCII(UTF-8) code in the *.csv 
  if(getvalue(env_AudioSD_SL_DataSource) == AUDIO_EXTERNAL_LIST) //output data in write window "FSGSourceList"  
  {
    writeClear(gSourceList_writeWindow);
    writelineEx(gSourceList_writeWindow, 0,"*******External SourceList*******");
    writelineEx(gSourceList_writeWindow, 0, "");
    writelineEx(gSourceList_writeWindow, 0, "**********************Start load new SourceList**********************");   
    //clear  
    for(j=0;j<AUDIO_SOURCELIST_ENTRIES;j++) 
    {
	    gSourceList_Pos[j]                          =0;
	    gSourceList_SourceType[j]                   =0;
      gSourceList_InstanceID[j]                   =0;
      gSourceList_PicRef[j]                       =0;
      gSourceList_Attributes_Bit0[j]    =0;
      gSourceList_Attributes_Bit1[j]    =0;
      gSourceList_Attributes_Bit2[j]    =0;
      gSourceList_Attributes_Bit3[j]    =0;
      gSourceList_Attributes_Bit4[j]    =0;
      gSourceList_Attributes_Bit5[j]    =0;
      gSourceList_Attributes_Bit6[j]    =0;
      gSourceList_Attributes[j]                   =0;
      gSourceList_ListEntryValidInformation[j] =0;
	    for(i=0;i<AUDIO_SOURCELIST_NAME_LENGTH;i++)
		    gSourceList_Name[j][i] =0;
	  }
    for(i=0;i<AUDIO_FILENAME_SIZE; i++) //clear "filename"
      gSourceList_CSV_filename[i] =0;       
    for(j=0;j<AUDIO_SOURCELIST_ENTRIES; j++) //clear "buffer"
    {
      buffer_string[j]    =0;
      buffer_byte[j]      =0;
      for(i=0;i<AUDIO_TEXTLENGTH;i++) //clear help value
      {
        SourceList_Pos_string[j][i]          =0;
        SourceList_SourceType_string[j][i]   =0;
        SourceList_InstanceID_string[j][i]   =0;
        SourceList_PicRef_string[j][i]       =0;
        SourceList_Attributes_string[j][i]   =0;
      }
    }        
    i =0; j =0; SourceListLine =0; current_CSV_line =0; //reset values 
    getvalue(env_AudioSD_SL_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
    //write("complete path *.csv: %s", Path_CSV); //debug
    i =0;
    while (Path_CSV[i] !=0) //scan "path"
    {
      if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
        count1++;                
      //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
      i++;
    }  
    i =0; j =0; //reset values
    while (Path_CSV[i] !=0) //seperate "path" and "filename"
    {
      if(count2==count1) //get filename after last "\"
      {              
        gSourceList_CSV_filename[j] =Path_CSV[i];
        j++;
        Path_CSV[i] =0;              
      }
      if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
        count2++;
      i++;
    }
    writelineEx(gSourceList_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 
    writelineEx(gSourceList_writeWindow, 0,"filename of *.csv: '%s'", gSourceList_CSV_filename);  //output filename 
    putvalue(env_AudioSD_SL_DataSource_file, gSourceList_CSV_filename); //output current loaded *.csv-file on panel
    setFilePath(Path_CSV, 0); //set path for *.csv file
    CSVfileHandle =openFileRead(gSourceList_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        
    if (CSVfileHandle!=0) //*.csv file access successful
    {
      writelineEx(gSourceList_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gSourceList_CSV_filename);    //output result  
      putvalue(env_AudioSD_SL_DataSource_result, "successful");   //output result on panel                      
      Num_of_csv_byte =fileGetBinaryBlock(buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
      for (i=0; i<Num_of_csv_byte; i++) //copy data into "SourceList"
      {      
        if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
        {
          if(buffer_byte[i] ==0x0D && buffer_byte[i + 1] ==0x0A) //nextline in *.csv (next "record element" in SourceList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
          {
            if(current_CSV_line>0 && SourceListLine<AUDIO_SOURCELIST_ENTRIES) //ignore first line in *.csv file
            {   
              writelineEx(gSourceList_writeWindow, 0, "");
              writelineEx(gSourceList_writeWindow, 0,"*******Element %d*******", SourceListLine);
              //transform 'string' to 'long' for "POS", "SourceType", "InstanceID", "PictureReference" and "Attributes"
              gSourceList_Pos[SourceListLine]           =atol(SourceList_Pos_string[SourceListLine]);
              gSourceList_SourceType[SourceListLine]    =atol(SourceList_SourceType_string[SourceListLine]);
              gSourceList_InstanceID[SourceListLine]    =atol(SourceList_InstanceID_string[SourceListLine]);
              gSourceList_PicRef[SourceListLine]        =atol(SourceList_PicRef_string[SourceListLine]);
              gSourceList_Attributes[SourceListLine]    =atol(SourceList_Attributes_string[SourceListLine]);
              writelineEx(gSourceList_writeWindow, 0,"Pos[%d]: 0x%x", SourceListLine, gSourceList_Pos[SourceListLine]);
              writelineEx(gSourceList_writeWindow, 0,"SourceType[%d]: 0x%x", SourceListLine, gSourceList_SourceType[SourceListLine]);
              writelineEx(gSourceList_writeWindow, 0,"InstanceID[%d]: 0x%x", SourceListLine, gSourceList_InstanceID[SourceListLine]);
              writelineEx(gSourceList_writeWindow, 0,"Attributes[%d]: 0x%x", SourceListLine, gSourceList_Attributes[SourceListLine]);
              writelineEx(gSourceList_writeWindow, 0,"Name[%d]: %s", SourceListLine, gSourceList_Name[SourceListLine]);
              writelineEx(gSourceList_writeWindow, 0,"PictureReference[%d]: 0x%x", SourceListLine, gSourceList_PicRef[SourceListLine]);
              gSourceList_ListEntryValidInformation[SourceListLine]  =TRUE;
              SourceListLine++; // -> next line in *.csv (next record element)
            }
            current_CSV_line++; //next line in *.csv file
            element =0; //start at 'POS' (first record element of "array data")
            j=0; //reset value
          }
          else if(current_CSV_line>0 && SourceListLine<AUDIO_SOURCELIST_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
          {
            switch (element)
            {
              case 0: //POS
                      SourceList_Pos_string[SourceListLine][j] =buffer_byte[i];
                      j++;
              break;
              case 1: //SourceType
                      SourceList_SourceType_string[SourceListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 2: //InstanceID
                      SourceList_InstanceID_string[SourceListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 3: //Attributes
                      SourceList_Attributes_string[SourceListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 4: //Name
                      gSourceList_Name[SourceListLine][j] =buffer_byte[i];
                      j++; 
              break;
              case 5: //PictureReference
                      SourceList_PicRef_string[SourceListLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              default:
              break;
            }
          }                               
        }
        else  // ";" is detected ->next record element of "array data"
        {                                          
          element++;
          j=0; //reset value  
        }                                              
      }         
      gSourceList_TotalNumListElements =gSourceList_sum =SourceListLine; //get "total number of list elements"
      putvalue(env_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements);
      writelineEx(gSourceList_writeWindow, 0, "");
      writelineEx(gSourceList_writeWindow, 0,"Anzahl der Listenelemente: %d", gSourceList_sum); //output total number of list elements
      writelineEx(gSourceList_writeWindow, 0, "");
      if(fileClose(CSVfileHandle) !=0) //close *.csv file
        writelineEx(gSourceList_writeWindow, 0,"Datei '%s' geschlossen", gSourceList_CSV_filename); //output result
      else
        writelineEx(gSourceList_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gSourceList_CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
      writelineEx(gSourceList_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'", gSourceList_CSV_filename); //output result
      putvalue(env_AudioSD_SL_DataSource_result,"not successful"); //output result
    }
  }
}

byte SourceList_nextvalidLine(byte current_SourceListLine, byte direction)
{
  byte next_SourceListLine;
  int i;

  //init lokal variables
  next_SourceListLine = 0;
  i = 0;
  //search next "list entry"
  if (((gSourceList_sum - 1) == current_SourceListLine && FORWARD == direction) || (0 == current_SourceListLine && BACKWARD == direction))    //last-/fist-element of array reached
    next_SourceListLine = 0xFF;
  else
  {
    next_SourceListLine = current_SourceListLine + 1 - 2 * direction;       //increment or decrement array-line (depends on direction);
    if (0 == gSourceList_ListEntryValidInformation[next_SourceListLine])    // check if next element is "valid"
      next_SourceListLine = 0xff;
  }
  return (next_SourceListLine);
}

void SourceList_Indication(dword Indication_array [], int datalength)
{
  byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
  word valid_startelement, requested_startelement, startelement, elements;
  int i = 0, transSuppression;

  // Init local variables. 
  mode = 0;
  shift = 0;
  direction = 0;
  transmitpos = 0;
  indexsize = 0;
  recordaddress = 0;
  requested_startelement = 0;
  startelement = 0;
  elements = 0;
  valid_startelement = 0xff;
  i = 0;
  valid_elements = 0;
  transSuppression = getvalue(env_AudioSD_SL_noStatusArray);
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      if (getvalue(env_AudioSD_SL_Error_on))
        SourceList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue(env_AudioSD_SL_ErrorCode));
      else
      {
        //getData
        gSourceList_ASGID = (gBAP_Indication[3] & 0xF0) / 0x10;
        gSourceList_TAID = gBAP_Indication[3] & 0x0F;
        //decode BAP-ArrayHeader
        mode = (gBAP_Indication[4] & 0xF0) / 0x10;
        // decode "mode-byte"
        shift = mode & 0x01;
        direction = (mode & 0x02) / 0x02;
        transmitpos = (mode & 0x04) / 0x04;
        indexsize = (mode & 0x08) / 0x08;
        recordaddress = gBAP_Indication[4] & 0x0F;
        if (indexsize)
        {
          startelement = gBAP_Indication[5];
          startelement += gBAP_Indication[6] * 0x100;
          elements = gBAP_Indication[7];
          elements += gBAP_Indication[8] * 0x100;
        }
        else
        {
          startelement = gBAP_Indication[5];
          elements = gBAP_Indication[6];
        }
        requested_startelement = startelement;
        transmitpos = TRUE; //Position must always be sent in the case of *.GetArray.  
        mode = shift + (direction * 0x02) + (transmitpos * 0x04) + indexsize * 0x08;
        /***Startelement=0***/
        if (0 == startelement) //Startelement-ID =0 -> start at first array-entry
        {
          if (FORWARD == direction)  //forward-start
          {
            valid_startelement = 0;
            if (AUDIO_SOURCELIST_ENTRIES <= elements) //1. more elements requested, than in array
            {
              if (shift == FALSE)
              {
                for (i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++)
                {
                  if (0 != gSourceList_ListEntryValidInformation[i])  //if there is an valid element
                  {
                    if (gSourceList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                //no valid element, loop finished
                    i = AUDIO_SOURCELIST_ENTRIES;
                }
              }
              else if (shift == TRUE)
              {
                valid_startelement = startelement;
                valid_elements = 0;
              }
            }
            else    //2. number of requested elements < elements in array
            {
              if (shift == FALSE)
              {
                for (i = 0; i < elements; i++)
                {
                  if (0 != gSourceList_ListEntryValidInformation[i])      //if there is an valid element
                  {
                    if (gSourceList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                //no valid element, loop finished
                    i = AUDIO_SOURCELIST_ENTRIES;
                }
              }
              else if (shift == TRUE)
              {
                valid_startelement = startelement;
                valid_elements = 0;
              }
            }
          }                                                               //forward ends
          else if (BACKWARD == direction && TRUE == shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
          {
            //searching for valid startelement
            for (i = (AUDIO_SOURCELIST_ENTRIES - 1); i >= 0; i--)
            {
              if (0 != gSourceList_ListEntryValidInformation[i])      //found valid startelement
              {
                valid_startelement = i;
                i = 0;
              }
            }
            //searching for valid elements
            if (0xff == valid_startelement)                             //Startelement-ID doesn't exist in SMSReceived-array
            {
              valid_startelement = startelement;
              valid_elements = 0;
            }
            else if (0 == valid_startelement)
              valid_elements = 1;                                       //only 1 element because valid startelement is on position 0	
            else if (elements > (valid_startelement + 1))                   //not enougth array-elements available, because array endet at array-position 0
            {
              for (i = valid_startelement; i >= 0; i--)
              {
                if (0 != gSourceList_ListEntryValidInformation[i])  //if there is an valid element
                {
                  if (gSourceList_Pos[i] > 0xFF) //check indexsize
                    indexsize = TRUE;
                  valid_elements++;                               //increment elements
                }
                else                                                //no valid element, loop finished
                  i = 0;
              }
            }
            else                                                        //enougth array-elements available
            {
              for (i = valid_startelement; i > (valid_startelement - elements); i--)
              {
                if (0 != gSourceList_ListEntryValidInformation[i])  //if there is an valid element
                {
                  if (gSourceList_Pos[i] > 0xFF) //check indexsize
                    indexsize = TRUE;
                  valid_elements++;                               //increment elements
                }
                else                                                //no valid element, loop finished
                  i = 0;
              }
            }
          }                                                               //backward-end
        }                                                                   //startelement ==0 -end
        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID				
        {
          //searching for valid startelement
          for (i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++)
          {
            if (gSourceList_Pos[i] == startelement)                     //found a valid element
            {
              if (shift == TRUE)                                          //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
              {
                if (i != 0 || BACKWARD != direction)                        //if valid_startelement is not the first array element or direction is not backwards
                  valid_startelement = i + 1 - 2 * direction;
                else if (i == 0 && BACKWARD == direction)
                  valid_startelement = gSourceList_sum;        //valid element is last element in Array                                                
                else if (i == 0 && FORWARD == direction)
                  valid_startelement = 0;                          //valid element is first element in Array
              }
              else
                valid_startelement = i;                              //found element is valid_startelement
              i = AUDIO_SOURCELIST_ENTRIES;
            }
          }
          if (0xff == valid_startelement)                                     //Startelement-ID doesn't exist in array
          {
            valid_startelement = startelement;
            valid_elements = 0;
          }
          else                                                                //found valid entry for startelement in array
          {
            //verify number of valid elements
            if (BACKWARD == direction)                                          //backward-start
            {
              if (valid_startelement == 0)                                    //only 1 element because valid startelement is on position 0
                valid_elements = 1;
              else if (elements > (valid_startelement + 1))                   //not enougth array-elements available, because array endet at array-position 0
              {
                for (i = valid_startelement; i >= 0; i--)
                {
                  if (0 != gSourceList_ListEntryValidInformation[i])  //if there is an valid element
                  {
                    if (gSourceList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                //no valid element, loop finished
                    i = 0;
                }
              }
              else                                                        //enougth array-elements available
              {
                for (i = valid_startelement; i > (valid_startelement - elements); i--)
                {
                  if (0 != gSourceList_ListEntryValidInformation[i])  //if there is an valid element
                  {
                    if (gSourceList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                //no valid element, loop finished
                    i = 0;
                }
              }
            }                                                               //backward-end
            else                                                            //forward-start
            {
              if ((valid_startelement + elements) >= AUDIO_SOURCELIST_ENTRIES)
              {
                for (i = valid_startelement; i < AUDIO_SOURCELIST_ENTRIES; i++)
                {
                  if (0 != gSourceList_Pos[i])                        //if there is an valid element
                  {
                    if (gSourceList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                //no valid element, loop finished
                    i = AUDIO_SOURCELIST_ENTRIES;
                }
              }
              else
              {
                for (i = valid_startelement; i < (valid_startelement + elements); i++)
                {
                  if (0 != gSourceList_Pos[i])                            //if there is an valid element
                  {
                    if (gSourceList_Pos[i] > 0xFF) //check indexsize
                      indexsize = TRUE;
                    valid_elements++;                               //increment elements
                  }
                  else                                                //no valid element, loop finished
                    i = AUDIO_SOURCELIST_ENTRIES;
                }
              }
            }
          }
        }
        if ((valid_startelement > 0xFF) || (requested_startelement > 0xFF)) //check indexsize
          indexsize = TRUE;
        mode = shift + (direction * 0x02) + (transmitpos * 0x04) + indexsize * 0x08;
        //send StatusArray
        if (!transSuppression)
          SourceList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
      }
      //Panel
      putvalue(env_AudioSD_SL_ASGID, gSourceList_ASGID);
      putvalue(env_AudioSD_SL_TAID, gSourceList_TAID);
    break;
    case Error_IND:
      writelineEx(gError_Trace, 0, "FSG_AudioSD SourceList_Indication: received error, errorcode:0x%x", Indication_array[3]);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD SourceList_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void SourceList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements, byte errorcode)
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word SourceListLine;

    // Init local variables. 
    for (i = 0; i < BAP_BUFFER_SIZE; i++)
        requestarray[i] = 0;
    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    SourceListLine = 0;
    current_element = 0;
    Offset = 0;
    // decode "mode-byte"
    shift = mode & 0x01;
    direction = (mode & 0x02) / 0x02;
    transmitpos = (mode & 0x04) / 0x04;
    indexsize = (mode & 0x08) / 0x08;
    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_SourceList;         //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;
    switch (request)
    {
        case Changed_REQ:
            /***ArrayHeader***/
            requestarray[Offset] = ((mode * 0x10) & 0xF0) + (recordaddress & 0x0F);
            Offset++;
            if (indexsize)
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = (requested_startelement & 0xff00) / 0x100;
                Offset++;
                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = (elements & 0xff00) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }
            SourceListLine = startelement;
            if (getvalue(env_AudioSD_SL_CA_switch)) //ArrayData
            {
                //copy data
                switch (recordaddress)
                {
                    case 0: //complete record (FRU)
                        while (current_element < elements)
                        {
                            if (SourceListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD SourceList_Request: invalid SourceListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }
                                //SourceType
                                requestarray[Offset] = gSourceList_SourceType[SourceListLine];
                                Offset++;
                                //InstanceID
                                requestarray[Offset] = gSourceList_InstanceID[SourceListLine];
                                Offset++;
                                //Attributes
                                requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gSourceList_Name[SourceListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gSourceList_Name[SourceListLine]); i++)
                                {
                                    requestarray[Offset] = gSourceList_Name[SourceListLine][i];
                                    Offset++;
                                }
                                //PictureReference
                                requestarray[Offset] = (gSourceList_PicRef[SourceListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gSourceList_PicRef[SourceListLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                        }//end while
                    break;
                    case 1: //complete record
                        while (current_element < elements)
                        {
                            if (SourceListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD SourceList_Request: invalid SourceListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }
                                //SourceType
                                requestarray[Offset] = gSourceList_SourceType[SourceListLine];
                                Offset++;
                                //InstanceID
                                requestarray[Offset] = gSourceList_InstanceID[SourceListLine];
                                Offset++;
                                //Attributes
                                requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gSourceList_Name[SourceListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gSourceList_Name[SourceListLine]); i++)
                                {
                                    requestarray[Offset] = gSourceList_Name[SourceListLine][i];
                                    Offset++;
                                }
                                //PictureReference
                                requestarray[Offset] = (gSourceList_PicRef[SourceListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gSourceList_PicRef[SourceListLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                        }//end while
                    break;
                    case 2: //SourceType, InstanceID, Attributes
                        while (current_element < elements)
                        {
                            if (SourceListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD SourceList_Request: invalid SourceListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }
                                //SourceType
                                requestarray[Offset] = gSourceList_SourceType[SourceListLine];
                                Offset++;
                                //InstanceID
                                requestarray[Offset] = gSourceList_InstanceID[SourceListLine];
                                Offset++;
                                //Attributes
                                requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                                Offset++;
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                        }//end while
                    break;
                    case 3: //Name
                        while (current_element < elements)
                        {
                            if (SourceListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD SourceList_Request: invalid SourceListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }
                                //Name
                                requestarray[Offset] = strlen(gSourceList_Name[SourceListLine]);
                                Offset++;
                                for (i = 0; i < strlen(gSourceList_Name[SourceListLine]); i++)
                                {
                                    requestarray[Offset] = gSourceList_Name[SourceListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                        }//end while
                    break;    
                    case 4: //Attributes
                        while (current_element < elements)
                        {
                            if (SourceListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD SourceList_Request: invalid SourceListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }
                                //Attributes
                                requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                                Offset++;
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                        }//end while
                    break;    
                    case 5: //PicRef
                        while (current_element < elements)
                        {
                            if (SourceListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD SourceList_Request: invalid SourceListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }
                                //PictureReference
                                requestarray[Offset] = (gSourceList_PicRef[SourceListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gSourceList_PicRef[SourceListLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                        }//end while
                    break;    
                    case 15: //Pos
                        while (current_element < elements)
                        {
                            if (SourceListLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD SourceList_Request: invalid SourceListLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0x00FF);
                                        Offset++;
                                        requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                        }//end while
                    break;
                    default:
                        write("AudioSD SourceList_Request: invalid recordaddress %d", recordaddress);
                    break;
                } //end switch "recordaddress"
            }//end 'ArrayData'
            set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
        break; //end Changed_REQ
        case Data_REQ:
            requestarray[Offset] = ((gSourceList_ASGID * 0x10) & 0xF0) + (gSourceList_TAID & 0x0F);
            Offset++;
            requestarray[Offset] = gSourceList_TotalNumListElements & 0xff;
            Offset++;
            requestarray[Offset] = (gSourceList_TotalNumListElements & 0xff00) / 0x100;
            Offset++;
            /***ArrayHeader***/
            requestarray[Offset] = ((mode * 0x10) & 0xF0) + (recordaddress & 0x0F);
            Offset++;
            if (indexsize)
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = (requested_startelement & 0xff00) / 0x100;
                Offset++;
                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = (elements & 0xff00) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            SourceListLine = startelement;
            //copy data
            switch (recordaddress)
            {
                case 0: //complete record (FRU)
                    while (current_element < elements)
                    {
                        if (SourceListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD SourceList_Request: invalid SourceListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                    Offset++;
                                }
                            }
                            //SourceType
                            requestarray[Offset] = gSourceList_SourceType[SourceListLine];
                            Offset++;
                            //InstanceID
                            requestarray[Offset] = gSourceList_InstanceID[SourceListLine];
                            Offset++;
                            //Attributes
                            requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen(gSourceList_Name[SourceListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gSourceList_Name[SourceListLine]); i++)
                            {
                                requestarray[Offset] = gSourceList_Name[SourceListLine][i];
                                Offset++;
                            }
                            //PictureReference
                                requestarray[Offset] = (gSourceList_PicRef[SourceListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gSourceList_PicRef[SourceListLine] & 0xFF00) / 0x100);
                                Offset++;
                        }
                        current_element++;
                        SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                case 1: //complete record
                    while (current_element < elements)
                    {
                        if (SourceListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD SourceList_Request: invalid SourceListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                    Offset++;
                                }
                            }
                            //SourceType
                            requestarray[Offset] = gSourceList_SourceType[SourceListLine];
                            Offset++;
                            //InstanceID
                            requestarray[Offset] = gSourceList_InstanceID[SourceListLine];
                            Offset++;
                            //Attributes
                            requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen(gSourceList_Name[SourceListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gSourceList_Name[SourceListLine]); i++)
                            {
                                requestarray[Offset] = gSourceList_Name[SourceListLine][i];
                                Offset++;
                            }
                            //PictureReference
                                requestarray[Offset] = (gSourceList_PicRef[SourceListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gSourceList_PicRef[SourceListLine] & 0xFF00) / 0x100);
                                Offset++;
                        }
                        current_element++;
                        SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;    
                case 2: //SourceType, InstanceID, Attributes
                    while (current_element < elements)
                    {
                        if (SourceListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD SourceList_Request: invalid SourceListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                    Offset++;
                                }
                            }
                            //SourceType
                            requestarray[Offset] = gSourceList_SourceType[SourceListLine];
                            Offset++;
                            //InstanceID
                            requestarray[Offset] = gSourceList_InstanceID[SourceListLine];
                            Offset++;
                            //Attributes
                            requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                            Offset++;
                        }
                        current_element++;
                        SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;    
                case 3: //Name
                    while (current_element < elements)
                    {
                        if (SourceListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD SourceList_Request: invalid SourceListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                    Offset++;
                                }
                            }
                            //Name
                            requestarray[Offset] = strlen(gSourceList_Name[SourceListLine]);
                            Offset++;
                            for (i = 0; i < strlen(gSourceList_Name[SourceListLine]); i++)
                            {
                                requestarray[Offset] = gSourceList_Name[SourceListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;    
                case 4: //Attributes
                    while (current_element < elements)
                    {
                        if (SourceListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD SourceList_Request: invalid SourceListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                    Offset++;
                                }
                            }
                            //Attributes
                            requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                            Offset++;
                        }
                        current_element++;
                        SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;    
                case 5: //PicRef
                    while (current_element < elements)
                    {
                        if (SourceListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD SourceList_Request: invalid SourceListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0xFF);
                                    Offset++;
                                    requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                    Offset++;
                                }
                            }
                            //PictureReference
                                requestarray[Offset] = (gSourceList_PicRef[SourceListLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gSourceList_PicRef[SourceListLine] & 0xFF00) / 0x100);
                                Offset++;
                        }
                        current_element++;
                        SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;    
                case 15: //Pos
                    while (current_element < elements)
                    {
                        if (SourceListLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD SourceList_Request: invalid SourceListLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gSourceList_Pos[SourceListLine] & 0x00FF);
                                    Offset++;
                                    requestarray[Offset] = ((gSourceList_Pos[SourceListLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                    Offset++;
                                }
                            }
                        }
                        current_element++;
                        SourceListLine = SourceList_nextvalidLine(SourceListLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                default:
                    write("AudioSD SourceList_Request: invalid recordaddress %d", recordaddress);
                break;
            } //end switch "recordaddress"
        break; //end Data_REQ
        case Error_REQ:
            requestarray[3] = errorcode;
            set_status_requestbuffer(requestarray, 4, Bap_Error);
        break; //end Error_REQ
    } //end switch "request"   
}

//*************************************************************************
//*****************DedicatedAudioControl***********************************
on envVar env_AudioSD_DAC_ResButton
{
	if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this)) 
	{
		gAudioSD_DAC_AsgId =getvalue(env_AudioSD_DAC_AsgId);
    gAudioSD_DAC_Extension1 =getvalue(env_AudioSD_DAC_Extension1);
    gAudioSD_DAC_Result =getvalue(env_AudioSD_DAC_Res);
    DedicatedAudioControl_Request(Result_REQ, 0);
	}
}

void DedicatedAudioControl_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2])
  {
    case Processing_CNF:
      DedicatedAudioControl_Request(Processing_REQ, 0);          //send Processing
    break;
    case StartResult_IND:
      if (getvalue(env_AudioSD_DAC_Error_on))
        DedicatedAudioControl_Request(Error_REQ, getvalue(env_AudioSD_DAC_ErrorCode));
      else
      {
        if (FALSE == gAudioSD_DAC_status)
        {
          gAudioSD_DAC_status = TRUE;                         //method active
          //get data
          gAudioSD_DAC_AsgId = Indication_array[3]/0x10;
          gAudioSD_DAC_Extension1 = Indication_array[3]&0x0F;
          gAudioSD_DAC_ControlType = Indication_array[4];
          gAudioSD_DAC_FSGHandle = Indication_array[5] + (Indication_array[6] * 0x100);
          gAudioSD_DAC_ListType = Indication_array[7];
          if (gAudioSD_DAC_ControlType > 0x04)
          {
            DedicatedAudioControl_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE);
            gAudioSD_DAC_status = FALSE;
          }
          else if (gAudioSD_DAC_ListType > 0x03)
          {
            DedicatedAudioControl_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE);
            gAudioSD_DAC_status = FALSE;
          }
          else //received data valid
          {
            if (getvalue(env_AudioSD_DAC_Res) == AUDIO_DAC_SUCCESSFUL)
            {
              switch (gAudioSD_DAC_ControlType)
              {
                case AUDIO_DAC_FASTFORWARD:
                  gAudioSD_DAC_MethodHandling = 3;
                  settimer(DAC_MethodHandling_Timer, 20);
                break;
                case AUDIO_DAC_FASTBACKWARD:
                  gAudioSD_DAC_MethodHandling = 3;
                  settimer(DAC_MethodHandling_Timer, 20);
                break;
                case AUDIO_DAC_SELECT_LIST_ENTRY:
                  gAudioSD_DAC_MethodHandling = 1;
                  settimer(DAC_MethodHandling_Timer, 20);
                  settimer(DAC_Timer, gAudioSD_DAC_TimerTime);
                break;
                case AUDIO_DAC_NEXT:
                  gAudioSD_DAC_MethodHandling = 1;
                  settimer(DAC_MethodHandling_Timer, 20);
                  settimer(DAC_Timer, gAudioSD_DAC_TimerTime);
                break;
                case AUDIO_DAC_PREVIOUS:
                  gAudioSD_DAC_MethodHandling = 1;
                  settimer(DAC_MethodHandling_Timer, 20);
                  settimer(DAC_Timer, gAudioSD_DAC_TimerTime);
                break;
                default:
                  settimer(DAC_Timer, gAudioSD_DAC_TimerTime);
                break;
              }
            }
            else
              settimer(DAC_Timer, gAudioSD_DAC_TimerTime);
          }
        }
      }
    break;
    case Abort_IND:
      if (getvalue(env_AudioSD_DAC_Error_on))
          DedicatedAudioControl_Request(Error_REQ, getvalue(env_AudioSD_DAC_ErrorCode));
      else
      {
        if (FALSE == gAudioSD_DAC_status)                                //method not active							
          DedicatedAudioControl_Request(Error_REQ, 0x50);         //send error-message
        else if (TRUE == gAudioSD_DAC_status)                           //method still active
        {
          gAudioSD_DAC_Result = getvalue(env_AudioSD_DAC_Abort);
          if (AUDIO_DAC_ABORTSUCCESSFUL == gAudioSD_DAC_Result)       //only, if abort is successful
          {
            canceltimer(DAC_Timer);                             //abort method
            canceltimer(DAC_MethodHandling_Timer);
            gAudioSD_DAC_status = FALSE;                            //method finished
            gAudioSD_DAC_MethodHandling = 0;
          }
          DedicatedAudioControl_Request(Result_REQ, 0);   //send result-message				
        }
      }
    break;
    default:
      writelineEx(gError_Trace, 0, "AudioSD DedicatedAudioControl_Indication: unknown indication %d", Indication_array[2]);
    break;
  }
}

void DedicatedAudioControl_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;                  //LSG-ID
  requestarray[1] = FctID_DedicatedAudioControl;   //Fct.-ID
  requestarray[2] = request;
  switch (request)
  {
    case Processing_REQ:
      requestarray[3] = (gAudioSD_DAC_AsgId*0x10) + (gAudioSD_DAC_Extension1&0x0F);
      requestarray[4] = gAudioSD_DAC_Reserve;
      set_status_requestbuffer(requestarray, 5, Bap_ByteSequence);
    break;
    case Result_REQ:
      requestarray[3] = (gAudioSD_DAC_AsgId*0x10) + (gAudioSD_DAC_Extension1&0x0F);
      requestarray[4] = gAudioSD_DAC_Result;
      set_status_requestbuffer(requestarray, 5, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:    //error
      writelineEx(gError_Trace, 0, "AudioSD DedicatedAudioControl_Request: unknown request %d", request);
    break;
  }
}

on timer DAC_Timer
{
  gAudioSD_DAC_Result =getvalue(env_AudioSD_DAC_Res);
  if (gAudioSD_DAC_Result !=AUDIO_DAC_NOTSUCCESSFUL && gAudioSD_DAC_status ==TRUE)    
  {
    //Panel
    putvalue(env_AudioSD_DAC_AsgId, gAudioSD_DAC_AsgId);
    putvalue(env_AudioSD_DAC_Extension1, gAudioSD_DAC_Extension1);
    putvalue(env_AudioSD_DAC_CT, gAudioSD_DAC_ControlType);
    putvalue(env_AudioSD_DAC_LT, gAudioSD_DAC_ListType);
    putvalue(env_AudioSD_DAC_FSGHandle, gAudioSD_DAC_FSGHandle);
  }
  DedicatedAudioControl_Request(Result_REQ, 0); //send Result
  gAudioSD_DAC_status =FALSE; //method not active
  if(gAudioSD_DAC_Result ==AUDIO_DAC_SUCCESSFUL)
  {
    gAudioSD_DAC_MethodHandling =2;
    settimer(DAC_MethodHandling_Timer,100);
  }    
}

on timer DAC_MethodHandling_Timer
{
  switch (gAudioSD_DAC_MethodHandling)
  {
    case 1:
      if (gAudioSD_DAC_ControlType ==AUDIO_DAC_SELECT_LIST_ENTRY)
      {    
        gAudioSD_CSIhandle_FSGhandle =gAudioSD_DAC_FSGHandle;
        putvalue(env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle); 
      }
      CurrentStationHandle_Request(Data_REQ, 0);    //send status
      gAudioSD_DAC_MethodHandling =0;
    break;
    case 2:
      CurrentStationInfo_Request(Data_REQ, 0);    //send status
      gAudioSD_DAC_MethodHandling =0;
    break;
    case 3:
      if(gAudioSD_DAC_status ==TRUE)
      {
        CurrentStationInfo_Request(Data_REQ, 0);    //send status
        gAudioSD_DAC_MethodHandling =3;
        settimer(DAC_MethodHandling_Timer, 250);
      }
    break;
    default:
    break;
  }   
}

//*************************************************************************
//*****************SwitchSource********************************************
on envVar env_AudioSD_SwitchSource_ResBtn
{
	if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this)) 
	{
		gAudioSD_SwitchSource_AsgId =getvalue(env_AudioSD_SwitchSource_AsgID);
    gAudioSD_SwitchSource_Extension1 =getvalue(env_AudioSD_SwitchSource_Ext1);
    gAudioSD_SwitchSource_Result =getvalue(env_AudioSD_SwitchSource_Result);
    SwitchSource_Request(Result_REQ, 0);
	}
}

void SwitchSource_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2])
  {
    case Processing_CNF:
      SwitchSource_Request(Processing_REQ, 0);          //send Processing
    break;
    case StartResult_IND:
      if (getvalue(env_AudioSD_SwitchSource_ErrorON))
        SwitchSource_Request(Error_REQ, getvalue(env_AudioSD_SwitchSource_ErrorC));
      else
      {
        if (FALSE == gAudioSD_SwitchSource_status)
        {
          gAudioSD_SwitchSource_status = TRUE;                            //method active
          //get data
          gAudioSD_SwitchSource_AsgId = Indication_array[3]/0x10;
          gAudioSD_SwitchSource_Extension1 = Indication_array[3]&0x0F;
          gAudioSD_SwitchSource_ControlType = Indication_array[4];
          gAudioSD_SwitchSource_Reference = Indication_array[5];
          gAudioSD_SwitchSource_Reference += Indication_array[6]*0x100;
          settimer(SwitchSource_Timer, SwitchSource_TimerTime);
        }
      }
    break;
    case Abort_IND:
      if (getvalue(env_AudioSD_SwitchSource_ErrorON))
        SwitchSource_Request(Error_REQ, getvalue(env_AudioSD_SwitchSource_ErrorC));
      else
      {
        if (FALSE == gAudioSD_SwitchSource_status)                               //method not active								
          SwitchSource_Request(Error_REQ, 0x50);          //send error-message
        else if (TRUE == gAudioSD_SwitchSource_status)                          //method still active
        {
          gAudioSD_SwitchSource_Result = getvalue(env_AudioSD_SwitchSource_Abort);
          if (AUDIO_SWITCHSOURCERESULT_ABORT_SUCCESSFUL == gAudioSD_SwitchSource_Result)      //only, if abort is successful
          {
            canceltimer(SwitchSource_Timer);                                //abort method
            gAudioSD_SwitchSource_status = FALSE;                           //method finished
          }
          SwitchSource_Request(Result_REQ, 0);    //send result-message				
        }
      }
    break;
    default:
      writelineEx(gError_Trace, 0, "AudioSD SwitchSource_Indication: unknown indication %d", Indication_array[2]);
    break;
  }
}

SwitchSource_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;         //LSG-ID
  requestarray[1] = FctID_SwitchSource;   //Fct.-ID
  requestarray[2] = request;
  switch (request)
  {
    case Processing_REQ:
      requestarray[3] = (gAudioSD_SwitchSource_AsgId*0x10) + (gAudioSD_SwitchSource_Extension1&0x0F);
      requestarray[4] = gAudioSD_SwitchSource_Reserve;
      set_status_requestbuffer(requestarray, 5, Bap_ByteSequence);
    break;
    case Result_REQ:
      requestarray[3] = (gAudioSD_SwitchSource_AsgId*0x10) + (gAudioSD_SwitchSource_Extension1&0x0F);
      requestarray[4] = gAudioSD_SwitchSource_Result;
      set_status_requestbuffer(requestarray, 5, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:    //error
      writelineEx(gError_Trace, 0, "AudioSD SwitchSource_Request: unknown request %d", request);
    break;
  }
}

on timer SwitchSource_Timer
{
  gAudioSD_SwitchSource_Result =getvalue(env_AudioSD_SwitchSource_Result);
  //Panel
  if (gAudioSD_SwitchSource_Result !=AUDIO_SWITCHSOURCERESULT_NOT_SUCCESSFUL && gAudioSD_SwitchSource_status ==TRUE)  
  {
    putvalue(env_AudioSD_SwitchSource_AsgID, gAudioSD_SwitchSource_AsgId);
    putvalue(env_AudioSD_SwitchSource_Ext1, gAudioSD_SwitchSource_Extension1);
    putvalue(env_AudioSD_SwitchSource_CT, gAudioSD_SwitchSource_ControlType);
    putvalue(env_AudioSD_SwitchSource_Ref, gAudioSD_SwitchSource_Reference);
  }
  SwitchSource_Request(Result_REQ, 0); //send Result
  gAudioSD_SwitchSource_status =FALSE; //method not active    
}

//*************************************************************************
//*****************Browser_FolderLevel*************************************
on envVar env_AudioSD_MedBrFoLev_update
{
  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    gAudioSD_MediaBrowser_FL_FolderLevel            =getvalue(env_AudioSD_MedBrFoLev_FolLev);
    gAudioSD_MediaBrowser_FL_RefMediaBrowser        =getvalue(env_AudioSD_MedBrFoLev_Ref);
    gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos =getvalue(env_AudioSD_MedBrFoLev_Ref_abs);
    gAudioSD_MediaBrowser_FL_Extension1             =getvalue(env_AudioSD_MedBrFoLev_Ext1);
    Browser_FolderLevel_Request(Data_REQ, 0);
  }
}

void Browser_FolderLevel_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      Browser_FolderLevel_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD Browser_FolderLevel_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void Browser_FolderLevel_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;                      //LSG-ID
  requestarray[1] = FctID_Browser_FolderLevel;   //Fct.-ID
  requestarray[2] = request;                           //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_MediaBrowser_FL_FolderLevel;
      requestarray[4] = gAudioSD_MediaBrowser_FL_RefMediaBrowser & 0xff;
      requestarray[5] = (gAudioSD_MediaBrowser_FL_RefMediaBrowser & 0xff00) / 0x100;
      requestarray[6] = gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos & 0xff;
      requestarray[7] = (gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos & 0xff00) / 0x100;
      requestarray[8] = gAudioSD_MediaBrowser_FL_Extension1;
      set_status_requestbuffer(requestarray, 9, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD Browser_FolderLevel_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************Browser*************************************************
on envVar env_AudioSD_MB_CA
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;

  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    if(getvalue(env_AudioSD_MB_AH_start) >255 && getvalue(env_AudioSD_MB_AH_IS) ==0)// check if 8 or 16 bit
      putvalue(env_AudioSD_MB_AH_IS,1);
    //get data from Panel
    recordaddress   =getvalue(env_AudioSD_MB_AH_RA);
    shift           =getvalue(env_AudioSD_MB_AH_shift);
    direction       =getvalue(env_AudioSD_MB_AH_dir);
    transmitpos     =getvalue(env_AudioSD_MB_AH_POS);
    indexsize       =getvalue(env_AudioSD_MB_AH_IS);
    startelement    =getvalue(env_AudioSD_MB_AH_start);
    elements        =getvalue(env_AudioSD_MB_AH_elements);
    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    requested_startelement =startelement;
    /***Startelement=0***/
    if (getvalue(env_AudioSD_MB_CA_switch)) //ArrayData
    {
      if(0==startelement) //Startelement-ID =0 -> start at first array-entry
	    {
        if(FORWARD==direction)  //forward-start
		    {
          valid_startelement =0;				       									
          if(AUDIO_MEDIABROWSER_ENTRIES <=elements) //1. more elements requested, than in array
			    {
            if (shift ==FALSE)  
            {
              for(i=0;i<AUDIO_MEDIABROWSER_ENTRIES;i++)
					    {
				        if(0 !=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
				        else												//no valid element, loop finished
					        i =AUDIO_MEDIABROWSER_ENTRIES;
				      }
            }
            else if (shift ==TRUE)
            {   
              valid_startelement  =startelement;
			        valid_elements      =0;
            }
	        }
          else    //2. number of requested elements < elements in array
			    {
            if (shift ==FALSE)
            {
				      for(i=0;i<elements;i++)
					    {
				        if(0!=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
				        else												//no valid element, loop finished
				          i =AUDIO_MEDIABROWSER_ENTRIES;
				      }
            }
            else if (shift ==TRUE)
            {
              valid_startelement  =startelement;
			        valid_elements      =0;  
            }
			    }
        }                                                               //forward ends
        else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
		    {   
		      //searching for valid startelement
			    for(i=(AUDIO_MEDIABROWSER_ENTRIES-1);i>=0;i--)
			    {
			      if(0!=gMediaBrowser_ListEntryValidInformation[i])		//found valid startelement
				    {
				      valid_startelement =i;								
					    i =0;												
				    }
			    }
          //searching for valid elements
			    if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
			    {
			      valid_startelement  =startelement;
				    valid_elements      =0;
			    }
			    else if(0==valid_startelement)								
			      valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
			    else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
			    {
			      for(i=valid_startelement;i>=0;i--)
				    {
			        if(0!=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
				        valid_elements++;								//increment elements
					    else												//no valid element, loop finished
					      i=0;
			      }
			    }
          else														//enougth array-elements available
			    {
			      for(i=valid_startelement;i>(valid_startelement-elements);i--)
				    {
			        if(0!=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
				        valid_elements++;								//increment elements
					    else												//no valid element, loop finished
						    i=0;
				    }                   
			    }															
        }                                                               //backward-end
      }                                                                   //startelement ==0 -end
      /***Startelement!=0***/
      else																//searching for Startelement-ID				
	    {
	      //searching for valid startelement
		    for(i=0;i<AUDIO_MEDIABROWSER_ENTRIES;i++)
		    {
			    if(gMediaBrowser_Pos[i] ==startelement)					    //found a valid element
			    {                                       
            if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
				    {
			        if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
				        valid_startelement =i+1-2* direction;
              else if(i==0 && BACKWARD==direction) 
                valid_startelement =gMediaBrowser_sum;     //valid element is last element in Array                                                
              else if(i==0 && FORWARD==direction) 
                valid_startelement =0;                          //valid element is first element in Array
            }
            else
              valid_startelement =i;                              //found element is valid_startelement
				    i =AUDIO_MEDIABROWSER_ENTRIES;
			    }
          else
            valid_startelement =0xff;
		    }
		    if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
		    {   
			    valid_startelement  =startelement;
			    valid_elements      =0;
		    }
		    else																//found valid entry for startelement in array
		    {
		      //verify number of valid elements
			    if(BACKWARD==direction)											//backward-start
			    {
		        if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
			        valid_elements=1;
				    else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
		        {
			        for(i=valid_startelement;i>=0;i--)
					    {
				        if(0!=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
                else												//no valid element, loop finished
					        i=0;
					    }
			      }
				    else														//enougth array-elements available
				    {
				      for(i=valid_startelement;i>(valid_startelement-elements);i--)
					    {
				        if(0!=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
							    i=0;
					    }
				    }
			    }																//backward-end
			    else															//forward-start
			    {
			      if((valid_startelement+elements)>=AUDIO_MEDIABROWSER_ENTRIES)
				    {
				      for(i=valid_startelement;i<AUDIO_MEDIABROWSER_ENTRIES;i++)
					    {
				        if(0!=gMediaBrowser_Pos[i])							//if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						      i=AUDIO_MEDIABROWSER_ENTRIES;
					    }
				    }
				    else
				    {
				      for(i=valid_startelement;i<(valid_startelement+elements);i++)
					    {
				        if(0!=gMediaBrowser_Pos[i])						    //if there is an valid element
					        valid_elements++;								//increment elements
						    else												//no valid element, loop finished
						      i=AUDIO_MEDIABROWSER_ENTRIES;
					    }
				    }
			    }
		    }
	    }
      putvalue(env_AudioSD_MB_AH_elements, valid_elements);
      //send ChangedArray
      Browser_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
    else
    {
      //send ChangedArray
      Browser_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
    }
  }
}

on envVar env_AudioSD_MB_DataSource
{
  if (getvalue(this) ==AUDIO_DEFAULT_LIST)
  {
    Browser_init_static();
    putvalue(env_AudioSD_MB_DataSource_file, empty_string);
    putvalue(env_AudioSD_MB_DataSource_result, empty_string);
  }
}

on envVar env_AudioSD_MB_reload //load external MediaBrowser from *.csv
{
  if(getvalue(this) && getvalue(env_AudioSD_MB_DataSource) ==AUDIO_EXTERNAL_LIST)
    Browser_init_CSV();
  else if(getvalue(env_AudioSD_MB_DataSource) != AUDIO_EXTERNAL_LIST)
    putvalue(env_AudioSD_MB_DataSource_result,"not successful, select 'external *.csv'");
}

on envVar env_AudioSD_MB_StatusArray
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i, transSuppression;

  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;
  transSuppression        = getvalue(env_AudioSD_MB_noStatusArray);
  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    if(getvalue(env_AudioSD_MB_AH_start) >255 && getvalue(env_AudioSD_MB_AH_IS) ==0)// check if 8 or 16 bit
      putvalue(env_AudioSD_MB_AH_IS,1);
    //get data from Panel
    gMediaBrowser_ASGID                =getvalue(env_AudioSD_MB_ASGID);
    gMediaBrowser_TAID                 =getvalue(env_AudioSD_MB_TAID);
    gMediaBrowser_ActiveListPos        =getvalue(env_AudioSD_MB_ActiveListPos);
    gMediaBrowser_TotalNumListElements =getvalue(env_AudioSD_MB_TotalNumLE);
    recordaddress   =getvalue(env_AudioSD_MB_AH_RA);
    shift           =getvalue(env_AudioSD_MB_AH_shift);
    direction       =getvalue(env_AudioSD_MB_AH_dir);
    transmitpos     =getvalue(env_AudioSD_MB_AH_POS);
    indexsize       =getvalue(env_AudioSD_MB_AH_IS);
    startelement    =getvalue(env_AudioSD_MB_AH_start);
    elements        =getvalue(env_AudioSD_MB_AH_elements);
    mode =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;     
    requested_startelement =startelement;    
    /***Startelement=0***/
    if(0==startelement) //Startelement-ID =0 -> start at first array-entry
		{
      if(FORWARD==direction)  //forward-start
			{
        valid_startelement =0;
        if(AUDIO_MEDIABROWSER_ENTRIES <=elements) //1. more elements requested, than in array
				{
          if (shift ==FALSE)  
          {
            for(i=0;i<AUDIO_MEDIABROWSER_ENTRIES;i++)
						{
						  if(0 !=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
							  valid_elements++;								//increment elements
						  else												//no valid element, loop finished
							  i =AUDIO_MEDIABROWSER_ENTRIES;
					  }
          }
          else if (shift ==TRUE)
          {   
            valid_startelement  =startelement;
    			  valid_elements      =0;
          }
			  }
        else    //2. number of requested elements < elements in array
				{
          if (shift ==FALSE)
          {
					  for(i=0;i<elements;i++)
						{
						  if(0!=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
							  valid_elements++;								//increment elements
						  else												//no valid element, loop finished
						    i =AUDIO_MEDIABROWSER_ENTRIES;
					  }
          }
          else if (shift ==TRUE)
          {
            valid_startelement  =startelement;
					  valid_elements      =0;  
          }
				}
      }
      else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
			{   
			  //searching for valid startelement
				for(i=(AUDIO_MEDIABROWSER_ENTRIES-1);i>=0;i--)
				{
				  if(0!=gMediaBrowser_ListEntryValidInformation[i])		//found valid startelement
					{
					  valid_startelement =i;								
						i =0;												
					}
				}       
        //searching for valid elements
				if(0xff==valid_startelement)//Startelement-ID doesn't exist in SMSReceived-array
				{
				  valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(0==valid_startelement)								
				  valid_elements=1;//only 1 element because valid startelement is on position 0	
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				  for(i=valid_startelement;i>=0;i--)
					{
					  if(0!=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
						  valid_elements++;								//increment elements
						else												//no valid element, loop finished
						  i=0;
				  }
				}
        else														//enougth array-elements available
				{
				  for(i=valid_startelement;i>(valid_startelement-elements);i--)
					{
					  if(0!=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
						  valid_elements++;								//increment elements
						else												//no valid element, loop finished
							i=0;
					}                   
				}															
	    }                                                               //backward-end
    }
    /***Startelement!=0***/
    else																//searching for Startelement-ID				
		{
		  //searching for valid startelement
			for(i=0;i<AUDIO_MEDIABROWSER_ENTRIES;i++)
			{
				if(gMediaBrowser_Pos[i] ==startelement)					    //found a valid element
				{                                       
          if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
					{
					  if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
						  valid_startelement =i+1-2* direction;					
            else if(i==0 && BACKWARD==direction) 
              valid_startelement =gMediaBrowser_sum;     //valid element is last element in Array            
            else if(i==0 && FORWARD==direction) 
              valid_startelement =0;                          //valid element is first element in Array
          }
          else
            valid_startelement =i;                              //found element is valid_startelement
					i =AUDIO_MEDIABROWSER_ENTRIES;
				}
        else
          valid_startelement =0xff;
			}
      
			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			  //verify number of valid elements
				if(BACKWARD==direction)											//backward-start
				{
				  if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
					  valid_elements=1;	
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				  {
					  for(i=valid_startelement;i>=0;i--)
					  {
						  if(0!=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
							  valid_elements++;								//increment elements
              else												//no valid element, loop finished
							  i=0;
						}
				  }
					else														//enougth array-elements available
					{
					  for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
						  if(0!=gMediaBrowser_ListEntryValidInformation[i])	//if there is an valid element
							  valid_elements++;								//increment elements
							else												//no valid element, loop finished
								i=0;
						}
					}
				}																//backward-end
				else															//forward-start
				{
				  if((valid_startelement+elements)>=AUDIO_MEDIABROWSER_ENTRIES)
					{
					  for(i=valid_startelement;i<AUDIO_MEDIABROWSER_ENTRIES;i++)
						{
						  if(0!=gMediaBrowser_Pos[i])							//if there is an valid element
							  valid_elements++;								//increment elements
							else												//no valid element, loop finished
							  i=AUDIO_MEDIABROWSER_ENTRIES;
						}
					}
					else
					{
					  for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
						  if(0!=gMediaBrowser_Pos[i])						    //if there is an valid element
							  valid_elements++;								//increment elements
							else												//no valid element, loop finished
							  i=AUDIO_MEDIABROWSER_ENTRIES;
						}
					}
				}
			}
		}
    putvalue(env_AudioSD_MB_AH_elements, valid_elements);
    //send StatusArray
    if(!transSuppression)
      Browser_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
  }
}

void Browser_init_CSV() //Byte & file selection
{
  dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, 
        current_CSV_line = 0, count1 = 0, count2 = 0;
  char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
  byte MediaBrowserLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
  char MediaBrowser_Pos_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
  char MediaBrowser_Type_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Type" is stored in the ASCII(UTF-8) code in the *.csv 
  char MediaBrowser_FileState_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"FileState" is stored in the ASCII(UTF-8) code in the *.csv 
  char MediaBrowser_Waveband_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"" is stored in the ASCII(UTF-8) code in the *.csv 
  char MediaBrowser_RadioCategory_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"" is stored in the ASCII(UTF-8) code in the *.csv 
  char MediaBrowser_FmRegCode_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"" is stored in the ASCII(UTF-8) code in the *.csv 
  char MediaBrowser_PresetID_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"" is stored in the ASCII(UTF-8) code in the *.csv 
  char MediaBrowser_Attributes1_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"" is stored in the ASCII(UTF-8) code in the *.csv 
  char MediaBrowser_Attributes2_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"" is stored in the ASCII(UTF-8) code in the *.csv 
  char MediaBrowser_PicRef_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"" is stored in the ASCII(UTF-8) code in the *.csv 
  
  if(getvalue(env_AudioSD_MB_DataSource) == AUDIO_EXTERNAL_LIST) //output data in write window "FSGMediaBrowser"  
  {
    writeClear(gMediaBrowser_writeWindow);
    writelineEx(gMediaBrowser_writeWindow, 0,"*******External MediaBrowser*******");
    writelineEx(gMediaBrowser_writeWindow, 0, "");
    writelineEx(gMediaBrowser_writeWindow, 0, "**********************Start load new MediaBrowser**********************");   
    //clear  
    for(j=0;j<AUDIO_MEDIABROWSER_ENTRIES;j++) 
    {
	    gMediaBrowser_Pos[j]                            =0;
	    gMediaBrowser_Type[j]                       =0;
      gMediaBrowser_FileState_Bit0[j]     =0;
      gMediaBrowser_FileState_Bit0[j]             =0;
      gMediaBrowser_FileState_Bit0[j]   =0;
      gMediaBrowser_FileState_Bit0[j]        =0;
      gMediaBrowser_FileState_Bit0[j]  =0;
      gMediaBrowser_FileState_Bit0[j]   =0;
      gMediaBrowser_FileState_Bit0[j]  =0;
      gMediaBrowser_Waveband[j]                      =0;
      gMediaBrowser_RadioCategory[j]                      =0;
      gMediaBrowser_FmRegCode[j]                      =0;
      gMediaBrowser_PresetID[j]                      =0;
      gMediaBrowser_Attributes1_Bit0[j]     =0;
      gMediaBrowser_Attributes1_Bit1[j]     =0;
      gMediaBrowser_Attributes1_Bit2[j]     =0;
      gMediaBrowser_Attributes1_Bit3[j]     =0;
      gMediaBrowser_Attributes1_Bit4[j]     =0;
      gMediaBrowser_Attributes1_Bit5[j]     =0;
      gMediaBrowser_Attributes1_Bit6[j]     =0;
      gMediaBrowser_Attributes1_Bit7[j]     =0;
      gMediaBrowser_Attributes1[j]                      =0;
      gMediaBrowser_Attributes2_Bit0[j]     =0;
      gMediaBrowser_Attributes2_Bit1[j]     =0;
      gMediaBrowser_Attributes2[j]                      =0;
      gMediaBrowser_PicRef[j]                      =0;
      gMediaBrowser_ListEntryValidInformation[j] =0;
      for(i=0;i<AUDIO_MEDIABROWSER_NAME_LENGTH;i++)
        gMediaBrowser_Name[j][i] =0;
      for(i=0;i<AUDIO_MEDIABROWSER_FREQUENCY_LENGTH;i++)
        gMediaBrowser_Frequency[j][i] =0;
    }
    for(i=0;i<AUDIO_FILENAME_SIZE; i++) //clear "filename"
          gMediaBrowser_CSV_filename[i] =0;       
    for(j=0;j<AUDIO_MEDIABROWSER_ENTRIES; j++) //clear "buffer"
    {
      buffer_string[j]    =0;
      buffer_byte[j]      =0;
      for(i=0;i<AUDIO_TEXTLENGTH;i++) //clear help value
      {
        MediaBrowser_Pos_string[j][i]       =0;
        MediaBrowser_Type_string[j][i]  =0;
        MediaBrowser_FileState_string[j][i] =0;
        MediaBrowser_Waveband_string[j][i]       =0;
        MediaBrowser_RadioCategory_string[j][i]       =0;
        MediaBrowser_FmRegCode_string[j][i]       =0;
        MediaBrowser_PresetID_string[j][i]       =0;
        MediaBrowser_Attributes1_string[j][i]       =0;
        MediaBrowser_Attributes2_string[j][i]       =0;
        MediaBrowser_PicRef_string[j][i]       =0;
      }
    }        
    i =0; j =0; MediaBrowserLine =0; current_CSV_line =0; //reset values 
    getvalue(env_AudioSD_MB_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
    //write("complete path *.csv: %s", Path_CSV); //debug
    i =0;
    while (Path_CSV[i] !=0) //scan "path"
    {
        if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
            count1++;                
        //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
        i++;
    }  
    i =0; j =0; //reset values
    while (Path_CSV[i] !=0) //seperate "path" and "filename"
    {
        if(count2==count1) //get filename after last "\"
        {              
            gMediaBrowser_CSV_filename[j] =Path_CSV[i];
            j++;
            Path_CSV[i] =0;              
        }
        if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
            count2++;
        i++;
    }
    writelineEx(gMediaBrowser_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 
    writelineEx(gMediaBrowser_writeWindow, 0,"filename of *.csv: '%s'", gMediaBrowser_CSV_filename);  //output filename 
    putvalue(env_AudioSD_MB_DataSource_file, gMediaBrowser_CSV_filename); //output current loaded *.csv-file on panel
    setFilePath(Path_CSV, 0); //set path for *.csv file
    CSVfileHandle =openFileRead(gMediaBrowser_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        
    if (CSVfileHandle!=0) //*.csv file access successful
    {
      writelineEx(gMediaBrowser_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gMediaBrowser_CSV_filename);    //output result  
      putvalue(env_AudioSD_MB_DataSource_result, "successful");   //output result on panel                      
      Num_of_csv_byte =fileGetBinaryBlock(buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
      for (i=0; i<Num_of_csv_byte; i++) //copy data into "MediaBrowser"
      {      
        if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
        {
          if(buffer_byte[i] ==0x0D && buffer_byte[i + 1] ==0x0A) //nextline in *.csv (next "record element" in MediaBrowser) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
          {
            if(current_CSV_line>0 && MediaBrowserLine<AUDIO_MEDIABROWSER_ENTRIES) //ignore first line in *.csv file
            {   
              writelineEx(gMediaBrowser_writeWindow, 0, "");
              writelineEx(gMediaBrowser_writeWindow, 0,"*******Element %d*******", MediaBrowserLine);
              //transform 'string' to 'long' for "POS", "FileType" and "FileState"
              gMediaBrowser_Pos[MediaBrowserLine]             =atol(MediaBrowser_Pos_string[MediaBrowserLine]);
              gMediaBrowser_Type[MediaBrowserLine]            =atol(MediaBrowser_Type_string[MediaBrowserLine]);
              gMediaBrowser_FileState[MediaBrowserLine]       =atol(MediaBrowser_FileState_string[MediaBrowserLine]);
              gMediaBrowser_Waveband[MediaBrowserLine]        =atol(MediaBrowser_Waveband_string[MediaBrowserLine]);
              gMediaBrowser_RadioCategory[MediaBrowserLine]   =atol(MediaBrowser_RadioCategory_string[MediaBrowserLine]);
              gMediaBrowser_FmRegCode[MediaBrowserLine]       =atol(MediaBrowser_FmRegCode_string[MediaBrowserLine]);
              gMediaBrowser_PresetID[MediaBrowserLine]        =atol(MediaBrowser_PresetID_string[MediaBrowserLine]);
              gMediaBrowser_Attributes1[MediaBrowserLine]     =atol(MediaBrowser_Attributes1_string[MediaBrowserLine]);
              gMediaBrowser_Attributes2[MediaBrowserLine]     =atol(MediaBrowser_Attributes2_string[MediaBrowserLine]);
              gMediaBrowser_PicRef[MediaBrowserLine]          =atol(MediaBrowser_PicRef_string[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"Pos[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_Pos[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"FileType[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_Type[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"FileState[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_FileState[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"FileName[%d]: %s", MediaBrowserLine, gMediaBrowser_Name[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"Waveband[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_Waveband[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"RadioCategory[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_RadioCategory[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"Frequency[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_Frequency[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"FmRegCode[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_FmRegCode[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"PresetID[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_PresetID[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"Attributes1[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_Attributes1[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"Attributes2[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_Attributes2[MediaBrowserLine]);
              writelineEx(gMediaBrowser_writeWindow, 0,"PicRef[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_PicRef[MediaBrowserLine]);
              gMediaBrowser_ListEntryValidInformation[MediaBrowserLine]  =TRUE;
              MediaBrowserLine++; // -> next line in *.csv (next record element)
            }
            current_CSV_line++; //next line in *.csv file
            element =0; //start at 'POS' (first record element of "array data")
            j=0; //reset value
          } 
          else if(current_CSV_line>0 && MediaBrowserLine<AUDIO_MEDIABROWSER_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
          {
            switch (element)
            {
              case 0: //POS
                      MediaBrowser_Pos_string[MediaBrowserLine][j] =buffer_byte[i];
                      j++;
              break;
              case 1: //Type
                      MediaBrowser_Type_string[MediaBrowserLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 2: //Name
                      gMediaBrowser_Name[MediaBrowserLine][j] =buffer_byte[i];
                      j++;                                
              break;
              case 3: //FileState
                      MediaBrowser_FileState_string[MediaBrowserLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 4: //Waveband
                      MediaBrowser_Waveband_string[MediaBrowserLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 5: //RadioCategory
                      MediaBrowser_RadioCategory_string[MediaBrowserLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 6: //Frequency
                      gMediaBrowser_Frequency[MediaBrowserLine][j] =buffer_byte[i];
                      j++;                                
              break;
              case 7: //FmRegCode
                      MediaBrowser_FmRegCode_string[MediaBrowserLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 8: //PresetID
                      MediaBrowser_PresetID_string[MediaBrowserLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 9: //Attributes1
                      MediaBrowser_Attributes1_string[MediaBrowserLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 10: //Attributes2
                      MediaBrowser_Attributes2_string[MediaBrowserLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              case 11: //PicRef
                      MediaBrowser_PicRef_string[MediaBrowserLine][j] =buffer_byte[i];                                   
                      j++;
              break;
              default:
              break;
            }
          }                               
        }         
        else  // ";" is detected ->next record element of "array data"
        {                                          
          element++;
          j=0; //reset value  
        }    
      }   
      gMediaBrowser_TotalNumListElements =gMediaBrowser_sum =MediaBrowserLine; //get "total number of list elements"
      putvalue(env_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements);
      writelineEx(gMediaBrowser_writeWindow, 0, "");
      writelineEx(gMediaBrowser_writeWindow, 0,"Anzahl der Listenelemente: %d", gMediaBrowser_sum); //output total number of list elements
      writelineEx(gMediaBrowser_writeWindow, 0, "");
      if(fileClose(CSVfileHandle) !=0) //close *.csv file
          writelineEx(gMediaBrowser_writeWindow, 0,"Datei '%s' geschlossen", gMediaBrowser_CSV_filename); //output result
      else
          writelineEx(gMediaBrowser_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gMediaBrowser_CSV_filename);//output result
    }
    else //*.csv file access not successful
    {
      writelineEx(gMediaBrowser_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'", gMediaBrowser_CSV_filename); //output result
      putvalue(env_AudioSD_MB_DataSource_result,"not successful"); //output result
    }
  }
}

byte Browser_nextvalidLine(byte current_MediaBrowserLine, byte direction)
{
  byte next_MediaBrowserLine;
  int i;

  //init lokal variables
  next_MediaBrowserLine = 0;
  i = 0;
  //search next "list entry"
  if (((gMediaBrowser_sum - 1) == current_MediaBrowserLine && FORWARD == direction) || (0 == current_MediaBrowserLine && BACKWARD == direction))  //last-/fist-element of array reached
    next_MediaBrowserLine = 0xFF;
  else
  {
    next_MediaBrowserLine = current_MediaBrowserLine + 1 - 2 * direction;       //increment or decrement array-line (depends on direction);
    if (0 == gMediaBrowser_ListEntryValidInformation[next_MediaBrowserLine])    // check if next element is "valid"
      next_MediaBrowserLine = 0xff;
  }
  return (next_MediaBrowserLine);
}

void Browser_Indication(dword Indication_array [], int datalength)
{
  byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
  word valid_startelement, requested_startelement, startelement, elements;
  int i = 0, transSuppression;

  // Init local variables. 
  mode = 0;
  shift = 0;
  direction = 0;
  transmitpos = 0;
  indexsize = 0;
  recordaddress = 0;
  requested_startelement = 0;
  startelement = 0;
  elements = 0;
  valid_startelement = 0xff;
  i = 0;
  valid_elements = 0;
  transSuppression = getvalue(env_AudioSD_MB_noStatusArray);
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      //getData
      gMediaBrowser_ASGID = (gBAP_Indication[3] & 0xF0) / 0x10;
      gMediaBrowser_TAID = gBAP_Indication[3] & 0x0F;
      //decode BAP-ArrayHeader
      mode = (gBAP_Indication[4] & 0xF0) / 0x10;
      // decode "mode-byte"
      shift = mode & 0x01;
      direction = (mode & 0x02) / 0x02;
      transmitpos = (mode & 0x04) / 0x04;
      indexsize = (mode & 0x08) / 0x08;
      recordaddress = gBAP_Indication[4] & 0x0F;
      if (indexsize)
      {
          startelement = gBAP_Indication[5];
          startelement += gBAP_Indication[6] * 0x100;
          elements = gBAP_Indication[7];
          elements += gBAP_Indication[8] * 0x100;
      }
      else
      {
          startelement = gBAP_Indication[5];
          elements = gBAP_Indication[6];
      }
      requested_startelement = startelement;
      transmitpos = TRUE; //Position must always be sent in the case of *.GetArray.  
      /***Startelement=0***/
      if (0 == startelement) //Startelement-ID =0 -> start at first array-entry
      {
        if (FORWARD == direction)  //forward-start
        {
          valid_startelement = 0;
          if (AUDIO_MEDIABROWSER_ENTRIES <= elements) //1. more elements requested, than in array
          {
            if (shift == FALSE)
            {
              for (i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++)
              {
                if (0 != gMediaBrowser_ListEntryValidInformation[i])    //if there is an valid element
                {
                  if (gMediaBrowser_Pos[i] > 0xFF) //check indexsize
                    indexsize = TRUE;
                  valid_elements++;                               //increment elements
                }
                else                                                //no valid element, loop finished
                  i = AUDIO_MEDIABROWSER_ENTRIES;
              }
            }
            else if (shift == TRUE)
            {
              valid_startelement = startelement;
              valid_elements = 0;
            }
          }
          else    //2. number of requested elements < elements in array
          {
            if (shift == FALSE)
            {
              for (i = 0; i < elements; i++)
              {
                if (0 != gMediaBrowser_ListEntryValidInformation[i])    //if there is an valid element
                {
                  if (gMediaBrowser_Pos[i] > 0xFF) //check indexsize
                    indexsize = TRUE;
                  valid_elements++;                               //increment elements
                }
                else                                                //no valid element, loop finished
                  i = AUDIO_MEDIABROWSER_ENTRIES;
              }
            }
            else if (shift == TRUE)
            {
              valid_startelement = startelement;
              valid_elements = 0;
            }
          }
        }                                                               //forward ends
        else if (BACKWARD == direction && TRUE == shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
        {
          //searching for valid startelement
          for (i = (AUDIO_MEDIABROWSER_ENTRIES - 1); i >= 0; i--)
          {
            if (0 != gMediaBrowser_ListEntryValidInformation[i])        //found valid startelement
            {
              valid_startelement = i;
              i = 0;
            }
          }
          //searching for valid elements
          if (0xff == valid_startelement)                             //Startelement-ID doesn't exist in SMSReceived-array
          {
            valid_startelement = startelement;
            valid_elements = 0;
          }
          else if (0 == valid_startelement)
            valid_elements = 1;                                       //only 1 element because valid startelement is on position 0	
          else if (elements > (valid_startelement + 1))                   //not enougth array-elements available, because array endet at array-position 0
          {
            for (i = valid_startelement; i >= 0; i--)
            {
              if (0 != gMediaBrowser_ListEntryValidInformation[i])    //if there is an valid element
              {
                if (gMediaBrowser_Pos[i] > 0xFF) //check indexsize
                  indexsize = TRUE;
                valid_elements++;                               //increment elements
              }
              else                                                //no valid element, loop finished
                i = 0;
            }
          }
          else                                                        //enougth array-elements available
          {
            for (i = valid_startelement; i > (valid_startelement - elements); i--)
            {
              if (0 != gMediaBrowser_ListEntryValidInformation[i])    //if there is an valid element
              {
                if (gMediaBrowser_Pos[i] > 0xFF) //check indexsize
                  indexsize = TRUE;
                valid_elements++;                               //increment elements
              }
              else                                                //no valid element, loop finished
                i = 0;
            }
          }
        }                                                               //backward-end
      }                                                                   //startelement ==0 -end
      /***Startelement!=0***/
      else                                                                //searching for Startelement-ID				
      {
        //searching for valid startelement
        for (i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++)
        {
          if (gMediaBrowser_Pos[i] == startelement)                       //found a valid element
          {
            if (shift == TRUE)                                          //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
            {
              if (i != 0 || BACKWARD != direction)                        //if valid_startelement is not the first array element or direction is not backwards
                valid_startelement = i + 1 - 2 * direction;
              else if (i == 0 && BACKWARD == direction)
                valid_startelement = gMediaBrowser_sum;     //valid element is last element in Array                                                
              else if (i == 0 && FORWARD == direction)
                valid_startelement = 0;                          //valid element is first element in Array
            }
            else
              valid_startelement = i;                              //found element is valid_startelement
            i = AUDIO_MEDIABROWSER_ENTRIES;
          }
        }
        if (0xff == valid_startelement)                                     //Startelement-ID doesn't exist in array
        {
          valid_startelement = startelement;
          valid_elements = 0;
        }
        else                                                                //found valid entry for startelement in array
        {
          //verify number of valid elements
          if (BACKWARD == direction)                                          //backward-start
          {
            if (valid_startelement == 0)                                    //only 1 element because valid startelement is on position 0
              valid_elements = 1;
            else if (elements > (valid_startelement + 1))                   //not enougth array-elements available, because array endet at array-position 0
            {
              for (i = valid_startelement; i >= 0; i--)
              {
                if (0 != gMediaBrowser_ListEntryValidInformation[i])    //if there is an valid element
                {
                  if (gMediaBrowser_Pos[i] > 0xFF) //check indexsize
                    indexsize = TRUE;
                  valid_elements++;                               //increment elements
                }
                else                                                //no valid element, loop finished
                  i = 0;
              }
            }
            else                                                        //enougth array-elements available
            {
              for (i = valid_startelement; i > (valid_startelement - elements); i--)
              {
                if (0 != gMediaBrowser_ListEntryValidInformation[i])    //if there is an valid element
                {
                  if (gMediaBrowser_Pos[i] > 0xFF) //check indexsize
                    indexsize = TRUE;
                  valid_elements++;                               //increment elements
                }
                else                                                //no valid element, loop finished
                  i = 0;
              }
            }
          }                                                               //backward-end
          else                                                            //forward-start
          {
            if ((valid_startelement + elements) >= AUDIO_MEDIABROWSER_ENTRIES)
            {
              for (i = valid_startelement; i < AUDIO_MEDIABROWSER_ENTRIES; i++)
              {
                if (0 != gMediaBrowser_Pos[i])                      //if there is an valid element
                {
                  if (gMediaBrowser_Pos[i] > 0xFF) //check indexsize
                    indexsize = TRUE;
                  valid_elements++;                               //increment elements
                }
                else                                                //no valid element, loop finished
                  i = AUDIO_MEDIABROWSER_ENTRIES;
              }
            }
            else
            {
              for (i = valid_startelement; i < (valid_startelement + elements); i++)
              {
                if (0 != gMediaBrowser_Pos[i])                          //if there is an valid element
                {
                  if (gMediaBrowser_Pos[i] > 0xFF) //check indexsize
                    indexsize = TRUE;
                  valid_elements++;                               //increment elements
                }
                else                                                //no valid element, loop finished
                  i = AUDIO_MEDIABROWSER_ENTRIES;
              }
            }
          }
        }
      }
      if ((valid_startelement > 0xFF) || (requested_startelement > 0xFF)) //check indexsize
        indexsize = TRUE;
      mode = shift + (direction * 0x02) + (transmitpos * 0x04) + indexsize * 0x08;
      //send StatusArray
      if (!transSuppression)
        Browser_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
      //Panel
      putvalue(env_AudioSD_MB_ASGID, gMediaBrowser_ASGID);
      putvalue(env_AudioSD_MB_TAID, gMediaBrowser_TAID);
    break;
    case Error_IND:
      writelineEx(gError_Trace, 0, "FSG_AudioSD MediaBrowser_Indication: received error, errorcode:0x%x", Indication_array[3]);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD MediaBrowser_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void Browser_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements, byte errorcode)
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word MediaBrowserLine;

    // Init local variables. 
    for (i = 0; i < BAP_BUFFER_SIZE; i++)
        requestarray[i] = 0;
    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    MediaBrowserLine = 0;
    current_element = 0;
    Offset = 0;
    // decode "mode-byte"
    shift = mode & 0x01;
    direction = (mode & 0x02) / 0x02;
    transmitpos = (mode & 0x04) / 0x04;
    indexsize = (mode & 0x08) / 0x08;
    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_Browser;       //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;
    switch (request)
    {
        case Changed_REQ:
            /***ArrayHeader***/
            requestarray[Offset] = ((mode * 0x10) & 0xF0) + (recordaddress & 0x0F);
            Offset++;
            if (indexsize)
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = (requested_startelement & 0xff00) / 0x100;
                Offset++;
                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = (elements & 0xff00) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }
            MediaBrowserLine = startelement;
            if (getvalue(env_AudioSD_MB_CA_switch)) //ArrayData
            {
                //copy data
                switch (recordaddress)
                {
                    case 0: //complete record (FRU)
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Type
                                requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gMediaBrowser_Name[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Name[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Name[MediaBrowserLine][i];
                                    Offset++;
                                }
                                //FileState
                                requestarray[Offset] = gMediaBrowser_FileState[MediaBrowserLine];
                                Offset++;
                                //Waveband
                                requestarray[Offset] = gMediaBrowser_Waveband[MediaBrowserLine];
                                Offset++;
                                //RadioCategory
                                requestarray[Offset] = gMediaBrowser_RadioCategory[MediaBrowserLine];
                                Offset++;
                                //Frequency
                                requestarray[Offset] = strlen(gMediaBrowser_Frequency[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Frequency[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Frequency[MediaBrowserLine][i];
                                    Offset++;
                                }
                                //FmRegCode
                                requestarray[Offset] = gMediaBrowser_FmRegCode[MediaBrowserLine];
                                Offset++;
                                //PresetID
                                requestarray[Offset] = gMediaBrowser_PresetID[MediaBrowserLine];
                                Offset++;
                                //Attributes1
                                requestarray[Offset] = gMediaBrowser_Attributes1[MediaBrowserLine];
                                Offset++;
                                //Attributes2
                                requestarray[Offset] = gMediaBrowser_Attributes2[MediaBrowserLine];
                                Offset++;
                                //PictureReference
                                requestarray[Offset] = (gMediaBrowser_PicRef[MediaBrowserLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gMediaBrowser_PicRef[MediaBrowserLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;
                    case 1: //complete record
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Type
                                requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gMediaBrowser_Name[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Name[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Name[MediaBrowserLine][i];
                                    Offset++;
                                }
                                //FileState
                                requestarray[Offset] = gMediaBrowser_FileState[MediaBrowserLine];
                                Offset++;
                                //Waveband
                                requestarray[Offset] = gMediaBrowser_Waveband[MediaBrowserLine];
                                Offset++;
                                //RadioCategory
                                requestarray[Offset] = gMediaBrowser_RadioCategory[MediaBrowserLine];
                                Offset++;
                                //Frequency
                                requestarray[Offset] = strlen(gMediaBrowser_Frequency[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Frequency[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Frequency[MediaBrowserLine][i];
                                    Offset++;
                                }
                                //FmRegCode
                                requestarray[Offset] = gMediaBrowser_FmRegCode[MediaBrowserLine];
                                Offset++;
                                //PresetID
                                requestarray[Offset] = gMediaBrowser_PresetID[MediaBrowserLine];
                                Offset++;
                                //Attributes1
                                requestarray[Offset] = gMediaBrowser_Attributes1[MediaBrowserLine];
                                Offset++;
                                //Attributes2
                                requestarray[Offset] = gMediaBrowser_Attributes2[MediaBrowserLine];
                                Offset++;
                                //PictureReference
                                requestarray[Offset] = (gMediaBrowser_PicRef[MediaBrowserLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gMediaBrowser_PicRef[MediaBrowserLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;
                    case 2: //Type,Name,Waveband,RadioCategory,Frequency,FmRegCode,PresetID,Attributes1&2,PicRef
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Type
                                requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gMediaBrowser_Name[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Name[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Name[MediaBrowserLine][i];
                                    Offset++;
                                }
                                //Waveband
                                requestarray[Offset] = gMediaBrowser_Waveband[MediaBrowserLine];
                                Offset++;
                                //RadioCategory
                                requestarray[Offset] = gMediaBrowser_RadioCategory[MediaBrowserLine];
                                Offset++;
                                //Frequency
                                requestarray[Offset] = strlen(gMediaBrowser_Frequency[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Frequency[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Frequency[MediaBrowserLine][i];
                                    Offset++;
                                }
                                //FmRegCode
                                requestarray[Offset] = gMediaBrowser_FmRegCode[MediaBrowserLine];
                                Offset++;
                                //PresetID
                                requestarray[Offset] = gMediaBrowser_PresetID[MediaBrowserLine];
                                Offset++;
                                //Attributes1
                                requestarray[Offset] = gMediaBrowser_Attributes1[MediaBrowserLine];
                                Offset++;
                                //Attributes2
                                requestarray[Offset] = gMediaBrowser_Attributes2[MediaBrowserLine];
                                Offset++;
                                //PictureReference
                                requestarray[Offset] = (gMediaBrowser_PicRef[MediaBrowserLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gMediaBrowser_PicRef[MediaBrowserLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;   
                    case 3: //Type,Name,FileState,PicRef
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Type
                                requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gMediaBrowser_Name[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Name[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Name[MediaBrowserLine][i];
                                    Offset++;
                                }
                                //FileState
                                requestarray[Offset] = gMediaBrowser_FileState[MediaBrowserLine];
                                Offset++;
                                //PictureReference
                                requestarray[Offset] = (gMediaBrowser_PicRef[MediaBrowserLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gMediaBrowser_PicRef[MediaBrowserLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;
                    case 4: //Type,WB,Attr1&2
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Type
                                requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                                Offset++;
                                //Waveband
                                requestarray[Offset] = gMediaBrowser_Waveband[MediaBrowserLine];
                                Offset++;
                                //Attributes1
                                requestarray[Offset] = gMediaBrowser_Attributes1[MediaBrowserLine];
                                Offset++;
                                //Attributes2
                                requestarray[Offset] = gMediaBrowser_Attributes2[MediaBrowserLine];
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;    
                    case 5: //Type,FileState
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Type
                                requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                                Offset++;
                                //FileState
                                requestarray[Offset] = gMediaBrowser_FileState[MediaBrowserLine];
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;    
                    case 6: //Name
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Name
                                requestarray[Offset] = strlen(gMediaBrowser_Name[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Name[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Name[MediaBrowserLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;    
                    case 7: //Frequency
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Frequency
                                requestarray[Offset] = strlen(gMediaBrowser_Frequency[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Frequency[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Frequency[MediaBrowserLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;    
                    case 8: //Attr1&2
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Attributes1
                                requestarray[Offset] = gMediaBrowser_Attributes1[MediaBrowserLine];
                                Offset++;
                                //Attributes2
                                requestarray[Offset] = gMediaBrowser_Attributes2[MediaBrowserLine];
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;    
                    case 9: //PicRef
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //PictureReference
                                requestarray[Offset] = (gMediaBrowser_PicRef[MediaBrowserLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gMediaBrowser_PicRef[MediaBrowserLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;
                    case 15: //Pos
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0x00FF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);

                        }//end while
                        break;

                    default:
                        write("AudioSD MediaBrowser_Request: invalid recordaddress %d", recordaddress);
                        break;
                } //end switch "recordaddress"
            }// end 'ArrayData'
            set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
        break; //end Changed_REQ
        case Data_REQ:
            requestarray[Offset] = ((gMediaBrowser_ASGID * 0x10) & 0xF0) + (gMediaBrowser_TAID & 0x0F);
            Offset++;
            requestarray[Offset] = gMediaBrowser_TotalNumListElements & 0xff;
            Offset++;
            requestarray[Offset] = (gMediaBrowser_TotalNumListElements & 0xff00) / 0x100;
            Offset++;
            requestarray[Offset] = gMediaBrowser_ActiveListPos & 0xff;
            Offset++;
            requestarray[Offset] = (gMediaBrowser_ActiveListPos & 0xff00) / 0x100;
            Offset++;
            /***ArrayHeader***/
            requestarray[Offset] = ((mode * 0x10) & 0xF0) + (recordaddress & 0x0F);
            Offset++;
            if (indexsize)
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = (requested_startelement & 0xff00) / 0x100;
                Offset++;
                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = (elements & 0xff00) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }
            MediaBrowserLine = startelement;
            //copy data
            switch (recordaddress)
            {
                case 0: //complete record (FRU)
                  while (current_element < elements)
                      {
                          if (MediaBrowserLine == 0xff) //Invalid "list entry"
                          {
                              write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                              current_element = elements;
                          }
                          else //"list entry" valid
                          {
                              /***Array Data***/
                              if (transmitpos) // Pos  ->Array position transmitted
                              {
                                  if (indexsize)
                                  {
                                      requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                      Offset++;
                                      requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                      Offset++;
                                  }
                                  else
                                  {
                                      requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                      Offset++;
                                  }
                              }
                              //Type
                              requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                              Offset++;
                              //Name
                              requestarray[Offset] = strlen(gMediaBrowser_Name[MediaBrowserLine]);
                              Offset++;
                              for (i = 0; i < strlen(gMediaBrowser_Name[MediaBrowserLine]); i++)
                              {
                                  requestarray[Offset] = gMediaBrowser_Name[MediaBrowserLine][i];
                                  Offset++;
                              }
                              //FileState
                              requestarray[Offset] = gMediaBrowser_FileState[MediaBrowserLine];
                              Offset++;
                              //Waveband
                              requestarray[Offset] = gMediaBrowser_Waveband[MediaBrowserLine];
                              Offset++;
                              //RadioCategory
                              requestarray[Offset] = gMediaBrowser_RadioCategory[MediaBrowserLine];
                              Offset++;
                              //Frequency
                              requestarray[Offset] = strlen(gMediaBrowser_Frequency[MediaBrowserLine]);
                              Offset++;
                              for (i = 0; i < strlen(gMediaBrowser_Frequency[MediaBrowserLine]); i++)
                              {
                                  requestarray[Offset] = gMediaBrowser_Frequency[MediaBrowserLine][i];
                                  Offset++;
                              }
                              //FmRegCode
                              requestarray[Offset] = gMediaBrowser_FmRegCode[MediaBrowserLine];
                              Offset++;
                              //PresetID
                              requestarray[Offset] = gMediaBrowser_PresetID[MediaBrowserLine];
                              Offset++;
                              //Attributes1
                              requestarray[Offset] = gMediaBrowser_Attributes1[MediaBrowserLine];
                              Offset++;
                              //Attributes2
                              requestarray[Offset] = gMediaBrowser_Attributes2[MediaBrowserLine];
                              Offset++;
                              //PictureReference
                              requestarray[Offset] = (gMediaBrowser_PicRef[MediaBrowserLine] & 0x00FF);
                              Offset++;
                              requestarray[Offset] = ((gMediaBrowser_PicRef[MediaBrowserLine] & 0xFF00) / 0x100);
                              Offset++;
                          }
                          current_element++;
                          MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                      }//end while
                      set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                  break;
                case 1: //complete record
                  while (current_element < elements)
                      {
                          if (MediaBrowserLine == 0xff) //Invalid "list entry"
                          {
                              write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                              current_element = elements;
                          }
                          else //"list entry" valid
                          {
                              /***Array Data***/
                              if (transmitpos) // Pos  ->Array position transmitted
                              {
                                  if (indexsize)
                                  {
                                      requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                      Offset++;
                                      requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                      Offset++;
                                  }
                                  else
                                  {
                                      requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                      Offset++;
                                  }
                              }
                              //Type
                              requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                              Offset++;
                              //Name
                              requestarray[Offset] = strlen(gMediaBrowser_Name[MediaBrowserLine]);
                              Offset++;
                              for (i = 0; i < strlen(gMediaBrowser_Name[MediaBrowserLine]); i++)
                              {
                                  requestarray[Offset] = gMediaBrowser_Name[MediaBrowserLine][i];
                                  Offset++;
                              }
                              //FileState
                              requestarray[Offset] = gMediaBrowser_FileState[MediaBrowserLine];
                              Offset++;
                              //Waveband
                              requestarray[Offset] = gMediaBrowser_Waveband[MediaBrowserLine];
                              Offset++;
                              //RadioCategory
                              requestarray[Offset] = gMediaBrowser_RadioCategory[MediaBrowserLine];
                              Offset++;
                              //Frequency
                              requestarray[Offset] = strlen(gMediaBrowser_Frequency[MediaBrowserLine]);
                              Offset++;
                              for (i = 0; i < strlen(gMediaBrowser_Frequency[MediaBrowserLine]); i++)
                              {
                                  requestarray[Offset] = gMediaBrowser_Frequency[MediaBrowserLine][i];
                                  Offset++;
                              }
                              //FmRegCode
                              requestarray[Offset] = gMediaBrowser_FmRegCode[MediaBrowserLine];
                              Offset++;
                              //PresetID
                              requestarray[Offset] = gMediaBrowser_PresetID[MediaBrowserLine];
                              Offset++;
                              //Attributes1
                              requestarray[Offset] = gMediaBrowser_Attributes1[MediaBrowserLine];
                              Offset++;
                              //Attributes2
                              requestarray[Offset] = gMediaBrowser_Attributes2[MediaBrowserLine];
                              Offset++;
                              //PictureReference
                              requestarray[Offset] = (gMediaBrowser_PicRef[MediaBrowserLine] & 0x00FF);
                              Offset++;
                              requestarray[Offset] = ((gMediaBrowser_PicRef[MediaBrowserLine] & 0xFF00) / 0x100);
                              Offset++;
                          }
                          current_element++;
                          MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                      }//end while
                      set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                  break;
                case 2: //Type,Name,Waveband,RadioCategory,Frequency,FmRegCode,PresetID,Attributes1&2,PicRef
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Type
                                requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gMediaBrowser_Name[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Name[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Name[MediaBrowserLine][i];
                                    Offset++;
                                }
                                //Waveband
                                requestarray[Offset] = gMediaBrowser_Waveband[MediaBrowserLine];
                                Offset++;
                                //RadioCategory
                                requestarray[Offset] = gMediaBrowser_RadioCategory[MediaBrowserLine];
                                Offset++;
                                //Frequency
                                requestarray[Offset] = strlen(gMediaBrowser_Frequency[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Frequency[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Frequency[MediaBrowserLine][i];
                                    Offset++;
                                }
                                //FmRegCode
                                requestarray[Offset] = gMediaBrowser_FmRegCode[MediaBrowserLine];
                                Offset++;
                                //PresetID
                                requestarray[Offset] = gMediaBrowser_PresetID[MediaBrowserLine];
                                Offset++;
                                //Attributes1
                                requestarray[Offset] = gMediaBrowser_Attributes1[MediaBrowserLine];
                                Offset++;
                                //Attributes2
                                requestarray[Offset] = gMediaBrowser_Attributes2[MediaBrowserLine];
                                Offset++;
                                //PictureReference
                                requestarray[Offset] = (gMediaBrowser_PicRef[MediaBrowserLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gMediaBrowser_PicRef[MediaBrowserLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;   
                    case 3: //Type,Name,FileState,PicRef
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Type
                                requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen(gMediaBrowser_Name[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Name[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Name[MediaBrowserLine][i];
                                    Offset++;
                                }
                                //FileState
                                requestarray[Offset] = gMediaBrowser_FileState[MediaBrowserLine];
                                Offset++;
                                //PictureReference
                                requestarray[Offset] = (gMediaBrowser_PicRef[MediaBrowserLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gMediaBrowser_PicRef[MediaBrowserLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;
                    case 4: //Type,WB,Attr1&2
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Type
                                requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                                Offset++;
                                //Waveband
                                requestarray[Offset] = gMediaBrowser_Waveband[MediaBrowserLine];
                                Offset++;
                                //Attributes1
                                requestarray[Offset] = gMediaBrowser_Attributes1[MediaBrowserLine];
                                Offset++;
                                //Attributes2
                                requestarray[Offset] = gMediaBrowser_Attributes2[MediaBrowserLine];
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;    
                    case 5: //Type,FileState
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Type
                                requestarray[Offset] = gMediaBrowser_Type[MediaBrowserLine];
                                Offset++;
                                //FileState
                                requestarray[Offset] = gMediaBrowser_FileState[MediaBrowserLine];
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;    
                    case 6: //Name
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Name
                                requestarray[Offset] = strlen(gMediaBrowser_Name[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Name[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Name[MediaBrowserLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;    
                    case 7: //Frequency
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Frequency
                                requestarray[Offset] = strlen(gMediaBrowser_Frequency[MediaBrowserLine]);
                                Offset++;
                                for (i = 0; i < strlen(gMediaBrowser_Frequency[MediaBrowserLine]); i++)
                                {
                                    requestarray[Offset] = gMediaBrowser_Frequency[MediaBrowserLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;    
                    case 8: //Attr1&2
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //Attributes1
                                requestarray[Offset] = gMediaBrowser_Attributes1[MediaBrowserLine];
                                Offset++;
                                //Attributes2
                                requestarray[Offset] = gMediaBrowser_Attributes2[MediaBrowserLine];
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;    
                    case 9: //PicRef
                        while (current_element < elements)
                        {
                            if (MediaBrowserLine == 0xff) //Invalid "list entry"
                            {
                                write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0xFF);
                                        Offset++;
                                        requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                                //PictureReference
                                requestarray[Offset] = (gMediaBrowser_PicRef[MediaBrowserLine] & 0x00FF);
                                Offset++;
                                requestarray[Offset] = ((gMediaBrowser_PicRef[MediaBrowserLine] & 0xFF00) / 0x100);
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                        }//end while
                    break;
                case 15: //Pos
                    while (current_element < elements)
                    {
                        if (MediaBrowserLine == 0xff) //Invalid "list entry"
                        {
                            write("AudioSD MediaBrowser_Request: invalid MediaBrowserLine");
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if (transmitpos) // Pos  ->Array position transmitted
                            {
                                if (indexsize)
                                {
                                    requestarray[Offset] = (gMediaBrowser_Pos[MediaBrowserLine] & 0x00FF);
                                    Offset++;
                                    requestarray[Offset] = ((gMediaBrowser_Pos[MediaBrowserLine] & 0xFF00) / 0x100);
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                    Offset++;
                                }
                            }
                        }
                        current_element++;
                        MediaBrowserLine = Browser_nextvalidLine(MediaBrowserLine, direction);
                    }//end while
                    set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
                break;
                default:
                    write("AudioSD MediaBrowser_Request: invalid recordaddress %d", recordaddress);
                break;
            } //end switch "recordaddress"
        break; //end Data_REQ
        case Error_REQ:
            requestarray[3] = errorcode;
            set_status_requestbuffer(requestarray, 4, Bap_Error);
        break; //end Error_REQ
    } //end switch "request"   
}

//*************************************************************************
//*****************BrowserPath*********************************************
on envVar env_AudioSD_MedPath_update
{
  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    gAudioSD_MediaPath_FolderType =getvalue(env_AudioSD_MedPath_Type);
    getvalue(env_AudioSD_MedPath_Path_s, gAudioSD_MediaPath_Path);
    BrowserPath_Request(Data_REQ, 0);
  }
}

void BrowserPath_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      BrowserPath_Request(Data_REQ, 0);    //send status
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD BrowserPath_Indication: invalid indication %d", Indication_array[2]);
    break;
  }
}

void BrowserPath_Request(byte request, byte errorcode)
{
  int i, Offset = 0;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;      //LSG-ID
  requestarray[1] = FctID_BrowserPath;  //Fct.-ID
  requestarray[2] = request;           //request type
  switch (request)
  {
    case Data_REQ:
      requestarray[3] = gAudioSD_MediaPath_FolderType;
      requestarray[4] = strlen(gAudioSD_MediaPath_Path);
      Offset = 5;
      for (i = 0; i < strlen(gAudioSD_MediaPath_Path); i++)
      {
        requestarray[Offset] = gAudioSD_MediaPath_Path[i];
        Offset++;
      }
      set_status_requestbuffer(requestarray, Offset, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:
      writelineEx(gError_Trace, 0, "FSG_AudioSD BrowserPath_Request: invalid request %d", request);
    break;
  }
}

//*************************************************************************
//*****************BrowserControl******************************************
on envVar env_AudioSD_MBrC_ResBtn
{
	if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this)) 
	{
		gAudioSD_MediaBrowserControl_AsgId =getvalue(env_AudioSD_MBrC_AsgId);
    gAudioSD_MediaBrowserControl_Extension1 =getvalue(env_AudioSD_MBrC_Ext1);
    gAudioSD_MediaBrowserControl_Result =getvalue(env_AudioSD_MBrC_Res);
    BrowserControl_Request(Result_REQ, 0);
	}
}

void BrowserControl_Indication(dword Indication_array [], int datalength)
{
  switch (Indication_array[2])
  {
    case Processing_CNF:
      BrowserControl_Request(Processing_REQ, 0);          //send Processing
    break;
    case StartResult_IND:
      if (getvalue(env_AudioSD_MBrC_Error_on))
        BrowserControl_Request(Error_REQ, getvalue(env_AudioSD_MBrC_ErrorCode));
      else
      {
        if (FALSE == gAudioSD_MediaBrowserControl_status)
        {
          gAudioSD_MediaBrowserControl_status = TRUE;                         //method active
          //get data
          gAudioSD_MediaBrowserControl_AsgId = Indication_array[3]/0x10;
          gAudioSD_MediaBrowserControl_Extension1 = Indication_array[3]&0x0F;
          gAudioSD_MediaBrowserControl_Control = Indication_array[4];
          gAudioSD_MediaBrowserControl_Reference = Indication_array[5] + (Indication_array[6] * 0x100);
          if (gAudioSD_MediaBrowserControl_Control > 0x04)
          {
            BrowserControl_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE);
            gAudioSD_MediaBrowserControl_status = FALSE;
          }
          else //received data valid
            settimer(MediaBrowserControl_Timer, MediaBrowserControl_TimerTime);
        }
      }
    break;
    case Abort_IND:
      if (getvalue(env_AudioSD_MBrC_Error_on))
        BrowserControl_Request(Error_REQ, getvalue(env_AudioSD_MBrC_ErrorCode));
      else
      {
        if (FALSE == gAudioSD_MediaBrowserControl_status)                                //method not active					
          BrowserControl_Request(Error_REQ, 0x50);           //send error-message
        else if (TRUE == gAudioSD_MediaBrowserControl_status)       //method still active
        {
          gAudioSD_MediaBrowserControl_Result = getvalue(env_AudioSD_MBrC_Abort);
          if (AUDIO_MEDIABROWSERCONTROL_ABORT_SUCCESSFUL == gAudioSD_MediaBrowserControl_Result)      //only, if abort is successful
          {
            canceltimer(MediaBrowserControl_Timer);                             //abort method
            gAudioSD_MediaBrowserControl_status = FALSE;                            //method finished
          }
          BrowserControl_Request(Result_REQ, 0); //send result-message				
        }
      }
    break;
    default:
      writelineEx(gError_Trace, 0, "AudioSD BrowserControl_Indication: unknown indication %d", Indication_array[2]);
    break;
  }
}

void BrowserControl_Request(byte request, byte errorcode)
{
  int i;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables. 
  for (i = 0; i < BAP_BUFFER_SIZE; i++)
    requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;                //LSG-ID
  requestarray[1] = FctID_BrowserControl;   //Fct.-ID
  requestarray[2] = request;
  switch (request)
  {
    case Processing_REQ:
      requestarray[3] = (gAudioSD_MediaBrowserControl_AsgId*0x10) + (gAudioSD_MediaBrowserControl_Extension1&0x0F);
      requestarray[4] = gAudioSD_MediaBrowserControl_Reserve;
      set_status_requestbuffer(requestarray, 5, Bap_ByteSequence);
    break;
    case Result_REQ:
      requestarray[3] = (gAudioSD_MediaBrowserControl_AsgId*0x10) + (gAudioSD_MediaBrowserControl_Extension1&0x0F);
      requestarray[4] = gAudioSD_MediaBrowserControl_Result;
      set_status_requestbuffer(requestarray, 5, Bap_ByteSequence);
    break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer(requestarray, 4, Bap_Error);
    break;
    default:    //error
      writelineEx(gError_Trace, 0, "AudioSD BrowserControl_Request: unknown request %d", request);
    break;
  }
}

on timer MediaBrowserControl_Timer
{
  gAudioSD_MediaBrowserControl_Result =getvalue(env_AudioSD_MBrC_Res);
  if (gAudioSD_MediaBrowserControl_Result !=AUDIO_MEDIABROWSERCONTROL_NOT_SUCCESSFUL && gAudioSD_MediaBrowserControl_status ==TRUE)    
  {
    //Panel
    putvalue(env_AudioSD_MBrC_AsgId, gAudioSD_MediaBrowserControl_AsgId);
    putvalue(env_AudioSD_MBrC_Ext1, gAudioSD_MediaBrowserControl_Extension1);
    putvalue(env_AudioSD_MBrC_Control, gAudioSD_MediaBrowserControl_Control);
    putvalue(env_AudioSD_MBrC_Ref, gAudioSD_MediaBrowserControl_Reference);
  }
  BrowserControl_Request(Result_REQ, 0); //send Result
  gAudioSD_MediaBrowserControl_status =FALSE; //method not active    
}

//*************************************************************************
//*****************Picture*************************************************
on envVar env_AudioSD_Pic_FullRangeUpd
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;
  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;

  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    recordaddress   =0;
    shift           =0;
    direction       =0;
    transmitpos     =0;
    indexsize       =1;
    startelement    =0;
    elements        =65535;
    
    putvalue(env_AudioSD_Pic_AH_RecordAdd,recordaddress);
    putvalue(env_AudioSD_Pic_AH_Shift,shift);
    putvalue(env_AudioSD_Pic_AH_Dir,direction);
    putvalue(env_AudioSD_Pic_AH_TransPos,transmitpos);
    putvalue(env_AudioSD_Pic_AH_IndexSize,indexsize);
    putvalue(env_AudioSD_Pic_AH_Start,startelement);
    putvalue(env_AudioSD_Pic_AH_Elements,elements);
    mode = shift+(direction*0x02)+(transmitpos*0x04)+indexsize*0x08;

    //send ChangedArray
    Picture_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
  }
}

on envVar env_AudioSD_Pic_Changed
{
  word requested_startelement, startelement, elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
  int i;
  
  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;

  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
  {
    //get data from Panel
    recordaddress   = getvalue(env_AudioSD_Pic_AH_RecordAdd);
    shift           = getvalue(env_AudioSD_Pic_AH_Shift);
    direction       = getvalue(env_AudioSD_Pic_AH_Dir);
    transmitpos     = getvalue(env_AudioSD_Pic_AH_TransPos);
    indexsize       = getvalue(env_AudioSD_Pic_AH_IndexSize);
    startelement    = getvalue(env_AudioSD_Pic_AH_Start);
    elements        = getvalue(env_AudioSD_Pic_AH_Elements);
    mode            = shift+(direction*0x02)+(transmitpos*0x04)+indexsize*0x08;
    requested_startelement =startelement;

    if(getvalue(env_AudioSD_Pic_Changed_wData)==0 || getvalue(env_AudioSD_Pic_Changed_wData)==1) // ArrayHeader (+ Data)
    {
      /***Startelement=0***/
      if(0==startelement) //Startelement-ID =0 -> start at first array-entry
	    {
        if(FORWARD==direction)  //forward-start
		    {
          valid_startelement =0;				       									
          if(AUDIO_PICTURE_ENTRIES <=elements) //1. more elements requested, than in array
			    {
            if (shift ==FALSE)  
            {
              for(i=0;i<AUDIO_PICTURE_ENTRIES;i++)
			        {
                if(0 !=gPicture_ListEntryValidInformation[i])	//if there is an valid element
                {
                  if(gPicture_Pos[i] >0xff)
                  {
                    indexsize =TRUE;
                  }
                  valid_elements++;								//increment elements
					      }    
                else												//no valid element, loop finished
                {
						        i =AUDIO_PICTURE_ENTRIES;
                }
				      }
            }
            else
            {   
              valid_startelement  =startelement;
			        valid_elements      =0;
            }
			    }
          else    //2. number of requested elements < elements in array
			    {
            if (shift ==FALSE)
            {
			        for(i=0;i<elements;i++)
			        {
					      if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
                {
                  if(gPicture_Pos[i] >0xff)
                  {
                    indexsize =TRUE;
                  }
                  valid_elements++;								//increment elements
				        }
					      else												//no valid element, loop finished
						    {
                  i =AUDIO_PICTURE_ENTRIES;
                }
				      }
            }
            else
            {
              valid_startelement  =startelement;
			        valid_elements      =0;
            }
			    }
        }                                                               //forward ends
        else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
		    {   
			    //searching for valid startelement
			    for(i=(AUDIO_PICTURE_ENTRIES-1);i>=0;i--)
			    {
				    if(0!=gPicture_ListEntryValidInformation[i])		//found valid startelement
				    {
					    valid_startelement =i;								
					    i =0;												
				    }
			    } 
          //searching for valid elements
			    if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
			    {
				    valid_startelement  =startelement;
				    valid_elements      =0;
			    }
			    else if(0==valid_startelement)								
          {
				    valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
          }
			    else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
			    {
				    for(i=valid_startelement;i>=0;i--)
				    {
					    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
						  {
                if(gPicture_Pos[i] >0xff)
                {
                  indexsize =TRUE;
                }
                valid_elements++;								//increment elements
					    }
              else												//no valid element, loop finished
              {
						    i=0;
              }
				    }
			    }
          else														//enougth array-elements available
			    {
				    for(i=valid_startelement;i>(valid_startelement-elements);i--)
				    {
					    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
						  {
                valid_elements++;								//increment elements
                if(gPicture_Pos[i] >0xff)
                {
                  indexsize =TRUE;
                }
              }
              else												//no valid element, loop finished
              {
						    i=0;
              }
			    	}                 
			    }															
	      }  //backward-end
      }    //startelement ==0 -end
      /***Startelement!=0***/
      else	//searching for Startelement-ID				
	    {
		    //searching for valid startelement
		    for(i=0;i<AUDIO_PICTURE_ENTRIES;i++)
		    {
			    if(gPicture_Pos[i] ==startelement)					    //found a valid element
			    {                                          
            if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
				    {
					    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
              {
						    valid_startelement =i+1-2*direction;
              }           							
              else if(i==0 && BACKWARD==direction) 
              {
                valid_startelement =gPicture_sum;     //valid element is last element in Array                                                
              }        
              else if(i==0 && FORWARD==direction) 
              {
                valid_startelement =0;                          //valid element is first element in Array
              }
            }
            else
            {
              valid_startelement =i;                              //found element is valid_startelement
            }
				    i=AUDIO_PICTURE_ENTRIES;
			    }
		    }
		    if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
		    {
			    valid_startelement  =startelement;
			    valid_elements      =0;
		    }
		    else																//found valid entry for startelement in array
		    {
			    //verify number of valid elements
			    if(BACKWARD==direction)											//backward-start
			    {
				    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
            {
					    valid_elements=1;
            }
				    else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				    {
					    for(i=valid_startelement;i>=0;i--)
					    {
						    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
							  {
                  if(gPicture_Pos[i] >0xff)
                  {
                    indexsize =TRUE;
                  }
                  valid_elements++;								//increment elements
						    }
                else												//no valid element, loop finished
                {
							    i=0;
                }
					    }
				    }
				    else														//enougth array-elements available
				    {
					    for(i=valid_startelement;i>(valid_startelement-elements);i--)
					    {
						    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
							  { 
                  if(gPicture_Pos[i] >0xff)
                  {
                    indexsize =TRUE;
                  }
                  valid_elements++;								//increment elements
                }
                else												//no valid element, loop finished
                {
							    i=0;
                }
					    }
				    }
			    }																//backward-end
			    else															//forward-start
			    {
				    if((valid_startelement+elements)>=AUDIO_PICTURE_ENTRIES)
				    {
					    for(i=valid_startelement;i<AUDIO_PICTURE_ENTRIES;i++)
					    {   
						    if(0!=gPicture_Pos[i])							//if there is an valid element
							  {
                  if(gPicture_Pos[i] >0xff)
                  {
                    indexsize =TRUE;
                  }
                  valid_elements++;								//increment elements
						    }
                else    												//no valid element, loop finished
                {
							    i=AUDIO_PICTURE_ENTRIES;
                }
					    }
				    }
				    else
				    {
					    for(i=valid_startelement;i<(valid_startelement+elements);i++)
					    {
						    if(0!=gPicture_Pos[i])						    //if there is an valid element
							  {
                  if(gPicture_Pos[i] >0xff)
                  {
                    indexsize =TRUE;
                  }
                  valid_elements++;								//increment elements
						    }
                else												//no valid element, loop finished
                {
							    i=AUDIO_PICTURE_ENTRIES;
                }
					    }
				    }
			    }
	    	} //END: if(BACKWARD==direction)	
	    } //END: if(0==startelement)                
      transmitpos =TRUE;
      if((requested_startelement >0xFF) || (valid_startelement >0xFF))
      {
        indexsize =TRUE;
      }
      mode = shift+(direction*0x02)+(transmitpos*0x04)+indexsize*0x08;
      //send StatusArray
      Picture_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);   
    } // END: if(getvalue(env_NaviSD_AL_CA_switch))
  }//END: if(gNaviSD_PowerOnOff==POWER_ON && getvalue(env_NaviSD_Pic_Changed))
}

on envVar env_AudioSD_Pic_Status
{
  word requested_startelement, startelement, elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
  int i, transSuppression;
  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;
  transSuppression        = getvalue(env_AudioSD_Pic_StatusOFF);

  if(gAudioSD_PowerOnOff==POWER_ON && getvalue(this))
	{
    //get data from Panel
    gPicture_ASGID                 = getvalue(env_AudioSD_Pic_AsgId);
    gPicture_TAID                  = getvalue(env_AudioSD_Pic_TAID);
    gPicture_TotalNumListElements  = getvalue(env_AudioSD_Pic_TNLE);
    recordaddress   = getvalue(env_AudioSD_Pic_AH_RecordAdd);
    shift           = getvalue(env_AudioSD_Pic_AH_Shift);
    direction       = getvalue(env_AudioSD_Pic_AH_Dir);
    transmitpos     = getvalue(env_AudioSD_Pic_AH_TransPos);
    indexsize       = getvalue(env_AudioSD_Pic_AH_IndexSize);
    startelement    = getvalue(env_AudioSD_Pic_AH_Start);
    elements        = getvalue(env_AudioSD_Pic_AH_Elements);
    mode            =shift+(direction*0x02)+(transmitpos*0x04)+indexsize*0x08;
    requested_startelement = startelement;

    /***Startelement=0***/
    if(0==startelement) //Startelement-ID =0 -> start at first array-entry
		{
      if(FORWARD==direction)  //forward-start
			{
        valid_startelement =0;				       									
        if(AUDIO_PICTURE_ENTRIES <=elements) //1. more elements requested, than in array
				{
          if (shift ==FALSE)  
          {
            for(i=0;i<AUDIO_PICTURE_ENTRIES;i++)
						{
					    if(0 !=gPicture_ListEntryValidInformation[i])	//if there is an valid element
              {
						    valid_elements++;								//increment elements
              }
					    else												//no valid element, loop finished
              {
						    i =AUDIO_PICTURE_ENTRIES;
              }
					  }
          }
          else 
          {   
            valid_startelement  =startelement;
				    valid_elements      =0;
          }
			  }
        else    //2. number of requested elements < elements in array
				{
          if (shift ==FALSE)
          {
					  for(i=0;i<elements;i++)
						{
					    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
              {
						    valid_elements++;								//increment elements
              }
					    else												//no valid element, loop finished
              {
					      i =AUDIO_PICTURE_ENTRIES;
              }
					  }
          }
          else 
          {   
            valid_startelement  =startelement;
  			    valid_elements      =0;
          }
				}
      }  //forward ends 
      else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
			{   
			  //searching for valid startelement
				for(i=(AUDIO_PICTURE_ENTRIES-1);i>=0;i--)
				{
				  if(0!=gPicture_ListEntryValidInformation[i])		//found valid startelement
					{
					  valid_startelement =i;								
						i =0;												
					}
				}            
        //searching for valid elements
				if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
				{
				  valid_startelement  =startelement;
					valid_elements      =0;
				}
				else if(0==valid_startelement)								
        {
				  valid_elements=1;                                       //only 1 element because valid startelement is on position 0	
        }	
				else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				{
				  for(i=valid_startelement;i>=0;i--)
					{
				    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
            {
					    valid_elements++;								//increment elements
            }
						else												//no valid element, loop finished
            {
						    i=0;
            }
				  }
				}
        else	//enougth array-elements available
				{
				  for(i=valid_startelement;i>(valid_startelement-elements);i--)
					{
				    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
            {
					    valid_elements++;								//increment elements
            }
						else												//no valid element, loop finished
            {
							i=0;
            }
					}                   
				}															
	    }  //backward-end
    }    //startelement ==0 -end
    /***Startelement!=0***/
    else //searching for Startelement-ID				
		{
		  //searching for valid startelement
			for(i=0;i<AUDIO_PICTURE_ENTRIES;i++)
			{
				if(gPicture_Pos[i] ==startelement)					    //found a valid element
				{                                       
          if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
					{
				    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
            {
					    valid_startelement =i+1-2*direction;            							
            }
            else if(i==0 && BACKWARD==direction) 
            {
              valid_startelement =gPicture_sum;     //valid element is last element in Array                                                
            }                
            else if(i==0 && FORWARD==direction) 
            {
              valid_startelement =0;                          //valid element is first element in Array
            }
          }
          else
          {
            valid_startelement =i;                              //found element is valid_startelement
          }
					i =AUDIO_PICTURE_ENTRIES;
				}
        else
        {
          valid_startelement =0xff;
        }
			}
			if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
			{   
				valid_startelement  =startelement;
				valid_elements      =0;
			}
			else																//found valid entry for startelement in array
			{
			  //verify number of valid elements
				if(BACKWARD==direction)											//backward-start
				{
			    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
          {
				    valid_elements=1;
          }		
					else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
				  {
					  for(i=valid_startelement;i>=0;i--)
					  {
					    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
              {
						    valid_elements++;								//increment elements
              }
              else												//no valid element, loop finished
              {
						    i=0;
              }
						}
				  }
					else														//enougth array-elements available
					{
					  for(i=valid_startelement;i>(valid_startelement-elements);i--)
						{
					    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
              {
						    valid_elements++;								//increment elements
              }
							else												//no valid element, loop finished
              {
								i=0;
              }
						}
					}
				}																//backward-end
				else															//forward-start
				{
				  if((valid_startelement+elements)>=AUDIO_PICTURE_ENTRIES)
					{
					  for(i=valid_startelement;i<AUDIO_PICTURE_ENTRIES;i++)
						{
					    if(0!=gPicture_Pos[i])							//if there is an valid element
              {
						    valid_elements++;								//increment elements
              }
							else												//no valid element, loop finished
              {
							  i=AUDIO_PICTURE_ENTRIES;
              }
						}
					}
					else
					{
					  for(i=valid_startelement;i<(valid_startelement+elements);i++)
						{
					    if(0!=gPicture_Pos[i])						    //if there is an valid element
              {
						    valid_elements++;								//increment elements
              }
							else												//no valid element, loop finished
              {
							  i=AUDIO_PICTURE_ENTRIES;
              }
						}
					}
				}
			}
		}
    putvalue(env_AudioSD_Pic_AH_Elements,valid_elements);
    //send StatusArray
    //writeEX(gBAP_Trace, 0, "StatusArray_valid_elements %x",valid_elements); //debug
    Picture_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);   
  }
}

on envVar env_AudioSD_Pic_CSV_Load
{
  if(getvalue(this))
  {
    if (getvalue(env_AudioSD_Pic_CSV_Default))
    {
      Picture_init_CSV();
    }
  }
}

void Picture_init_CSV () //Byte & file selection
{   
  dword CSVfileHandle, ConfigFileHandle, i, j, Num_of_csv_byte, element, current_CSV_line, count1, count2;
  char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
  byte PictureLine, buffer_byte[AUDIO_BUFFERSIZE];
  char Picture_Pos_string [AUDIO_PICTURE_ENTRIES][AUDIO_TEXTLENGTH];           //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
  char Picture_Type_string [AUDIO_PICTURE_ENTRIES][AUDIO_TEXTLENGTH];       //help value ->"Picture Type" is stored in the ASCII(UTF-8) code in the *.csv
  char Picture_TcpPort_string[AUDIO_PICTURE_ENTRIES][AUDIO_TEXTLENGTH];           //help value ->"TCP Port" is stored in the ASCII(UTF-8) code in the *.csv        
  int CSV_Name_Size, stop;
  
  CSVfileHandle     =0;
  ConfigFileHandle  =0;
  i                 =0;
  j                 =0;
  Num_of_csv_byte   =0;
  element           =0;
  current_CSV_line  =0;
  count1            =0;
  count2            =0;
  PictureLine  =0;
  CSV_Name_Size     =0;
  stop              =0;
 
  if(getvalue(env_AudioSD_Pic_CSV_Default)) //output data in write window "FSG Picture"  
  {
    writeClear(gPicture_writeWindow);
    writelineEx(gPicture_writeWindow, 0, "*******External Picture_List*******");
    writelineEx(gPicture_writeWindow, 0, "");
    writelineEx(gPicture_writeWindow, 0, "**********************Start load new Picture_List**********************");   
    for(j=0;j<AUDIO_PICTURE_ENTRIES;j++) //clear "Picture Array"
    {
      gPicture_ListEntryValidInformation[j]  =FALSE;
	    gPicture_Pos[j]          =0;
      gPicture_Type[j]         =0;
      gPicture_TcpPort[j]      =0;
      for(i=0;i<AUDIO_PICTURE_IPADDRESS_LENGTH;i++)
      {
        gPicture_IpAddress[j][i]=0;
      }
      for(i=0;i<AUDIO_PICTURE_URI_LENGTH;i++)
      {
        gPicture_Uri[j][i]=0;            
      }
    }
    for(i=0;i<AUDIO_FILENAME_SIZE; i++) //clear "filename"
    {
        gPicture_CSV_filename[i] =0;       
    }
    for(j=0;j<AUDIO_PICTURE_ENTRIES; j++) //clear "buffer"
    {
      buffer_string[j]    =0;
      buffer_byte[j]      =0;
      for(i=0;i<AUDIO_TEXTLENGTH;i++) //clear help value
      {
        Picture_Pos_string[j][i]       =0;
      }
    }        
    for(i=0;i<AUDIO_BUFFERSIZE;i++)
    {
      Path_CSV[i] =0;
    }
    getvalue(env_AudioSD_Pic_CSV_Path,Path_CSV);
    i =0; j =0; PictureLine =0; current_CSV_line =0; //reset values 
    //       write("complete path *.csv: %s", Path_CSV); //debug
    i =0;
    while (Path_CSV[i] !=0) //scan "path"
    {
      if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
      {
        count1++;                
      }
      //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
      i++;
    }         
    i =0; j =0; //reset values
    while (Path_CSV[i] !=0) //seperate "path" and "filename"
    {
      if(count2==count1) //get filename after last "\"
      {              
        gPicture_CSV_filename[j] =Path_CSV[i];
        j++;
        Path_CSV[i] =0;              
      }
      if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
      {
        count2++;
      }                  
      i++;
    }
    writelineEx(gPicture_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 
    writelineEx(gPicture_writeWindow, 0,"filename of *.csv: '%s'", gPicture_CSV_filename);  //output filename 
    putvalue(env_AudioSD_Pic_CSV_Current,gPicture_CSV_filename);
    setFilePath(Path_CSV, 0); //set path for *.csv file
    CSVfileHandle =openFileRead(gPicture_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        
    if (CSVfileHandle!=0) //*.csv file access successful
    {
      writelineEx(gPicture_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gPicture_CSV_filename);    //output result      
      putValue(env_AudioSD_Pic_CSV_Result,"successful");
      Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
      write("Num_of_csv_byte =%d", Num_of_csv_byte);
      for (i=0; i<Num_of_csv_byte; i++) //copy data into "Picture"
      {     
        if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
        {
          if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in Picture) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
          {
            if(current_CSV_line>0 && PictureLine<AUDIO_PICTURE_ENTRIES) //ignore first line in *.csv file
            {   
              writelineEx(gPicture_writeWindow, 0, "");
              writelineEx(gPicture_writeWindow, 0,"*******Element %d*******",PictureLine);

              //transform 'string' to 'long' for "POS", "PictureType", "Handle" and "TcpPort"
              gPicture_Pos[PictureLine]     =atol(Picture_Pos_string[PictureLine]);
              gPicture_Type[PictureLine]    =atol(Picture_Type_string[PictureLine]);
              gPicture_TcpPort[PictureLine] =atol(Picture_TcpPort_string[PictureLine]);  
              writelineEx(gPicture_writeWindow, 0,"*******Element %d*******",  PictureLine);        
              writelineEx(gPicture_writeWindow, 0,"Pos[%d]: 0x%x",             PictureLine, gPicture_Pos[PictureLine]);                     
              writelineEx(gPicture_writeWindow, 0,"PictureType[%d]: 0x%x",     PictureLine, gPicture_Type[PictureLine]);
              writelineEx(gPicture_writeWindow, 0,"IpAddress[%d]: %s",         PictureLine, gPicture_IpAddress[PictureLine]);
              writelineEx(gPicture_writeWindow, 0,"TcpPort[%d]: 0x%x",         PictureLine, gPicture_TcpPort[PictureLine]);
              writelineEx(gPicture_writeWindow, 0,"Uri[%d]: %s",               PictureLine, gPicture_Uri[PictureLine]);
              gPicture_ListEntryValidInformation[PictureLine]  =TRUE;
              PictureLine++; // -> next line in *.csv (next record element)
            }
            current_CSV_line++; //next line in *.csv file
            element =0; //start at 'POS' (first record element of "array data")
            j=0; //reset value
          }          
          else if(current_CSV_line>0 && PictureLine<AUDIO_PICTURE_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
          {
            switch (element)
            {
                case 0: //POS
                        Picture_Pos_string[PictureLine][j] =buffer_byte[i];
                        j++;
                break;
                case 1: //PictureType
                        Picture_Type_string[PictureLine][j] =buffer_byte[i];                                   
                        j++;
                break;
                case 2: //IP Address
                        gPicture_IpAddress[PictureLine][j] =buffer_byte[i];
                        j++;                                
                break;
                case 3: //TCP Port
                        Picture_TcpPort_string[PictureLine][j] =buffer_byte[i];
                        j++;                                
                break;
                case 4: //URI
                        gPicture_Uri[PictureLine][j] =buffer_byte[i];
                        j++;                                
                break;
                default:
                break;
            }
          }                               
        }                     
        else  // ";" is detected ->next record element of "array data"
        {                                          
          element++;
          j=0; //reset value  
        }                                              
      }             
      gPicture_TotalNumListElements =gPicture_sum =PictureLine; //get "total number of list elements"
      putvalue(env_AudioSD_Pic_TNLE,gPicture_TotalNumListElements);
      writelineEx(gPicture_writeWindow, 0, "");
      writelineEx(gPicture_writeWindow, 0,"Anzahl der Listenelemente: %d", gPicture_sum); //output total number of list elements
      writelineEx(gPicture_writeWindow, 0, "");
      if(fileClose (CSVfileHandle) !=0) //close *.csv file
      {
        writelineEx(gPicture_writeWindow, 0,"Datei '%s' geschlossen", gPicture_CSV_filename); //output result
      }
      else
      {
        writelineEx(gPicture_writeWindow, 0,"Fehler beim Schließen der Datei '%s'", gPicture_CSV_filename);//output result
      }
    }
    else //*.csv file access not successful
    {
      writelineEx(gPicture_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gPicture_CSV_filename); //output result
      putValue(env_AudioSD_Pic_CSV_Result,"not successful"); //output result
    }
  }
}

byte Picture_nextvalidLine (byte current_PictureLine, byte direction)
{
    byte next_PictureLine;
    int i;         
    //init local variables
    next_PictureLine  =0;
    i                       =0;

    //search next "list entry"
    if(((gPicture_sum-1)==current_PictureLine && FORWARD ==direction) || (0 ==current_PictureLine && BACKWARD ==direction))	//last-/fist-element of array reached
    {
	    next_PictureLine =0xFF;
    }
    else
    {
  		next_PictureLine =current_PictureLine +1-2*direction;       //increment or decrement array-line (depends on direction);           
      if(0 ==gPicture_ListEntryValidInformation[next_PictureLine])	// check if next element is "valid"
      {
  		  next_PictureLine =0xff; 					
      }
    }
    return(next_PictureLine);
}

void Picture_Indication (dword Indication_array [], int datalength)
{
  byte mode, shift, direction, recordaddress, indexsize, transmitpos;
  word valid_startelement, requested_startelement, startelement, elements, Offset, valid_elements;
  int i=0, transSuppression;
  
  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;
  transSuppression        = getvalue(env_AudioSD_Pic_StatusOFF);

  switch (Indication_array[2]) // indication
  {
	    case DataGet_IND:        
        if(getvalue(env_AudioSD_Pic_Error_Status))
        {
          Picture_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue(env_AudioSD_Pic_ErrorCode));
        }
        else
        {
          //getData
          gPicture_ASGID =(gBAP_Indication[3] &0xF0) /0x10;
          gPicture_TAID  =gBAP_Indication[3] &0x0F;
          /***ArrayHeader***/
          mode            =(Indication_array[4] &0xF0) /0x10;
          recordaddress   =Indication_array[4] &0x0F;
          Offset =5;
          // decode "mode-byte"
          shift       =mode &0x01;
          direction   =(mode &0x02)/0x02;
          transmitpos =(mode &0x04)/0x04;
          indexsize   =(mode &0x08)/0x08;              
          if (indexsize)
          {   
              startelement =Indication_array[Offset];
              Offset++;
              startelement +=(Indication_array[Offset] *0x100);
              Offset++;
              elements =Indication_array[Offset];
              Offset++;
              elements +=(Indication_array[Offset] *0x100);
              Offset++;
          }
          else
          {   
              startelement =Indication_array[Offset];
              Offset++;
              elements =Indication_array[Offset];
              Offset++;
          }   

          requested_startelement =startelement;
          /***Startelement=0***/
          if(0==startelement) //Startelement-ID =0 -> start at first array-entry
			    {
            if(FORWARD==direction)  //forward-start
				    {
              valid_startelement =0;				       									
              if(AUDIO_PICTURE_ENTRIES <=elements) //1. more elements requested, than in array
					    {
                if (shift ==FALSE)  
                {
                  for(i=0;i<AUDIO_PICTURE_ENTRIES;i++)
						      {
							      if(0 !=gPicture_ListEntryValidInformation[i])	//if there is an valid element
                    {
                      if(gPicture_Pos[i] >0xff)
                      {
                        indexsize =TRUE;
                      }
                      valid_elements++;								//increment elements
							      }    
                    else	  //no valid element, loop finished
                    {
								      i =AUDIO_PICTURE_ENTRIES;
                    }
						      }
                }
                else
                {   
                  valid_startelement  =startelement;
  						    valid_elements      =0;
                }
					    }
              else    //2. number of requested elements < elements in array
					    {
                if (shift ==FALSE)
                {
					        for(i=0;i<elements;i++)
					        {
							      if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
                    {
                      if(gPicture_Pos[i] >0xff)
                      {
                        indexsize =TRUE;
                      }
                      valid_elements++;								//increment elements
							      }
							      else												//no valid element, loop finished
                    {
								      i =AUDIO_PICTURE_ENTRIES;
                    }
						      }
                }
                else
                {
                  valid_startelement  =startelement;
  				        valid_elements      =0;
                }
					    }
            }                                                               //forward ends
            else if(BACKWARD==direction && TRUE==shift)						//backward-start, only if the shift bit is set (this means starting with the last element of the array)
				    {   
					    //searching for valid startelement
					    for(i=(AUDIO_PICTURE_ENTRIES-1);i>=0;i--)
					    {
						    if(0!=gPicture_ListEntryValidInformation[i])		//found valid startelement
						    {
							    valid_startelement =i;								
							    i =0;												
						    }
					    }       
              //searching for valid elements
					    if(0xff==valid_startelement)								//Startelement-ID doesn't exist in SMSReceived-array
					    {
						    valid_startelement  =startelement;
						    valid_elements      =0;
					    }
					    else if(0==valid_startelement)								
						    valid_elements=1;                                       //only 1 element because valid startelement is on position 0						
					    else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
					    {
						    for(i=valid_startelement;i>=0;i--)
						    {
							    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
								  { 
                    if(gPicture_Pos[i] >0xff)
                    {
                      indexsize =TRUE;
                    }
                    valid_elements++;								//increment elements
							    }
                  else												//no valid element, loop finished
                  {
								    i=0;
                  }
						    }
					    }
              else														//enougth array-elements available
					    {
						    for(i=valid_startelement;i>(valid_startelement-elements);i--)
						    {
							    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
								  {
                    valid_elements++;								//increment elements
                    if(gPicture_Pos[i] >0xff)
                    {
                      indexsize =TRUE;
                    }
                  }
                  else												//no valid element, loop finished
                  {
								    i=0;
                  }
					    	}                 
					    }															
			      }                                                               //backward-end
          }                                                                   //startelement ==0 -end
          /***Startelement!=0***/
          else																//searching for Startelement-ID				
			    {
				    //searching for valid startelement
				    for(i=0;i<AUDIO_PICTURE_ENTRIES;i++)
				    {
  				    if(gPicture_Pos[i] ==startelement)					    //found a valid element
  				    {                                          
                if(shift==TRUE)											//shift ist set, this means starting with the next/previous element (depending on the direction-setting)
						    {
							    if(i!=0 || BACKWARD!=direction)						//if valid_startelement is not the first array element or direction is not backwards
                  {
								    valid_startelement =i+1-2*direction;                              							
                  }
                  else if(i==0 && BACKWARD==direction) 
                  {
                    valid_startelement =gPicture_sum;           //valid element is last element in Array                                                
                  }
                  else if(i==0 && FORWARD==direction) 
                  {
                    valid_startelement =0;                          //valid element is first element in Array
                  }
                }
                else
                {
                  valid_startelement =i;                              //found element is valid_startelement
                }
						    i=AUDIO_PICTURE_ENTRIES;
					    }
				    }
				    if(0xff==valid_startelement)										//Startelement-ID doesn't exist in array
				    {
					    valid_startelement  =startelement;
					    valid_elements      =0;
				    }
				    else																//found valid entry for startelement in array
				    {
					    //verify number of valid elements
					    if(BACKWARD==direction)											//backward-start
					    {
						    if(valid_startelement==0)									//only 1 element because valid startelement is on position 0
                {
							    valid_elements=1;
                }
						    else if(elements>(valid_startelement+1))					//not enougth array-elements available, because array endet at array-position 0
						    {
							    for(i=valid_startelement;i>=0;i--)
							    {
								    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
									  { 
                      if(gPicture_Pos[i] >0xff)
                      {
                        indexsize =TRUE;
                      }
                      valid_elements++;								//increment elements
								    }
                    else												//no valid element, loop finished
                    {
									    i=0;
                    }
							    }
						    }
						    else														//enougth array-elements available
						    {
							    for(i=valid_startelement;i>(valid_startelement-elements);i--)
							    {
								    if(0!=gPicture_ListEntryValidInformation[i])	//if there is an valid element
									  {
                      if(gPicture_Pos[i] >0xff)
                      {
                        indexsize =TRUE;
                      }
                      valid_elements++;								//increment elements
                    }
                    else												//no valid element, loop finished
                    {
									    i=0;
                    }
							    }
						    }
					    }																//backward-end
					    else															//forward-start
					    {
						    if((valid_startelement+elements)>=AUDIO_PICTURE_ENTRIES)
						    {
							    for(i=valid_startelement;i<AUDIO_PICTURE_ENTRIES;i++)
							    {   
								    if(0!=gPicture_Pos[i])							//if there is an valid element
									  {
                      if(gPicture_Pos[i] >0xff)
                      {
                        indexsize =TRUE;
                      }
                      valid_elements++;								//increment elements
								    }
                    else    												//no valid element, loop finished
                    {
									    i=AUDIO_PICTURE_ENTRIES;
                    }
							    }
						    }
						    else
						    {
							    for(i=valid_startelement;i<(valid_startelement+elements);i++)
							    {
								    if(0!=gPicture_Pos[i])						    //if there is an valid element
									  {
                      if(gPicture_Pos[i] >0xff)
                      {
                        indexsize =TRUE;
                      }
                      valid_elements++;								//increment elements
								    }
                    else												//no valid element, loop finished
                    {
									    i=AUDIO_PICTURE_ENTRIES;
                    }
							    }
						    }
					    }
			    	} //END: if(BACKWARD==direction)	
			    } //END: if(0==startelement)    
          transmitpos =TRUE;
          if((requested_startelement >0xFF) || (valid_startelement >0xFF))
          {
            indexsize =TRUE;
          }
          mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
          //set header data to panel
          putvalue(env_AudioSD_Pic_AH_RecordAdd,recordaddress);
          putvalue(env_AudioSD_Pic_AH_Start,requested_startelement);
          putvalue(env_AudioSD_Pic_AH_Elements,valid_elements);
          putvalue(env_AudioSD_Pic_AH_Shift,shift);
          putvalue(env_AudioSD_Pic_AH_Dir,direction);
          putvalue(env_AudioSD_Pic_AH_TransPos,transmitpos);
          putvalue(env_AudioSD_Pic_AH_IndexSize,indexsize);
          putvalue(env_AudioSD_Pic_AsgId,gPicture_ASGID);
          putvalue(env_AudioSD_Pic_TAID,gPicture_TAID);
          //send StatusArray
          if(!transSuppression)
          {
            Picture_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                   
          }
        }
	    break;         
      case Error_IND:
  			writelineEx(gError_Trace, 0, "FSG_AudioSD Indication_Picture: received error, errorcode:0x%x", Indication_array[3]);  		break;
      default:
  	    writelineEx(gError_Trace, 0, "FSG_AudioSD Indication_Picture: invalid indication %d", Indication_array[2]);
      break;
	}
}

void Picture_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{ 
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];
  byte shift, direction, transmitpos, indexsize, current_element; 
  word PictureListLine, Offset;          
	// Init local variables. 
  for(i=0;i<BAP_BUFFER_SIZE;i++)
  {
    requestarray [i]=0;
  } 
  shift               =0;
  direction           =0;
	transmitpos         =0;
	indexsize           =0;
  PictureListLine     =0;
  current_element     =0;
  Offset              =0;
  // decode "mode-byte"
  shift       =mode &0x01;
  direction   =(mode &0x02)/0x02;
	transmitpos =(mode &0x04)/0x04;
	indexsize   =(mode &0x08)/0x08;
	// Handle request.
  requestarray[0] =LSG_AudioSD;				//LSG-ID
	requestarray[1] =FctID_Picture;		    //Fct.-ID
	requestarray[2] =request;                   //request type
	Offset =3;

  //-------------------------------------------------------------------------
  //-------------------------------------------------------------------------
  switch(request)
	{
		  case Changed_REQ:
        /***ArrayHeader***/
			  requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
        Offset++;		
        if (indexsize)
        {   
          requestarray[Offset] =(requested_startelement &0x00FF);
          Offset++;
          requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
          Offset++;
          requestarray[Offset] =(elements &0x00FF);
          Offset++;
          requestarray[Offset] =((elements &0xFF00) /0x100);
          Offset++;
        }
        else
        {   
          requestarray[Offset] =requested_startelement;
          Offset++;
          requestarray[Offset] =elements;
          Offset++;
        }
        PictureListLine =startelement;           
        if (getvalue(env_AudioSD_Pic_Changed_wData)==0 || getvalue(env_AudioSD_Pic_Changed_wData)==1) //ArrayData
        {
          //   if(elements != 0xffff)                                  // if FullRangeUpdate
          //   {
          //copy data
          for(i =0;i<BAP_BUFFER_SIZE;i++)
          {
            requestarrayPictureGlobal[i] = requestarray[i];
          }
          offsetPictureGlobal = Offset;
          if(elements != 0xffff)                                  // if no FullRangeUpdate
          {
            Picture_Request_RecordAddress(recordaddress, transmitpos, indexsize, elements, PictureListLine);
          }
          for(i =0;i<BAP_BUFFER_SIZE;i++)
          {
            requestarray[i] = requestarrayPictureGlobal[i];
          }
          Offset = offsetPictureGlobal;
          // }
          set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
        }
      break; //end Changed_REQ 
      case Data_REQ:
        requestarray[Offset] =((gPicture_ASGID *0x10) &0xF0) +(gPicture_TAID &0x0F);	
        Offset++;
        requestarray[Offset] =gPicture_TotalNumListElements;	
        Offset++;
        /***ArrayHeader***/
			  requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
        Offset++;
        if (indexsize)
        {   
          requestarray[Offset] =(requested_startelement &0x00FF);
          Offset++;
          requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
          Offset++;
          requestarray[Offset] =(elements &0x00FF);
          Offset++;
          requestarray[Offset] =((elements &0xFF00) /0x100);
          Offset++;
        }
        else
        {   
          requestarray[Offset] =requested_startelement;
          Offset++;
          requestarray[Offset] =elements;
          Offset++;
        }
			  PictureListLine =startelement; 
        //copy data
        for(i =0;i<BAP_BUFFER_SIZE;i++)
        {
          requestarrayPictureGlobal[i] = requestarray[i];
        }
        offsetPictureGlobal = Offset;
        Picture_Request_RecordAddress (recordaddress, transmitpos, indexsize, elements, PictureListLine);   
        for(i =0;i<BAP_BUFFER_SIZE;i++)
        {
          requestarray[i] = requestarrayPictureGlobal[i];
        }
        Offset = offsetPictureGlobal;
        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
      break; //end Data_REQ
      case Error_REQ:
        requestarray[3] =errorcode;
			  set_status_requestbuffer (requestarray, 4, Bap_Error);
      break; //end Error_REQ
  } //end switch "request"   
}

void Picture_Request_RecordAddress (byte recordaddress, byte transmitpos, byte indexsize, word elements, word PictureListLine)
{
  int  i, temp =0, first =1;
  dword requestarray [BAP_BUFFER_SIZE];
  byte  current_element, direction;
  word  Offset;
  current_element =0;
  direction =0;
  temp =0;   
  for(i =0;i<BAP_BUFFER_SIZE;i++)
  {
    requestarray[i] = requestarrayPictureGlobal[i];
  }
  Offset  =offsetPictureGlobal;
  if(PictureListLine == 0xff) // invalid "list entry"
  {
    write("AudioSD Picture_Request_RecordAddress: invalid PictureListLine");
    current_element =elements;
  }//----------------------
  else //valid "list entry"
  {          
    //------------------------------------------------------------------------------------------------------
    //------------------------------------------------------------------------------------------------------
    // PictureType, IPv6Address, TCP_Port, URI
    switch(recordaddress)
		{
        case 0: //changed array full range update -> POS only
          while(current_element <elements)
          {       
            /***Array Data***/
            if (transmitpos) // Pos  -> Array position transmitted
            {
              if (indexsize)
              {
                  requestarray[Offset] =(gPicture_Pos[PictureListLine] &0x00FF);
                  Offset++;
                  requestarray[Offset] =((gPicture_Pos[PictureListLine]&0xFF00) /0x100);
                  Offset++;
              }
              else
              {
                  requestarray[Offset] =gPicture_Pos[PictureListLine];
                  Offset++;
              }
            }
            if(elements != 0xffff) // if no FullRangeUpdate
            {
                //might be GetArray for List display in ASG -> complete record
                // -------------------------------------------------
                // PictureType
                requestarray[Offset] =gPicture_Type[PictureListLine];
                Offset++;
                // -------------------------------------------------
                // IPv6 Address
                requestarray[Offset] =strlen(gPicture_IpAddress[PictureListLine]);
                Offset++;    
                for(i=0;i<strlen(gPicture_IpAddress[PictureListLine]);i++)
          			{
                  requestarray[Offset] =gPicture_IpAddress[PictureListLine][i];	
                  Offset++;
                }
                // -------------------------------------------------
                // TCP Port
                requestarray[Offset] =gPicture_TcpPort[PictureListLine];
                Offset++;
                requestarray[Offset] =((gPicture_TcpPort[PictureListLine] & 0xFF00) /0x100);
                Offset++;
                // -------------------------------------------------
                // URI
                requestarray[Offset] =strlen(gPicture_Uri[PictureListLine]);
                Offset++;                  
                for(i=0;i<strlen(gPicture_Uri[PictureListLine]);i++)
          			{
                  requestarray[Offset] =gPicture_Uri[PictureListLine][i];	
                  Offset++;
                }
            }
            current_element++;
            PictureListLine =Picture_nextvalidLine(PictureListLine, direction);
          }//end while
        break;
        case 1: //PictureType, IPv6Address, TCP_Port, URI
          while(current_element <elements)
          {
            /***Array Data***/
            if (transmitpos) // Pos  ->Array position transmitted
            {
              if (indexsize)
              {
                requestarray[Offset] =(gPicture_Pos[PictureListLine] &0x00FF);
                Offset++;
                requestarray[Offset] =((gPicture_Pos[PictureListLine]&0xFF00) /0x100);
                Offset++;
              }
              else
              {
                requestarray[Offset] =gPicture_Pos[PictureListLine];
                Offset++;
              }
            }
            // -------------------------------------------------
            // PictureType
            requestarray[Offset] =gPicture_Type[PictureListLine];
            Offset++;
            // -------------------------------------------------
            // IPv6 Address
            requestarray[Offset] =strlen(gPicture_IpAddress[PictureListLine]);
            Offset++;    
            for(i=0;i<strlen(gPicture_IpAddress[PictureListLine]);i++)
      			{
              requestarray[Offset] =gPicture_IpAddress[PictureListLine][i];	
              Offset++;
            }
            // -------------------------------------------------
            // TCP Port
            requestarray[Offset] =gPicture_TcpPort[PictureListLine];
            Offset++;
            requestarray[Offset] =((gPicture_TcpPort[PictureListLine] & 0xFF00) /0x100);
            Offset++;
            // -------------------------------------------------
            // URI
            requestarray[Offset] =strlen(gPicture_Uri[PictureListLine]);
            Offset++;                  
            for(i=0;i<strlen(gPicture_Uri[PictureListLine]);i++)
      			{
              requestarray[Offset] =gPicture_Uri[PictureListLine][i];	
              Offset++;
            } 
            current_element++;
            PictureListLine =Picture_nextvalidLine(PictureListLine, direction);			                                     
          }//end while
        break;
        case 2: //TCP_Port, URI
          while(current_element <elements)
          {
            /***Array Data***/
            if (transmitpos) // Pos  ->Array position transmitted
            {
              if (indexsize)
              {
                requestarray[Offset] =(gPicture_Pos[PictureListLine] &0x00FF);
                Offset++;
                requestarray[Offset] =((gPicture_Pos[PictureListLine]&0xFF00) /0x100);
                Offset++;
              }
              else
              {
                requestarray[Offset] =gPicture_Pos[PictureListLine];
                Offset++;
              }
            }
            // -------------------------------------------------
            // TCP Port
            requestarray[Offset] =gPicture_TcpPort[PictureListLine];
            Offset++;
            requestarray[Offset] =((gPicture_TcpPort[PictureListLine] & 0xFF00) /0x100);
            Offset++;
            // -------------------------------------------------
            // URI
            requestarray[Offset] =strlen(gPicture_Uri[PictureListLine]);
            Offset++;                  
            for(i=0;i<strlen(gPicture_Uri[PictureListLine]);i++)
      			{
              requestarray[Offset] =gPicture_Uri[PictureListLine][i];	
              Offset++;
            } 
            current_element++;
            PictureListLine =Picture_nextvalidLine(PictureListLine, direction);			                                     
          }//end while
        break;
        case 15:    //Pos
          while(current_element <elements)
          {
            /***Array Data***/
            if (transmitpos) // Pos  ->Array position transmitted
            {
              if (indexsize)
              {
                requestarray[Offset] =(gPicture_Pos[PictureListLine] &0x00FF);
                Offset++;
                requestarray[Offset] =((gPicture_Pos[PictureListLine]&0xFF00) /0x100);
                Offset++;
              }
              else
              {
                requestarray[Offset] =gPicture_Pos[PictureListLine];
                Offset++;
              }
            }
            current_element++;
            PictureListLine =Picture_nextvalidLine(PictureListLine, direction);                           
          }//end while
        break;
        default:
				  write("AudioSD Picture_Request_RecordAddress: invalid recordaddress %d", recordaddress);
			  break;
    } //end switch "recordaddress"
  }//end if(PictureListLine == 0xff)
  //clear
  for(i =0;i<BAP_BUFFER_SIZE;i++)
  {
    requestarrayPictureGlobal[i] = 0;
  }
  offsetPictureGlobal = 0;
  //save data
  for(i =0;i<BAP_BUFFER_SIZE;i++)
  {
    requestarrayPictureGlobal[i] = requestarray[i];
  }
  offsetPictureGlobal = Offset; 
} 

//*************************************************************************
//*************************************************************************

void fctDummy()
{
}