/*@!Encoding:1252*/
includes
{
#include "..\Nodes\includes\variablesASG.cin"
	//#include "..\Nodes\includes\generalFunctions.cin"
}

on preStart
{
	char Path[255];
	char BAPVersion [200];
	word test;
	
	// create write window for BAP communication
	gBAP_Trace  =writecreate("BAP-Trace ASG-NaviSD");								
	
	// clear BAP trace window
	writeclear(gBAP_Trace);													
	
	// error window for BAP communication
	gError_Trace=writecreate("ASG-NaviSD Error");									
	writeclear(gError_Trace);												

	//clear CAPL-window in write-window
	writeclear(1);															

	//get version from Stack
	Bap180_GetVersions(BAPVersion, 200);
	write(" ");
	write("***************************************************");
	write(BAPVersion);
	write("***************************************************");
	write(" ");
	
	write("***************************************************");
	write("***************************************************");
	
	// Create Node
	NODE_INDEX=Bap180_CreateNode();

	// Debug info
	// write("NODE_INDEX = 0x%x", NODE_INDEX); 

	// Load DBC and XML files. 
	write("*********************************************************************************");

	canethdecider = prestartEthernetCanDecider();

	switch(canethdecider)
	{
	case 2: // CAN
		getAbsFilePath(dbc_path, Path, 255);
		write("NaviSD Load BAP_DBC-File: '%s'",Path);

		if(Bap180_LoadDBC(NODE_INDEX, 1, Path) != BAP_ERR_OK)		
		writelineEx(gError_Trace, 0, "FSG-NaviSD Fehler beim Laden: '%s', Path");
		
		//load xml-file 
		getAbsFilePath(xml_path, Path, 255);
		write("ASG-AudioSD: Load BAP-XML-File: '%s'", Path);
		if (Bap180_LoadConfig(NODE_INDEX, Path, "") != BAP_ERR_OK) 
		writelineEx(gError_Trace, 0, "ASG-NaviSD: Fehler beim Laden: '%s' !", Path);	   
		write("*********************************************************************************");
		write("");
		
		break;
	case 1: // Ethernet
		getAbsFilePath(dbce_path, Path, 255);
		write("NaviSD Load BAP_DBC-File: '%s'",Path);

		if(Bap180_LoadDB(NODE_INDEX, 20, 2, Path) != BAP_ERR_OK)		
		writelineEx(gError_Trace, 0, "FSG-NaviSD Fehler beim Laden: '%s', Path");
		
		//load xml-file 
		getAbsFilePath(xmle_path, Path, 255);
		write("ASG-NaviSD: Load BAP-XML-File: '%s'", Path);
		if (Bap180_LoadConfig(NODE_INDEX, Path, "") != BAP_ERR_OK) 
		writelineEx(gError_Trace, 0, "ASG-NaviSD: Fehler beim Laden: '%s' !", Path);	   
		write("*********************************************************************************");
		write("");
		
		break;
	case -1:
		write("Neither Ethernet nor CAN could be find in Configuration Name!");
		break;
	default:
		write("Not a possible Value");
		break;
	}
	// BAP DLL: Add CAN channel: BAP channel 1 is mapped to CAN card channel 1.
	if(canethdecider==1)
	{
		Bap180_AddCanMap(NODE_INDEX, 20, 1);
		EthernetCreateSocket();
	} 
	else
	{
		Bap180_AddCanMap(NODE_INDEX, 1, 1);
	}

} /* end of method */


int prestartEthernetCanDecider()
{
	char configNameBuffer[100];

	getConfigurationName(configNameBuffer,100);

	if(strstr_regex(configNameBuffer, "Ethernet") > 0)
	{
		return 1;
	}
	else if(strstr_regex(configNameBuffer, "CAN") > 0)
	{
		return 2;
	}
	else
	{
		return -1;
	}
}

on start
{
	//Power on/off
	gBAP_Init =0;
	gASG_PowerOnOff =0;
	putvalue(env_ASG_PowerOnOff_s, gstring_ASG_PowerOnOff [gASG_PowerOnOff]);
	
	//Panel
	closePanel("ASG_NaviSD_Properties_1");
	closePanel("ASG_NaviSD_Properties_2");
	closePanel("ASG_NaviSD_Properties_3");
	closePanel("ASG_NaviSD_Methods");
	closePanel("ASG_NaviSD_0x18 - LaneGuidance_(array)");
	closePanel("ASG_NaviSD_0x3D - LaneGuidance2_(array)");
	closePanel("ASG_NaviSD_0x1D - LastDest_List_(array)");
	closePanel("ASG_NaviSD_0x1E - FavoriteDest_List_(array)");
	closePanel("ASG_NaviSD_0x20 - NavBook_(array)");
	closePanel("ASG_NaviSD_0x21 - Address_List_(array)");
	closePanel("ASG_Properties_4");
	closePanel("ASG_Properties_5");
	closePanel("ASG_NaviSD_MainPanel");
	closePanel("MethodMIB2ASG");
	closePanel("Method3MIB2ASG");
	closePanel("0x34_POI_List_ASG2");
	closePanel("0x3A_VideoStreams_ASG2");
	closePanel("0x3E_Picture_ASG2");

	openPanel("NaviSD_MainPanel");							
}

on stopMeasurement
{
	Bap180_Shutdown(NODE_INDEX,LSG_NaviSD);
}

on message CAN1.BAP_Navigation_FSG_01	//BAP-message
{
	int i, error;
	byte RX_Data[8];		//received CAN-DATA
	dword RX_Header[3];		//received CAN-Header

	RX_Header[0]=this.CAN; 
	RX_Header[1]=this.ID; 
	RX_Header[2]=this.DLC; // received length
	
	// extract CAN data    																	
	for (i=0; i<this.DLC; i++) 														
	RX_Data[i]=this.byte(i);	
	
	//send recieved CAN-data with CAN-header to BAP-DLL
	error =Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
	if(error !=0)
	write("ASG-NaviSD: BAP_CAN_SetRxData: %d", error);   
}

OnUdpReceiveFrom( dword socket, long result, byte ipv6Address[], dword port, byte buffer[], dword size)
{
	int i;
	dword Header[13];
	byte Ipv6_temp[16];
	const long  INVALID_SOCKET = ~0;

	if(socket != INVALID_SOCKET)
	{
		if(result == 0)
		{
			Header[0] = 4; // /*BusType: 1=Can, 2=Lin, 3=Flexray, 4=Ethernet*/
			Header[1] = 1; //channel
			Header[2] = size;

			for(i=0;i<gUdpSocketCnt;i++)
			{
				if(gUdpSockets[i].Handle == socket)
				{
					Header[3] = gUdpSockets[i].Id;
					for(i=0; i<8; i++)
					{
						Header[i+4] = ((dword)ipv6Address[2*i]) << 8;
						Header[i+4] |= ((dword)ipv6Address[2*i+1]) ;
					}
					Header[12] = port;
					BAP180_SetRxData(NODE_INDEX, Header, buffer);
					
					break;
				}
			}
		}
	}
}

BAP_DLL_Indication()
{
	int i, length, datalength, temp;
	byte Indication_data[BAP_BUFFER_SIZE];												//indication data from DLL
	dword Indication_header[6];															//indication header from DLL
	byte BAP_data_type;

	//init lokal variables
	length=0;
	datalength=0;
	temp=0;
	BAP_data_type=0;

	for(i=0;i<6;i++)
	Indication_header[i]=0;

	for(i=0;i<BAP_BUFFER_SIZE;i++)
	Indication_data[i]=0;
	//********************

	Indication_header[4]=BAP_BUFFER_SIZE;											//BAP-Stack needs this information for successful BAP_GetIndication 

	temp=Bap180_GetInd(NODE_INDEX, Indication_header, Indication_data);				//get BAP-Indication data from DLL
	//write("BAP_GetIndication: %d", temp);											//debug
	
	if(temp==0)
	{
		//read header
		gBAP_Indication[0]=Indication_header[0];									//LSG-ID
		gBAP_Indication[1]=Indication_header[1];									//Function-ID
		gBAP_Indication[2]=Indication_header[2];									//indication
		
		//debug
		//write("Debug_Ind: LSG=%d, FctID=%x, indication=%d, BAP_data_type=%d",Indication_header[0],Indication_header[1],Indication_header[2],Indication_header[3]);

		BAP_data_type=Indication_header[3];											//BAP data type
		//writelineEx(gBAP_Trace, 0, "Data-Type: %d", BAP_data_type);					//debug
		
		switch(BAP_data_type)
		{
		case Bap_Void:
			datalength=3;
			//writelineEx(gBAP_Trace, 0, "ASG-Indication: ");						//BAL-Trace
			for (i=0;i<datalength;i++)											//BAL-Trace
			//writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace
			BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
		case Bap_UInt8:
			gBAP_Indication[3]=Indication_header[5];							//unit8-value				
			datalength=4;				
			/*			
		writelineEx(gBAP_Trace, 0, "Indication_header:");					//debug
				for (i=0;i<6;i++)													//debug
					writeEX(gBAP_Trace, 0, " %x",Indication_header [i]);			//debug
			*/		
			//writelineEx(gBAP_Trace, 0, "ASG-Indication: ");						//BAL-Trace
			for (i=0;i<datalength;i++)											//BAL-Trace
			//writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace
			BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
		case Bap_UInt16:
			gBAP_Indication[3]=Indication_header[5];							//unit16-value				
			datalength=4;
			/*				
		writelineEx(1, 0, "Indication_header:");							//debug
				for (i=0;i<6;i++)													//debug
					writeEX(1, 0, " %x",Indication_header [i]);						//debug
			*/
			//writelineEx(gBAP_Trace, 0, "ASG Indication: ");						//BAL-Trace
			for (i=0;i<datalength;i++)											//BAL-Trace
			//writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace
			BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
		case Bap_UInt32:
			gBAP_Indication[3]=Indication_header[5];							//unit32-value				
			datalength=4;
			/*
		writelineEx(1, 0, "Indication_header:");							//debug
				for (i=0;i<6;i++)													//debug
					writeEX(1, 0, " %x",Indication_header [i]);						//debug
			*/
			//writelineEx(gBAP_Trace, 0, "ASG Indication: ");						//BAL-Trace
			for (i=0;i<datalength;i++)											//BAL-Trace
			//writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace
			BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
		case Bap_ByteSequence:													//BAP-data-type is byte sequence
			//read datalength
			length=Indication_header[4];										//length of date-array
			datalength=length+3;												//length of indication-array
			//read data-array
			for(i=0;i<length;i++)
			gBAP_Indication[i+3]=Indication_data[i];
			/*				
		writelineEx(gBAP_Trace, 0, "Indication_header:");					//debug
				for (i=0;i<6;i++)													//debug
					writeEX(gBAP_Trace, 0, " %x",Indication_header [i]);			//debug		
				writelineEx(gBAP_Trace, 0, "Indication_data:");						//debug
				for (i=0;i<length;i++)												//debug
					writeEX(gBAP_Trace, 0, " %x",Indication_data [i]);				//debug
		*/				
			//writelineEx(gBAP_Trace, 0, "ASG-Indication: ");						//BAL-Trace
			for (i=0;i<datalength;i++)											//BAL-Trace
			{
				writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);				//BAL-Trace
				if(i>20)
				{
					i=datalength;
					writeEX(gBAP_Trace, 0, "...");
				}
			}
			BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
		case Bap_Acknowledge:
			break;
		case Bap_Error:
			gBAP_Indication[2]=Error_IND;										//internal indication-value for error
			gBAP_Indication[3]=Indication_header[5];							//error-code
			datalength=4;														//length of indication-array
			writelineEx(gBAP_Trace, 0, "ASG-Error-Indication: ");				//BAL-Trace
			writeEX(gBAP_Trace, 0, "LSG-ID: 0x%x   ",gBAP_Indication[0]);		//BAL-Trace
			writeEX(gBAP_Trace, 0, "Fct-ID: 0x%x   ",gBAP_Indication[1]);		//BAL-Trace
			//	writeEX(gBAP_Trace, 0, "Opcode: 0x%x   ",gBAP_Indication[2]);		//BAL-Trace
			writeEX(gBAP_Trace, 0, "Error-Code: 0x%x   ",gBAP_Indication[3]);	//BAL-Trace
			BAP_Indication(datalength);											        //evaluate BAP-Indication data
			break;
		default:
			writelineEx(gError_Trace, 0, "ASG BAP_DLL_Indication: invalid BAP-Data-Type: %d", BAP_data_type);
			break;
		}
	}
}

BAP_DLL_Request ()
{
	int i, datalength;
	byte temp;
	byte Request_data[BAP_BUFFER_SIZE];	//Request data for DLL
	dword Request_header[6];	//Request header for DLL
	byte error;					//data-error-flag (Geräusch)

	//init lokal variables
	datalength=0;
	temp=0;
	error=1;

	for(i=0;i<6;i++)
	Request_header[i]=0;

	for(i=0;i<BAP_BUFFER_SIZE;i++)
	Request_data[i]=0;
	//********************

	if(gBAP_Requestbuffer_status [gstatus_requestbuffer]>0)							//if ready to send
	{
		//	writelineEx(gBAP_Trace, 0, "DataTyp: %d", gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]);
		switch(gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer])
		{
		case Bap_Void:
			//request-array for BAP-DLL funcion 'BAP_Request'
			Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
			Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
			Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
			Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
			Request_header[4]=0;														//not used
			Request_header[5]=0;														//not used
			break;
		case Bap_UInt8:
			//request-array for BAP-DLL funcion 'BAP_Request'
			Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
			Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
			Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
			Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
			Request_header[4]=0;														//not used
			Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit8-value
			break;
		case Bap_UInt16:
			//request-array for BAP-DLL funcion 'BAP_Request'
			Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
			Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
			Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
			Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
			Request_header[4]=0;														//not used
			Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit16-value
			break;
		case Bap_UInt32:
			//request-array for BAP-DLL funcion 'BAP_Request'
			Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
			Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
			Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
			Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];	//BAP data type
			Request_header[4]=0;														//not used
			Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];					//unit32-value
			break;
		case Bap_ByteSequence:					//BAP-data-type is byte sequence
			datalength=gBAP_Requestbuffer_status [gstatus_requestbuffer]-3;

			//request-array for BAP-DLL funcion 'BAP_Request'
			Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];					//LSG-ID
			Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];					//Function-ID
			Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];					//request
			Request_header[3]=Bap_ByteSequence;											//BAP data type
			Request_header[4]=datalength;												//length of date-array

			//data-array for BAP-DLL funcion 'BAP_Request'
			for(i=0;i<datalength;i++)
			Request_data[i]=gBAP_Request[gstatus_requestbuffer] [i+3];

			/*				
		writelineEx(1, 0, "Request_header:");							//debug
				for (i=0;i<6;i++)												//debug
					writeEX(1, 0, " %x",Request_header [i]);					//debug
				
				writelineEx(1, 0, "Request_data:");								//debug
				for (i=0;i<datalength;i++)										//debug
					writeEX(1, 0, " %x",Request_data [i]);						//debug
		*/
			break;
		case Bap_Acknowledge:
			break;
		default:
			writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer]);
			error=0;
			break;			
		}
		if(error)																			//no data-error
		{
			temp=Bap180_Request(NODE_INDEX, Request_header, Request_data);					//send data to BAP-DLL
			
			if(temp==0)																		//BAP-Request succesful											
			{
				//writelineEx(gBAP_Trace, 0, "ASG-Request:    ");								//BAL-Trace		
				//for (i=0;i<gBAP_Requestbuffer_status [gstatus_requestbuffer];i++)			//BAL-Trace	
				//writeEX(gBAP_Trace, 0, " %x",gBAP_Request [gstatus_requestbuffer] [i]);	//BAL-Trace	
				//write("Send buffer-element %d to BAP-DLL", gstatus_requestbuffer); 			//debug
			}
			else																			//BAP-Request error
			{
				writelineEx(gBAP_Trace, 0, "ASG Error BAP_Request, errorcode: %x. ASG-Request:",temp);				//debug
				for (i=0;i<gBAP_Requestbuffer_status [gstatus_requestbuffer];i++)									//debug
				writeEX(gBAP_Trace, 0, " %x",gBAP_Request [gstatus_requestbuffer] [i]);							//debug
			}
		}

		gBAP_Requestbuffer_status [gstatus_requestbuffer]=0;		//reset position status -> free position 
		gBAP_Requestbuffer_BAPDataTyp [gstatus_requestbuffer]=0;	//reset BAP-datatyp of sendet buffer element

		//delete sendet request buffer elements
		for(i=0;i<BAP_BUFFER_SIZE;i++)
		gBAP_Request [gstatus_requestbuffer] [i]=0;				//delete sended array
		
		if (gstatus_requestbuffer<(REQUESTBUFFER_LINES-1))			//last element of buffer is not reached	
		gstatus_requestbuffer++;
		else														//last element of buffer is reached
		gstatus_requestbuffer=0;
	}
}

init_variables()	//initialize/reset all global variables
{
	dword i, j;

	//BAP communication
	for (i=0;i<BAP_BUFFER_SIZE;i++)
	gBAP_Indication[i]=0;
	
	//RGB-Values for background colors
	gRGB_red    =MakeRGB(255,0,0);
	gRGB_yellow =MakeRGB(255,255,0);
	gRGB_green  =MakeRGB(0,255,0);
	gRGB_grey   =MakeRGB(192,192,192);
	gRGB_white  =MakeRGB(255,255,255);

	for (j=0;j<REQUESTBUFFER_LINES;j++)
	{
		gBAP_Requestbuffer_status[j] =0;
		gBAP_Requestbuffer_BAPDataTyp[j] =0;
		
		for (i=0;i<BAP_BUFFER_SIZE;i++)
		gBAP_Request[j][i] =0;
	}

	gwrite_requestbuffer_line   =0; 
	gstatus_requestbuffer       =0;

	putvalue(env_ASG_NaviSD_Config_SWConfig,xml_path);
	putvalue(env_ASG_NaviSD_Config_DBC,dbc_path);

	//FunctionList
	for (i=0;i<8;i++)
	gFunctionList_FctList[i] =0;

	putvalue(env_ASG_NaviSD_FctList_Bit01,FALSE); 
	putvalue(env_ASG_NaviSD_FctList_Bit02,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit03,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit04,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit13,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit14,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit15,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit16,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit17,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit18,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit19,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit20,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit21,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit22,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit23,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit24,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit25,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit26,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit27,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit28,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit29,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit30,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit31,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit32,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit33,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit33,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit34,FALSE); 
	putvalue(env_ASG_NaviSD_FctList_Bit35,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit36,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit37,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit38,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit39,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit40,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit41,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit42,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit43,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit44,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit45,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit46,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit47,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit48,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit49,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit50,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit51,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit52,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit53,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit54,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit55,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit56,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit57,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit58,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit59,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit60,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit61,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit62,FALSE);

	//FSG-OperationState
	gFSG_OperationState =NAV_OPSTATE_OFF;
	putvalue(env_ASG_NaviSD_FSG_OP_State, empty_string);

	//CompassInfo
	gCI_Direction_Symbolic  =0;
	gCI_Direction_Angle     =0;
	putValue(env_ASG_NaviSD_DirectionSymbolic,empty_string);
	putValue(env_ASG_NaviSD_Direction_Angle, 0);

	//RouteGuidance_Stus
	gRG_Status =0;
	putValue(env_ASG_NaviSD_RG_Status, empty_string);

	//DistanceToNextManeuver
	gDTNM_Distance      =0;
	gDTNM_Unit          =0;
	gDTNM_BargraphOnOff =0;
	gDTNM_Bargraph      =0;
	putValue(env_ASG_NaviSD_DTNM_Distance, 0);
	putValue(env_ASG_NaviSD_DTNM_Unit, empty_string);
	putValue(env_ASG_NaviSD_DTNM_BG_ON_OFF, empty_string);
	putValue(env_ASG_NaviSD_DTNM_BG, 0);
	putValue(env_ASG_NaviSD_DTNM_ValidityInfo, empty_string); 

	//CurrentPositionInfo
	for (i=0;i<NAV_CURRENTPOSITIONINFO_LENGTH;i++)
	gCurrentPositionInfo_PositionInfo[i] =0;
	
	putValue(env_ASG_NaviSD_PositionInfo, empty_string);

	//DistanceToDestination
	gDTD_Distance              =0;
	gDTD_Unit                  =0;
	gDTD_ValidityInformation   =0;
	
	putValue(env_ASG_NaviSD_DTD_Distance, 0);
	putValue(env_ASG_NaviSD_DTD_Unit, empty_string);
	putValue(env_ASG_NaviSD_DTD_ValidityInfo, empty_string);

	//TimeToDestination
	gTTD_TimeInfoType           =0;
	gTTD_NavigationTimeFormat   =0;
	gTTD_Minute                 =0;
	gTTD_Hour                   =0;
	gTTD_Day                    =0;
	gTTD_Month                  =0;
	gTTD_Year                   =0;
	gTTD_ValidityInformation    =0;
	
	putValue(env_ASG_NaviSD_TTD_TimeInfoType, empty_string);
	putValue(env_ASG_NaviSD_TTD_NavigationTF, empty_string);
	putValue(env_ASG_NaviSD_TTD_Minute, 0);
	putValue(env_ASG_NaviSD_TTD_Hour, 0);
	putValue(env_ASG_NaviSD_TTD_Day, 0);
	putValue(env_ASG_NaviSD_TTD_Month, 0);
	putValue(env_ASG_NaviSD_TTD_Year, 0);
	putValue(env_ASG_NaviSD_TTD_Minute_VI, empty_string);
	putValue(env_ASG_NaviSD_TTD_Hour_VI, empty_string);
	putValue(env_ASG_NaviSD_TTD_Day_VI, empty_string);
	putValue(env_ASG_NaviSD_TTD_Month_VI, empty_string);
	putValue(env_ASG_NaviSD_TTD_Year_VI, empty_string);

	//TMCinfo
	gTMCinfo_MessageID      =0;
	gTMCinfo_MessageStatus  =0;

	putvalue(env_ASG_NaviSD_TMCI_MsgID, gTMCinfo_MessageID);
	putvalue(env_ASG_NaviSD_TMCI_MS_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_MS, gTMCinfo_MessageStatus);
	putvalue(env_ASG_NaviSD_TMCI_MesWaitInd_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_StreetName_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_Location_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_Infotext_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_Len_Vali_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_Len_Unit_s, empty_string);

	//FunctionSynchronisation
	for (i=0; i<8; i++)
	gNaviSD_FunctionSynchronisation_FctList[i] =0;
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit16, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit16_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit17, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit17_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit18, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit18_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit19, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit19_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit20, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit20_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit21, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit21_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit22, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit22_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit23, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit23_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit24, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit24_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit25, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit25_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit26, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit26_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit27, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit27_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit28, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit28_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit29, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit29_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit30, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit30_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit31, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit31_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit32, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit32_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit33, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit33_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit34, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit34_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit35, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit35_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit36, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit36_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit37, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit37_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit38, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit38_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit39, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit39_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit40, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit40_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit41, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit41_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit42, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit42_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit43, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit43_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit44, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit44_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit45, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit45_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit46, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit46_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit47, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit47_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit0, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit0_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit1, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit1_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit2, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit2_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit3, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit3_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit4, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit4_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit5, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit5_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit6, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit6_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit7, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit7_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit0, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit0_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit1, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit1_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit2, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit2_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit3, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit3_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit4, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit4_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit5, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit5_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit6, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit6_s, empty_string);
	
	//InfoStates
	putvalue(env_ASG_NaviSD_InfoSt_States_s,empty_string);

	//ActiveRgType
	gNAV_ActiveRgType_RGType =NAV_ACTIVERGTYPE_RGI;

	putvalue(env_ASG_NaviSD_ActRGTy_RGType_s,empty_string);
	putvalue(env_ASG_NaviSD_ActRGT_RGType,NAV_ACTIVERGTYPE_RGI);

	//RepeatLastNavAnnouncement
	gNav_RepeatLastNavAnn_Result =0;
	putvalue(env_ASG_NaviSD_RepLastNavAnn_Res,empty_string);
	putvalue(env_ASG_NaviSD_RepLastNavAnn_E_s,empty_string);
	putvalue(env_ASG_NaviSD_RepLastNavAnn_Err,0);

	//RG_ActDeact
	gNav_RG_ActDeact_Result =0;
	putvalue(env_ASG_NaviSD_RGActDeact_Res_s,empty_string);
	putvalue(env_ASG_NaviSD_RGActDeact_Err_s,empty_string);
	putvalue(env_ASG_NaviSD_RGActDeact_Err,0);

	gNav_ControlType        =0;
	putvalue(env_ASG_NaviSD_RGActDeact_CoType, NAV_STARTROUTEGUIDANCE);

	gNav_CI_Type            =0;
	putvalue(env_ASG_NaviSD_RGActDeact_CIType, NAV_INVALID);
	
	gNav_ControlInformation =0;
	putvalue(env_ASG_NaviSD_RGActDeact_CoInfo, gNav_ControlInformation);

	
	//LaneGuidance
	gLaneGuidance_ASGID    =0;
	gLaneGuidance_TAID     =0;
	
	putvalue(env_ASG_NaviSD_LG_ASGID, gLaneGuidance_ASGID);
	putvalue(env_ASG_NaviSD_LG_TAID,gLaneGuidance_TAID);
	putvalue(env_ASG_NaviSD_LG_AH_shift, 0); 
	putvalue(env_ASG_NaviSD_LG_AH_PosTrans, FALSE); 
	putvalue(env_ASG_NaviSD_LG_AH_RA, 0);
	putvalue(env_ASG_NaviSD_LG_AH_start,0);
	putvalue(env_ASG_NaviSD_LG_AH_elements,3);

	//LastDest_List
	gLastDestList_ASGID                 =NAV_LASTDESTLIST_ASGID_DEFAULTASG;
	gLastDestList_TAID                  =0;
	gLastDestList_TotalNumListElements  =0;
	
	for(j=0; j<NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE; j++)
	{     
		gLastDestList_Pos[j]                            =0;
		gLastDestList_ListEntryReceptionInformation[j]  =0;

		for(i=0;i<NAV_LASTDESTLIST_DESCRIPTION_LENGTH;i++)
		gLastDestList_Description[i] =0;
	}
	
	gLastDestList_SlidingWindow_State   =NAV_LASTDESTLIST_SLIDINGWINDOW_NOTACTIVE;
	gLastDestList_ListHandlingType      =NAV_LASTDESTLIST_NOCACHE;
	gLastDestList_cacheBuildUp          =NAV_LASTDESTLIST_BUILDUPCACHENOCACHE;
	gLastDestList_CallBackReason        =NAV_LASTDESTLIST_CALLBACKREASON_NOCALLBACK;

	gLastDestList_cacheDown             =FALSE;
	gLastDestList_cacheUp               =FALSE;
	gLastDestList_LastFirstElement      =0;

	gLastDestList_recordaddress         =0;
	gLastDestList_transmitpos           =FALSE;
	gLastDestList_CursorAction          =NAV_LASTDESTLIST_CURSORACTION_NOTHING;
	gLastDestList_DisplayStatus         =NAV_LASTDESTLIST_DISPLAYLIST_FIRST_ELEMENTS;

	putvalue(env_ASG_NaviSD_LDL_ASGID, gLastDestList_ASGID);
	putvalue(env_ASG_NaviSD_LDL_TAID, gLastDestList_TAID);
	putvalue(env_ASG_NaviSD_LDL_TotalNumLE, gLastDestList_TotalNumListElements);
	putvalue(env_ASG_NaviSD_LDL_AH_shift, 0);
	putvalue(env_ASG_NaviSD_LDL_AH_IS, FALSE);
	putvalue(env_ASG_NaviSD_LDL_AH_dir, FORWARD);
	putvalue(env_ASG_NaviSD_LDL_AH_PosTrans, gLastDestList_transmitpos);
	putvalue(env_ASG_NaviSD_LDL_AH_RA, gLastDestList_recordaddress);
	putvalue(env_ASG_NaviSD_LDL_AH_start, 0);
	putvalue(env_ASG_NaviSD_LDL_AH_elements, 3);
	putvalue(env_ASG_NaviSD_LDL_ListOpState, empty_string);
	putvalue(env_ASG_NaviSD_LDL_OnOff, FALSE);

	putvalue(env_ASG_NaviSD_LDL_pos_0, 0);
	putvalue(env_ASG_NaviSD_LDL_pos_1, 0);
	putvalue(env_ASG_NaviSD_LDL_pos_2, 0);

	putvalue(env_ASG_NaviSD_LDL_Type_s_0,empty_string);
	putvalue(env_ASG_NaviSD_LDL_Type_s_1,empty_string);
	putvalue(env_ASG_NaviSD_LDL_Type_s_2,empty_string);
	
	putvalue(env_ASG_NaviSD_LDL_Descr_s_0, empty_string);
	putvalue(env_ASG_NaviSD_LDL_Descr_s_1, empty_string);
	putvalue(env_ASG_NaviSD_LDL_Descr_s_2, empty_string);

	putvalue(env_ASG_NaviSD_LDL_OnOff, 0);

	//FavoriteDestList
	gFavoriteDestList_ASGID                 =NAV_FAVORITEDESTLIST_ASGID_DEFAULTASG;
	gFavoriteDestList_TAID                  =0;
	gFavoriteDestList_TotalNumListElements  =0;
	gFavoriteDestList_Pos                            =0;

	for(i=0;i<NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH;i++)
	  gFavoriteDestList_Description[i] =0;

	gFavoriteDestList_recordaddress         =0;
	gFavoriteDestList_transmitpos           =FALSE;

	putvalue(env_ASG_NaviSD_FDL_ASGID, gFavoriteDestList_ASGID);
	putvalue(env_ASG_NaviSD_FDL_TAID, gFavoriteDestList_TAID);
	putvalue(env_ASG_NaviSD_FDL_TotalNumLE, gFavoriteDestList_TotalNumListElements);
	putvalue(env_ASG_NaviSD_FDL_AH_shift, 0);
	putvalue(env_ASG_NaviSD_FDL_AH_dir, FORWARD);
	putvalue(env_ASG_NaviSD_FDL_AH_PosTrans, gFavoriteDestList_transmitpos);
	putvalue(env_ASG_NaviSD_FDL_AH_RA, gFavoriteDestList_recordaddress);
	putvalue(env_ASG_NaviSD_FDL_AH_start, 0);
	putvalue(env_ASG_NaviSD_FDL_AH_elements, 3);
	putvalue(env_ASG_NaviSD_FDL_ListOpState, empty_string);
	putvalue(env_ASG_NaviSD_FDL_OnOff, FALSE);

	putvalue(env_ASG_NaviSD_FDL_pos_0, 0);
	putvalue(env_ASG_NaviSD_FDL_pos_1, 0);
	putvalue(env_ASG_NaviSD_FDL_pos_2, 0);

	putvalue(env_ASG_NaviSD_FDL_Type_s_0,empty_string);
	putvalue(env_ASG_NaviSD_FDL_Type_s_1,empty_string);
	putvalue(env_ASG_NaviSD_FDL_Type_s_2,empty_string);
	
	putvalue(env_ASG_NaviSD_FDL_Descr_s_0, empty_string);
	putvalue(env_ASG_NaviSD_FDL_Descr_s_1, empty_string);
	putvalue(env_ASG_NaviSD_FDL_Descr_s_2, empty_string);

	putvalue(env_ASG_NaviSD_FDL_OnOff, 0);

	//-----------------------------------------------------------------
	//--------------------0x3A VideoStreams
	putvalue(env_ASG_NaviSD_VS_AH_TransPos,1);
	//-----------------------------------------------------------------
	//--------------------0x3E Picture
	putvalue(env_ASG_NaviSD_Pic_AH_TransPos,1);

	putvalue(env_ASG_NaviSD_AL_OnOff, 0);
}

BAP_Indication(int datalength)
{
	switch(gBAP_Indication[0])
	{
	case LSG_NaviSD:
		NaviSD_functions(datalength); 
		break;
	default:
		write("error BAP_Indication: invalid/unhandled LSG-ID %x", gBAP_Indication[0]);
	}
}

NaviSD_functions(int datalength)	
{
	//write("Debug: NaviSD_functions triggered -> Fct-ID=0x%x",gBAP_Indication[1]);
	switch (gBAP_Indication[1]) // function-ID
	{
	case FctID_GetAll: 
		//write("Debug: GetAll_Indication triggered");
		GetAll_Indication(gBAP_Indication, datalength);
		break;
	case FctID_BAP_Config:
		//write("Debug: BAP_Config_Indication triggered");
		BAP_Config_Indication(gBAP_Indication, datalength);
		break;
	case FctID_FunctionList:
		//write("Debug: FunctionList_Indication triggered");
		FunctionList_Indication(gBAP_Indication, datalength);
		break;
	case FctID_HeartBeat:
		//write("Debug: HeartBeat_Indication triggered");
		HeartBeat_Indication(gBAP_Indication, datalength);
		break;
	case FctID_FSG_Control:
		//write("Debug: HeartBeat_Indication triggered");
		FSG_Control_Indication(gBAP_Indication, datalength);
		break;
	case FctID_FSG_Setup:
		//write("Debug: HeartBeat_Indication triggered");
		FSG_Setup_Indication(gBAP_Indication, datalength);
		break;
	case FctID_FSG_OperationState:
		//write("Debug: FSG_OperationState_Indication triggered");
		FSG_OperationState_Indication(gBAP_Indication, datalength);
		break;
	case FctID_CompassInfo:
		//write("Debug: CompassInfo_Indication triggered");
		CompassInfo_Indication(gBAP_Indication, datalength);
		break;
	case FctID_RG_Status:
		//write("Debug: RG_Status_Indication triggered");
		RG_Status_Indication(gBAP_Indication, datalength);
		break;
	case FctID_DistanceToNextManeuver:
		//write("Debug: DistanceToNextManeuver_Indication triggered");
		DistanceToNextManeuver_Indication(gBAP_Indication, datalength);
		break;
	case FctID_CurrentPositionInfo:
		//write("Debug: CurrentPositionInfo_Indication triggered");
		CurrentPositionInfo_Indication(gBAP_Indication, datalength);
		break;
	case FctID_TurnToInfo:
		//write("Debug: TurnToInfo_Indication triggered");
		TurnToInfo_Indication(gBAP_Indication, datalength);
		break;
	case FctID_DistTimeToDestination:
		//write("Debug: DistanceToDestination_Indication triggered");
		DistTimeToDestination_Indication(gBAP_Indication, datalength);
		break;
	case FctID_ManeuverDescriptor_1:
		//write("Debug: ManeuverDescriptor_Indication triggered");
		ManeuverDescriptor_1_Indication(gBAP_Indication, datalength);
		break;
	case FctID_ManeuverDescriptor_2:
		//write("Debug: ManeuverDescriptor_Indication triggered");
		ManeuverDescriptor_2_Indication(gBAP_Indication, datalength);
		break;
	case FctID_ManeuverDescriptor_3:
		//write("Debug: ManeuverDescriptor_Indication triggered");
		ManeuverDescriptor_3_Indication(gBAP_Indication, datalength);
		break;
	case FctID_LaneGuidance:
		//write("Debug: LaneGuidance_Indication triggered");
		LaneGuidance_Indication(gBAP_Indication, datalength);
		break;
	case FctID_TMCinfo:
		//write("Debug: TMCinfo_Indication triggered");
		TMCinfo_Indication(gBAP_Indication, datalength);
		break;
	case FctID_LastDest_List:
		//write("Debug: LastDestList_Indication triggered");
		LastDestList_Indication(gBAP_Indication, datalength);
		break;
	case FctID_FavoriteDest_List:
		//write("Debug: FavoriteDestList_Indication triggered");
		FavoriteDestList_Indication(gBAP_Indication, datalength);
		break;
	case FctID_InfoState:
		//write("Debug: InfoStates_Indication triggered");
		InfoStates_Indication(gBAP_Indication, datalength);
		break;
	case FctID_ActiveRgType:
		//write("Debug: ActiveRgType_Indication triggered");
		ActiveRgType_Indication(gBAP_Indication, datalength);
		break;
	case FctID_RG_ActDeact:
		//write("Debug: RGActDeact_Indication triggered");
		RGActDeact_Indication(gBAP_Indication, datalength);
		break;
	case FctID_RptLastNavAnnouncement:
		//write("Debug: RepeatLastNavAnnouncement_Indication triggered");
		RepeatLastNavAnnouncement_Indication(gBAP_Indication, datalength);
		break;
	case FctID_ListSetup:
		//write("Debug: ListSetup_Indication triggered");
		ListSetup_Indication(gBAP_Indication, datalength);
		break;
	case FctID_MapScale:
		//write("Debug: Indication_MapScale triggered");
		MapScale_Indication(gBAP_Indication, datalength);
		break;
	case FctID_Altitude:
		//write("Debug: Indication_Altitude triggered");
		Altitude_Indication(gBAP_Indication, datalength);
		break;
	case FctID_VideoStreams:
		//write("Debug: Indication_VideoStreams triggered");
		VideoStreams_Indication(gBAP_Indication, datalength);
		break;
	case FctID_RequestSync_Video:
		//write("Debug: Indication_RequestSync_Video triggered");
		RequestSync_Video_Indication(gBAP_Indication, datalength);
		break;
	case FctID_Picture:
		//write("Debug: Indication_Picture triggered");
		Picture_Indication(gBAP_Indication, datalength);
		break;
	default:
		write("ASG-NaviSD NaviSD_functions: invalid funcion-ID %x", gBAP_Indication[1]);
		break;
	}	

}

byte get_requestbuffer_line()	//function to reserve memory in request-ring-buffer
{
	int line;

	//init lokal variables
	line=0;
	//********************	
	
	line=gwrite_requestbuffer_line;							//next free element in ring-buffer
	if(gwrite_requestbuffer_line<(REQUESTBUFFER_LINES-1))	//last element of ring-buffer is not reached
	gwrite_requestbuffer_line++;
	else													//last element of ring-buffer is reached
	gwrite_requestbuffer_line=0;
	
	return (line);											//return position of free ring-buffer element
}

on timer TaskTimer
{
	Bap180_Task(NODE_INDEX);	//DLL-Task
	BAP_DLL_Indication();
  BAP_DLL_Request();
	BAP_CAN_TX_Request();
	BAP_DLL_SetRxData();

	setTimer(TaskTimer, 10);	//restart BAP-DLL-Timer
}

GetAll_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
	case Data_IND:
		FunctionList_Request(DataGet_REQ);
		HeartBeat_Request(DataGet_REQ);
		FSG_Control_Request(DataGet_REQ);
		FSG_Setup_Request(DataGet_REQ);
		FSG_OperationState_Request(DataGet_REQ);
		InfoStates_Request(DataGet_REQ);
		ActiveRgType_Request(DataGet_REQ);
		CompassInfo_Request(DataGet_REQ);
		RG_Status_Request(DataGet_REQ);
		DistanceToNextManeuver_Request(DataGet_REQ);
		CurrentPositionInfo_Request(DataGet_REQ);
		Altitude_Request(DataGet_REQ);
		TurnToInfo_Request(DataGet_REQ);
		DistTimeToDestination_Request(DataGet_REQ);
		ManeuverDescriptor_1_Request(DataGet_REQ);
		ManeuverDescriptor_2_Request(DataGet_REQ);
		ManeuverDescriptor_3_Request(DataGet_REQ);
		TMCinfo_Request(DataGet_REQ);
		ListSetup_Request(DataGet_REQ);
		MapScale_Request(DataGet_REQ);
		//		  setTimer(OnStart_send_ASGcapabilities, 20);	//send ASG Capabilities.SetGet some seconds after GetAll
		//      setTimer(GetTMCInfo_Timer, 100);     
		break;
	case Error_IND:				
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD GetAll_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD GetAll_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD GetAll_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD GetAll_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		write("ASG-NaviSD GetAll_Indication: unknown indication 0x%d", gBAP_Indication[0]);
		break;
	}
}

GetAll_Request(byte request)
{
	int i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables.
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request
	requestarray[0]=LSG_NaviSD;	    //LSG-ID
	requestarray[1]=FctID_GetAll;	//Fct.-ID
	requestarray[2]=request;        //request

	switch (request)
	{
	case DataGet_REQ:					
		set_status_requestbuffer (requestarray, 3, Bap_Void);	//send GetAll.Get
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD GetAll_Request: unknown request %d", request);
		break;
	}
}

BAP_Config_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2]) // indication
	{ 
	case Reset_IND:         
		init_variables();				//reset all variables and states				
		gBAP_NaviSD_available =TRUE;    //FSG available                  
		GetAll_Request(DataGet_REQ);	//send GetAll.Get                            
		break;
	case Data_IND:   
		gBAP_NaviSD_available =TRUE;    //FSG available                    
		GetAll_Request(DataGet_REQ);	//send GetAll.Get                   
		break;
	case Error_IND:			            	            			            
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD BAP_Config_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD BAP_Config_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD BAP_Config_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD BAP_Config_Indication: Application-Error: 0x%x", Indication_array[3]);			            	
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD BAP_Config_Indication: unknown indication 0x%x", gBAP_Indication[2]);
		break;
	}
}

on envVar env_ASG_PowerOnOff
{
	int length, error;

	putvalue(env_ASG_PowerOnOff_s, gstring_ASG_PowerOnOff [getvalue(this)]);	
	if(TRUE==getvalue(this))
	{
		if(gBAP_Init==FALSE)
		{
			gBAP_Init =TRUE;
			//BAP-Init ASG
			error =Bap180_Init(NODE_INDEX,LSG_NaviSD);
			if(error==0)
			{
				write("ASG-NaviSD BAP_Init succesful");
			}
			else
			{
				write("ASG-NaviSD error BAP_Init: %d", error);
			}
		}
		init_variables();							//initialize variables
		//activate panel elements for TMCinfo
		enablecontrol("ASG_NaviSD", "NaviSD_TMCinfo", 1);
		setcontrolbackcolor("ASG_NaviSD", "NaviSD_TMCinfo", gRGB_white);

		//BAP-Start ASG
		error =Bap180_Start(NODE_INDEX,LSG_NaviSD);
		if(error ==BAP_ERR_OK)
		{
			write("ASG-NaviSD BAP_Start succesful\n");
		}
		else
		{
			write("ASG-NaviSD error BAP_Start: %d", error);
		}

		settimer(Powerontimer, 20);
	}
	else
	{
		Bap180_Shutdown(NODE_INDEX,LSG_NaviSD);
		gASG_PowerOnOff =getvalue(this);
		Shutdown_NaviSD();
	}
}

on envVar env_ASG_NaviSD_ActRGT_RGType_set
{
	if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{   
		gNAV_ActiveRgType_RGType =getvalue(env_ASG_NaviSD_ActRGT_RGType);
		ActiveRgType_Request(DataSetGet_REQ);
	}
}

on envVar env_ASG_NaviSD_TMCI_update
{
	if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
		gTMCinfo_MessageID      =getvalue(env_ASG_NaviSD_TMCI_MsgID);
		gTMCinfo_MessageStatus  =getvalue(env_ASG_NaviSD_TMCI_MS);
		
		TMCinfo_Request(DataSetGet_REQ);
	}
}

on envVar env_ASG_NaviSD_MS_update
{
	if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
		gASG_MapScale_Steps     = getvalue(env_ASG_NaviSD_MS_Setps);
		gASG_MapScale_AutoZoom  = getvalue(env_ASG_NaviSD_MS_AutoZoom_h);
		
		MapScale_Request(DataSetGet_REQ);
	}  
}

on envVar env_ASG_NaviSD_RGActDeact_SR
{
	if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
		gNav_RGAD_ASG_ID        = getvalue(env_ASG_NaviSD_RGActDeact_ASGid);
		gNav_ControlType        = getvalue(env_ASG_NaviSD_RGActDeact_CoType);
		gNav_CI_Type            = getvalue(env_ASG_NaviSD_RGActDeact_CIType);
		gNav_ControlInformation = getvalue(env_ASG_NaviSD_RGActDeact_CoInfo);

		putvalue(env_ASG_NaviSD_RGActDeact_Err,0);
		putvalue(env_ASG_NaviSD_RGActDeact_Err_s,empty_string);
		putvalue(env_ASG_NaviSD_RGActDeact_Res_s,empty_string);
		
		RGActDeact_Request(StartResult_REQ);
	}
}

on envVar env_ASG_NaviSD_RGActDeact_Abort
{
	if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
		RGActDeact_Request(AbortResult_REQ);
		
		putvalue(env_ASG_NaviSD_RGActDeact_Err,0);
		putvalue(env_ASG_NaviSD_RGActDeact_Err_s,empty_string);
		putvalue(env_ASG_NaviSD_RGActDeact_Res_s,empty_string);
	}
}

on envVar env_ASG_NaviSD_RepLastNavAnn_SR
{
	if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
		gNav_RepeatLastNavAnn_ASGID = getvalue(env_ASG_NaviSD_RepLastNavAnn_ASG);
		RepeatLastNavAnnouncement_Request(StartResult_REQ);
		
		putvalue(env_ASG_NaviSD_RepLastNavAnn_Err,0);
		putvalue(env_ASG_NaviSD_RepLastNavAnn_E_s,empty_string);
		putvalue(env_ASG_NaviSD_RepLastNavAnn_Res,empty_string);
	}
}

on envVar env_ASG_NaviSD_RepLastNavAnn_Abo
{
	if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
		RepeatLastNavAnnouncement_Request(AbortResult_REQ);

		putvalue(env_ASG_NaviSD_RepLastNavAnn_Err,0);
		putvalue(env_ASG_NaviSD_RepLastNavAnn_E_s,empty_string);
		putvalue(env_ASG_NaviSD_RepLastNavAnn_Res,empty_string);
	}       
}

on envVar env_ASG_NaviSD_RSV_Start
{
	if(getvalue(this))
	RequestSync_Video_Request(StartResult_REQ);
}

on envVar env_ASG_NaviSD_RSV_Abort
{
	if(getvalue(this))
	RequestSync_Video_Request(AbortResult_REQ);
}

on envVar env_ASG_NaviSD_LG_GetArray
{
	byte mode, shift, direction, transmitpos, indexsize,recordaddress;
	word requested_startelement, startelement, elements;

	// Init local variables. 
	mode                    =0;
	shift                   =0;
	direction               =0;
	transmitpos             =0;
	indexsize               =0;
	recordaddress           =0;
	requested_startelement  =0;
	startelement            =0;
	elements                =0;

	if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
		gLaneGuidance_ASGID   = getvalue(env_ASG_NaviSD_LG_ASGID);
		gLaneGuidance_TAID    = getvalue(env_ASG_NaviSD_LG_TAID);;
		shift                 = getvalue(env_ASG_NaviSD_LG_AH_shift);;
		direction             = getvalue(env_ASG_NaviSD_LG_AH_Dir);;
		transmitpos           = getvalue(env_ASG_NaviSD_LG_AH_PosTrans);;
		indexsize             = getvalue(env_ASG_NaviSD_LG_AH_IS);;
		recordaddress         = getvalue(env_ASG_NaviSD_LG_AH_RA);;
		startelement          = getvalue(env_ASG_NaviSD_LG_AH_start);;
		elements              = getvalue(env_ASG_NaviSD_LG_AH_elements);;
		
		requested_startelement  =startelement;
		mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
		//writeEX(gBAP_Trace, 0, "GetArray_indexSize %x",indexsize); //debug
		LaneGuidance_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
	}
}

on envVar env_ASG_NaviSD_LDL_GetArray
{
	byte mode, shift, direction, transmitpos, indexsize,recordaddress;
	word requested_startelement, startelement, elements;

	// Init local variables. 
	mode                    =0;
	shift                   =0;
	direction               =0;
	transmitpos             =0;
	indexsize               =0;
	recordaddress           =0;
	requested_startelement  =0;
	startelement            =0;
	elements                =0;

	if(POWER_ON==gASG_PowerOnOff && getvalue(this) && gLastDestList_ListHandlingType ==NAV_LASTDESTLIST_NOCACHE)
	{
		gLastDestList_ASGID             =getvalue(env_ASG_NaviSD_LDL_ASGID);
		gLastDestList_TAID              =getvalue(env_ASG_NaviSD_LDL_TAID);
		shift                           =getvalue(env_ASG_NaviSD_LDL_AH_shift);
		direction                       =getvalue(env_ASG_NaviSD_LDL_AH_dir);
		transmitpos                     =getvalue(env_ASG_NaviSD_LDL_AH_PosTrans);
		indexsize                       =getvalue(env_ASG_NaviSD_LDL_AH_IS);
		recordaddress                   =getvalue(env_ASG_NaviSD_LDL_AH_RA);
		startelement                    =getvalue(env_ASG_NaviSD_LDL_AH_start);
		elements                        =getvalue(env_ASG_NaviSD_LDL_AH_elements);
		
		requested_startelement  =startelement;
		mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

		LastDestList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
	}
}

on envVar env_ASG_NaviSD_FDL_GetArray
{
	byte mode, shift, direction, transmitpos, indexsize,recordaddress;
	word requested_startelement, startelement, elements;

	// Init local variables. 
	mode                    =0;
	shift                   =0;
	direction               =0;
	transmitpos             =0;
	indexsize               =0;
	recordaddress           =0;
	requested_startelement  =0;
	startelement            =0;
	elements                =0;

	if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
		gFavoriteDestList_ASGID         =getvalue(env_ASG_NaviSD_FDL_ASGID);
		gFavoriteDestList_TAID          =getvalue(env_ASG_NaviSD_FDL_TAID);
		shift                           =getvalue(env_ASG_NaviSD_FDL_AH_shift);
		direction                       =getvalue(env_ASG_NaviSD_FDL_AH_dir);
		transmitpos                     =getvalue(env_ASG_NaviSD_FDL_AH_PosTrans);
		indexsize                       =getvalue(env_ASG_NaviSD_FDL_AH_IS);
		recordaddress                   =getvalue(env_ASG_NaviSD_FDL_AH_RA);
		startelement                    =getvalue(env_ASG_NaviSD_FDL_AH_start);
		elements                        =getvalue(env_ASG_NaviSD_FDL_AH_elements);
		
		requested_startelement  =startelement;
		mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

		FavoriteDestList_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
	}
}

on envVar env_ASG_NaviSD_VS_GetArray
{
	byte mode, shift, direction, transmitpos, indexsize,recordaddress;
	word requested_startelement, startelement, elements;

	// Init local variables. 
	mode                    =0;
	shift                   =0;
	direction               =0;
	transmitpos             =0;
	indexsize               =0;
	recordaddress           =0;
	requested_startelement  =0;
	startelement            =0;
	elements                =0;

	if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
		gVideoStreams_ASGID             =getvalue(env_ASG_NaviSD_VS_AsgId);
		gVideoStreams_TAID              =getvalue(env_ASG_NaviSD_VS_TAID);;
		shift                           =getvalue(env_ASG_NaviSD_VS_AH_Shift);;
		direction                       =getvalue(env_ASG_NaviSD_VS_AH_Dir);;
		transmitpos                     =getvalue(env_ASG_NaviSD_VS_AH_TransPos);;
		indexsize                       =getvalue(env_ASG_NaviSD_VS_AH_IndexSize);;
		recordaddress                   =getvalue(env_ASG_NaviSD_VS_AH_RecAddress);;
		startelement                    =getvalue(env_ASG_NaviSD_VS_AH_Start);;
		elements                        =getvalue(env_ASG_NaviSD_VS_AH_Elements);;
		
		requested_startelement  =startelement;
		mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
		//writeEX(gBAP_Trace, 0, "GetArray_indexSize %x",indexsize); //debug
		VideoStreams_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
	}
}

on envVar env_ASG_NaviSD_Pic_GetArray
{
	byte mode, shift, direction, transmitpos, indexsize,recordaddress;
	word requested_startelement, startelement, elements;

	// Init local variables. 
	mode                    =0;
	shift                   =0;
	direction               =0;
	transmitpos             =0;
	indexsize               =0;
	recordaddress           =0;
	requested_startelement  =0;
	startelement            =0;
	elements                =0;

	if(POWER_ON==gASG_PowerOnOff && getvalue(this))
	{
		gPicture_ASGID                  =getvalue(env_ASG_NaviSD_Pic_AsgId);
		gPicture_TAID                   =getvalue(env_ASG_NaviSD_Pic_TAID);;
		shift                           =getvalue(env_ASG_NaviSD_Pic_AH_Shift);;
		direction                       =getvalue(env_ASG_NaviSD_Pic_AH_Dir);;
		transmitpos                     =getvalue(env_ASG_NaviSD_Pic_AH_TransPos);;
		indexsize                       =getvalue(env_ASG_NaviSD_Pic_AH_IndexSize);;
		recordaddress                   =getvalue(env_ASG_NaviSD_Pic_AH_RecAddress);;
		startelement                    =getvalue(env_ASG_NaviSD_Pic_AH_Start);;
		elements                        =getvalue(env_ASG_NaviSD_Pic_AH_Elements);;
		
		requested_startelement  =startelement;
		mode                    =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
		//writeEX(gBAP_Trace, 0, "GetArray_indexSize %x",indexsize); //debug
		Picture_Request(DataGet_REQ, mode, recordaddress, requested_startelement, startelement, elements);
	}
}

void Shutdown_NaviSD ()
{
	//Timer
	canceltimer(Powerontimer);
	canceltimer(TaskTimer);

	putvalue(env_ASG_NaviSD_Config_SWConfig,empty_string);
	putvalue(env_ASG_NaviSD_Config_DBC,empty_string);

	//Bap-NAVI
	gBAP_NaviSD_available=FALSE;

	//FunctionList
	putvalue(env_ASG_NaviSD_FctList_Bit01,FALSE); 
	putvalue(env_ASG_NaviSD_FctList_Bit02,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit03,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit04,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit13,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit14,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit15,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit16,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit17,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit18,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit19,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit20,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit21,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit22,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit23,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit24,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit25,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit26,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit27,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit28,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit29,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit30,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit31,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit32,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit33,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit33,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit34,FALSE); 
	putvalue(env_ASG_NaviSD_FctList_Bit35,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit36,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit37,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit38,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit39,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit40,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit41,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit42,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit43,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit44,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit45,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit46,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit47,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit48,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit49,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit50,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit51,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit52,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit53,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit54,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit55,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit56,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit57,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit58,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit59,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit60,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit61,FALSE);
	putvalue(env_ASG_NaviSD_FctList_Bit62,FALSE);

	//FSG-OperationState
	putvalue(env_ASG_NaviSD_FSG_OP_State, empty_string);

	//CompassInfo
	putValue(env_ASG_NaviSD_DirectionSymbolic,empty_string);
	putValue(env_ASG_NaviSD_Direction_Angle, 0);

	//RouteGuidance_Stus
	putValue(env_ASG_NaviSD_RG_Status, empty_string);

	//DistanceToNextManeuver
	putValue(env_ASG_NaviSD_DTNM_Distance, 0);
	putValue(env_ASG_NaviSD_DTNM_Unit, empty_string);
	putValue(env_ASG_NaviSD_DTNM_BG_ON_OFF, empty_string);
	putValue(env_ASG_NaviSD_DTNM_BG, 0);
	putValue(env_ASG_NaviSD_DTNM_ValidityInfo, empty_string); 

	//CurrentPositionInfo
	putValue(env_ASG_NaviSD_PositionInfo, empty_string);

	//TurnToInfo
	putValue(env_ASG_NaviSD_TTI_TurnToInfo, empty_string);
	putValue(env_ASG_NaviSD_TTI_SignPost, empty_string);

	//DistanceToDestination
	gDTD_Distance              =0;
	gDTD_Unit                  =0;
	gDTD_ValidityInformation   =0;

	putValue(env_ASG_NaviSD_DTD_Distance, 0);
	putValue(env_ASG_NaviSD_DTD_Unit, empty_string);
	putValue(env_ASG_NaviSD_DTD_ValidityInfo, empty_string);

	//TimeToDestination
	gTTD_TimeInfoType           =0;
	gTTD_NavigationTimeFormat   =0;
	gTTD_Minute                 =0;
	gTTD_Hour                   =0;
	gTTD_Day                    =0;
	gTTD_Month                  =0;
	gTTD_Year                   =0;
	gTTD_ValidityInformation    =0;
	
	putValue(env_ASG_NaviSD_TTD_TimeInfoType, empty_string);
	putValue(env_ASG_NaviSD_TTD_NavigationTF, empty_string);
	putValue(env_ASG_NaviSD_TTD_Minute, 0);
	putValue(env_ASG_NaviSD_TTD_Hour, 0);
	putValue(env_ASG_NaviSD_TTD_Day, 0);
	putValue(env_ASG_NaviSD_TTD_Month, 0);
	putValue(env_ASG_NaviSD_TTD_Year, 0);
	putValue(env_ASG_NaviSD_TTD_Minute_VI, empty_string);
	putValue(env_ASG_NaviSD_TTD_Hour_VI, empty_string);
	putValue(env_ASG_NaviSD_TTD_Day_VI, empty_string);
	putValue(env_ASG_NaviSD_TTD_Month_VI, empty_string);
	putValue(env_ASG_NaviSD_TTD_Year_VI, empty_string);
	//TMCinfo
	putvalue(env_ASG_NaviSD_TMCI_MsgID, 0);
	putvalue(env_ASG_NaviSD_TMCI_MS_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_MS, 0);
	putvalue(env_ASG_NaviSD_TMCI_MesWaitInd_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_Priority, 0);
	putvalue(env_ASG_NaviSD_TMCI_StreetName_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_Location_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_Infotext_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_Len_Vali_s, empty_string);
	putvalue(env_ASG_NaviSD_TMCI_Len_Value, 0);
	putvalue(env_ASG_NaviSD_TMCI_Len_Unit_s, empty_string);

	//FunctionSynchronisation
	putvalue(env_ASG_NaviSD_FctSyn_Bit16, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit16_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit17, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit17_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit18, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit18_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit19, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit19_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit20, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit20_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit21, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit21_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit22, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit22_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit23, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit23_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit24, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit24_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit25, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit25_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit26, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit26_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit27, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit27_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit28, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit28_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit29, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit29_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit30, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit30_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit31, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit31_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit32, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit32_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit33, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit33_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit34, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit34_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit35, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit35_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit36, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit36_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit37, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit37_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit38, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit38_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit39, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit39_s, empty_string);

	putvalue(env_ASG_NaviSD_FctSyn_Bit40, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit40_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit41, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit41_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit42, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit42_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit43, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit43_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit44, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit44_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit45, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit45_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit46, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit46_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn_Bit47, 0);
	putvalue(env_ASG_NaviSD_FctSyn_Bit47_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit0, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit0_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit1, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit1_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit2, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit2_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit3, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit3_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit4, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit4_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit5, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit5_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit6, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit6_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn2_Bit7, 0);
	putvalue(env_ASG_NaviSD_FctSyn2_Bit7_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit0, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit0_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit1, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit1_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit2, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit2_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit3, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit3_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit4, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit4_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit5, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit5_s, empty_string);
	
	putvalue(env_ASG_NaviSD_FctSyn3_Bit6, 0);
	putvalue(env_ASG_NaviSD_FctSyn3_Bit6_s, empty_string);

	//InfoStates
	putvalue(env_ASG_NaviSD_InfoSt_States_s,empty_string);

	//ActiveRgType
	putvalue(env_ASG_NaviSD_ActRGTy_RGType_s,empty_string);
	putvalue(env_ASG_NaviSD_ActRGT_RGType,NAV_ACTIVERGTYPE_RGI);
	
	//TrafficBlock_Indication
	putvalue(env_ASG_NaviSD_TBInd_TMCSym_s, empty_string);

	//RG_ActDeact
	putvalue(env_ASG_NaviSD_RGActDeact_Res_s, empty_string);
	putvalue(env_ASG_NaviSD_RGActDeact_CoType, NAV_STARTROUTEGUIDANCE);
	putvalue(env_ASG_NaviSD_RGActDeact_CIType, NAV_INVALID);
	putvalue(env_ASG_NaviSD_RGActDeact_CoInfo, 0);
	putvalue(env_ASG_NaviSD_RGActDeact_Err_s,empty_string);
	putvalue(env_ASG_NaviSD_RGActDeact_Err,0);

	//RepeatLastNavAnnouncement
	putvalue(env_ASG_NaviSD_RepLastNavAnn_Res,empty_string);
	putvalue(env_ASG_NaviSD_RepLastNavAnn_E_s,empty_string);
	putvalue(env_ASG_NaviSD_RepLastNavAnn_Err,0);


	//LaneGuidance
	putvalue(env_ASG_NaviSD_LG_ASGID, 0);
	putvalue(env_ASG_NaviSD_LG_TAID,0);
	putvalue(env_ASG_NaviSD_LG_AH_shift, 0); 
	putvalue(env_ASG_NaviSD_LG_AH_PosTrans, 0); 
	putvalue(env_ASG_NaviSD_LG_AH_RA, 0);
	putvalue(env_ASG_NaviSD_LG_AH_start,0);
	putvalue(env_ASG_NaviSD_LG_AH_elements,0);

	//LastDest_List
	putvalue(env_ASG_NaviSD_LDL_ASGID, 0);
	putvalue(env_ASG_NaviSD_LDL_TAID, 0);
	putvalue(env_ASG_NaviSD_LDL_OnOff,0);
	putvalue(env_ASG_NaviSD_LDL_TotalNumLE, 0);
	putvalue(env_ASG_NaviSD_LDL_AH_shift, 0);
	putvalue(env_ASG_NaviSD_LDL_AH_dir, FORWARD);
	putvalue(env_ASG_NaviSD_LDL_AH_PosTrans, 0);
	putvalue(env_ASG_NaviSD_LDL_AH_RA, 0);
	putvalue(env_ASG_NaviSD_LDL_AH_start, 0);
	putvalue(env_ASG_NaviSD_LDL_AH_elements, 0);
	putvalue(env_ASG_NaviSD_LDL_ListOpState, empty_string);

	putvalue(env_ASG_NaviSD_LDL_pos_0, 0);
	putvalue(env_ASG_NaviSD_LDL_pos_1, 0);
	putvalue(env_ASG_NaviSD_LDL_pos_2, 0);

	putvalue(env_ASG_NaviSD_LDL_Type_s_0,empty_string);
	putvalue(env_ASG_NaviSD_LDL_Type_s_1,empty_string);
	putvalue(env_ASG_NaviSD_LDL_Type_s_2,empty_string);
	
	putvalue(env_ASG_NaviSD_LDL_Descr_s_0, empty_string);
	putvalue(env_ASG_NaviSD_LDL_Descr_s_1, empty_string);
	putvalue(env_ASG_NaviSD_LDL_Descr_s_2, empty_string);

	putvalue(env_ASG_NaviSD_LDL_OnOff, 0);

	//FavoriteDest_List
	putvalue(env_ASG_NaviSD_FDL_ASGID, 0);
	putvalue(env_ASG_NaviSD_FDL_TAID, 0);
	putvalue(env_ASG_NaviSD_FDL_OnOff,0);
	putvalue(env_ASG_NaviSD_FDL_TotalNumLE, 0);
	putvalue(env_ASG_NaviSD_FDL_AH_shift, 0);
	putvalue(env_ASG_NaviSD_FDL_AH_dir, FORWARD);
	putvalue(env_ASG_NaviSD_FDL_AH_PosTrans, FALSE);
	putvalue(env_ASG_NaviSD_FDL_AH_RA, 0);
	putvalue(env_ASG_NaviSD_FDL_AH_start, 0);
	putvalue(env_ASG_NaviSD_FDL_AH_elements, 0);
	putvalue(env_ASG_NaviSD_FDL_ListOpState, empty_string);

	putvalue(env_ASG_NaviSD_FDL_pos_0, 0);
	putvalue(env_ASG_NaviSD_FDL_pos_1, 0);
	putvalue(env_ASG_NaviSD_FDL_pos_2, 0);

	putvalue(env_ASG_NaviSD_FDL_Type_s_0,empty_string);
	putvalue(env_ASG_NaviSD_FDL_Type_s_1,empty_string);
	putvalue(env_ASG_NaviSD_FDL_Type_s_2,empty_string);
	
	putvalue(env_ASG_NaviSD_FDL_Descr_s_0, empty_string);
	putvalue(env_ASG_NaviSD_FDL_Descr_s_1, empty_string);
	putvalue(env_ASG_NaviSD_FDL_Descr_s_2, empty_string);

	putvalue(env_ASG_NaviSD_FDL_OnOff, 0);    

	//Address_List
	putvalue(env_ASG_NaviSD_AL_ASGID, 0);
	putvalue(env_ASG_NaviSD_AL_TAID, 0);
	putvalue(env_ASG_NaviSD_AL_OnOff,0);
	putvalue(env_ASG_NaviSD_AL_TotalNumLE, 0);
	putvalue(env_ASG_NaviSD_AL_OtherListTy,0);
	putvalue(env_ASG_NaviSD_AL_OtherListRef,0);
	putvalue(env_ASG_NaviSD_AL_AH_shift, 0);
	putvalue(env_ASG_NaviSD_AL_AH_dir, FORWARD);
	putvalue(env_ASG_NaviSD_AL_AH_PosTrans, FALSE);
	putvalue(env_ASG_NaviSD_AL_AH_IS, FALSE);
	putvalue(env_ASG_NaviSD_AL_AH_RA, 0);
	putvalue(env_ASG_NaviSD_AL_AH_start, 0);
	putvalue(env_ASG_NaviSD_AL_AH_elements, 0);
	putvalue(env_ASG_NaviSD_AL_ListOpState, empty_string);

	putvalue(env_ASG_NaviSD_AL_pos_0, 0);
	putvalue(env_ASG_NaviSD_AL_pos_1, 0);
	putvalue(env_ASG_NaviSD_AL_pos_2, 0);
	
	putvalue(env_ASG_NaviSD_AL_FirstName_s_0, empty_string);
	putvalue(env_ASG_NaviSD_AL_FirstName_s_1, empty_string);
	putvalue(env_ASG_NaviSD_AL_FirstName_s_2, empty_string);

	putvalue(env_ASG_NaviSD_AL_LastName_s_0, empty_string);
	putvalue(env_ASG_NaviSD_AL_LastName_s_1, empty_string);
	putvalue(env_ASG_NaviSD_AL_LastName_s_2, empty_string);

	putvalue(env_ASG_NaviSD_AL_POIDescr_s_0, empty_string);
	putvalue(env_ASG_NaviSD_AL_POIDescr_s_1, empty_string);
	putvalue(env_ASG_NaviSD_AL_POIDescr_s_2, empty_string);

	putvalue(env_ASG_NaviSD_AL_PostalCode_s_0, empty_string);
	putvalue(env_ASG_NaviSD_AL_PostalCode_s_1, empty_string);
	putvalue(env_ASG_NaviSD_AL_PostalCode_s_2, empty_string);

	putvalue(env_ASG_NaviSD_AL_City_s_0, empty_string);
	putvalue(env_ASG_NaviSD_AL_City_s_1, empty_string);
	putvalue(env_ASG_NaviSD_AL_City_s_2, empty_string);

	putvalue(env_ASG_NaviSD_AL_Street_s_0, empty_string);
	putvalue(env_ASG_NaviSD_AL_Street_s_1, empty_string);
	putvalue(env_ASG_NaviSD_AL_Street_s_2, empty_string);

	putvalue(env_ASG_NaviSD_AL_Country_s_0, empty_string);
	putvalue(env_ASG_NaviSD_AL_Country_s_1, empty_string);
	putvalue(env_ASG_NaviSD_AL_Country_s_2, empty_string);

	putvalue(env_ASG_NaviSD_AL_Region_s_0, empty_string);
	putvalue(env_ASG_NaviSD_AL_Region_s_1, empty_string);
	putvalue(env_ASG_NaviSD_AL_Region_s_2, empty_string);

	putvalue(env_ASG_NaviSD_AL_Coord_s_0, empty_string);
	putvalue(env_ASG_NaviSD_AL_Coord_s_1, empty_string);
	putvalue(env_ASG_NaviSD_AL_Coord_s_2, empty_string);

	putvalue(env_ASG_NaviSD_AL_POIType_s_0, empty_string);
	putvalue(env_ASG_NaviSD_AL_POIType_s_1, empty_string);
	putvalue(env_ASG_NaviSD_AL_POIType_s_2, empty_string);

	putvalue(env_ASG_NaviSD_AL_AddressTy_s_0, empty_string);
	putvalue(env_ASG_NaviSD_AL_AddressTy_s_1, empty_string);
	putvalue(env_ASG_NaviSD_AL_AddressTy_s_2, empty_string);
	
	putvalue(env_ASG_NaviSD_AL_POIType_0, 0);
	putvalue(env_ASG_NaviSD_AL_POIType_1, 0);
	putvalue(env_ASG_NaviSD_AL_POIType_2, 0);

	putvalue(env_ASG_NaviSD_AL_AddressTy_0, 0);
	putvalue(env_ASG_NaviSD_AL_AddressTy_1, 0);
	putvalue(env_ASG_NaviSD_AL_AddressTy_2, 0);

	putvalue(env_ASG_NaviSD_AL_OnOff, 0);
}

void HeartBeat_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2]) // indication
	{
	case Data_IND:               
		break;
	case Error_IND:
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD HeartBeat_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD HeartBeat_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD HeartBeat_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD HeartBeat_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		writelineEx(gError_Trace, 0, "ASG-NaviSD HeartBeat_Indication: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

void HeartBeat_Request (byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0]=LSG_NaviSD;	        //LSG-ID
	requestarray[1]=FctID_HeartBeat;	//Fct.-ID
	requestarray[2]=request;            //request type

	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD HeartBeat_Request: unknown request %d", request);
		break;
	}
}

on timer Powerontimer
{
	gASG_PowerOnOff =TRUE;

	settimer(TaskTimer, 10);    //start BAP-DLL-Timer
}

on message CAN1.BAP_Navigation_FSG_02	//BAP-message
{
	int i, error;
	byte RX_Data[8];		//received CAN-DATA
	dword RX_Header[3];		//received CAN-Header

	RX_Header[0]=this.CAN; 
	RX_Header[1]=this.ID; 
	RX_Header[2]=this.DLC; // received length
	
	// extract CAN data    																	
	for (i=0; i<this.DLC; i++) 														
	RX_Data[i]=this.byte(i);		  
	
	//send recieved CAN-data with CAN-header to BAP-DLL
	error =Bap180_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);	
	if(error !=0)
	write("ASG-NaviSD: BAP_CAN_SetRxData: %d", error);   
}

void FunctionList_Indication(dword Indication_array [], int datalength)
{
	int i =0, j =0;
	switch (gBAP_Indication[2]) // indication
	{
	case Data_IND: 
		j=0;
		for(i=3;i<11;i++)
		{   
			gFunctionList_FctList[j] =Indication_array [i];
			j++;
		}
		
		//Panel
		//Byte_0
		if(gFunctionList_FctList[0] &0x40)
		putvalue(env_ASG_NaviSD_FctList_Bit01,TRUE); 
		else
		putvalue(env_ASG_NaviSD_FctList_Bit01,FALSE);

		if(gFunctionList_FctList[0] &0x20)
		putvalue(env_ASG_NaviSD_FctList_Bit02,TRUE);
		else
		putvalue(env_ASG_NaviSD_FctList_Bit02,FALSE);

		if(gFunctionList_FctList[0] &0x10)
		putvalue(env_ASG_NaviSD_FctList_Bit03,TRUE);
		else
		putvalue(env_ASG_NaviSD_FctList_Bit03,FALSE);

		if(gFunctionList_FctList[0] &0x08)
		putvalue(env_ASG_NaviSD_FctList_Bit04,TRUE);
		else
		putvalue(env_ASG_NaviSD_FctList_Bit04,FALSE);

		//Byte_1
		if(gFunctionList_FctList[1] &0x04)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit13,TRUE);
			//        SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState", gRGB_white);
			//        enableControl("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit13,FALSE);
			//        SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState", gRGB_red);
			//        enableControl("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState_PanelElement", FALSE);
		}
		
		if(gFunctionList_FctList[1] &0x02)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit14,TRUE);
			//        SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState", gRGB_white);
			//        enableControl("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit14,FALSE);
			//        SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState", gRGB_red);
			//        enableControl("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState_PanelElement", FALSE);
		}
		
		if(gFunctionList_FctList[1] &0x01)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit15,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState", gRGB_white);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit15,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState", gRGB_red);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x0F_FSG-OperationState_PanelElement", FALSE);
		}
		//Byte_2
		if(gFunctionList_FctList[2] &0x80)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit16,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x10_InfoState", gRGB_white);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x10_InfoState_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit16,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x10_InfoState", gRGB_red);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x10_InfoState_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[2] &0x40)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit17,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x11_ActiveRGType", gRGB_white);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x11_ActiveRGType_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit17,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x11_ActiveRGType", gRGB_red);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x11_ActiveRGType_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[2] &0x20)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit18,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x12_DistanceToNextManeuver", gRGB_white);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x12_DistanceToNextManeuver_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit18,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x12_DistanceToNextManeuver", gRGB_red);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x12_DistanceToNextManeuver_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[2] &0x10)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit19,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x13_CurrentPositionInfo", gRGB_white);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x13_CurrentPositionInfo_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit19,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x13_CurrentPositionInfo", gRGB_red);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x13_CurrentPositionInfo_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[2] &0x08)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit20,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x14_TurnToInfo", gRGB_white);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x14_TurnToInfo_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit20,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x14_TurnToInfo", gRGB_red);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x14_TurnToInfo_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[2] &0x04)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit21,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x15_DistanceToDestination", gRGB_white);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x15_DistanceToDestination_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit21,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x15_DistanceToDestination", gRGB_red);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x15_DistanceToDestination_PanelElement", FALSE);
		}
		
		if(gFunctionList_FctList[2] &0x02)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit22,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x16_TimeToDestination", gRGB_white);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x16_TimeToDestination_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit22,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x16_TimeToDestination", gRGB_red);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x16_TimeToDestination_PanelElement", FALSE);
		}
		
		if(gFunctionList_FctList[2] &0x01)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit23,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x17_ManeuverDescriptor", gRGB_white);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x17_ManeuverDescriptor_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit23,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_2", "ASG_0x17_ManeuverDescriptor", gRGB_red);
			enableControl("ASG_NaviSD_Properties_2", "ASG_0x17_ManeuverDescriptor_PanelElement", FALSE);
		}

		//Byte_3
		if(gFunctionList_FctList[3] &0x80)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit24,TRUE);
			SetControlBackColor("ASG_NaviSD_0x18 - LaneGuidance_(array)", "ASG_0x18_LaneGuidance", gRGB_white);
			enableControl("ASG_NaviSD_0x18 - LaneGuidance_(array)", "ASG_0x18_LaneGuidance_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit24,FALSE);
			SetControlBackColor("ASG_NaviSD_0x18 - LaneGuidance_(array)", "ASG_0x18_LaneGuidance", gRGB_red);
			enableControl("ASG_NaviSD_0x18 - LaneGuidance_(array)", "ASG_0x18_LaneGuidance_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[3] &0x40)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit25,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x19_TMCinfo", gRGB_white);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x19_TMCinfo_PanelElement", TRUE);    
		}

		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit25,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x19_TMCinfo", gRGB_red);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x19_TMCinfo_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[3] &0x20)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit26,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x1A_MagnetFieldZone", gRGB_white);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x1A_MagnetFieldZone_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit26,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x1A_MagnetFieldZone", gRGB_red);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x1A_MagnetFieldZone_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[3] &0x10)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit27,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x1B_Calibration", gRGB_white);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x1B_Calibration_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit27,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x1B_Calibration", gRGB_red);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x1B_Calibration_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[3] &0x08)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit28,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x1C_ASGcapabilities", gRGB_white);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x1C_ASGcapabilities_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit28,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x1C_ASGcapabilities", gRGB_red);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x1C_ASGcapabilities_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[3] &0x04)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit29,TRUE);
			SetControlBackColor("ASG_NaviSD_0x1D - LastDest_List_(array)", "ASG_0x1D_LastDest_List", gRGB_white);
			enableControl("ASG_NaviSD_0x1D - LastDest_List_(array)", "ASG_0x1D_LastDest_List_PanelElement", TRUE);
		}
		else
		{    
			putvalue(env_ASG_NaviSD_FctList_Bit29,FALSE);
			SetControlBackColor("ASG_NaviSD_0x1D - LastDest_List_(array)", "ASG_0x1D_LastDest_List", gRGB_red);
			enableControl("ASG_NaviSD_0x1D - LastDest_List_(array)", "ASG_0x1D_LastDest_List_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[3] &0x02)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit30,TRUE);
			SetControlBackColor("ASG_NaviSD_0x1E - FavoriteDest_List_(array)", "ASG_0x1E_FavoriteDest_List", gRGB_white);
			enableControl("ASG_NaviSD_0x1E - FavoriteDest_List_(array)", "ASG_0x1E_FavoriteDest_List_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit30,FALSE);
			SetControlBackColor("ASG_NaviSD_0x1E - FavoriteDest_List_(array)", "ASG_0x1E_FavoriteDest_List", gRGB_red);
			enableControl("ASG_NaviSD_0x1E - FavoriteDest_List_(array)", "ASG_0x1E_FavoriteDest_List_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[3] &0x01)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit31,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x1F_PreferredDestList", gRGB_white);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x1F_PreferredDestList_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit31,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x1F_PreferredDestList", gRGB_red);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x1F_PreferredDestList_PanelElement", FALSE);
		}

		//Byte_4
		if(gFunctionList_FctList[4] &0x80)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit32,TRUE);
			SetControlBackColor("ASG_NaviSD_0x20 - NavBook_(array)", "ASG_0x20_NavBook", gRGB_white);
			enableControl("ASG_NaviSD_0x20 - NavBook_(array)", "ASG_0x20_NavBook_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit32,FALSE);
			SetControlBackColor("ASG_NaviSD_0x20 - NavBook_(array)", "ASG_0x20_NavBook", gRGB_red);
			enableControl("ASG_NaviSD_0x20 - NavBook_(array)", "ASG_0x20_NavBook_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[4] &0x40)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit33,TRUE);
			SetControlBackColor("ASG_NaviSD_Methods", "ASG_0x21_RG_ActDeact", gRGB_white);
			enableControl("ASG_NaviSD_Methods", "ASG_0x21_RG_ActDeact_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit33,FALSE);
			SetControlBackColor("ASG_NaviSD_Methods", "ASG_0x21_RG_ActDeact", gRGB_red);
			enableControl("ASG_NaviSD_Methods", "ASG_0x21_RG_ActDeact_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[4] &0x20)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit34,TRUE);
			SetControlBackColor("ASG_NaviSD_Methods", "ASG_0x23_RepeatLastNavAnnouncement", gRGB_white);
			enableControl("ASG_NaviSD_Methods", "ASG_0x23_RepeatLastNavAnnouncement_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit34,FALSE);
			SetControlBackColor("ASG_NaviSD_Methods", "ASG_0x23_RepeatLastNavAnnouncement", gRGB_red);
			enableControl("ASG_NaviSD_Methods", "ASG_0x23_RepeatLastNavAnnouncement_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[4] &0x10)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit35,TRUE);
			SetControlBackColor("asg_navisd_properties_4_CN", "ASG_0x23_MapScale", gRGB_white);
			enableControl("asg_navisd_properties_4_CN", "ASG_0x23_MapScale_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit35,FALSE);
			SetControlBackColor("asg_navisd_properties_4_CN", "ASG_0x23_MapScale", gRGB_red);
			enableControl("asg_navisd_properties_4_CN", "ASG_0x23_MapScale_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[4] &0x08)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit36,TRUE);
			SetControlBackColor("0x3A_VideoStreams_ASG2", "ASG_0x3A_VideoStreams", gRGB_white);
			enableControl("0x3A_VideoStreams_ASG2", "ASG_0x3A_VideoStreams_PanelElements", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit36,FALSE);
			SetControlBackColor("0x3A_VideoStreams_ASG2", "ASG_0x3A_VideoStreams", gRGB_red);
			enableControl("0x3A_VideoStreams_ASG2", "ASG_0x3A_VideoStreams_PanelElements", FALSE);
		}
		
		if(gFunctionList_FctList[4] &0x04)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit37,TRUE);
			SetControlBackColor("ASG_NaviSD_Methods", "FSG_0x25_RequestSync_Video", gRGB_white);
			enableControl("ASG_NaviSD_Methods", "ASG_0x25_RequestSync_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit37,FALSE);
			SetControlBackColor("ASG_NaviSD_Methods", "FSG_0x25_RequestSync_Video", gRGB_red);
			enableControl("ASG_NaviSD_Methods", "ASG_0x25_RequestSync_PanelElement", FALSE);
		}

		if(gFunctionList_FctList[4] &0x02)
		{
			putvalue(env_ASG_NaviSD_FctList_Bit38,TRUE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x26_InfoStates", gRGB_white);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x26_InfoStates_PanelElement", TRUE);
		}
		else
		{
			putvalue(env_ASG_NaviSD_FctList_Bit38,FALSE);
			SetControlBackColor("ASG_NaviSD_Properties_1", "ASG_0x26_InfoStates", gRGB_red);
			enableControl("ASG_NaviSD_Properties_1", "ASG_0x26_InfoStates_PanelElement", FALSE);
		}
		break;		
	case Error_IND:
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD FunctionList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD FunctionList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD FunctionList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD FunctionList_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		writelineEx(gError_Trace, 0, "ASG-NaviSD FunctionList_Indication: unknown indication 0x%d", gBAP_Indication[2]);
		break;
	}
}

void FunctionList_Request(byte request)
{   
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	        //LSG-ID
	requestarray[1] =FctID_FunctionList;	//Fct.-ID
	requestarray[2] =request;               //request type
	
	switch (request)
	{
	case DataGet_REQ: 										
		set_status_requestbuffer (requestarray, 3, Bap_Void);      		 
		break;
	default:
		writelineEx(gError_Trace, 0, "ASG-NaviSD FunctionList_Request: unknown request %d", request);
		break;
	}
}

void FSG_OperationState_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
	case Data_IND:
		//get data
		gFSG_OperationState       = Indication_array[3];
		gFSG_OperationState_Ext1  = Indication_array[4];
		gFSG_OperationState_Ext2  = Indication_array[5];
		gFSG_OperationState_Ext3  = Indication_array[6];
		gFSG_OperationState_Ext4  = Indication_array[7];
		gFSG_OperationState_Ext5  = Indication_array[8];
		
		//Panel
		if (gFSG_OperationState ==0x0F)
		putvalue(env_ASG_NaviSD_FSG_OP_State, gstring_defect);
		else if(gFSG_OperationState<0x04 || gFSG_OperationState==0x0E)
		putvalue(env_ASG_NaviSD_FSG_OP_State, gstring_FSG_OperationState[gFSG_OperationState]);
		else
		putvalue(env_ASG_NaviSD_FSG_OP_State, gstring_reserved);
		break;
	case Error_IND:			
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD FSG_OperationState_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD FSG_OperationState_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD FSG_OperationState_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD FSG_OperationState_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD FSG_OperationState_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void FSG_OperationState_Request (byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	            //LSG-ID
	requestarray[1] =FctID_FSG_OperationState;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 9, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD FSG_OperationState_Request: invalid request %d", request);
		break;
	}
}

void FSG_Control_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
	case Data_IND:
		//get data
		gNav_Control_MainMap  = (Indication_array[3] & 0xF0 ) / 16;
		gNav_Control_1KDK     = Indication_array[3] & 0x0F;
		gNav_Control_2KDK     = (Indication_array[4] & 0xF0 ) / 16;
		gNav_Control_Ext1     = Indication_array[4] & 0x0F;
		gNav_Control_Ext2     = Indication_array[5];
		gNav_Control_Ext3     = Indication_array[6];
		gNav_Control_Ext4     = Indication_array[7];
		gNav_Control_Ext5     = Indication_array[8];
		
		//Panel
		putValue(env_ASG_NaviSD_Control_MainMap_s,gstring_FSG_Control[gNav_Control_MainMap]);
		putValue(env_ASG_NaviSD_Control_1KDK_s,gstring_FSG_Control[gNav_Control_1KDK]);
		putValue(env_ASG_NaviSD_Control_2KDK_s,gstring_FSG_Control[gNav_Control_2KDK]);
		break;
	case Error_IND:			
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD FSG_OperationState_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD FSG_OperationState_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD FSG_OperationState_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD FSG_OperationState_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD FSG_OperationState_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void FSG_Control_Request(byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	            //LSG-ID
	requestarray[1] =FctID_FSG_Control;	      //Fct.-ID
	requestarray[2] =request;                 //request type
	
	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	case DataSetGet_REQ:
		requestarray[3] = (gNav_Control_MainMap * 0x10) + (gNav_Control_1KDK & 0x0F);
		requestarray[4] = (gNav_Control_2KDK * 0x10) + (gNav_Control_Ext1 & 0x0F);
		requestarray[5] = gNav_Control_Ext2;
		requestarray[6] = gNav_Control_Ext3;
		requestarray[7] = gNav_Control_Ext4;
		requestarray[8] = gNav_Control_Ext5;
		set_status_requestbuffer (requestarray, 3, Bap_ByteSequence);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD FSG_Control_Request: invalid request %d", request);
		break;
	}
}

void InfoStates_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
	case Data_IND:
		//get data
		gNAV_InfoStates       = Indication_array[3];
		gNAV_InfoStates_Ext1  = Indication_array[4];
		gNAV_InfoStates_Ext2  = Indication_array[5];
		gNAV_InfoStates_Ext3  = Indication_array[6];
		gNAV_InfoStates_Ext4  = Indication_array[7];
		gNAV_InfoStates_Ext5  = Indication_array[8];
		
		//Panel
		if (gNAV_InfoStates <0x08)
		putvalue(env_ASG_NaviSD_InfoSt_States_s, gNAV_InfoStates_s[gNAV_InfoStates]);            
		else if(gNAV_InfoStates ==0xFF)
		putvalue(env_ASG_NaviSD_InfoSt_States_s, gNAV_InfoStates_0xFF_s);   
		else
		putvalue(env_ASG_NaviSD_InfoSt_States_s,gstring_reserved);
		
		break;

	case Error_IND:
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD InfoStates_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD InfoStates_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD InfoStates_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD InfoStates_Indication: Application-Error: 0x%x", Indication_array[3]);
		
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD InfoStates_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}   

void InfoStates_Request (byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	            //LSG-ID
	requestarray[1] =FctID_InfoState;	        //Fct.-ID
	requestarray[2] =request;                   //request type
	
	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD InfoStates_Request: invalid request %d", request);
		break;
	}
}


void ActiveRgType_Indication (dword Indication_array [], int datalength)
{   
	int i =0, Offset =0, length =0;
	switch (gBAP_Indication[2])
	{
	case Data_IND:
		//get data
		gNAV_ActiveRgType_RGType  =Indication_array[3];
		gNAV_ActiveRgType_Ext1    =Indication_array[4];
		gNAV_ActiveRgType_Ext2    =Indication_array[5];
		gNAV_ActiveRgType_Ext3    =Indication_array[6];
		gNAV_ActiveRgType_Ext4    =Indication_array[7];
		gNAV_ActiveRgType_Ext5    =Indication_array[8];
		
		//Panel 
		if(gNAV_ActiveRgType_RGType <0x06)
		{
			putvalue(env_ASG_NaviSD_ActRGTy_RGType_s,gNAV_ActiveRgType_RGType_s[gNAV_ActiveRgType_RGType]);
			putvalue(env_ASG_NaviSD_ActRGT_RGType,gNAV_ActiveRgType_RGType);
		}
		else if(gNAV_ActiveRgType_RGType ==0xFF)
		{
			putvalue(env_ASG_NaviSD_ActRGTy_RGType_s,gNAV_ActiveRgType_RGType_0xFF_s);
			putvalue(env_ASG_NaviSD_ActRGT_RGType,gNAV_ActiveRgType_RGType);
		}
		else
		putvalue(env_ASG_NaviSD_ActRGTy_RGType_s,gstring_reserved);
		
		break;
	case Error_IND:
		
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD ActiveRgType_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD ActiveRgType_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD ActiveRgType_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD ActiveRgType_Indication: Application-Error: 0x%x", Indication_array[3]);
		
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD ActiveRgType_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void ActiveRgType_Request(byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	        //LSG-ID
	requestarray[1] =FctID_ActiveRgType;	//Fct.-ID
	requestarray[2] =request;               //request type
	
	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	case DataSetGet_REQ:
		requestarray[3] =gNAV_ActiveRgType_RGType;
		requestarray[4] =gNAV_ActiveRgType_Ext1;
		requestarray[5] =gNAV_ActiveRgType_Ext2;
		requestarray[6] =gNAV_ActiveRgType_Ext3;
		requestarray[7] =gNAV_ActiveRgType_Ext4;
		requestarray[8] =gNAV_ActiveRgType_Ext5;

		set_status_requestbuffer (requestarray, 9, Bap_ByteSequence);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD ActiveRgType_Request: invalid request %d", request);
		break;
	}
}  

void CompassInfo_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2]) // indication
	{
	case Data_IND:
		//get data
		gCI_Direction_Symbolic= Indication_array[3];
		gCI_Direction_Angle   = Indication_array[4] +Indication_array[5]*0x100;
		gNAV_CompassInfo_Ext1 = Indication_array[6];
		gNAV_CompassInfo_Ext2 = Indication_array[7];
		gNAV_CompassInfo_Ext3 = Indication_array[8];
		
		//Panel
		if(gCI_Direction_Symbolic<=0xF)
		putValue(env_ASG_NaviSD_DirectionSymbolic, gCI_Direction_Symbolic_string[gCI_Direction_Symbolic]);
		else if(gCI_Direction_Symbolic ==NAV_COMPASSINFO_NOT_SUPPPORTED)
		putValue(env_ASG_NaviSD_DirectionSymbolic, gstring_not_supported);
		else
		putValue(env_ASG_NaviSD_DirectionSymbolic, gstring_reserved);

		putValue(env_ASG_NaviSD_Direction_Angle, gCI_Direction_Angle);

		break;
	case Error_IND:
		if(gBAP_Indication[5]!=4)
		writelineEx(gError_Trace, 0, "ASG-NaviSD CompassInfo_Indication: BAP-datalength-error");
		else
		{
			if(Indication_array[3]<0x20 && Indication_array[3] !=0)	            //BCL-error
			writelineEx(gError_Trace, 0, "ASG-NaviSD CompassInfo_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
			else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
			writelineEx(gError_Trace, 0, "ASG-NaviSD CompassInfo_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
			else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
			writelineEx(gError_Trace, 0, "ASG-NaviSD CompassInfo_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
			else
			writelineEx(gError_Trace, 0, "ASG-NaviSD CompassInfo_Indication: Application-Error: 0x%x", Indication_array[3]);
		}
		break;
	default:
		writelineEx(gError_Trace, 0, "ASG-NaviSD CompassInfo_Indication: invalid indication %d", gBAP_Indication[2]);
		break;
	}
}

void CompassInfo_Request (byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0]=LSG_NaviSD;			//LSG-ID
	requestarray[1]=FctID_CompassInfo;	//Fct.-ID
	requestarray[2]=request;            //request type

	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:	//error
		writelineEx(gError_Trace, 0, "ASG-NaviSD CompassInfo_Request: invalid request %d", request);
		break;
	}
}

void RG_Status_Indication (dword Indication_array [], int datalength)
{	
	switch (gBAP_Indication[2])
	{
	case Data_IND:
		//get data
		gRG_Status =Indication_array[3];
		gNAV_RG_Status_Ext1 =Indication_array[4];
		gNAV_RG_Status_Ext2 =Indication_array[5];
		gNAV_RG_Status_Ext3 =Indication_array[6];
		gNAV_RG_Status_Ext4 =Indication_array[7];
		gNAV_RG_Status_Ext5 =Indication_array[8];
		
		//Panel
		if(3>gRG_Status)
		putValue(env_ASG_NaviSD_RG_Status, gstring_RG_Status[gRG_Status]);
		else if(0xff==gRG_Status)
		putValue(env_ASG_NaviSD_RG_Status, gstring_not_supported);
		else
		putValue(env_ASG_NaviSD_RG_Status, gstring_reserved);

		break;
	case Error_IND:

		if(Indication_array[3]<0x20 && Indication_array[3] !=0)        //BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD RouteGuidanceStatus_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)   //BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD RouteGuidanceStatus_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)	//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD RouteGuidanceStatus_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD RouteGuidanceStatus_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		writelineEx(gError_Trace, 0, "ASG RouteGuidanceStatus_Indication: invalid indication %d", gBAP_Indication[2]);
		break;
	}
}

void RG_Status_Request (byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	    //LSG-ID
	requestarray[1] =FctID_RG_Status;	//Fct.-ID
	requestarray[2] =request;           //request type

	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:
		writelineEx(gError_Trace, 0, "ASG-NaviSD RouteGuidanceStatus_Request: invalid request %d", request);
		break;
	}
}

void DistanceToNextManeuver_Request(byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0]=LSG_NaviSD;                   	//LSG-ID
	requestarray[1]=FctID_DistanceToNextManeuver;	//Fct.-ID
	requestarray[2]=request;                        //request type
	
	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver: invalid request %d", request);
		break;
	}
}

void DistanceToNextManeuver_Indication (dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
	case Data_IND: 
		//Distance
		gDTNM_Distance  = Indication_array[3];
		gDTNM_Distance  +=Indication_array[4]*0x100;
		gDTNM_Distance  +=Indication_array[5]*0x10000;
		gDTNM_Distance  +=Indication_array[6]*0x1000000;
		gDTNM_Unit =Indication_array[7];
		gDTNM_Bargraph =Indication_array[8];
		
		putValue(env_ASG_NaviSD_DTNM_Distance, gDTNM_Distance);
		if(gDTNM_Unit<6)
		  putValue(env_ASG_NaviSD_DTNM_Unit, gstring_DTNM_Unit[gDTNM_Unit]);
		else if(gDTNM_Unit ==0xff)
		  putValue(env_ASG_NaviSD_DTNM_Unit, gstring_not_supported);
		else
		  putValue(env_ASG_NaviSD_DTNM_Unit, gstring_reserved);
    
		putValue(env_ASG_NaviSD_DTNM_BG, gDTNM_Bargraph);

		//ValidityInformation
		gDTNM_ValidityInformation =Indication_array[10];
		putValue(env_ASG_NaviSD_DTNM_ValidityInfo, gstring_DTNM_ValidityInformation[gDTNM_ValidityInformation]);

		break;
	case Error_IND:
		
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)        //BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)   //BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)   //BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver_Indication: invalid indication %d", gBAP_Indication[2]);
		break;
	}
}


void CurrentPositionInfo_Indication (dword Indication_array [], int datalength)
{
	byte length =0;
	int i;

	switch (gBAP_Indication[2])
	{
	case Data_IND:
		length=Indication_array[3];
		
		//get data
		for (i=0;i<NAV_CURRENTPOSITIONINFO_LENGTH;i++)
		gCurrentPositionInfo_PositionInfo[i]=0;
		
		for(i=0;i<Indication_array[3];i++)
		gCurrentPositionInfo_PositionInfo[i]=Indication_array[i+4];
		
		//Panel
		putValue(env_ASG_NaviSD_PositionInfo, gCurrentPositionInfo_PositionInfo);
		
		break;
	case Error_IND:
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD CurrentPositionInfo_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD CurrentPositionInfo_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD CurrentPositionInfo_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD CurrentPositionInfo_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		writelineEx(gError_Trace, 0, "ASG-NaviSD CurrentPositionInfo_Indication: invalid indication %d", gBAP_Indication[2]);
		break;
	}
}

void CurrentPositionInfo_Request (byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	            //LSG-ID
	requestarray[1] =FctID_CurrentPositionInfo;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD CurrentPositionInfo_Request: invalid request %d", request);
		break;
	}
}

void Altitude_Indication(dword Indication_array [], int datalength)
{  
	int i =0, Offset =0, length =0 ;
	word altitudeUpper, altitudeLower, altitudeTemp;

	switch (gBAP_Indication[2])
	{
	case Data_IND:
		//get data
		gNAV_Altitude = Indication_array[3];
		gNAV_Altitude += Indication_array[4] * 0x100;
		gNAV_Altitude_Unit  = Indication_array[5];
		gNAV_Altitude_Ext1  = Indication_array[6];
		gNAV_Altitude_Ext2  = Indication_array[7];
		gNAV_Altitude_Ext3  = Indication_array[8];      
    putValue(env_ASG_NaviSD_Altitude_Alti, gNAV_Altitude);
    putValue(env_ASG_NaviSD_Altitude_Unit, gNAV_Altitude_Unit);
    
		break;			
	case Error_IND:
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_Altitude: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_Altitude: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_Altitude: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_Altitude: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD Indication_Altitude: unknown indication %x", gBAP_Indication[2]);
		break;
	}
}

void Altitude_Request(byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	        //LSG-ID
	requestarray[1] =FctID_Altitude;	    //Fct.-ID
	requestarray[2] =request;               //request type
	
	switch(request)
	{
	case DataGet_REQ:		
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD Request_Altitude: invalid request %d", request);
		break;
	}
}

void TurnToInfo_Indication (dword Indication_array [], int datalength)
{
	byte length =0;
	int counter, i = 0;
  counter = 3;
  length = 0;
	
	for (i=0;i<TURNTOROAD_LENGTH;i++) //clear array
	gNAV_TurnToInfo_TurnToRoad[i] =0;
	for (i=0;i<DIRECTIONROAD_LENGTH;i++) //clear array
	gNAV_TurnToInfo_DirectionRoad[i] =0;

	switch (gBAP_Indication[2])
	{
  	case Data_IND:
      length = Indication_array[counter++];
  		for(i = 0; i < length; i++)
  		{
  			gNAV_TurnToInfo_TurnToRoad[i] = Indication_array[counter++];
  		}
  		gNAV_TurnToInfo_TurnToRoadIcon = Indication_array[counter++];
  		gNAV_TurnToInfo_TurnToRoadIcon += Indication_array[counter++] * 0x100;
  		
      length = Indication_array[counter++];
  		for(i = 0; i < length; i++)
  		{
  			gNAV_TurnToInfo_DirectionRoad[i] = Indication_array[counter++];
  		}
  		gNAV_TurnToInfo_DirectionRoadIcon = Indication_array[counter++];
  		gNAV_TurnToInfo_DirectionRoadIcon += Indication_array[counter++] * 0x100;

      putValue(env_ASG_NaviSD_TTI_TTR,gNAV_TurnToInfo_TurnToRoad);
      putValue(env_ASG_NaviSD_TTI_TTR_Icon,gNAV_TurnToInfo_TurnToRoadIcon);
      putValue(env_ASG_NaviSD_TTI_DR,gNAV_TurnToInfo_DirectionRoad);
      putValue(env_ASG_NaviSD_TTI_DR_Icon,gNAV_TurnToInfo_DirectionRoadIcon);
      
  		break;
  	case Error_IND:
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD TurnToInfo_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD TurnToInfo_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD TurnToInfo_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  		writelineEx(gError_Trace, 0, "ASG-NaviSD TurnToInfo_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  	default:
  		writelineEx(gError_Trace, 0, "ASG-NaviSD TurnToInfo_Indication: invalid indication %d", gBAP_Indication[2]);
  		break;
	}	
}

void TurnToInfo_Request (byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0]=LSG_NaviSD;	        //LSG-ID
	requestarray[1]=FctID_TurnToInfo;	//Fct.-ID
	requestarray[2]=request;            //request type

	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD TurnToInfo_Request: invalid request %d", request);
		break;
	}
}

void DistTimeToDestination_Indication(dword Indication_array [], int datalength)
{
  int counter;
  counter = 3;
	switch (gBAP_Indication[2])
	{
  	case Data_IND: 
  		//Distance
  		gDTTD_DestinationType         = Indication_array[counter++]; //3
  		gDTTD_DistanceToDestination   = Indication_array[counter++]; //4
  		gDTTD_DistanceToDestination   += Indication_array[counter++] * 0x100; //5
  		gDTTD_DistanceToDestination   += Indication_array[counter++] * 0x10000; //6
  		gDTTD_DistanceToDestination   += Indication_array[counter++] * 0x1000000; //7
  		gDTTD_DistanceToDestination_Unit  = Indication_array[counter++]; //8
  		gDTTD_NavigationTime.TimeType = (Indication_array[counter] & 0xF0 ) / 0x10; //9
  		gDTTD_NavigationTime.TimeFormat   = Indication_array[counter++] & 0x0F; //9
  		gDTTD_NavigationTime.Minute        = Indication_array[counter++];
  		gDTTD_NavigationTime.Hour          = Indication_array[counter++];
  		gDTTD_NavigationTime.Day           = Indication_array[counter++];
  		gDTTD_NavigationTime.Month         = Indication_array[counter++];
  		gDTTD_NavigationTime.Year          = Indication_array[counter++];
  		gDTTD_Ext1                         = Indication_array[counter++];
  		gDTTD_Ext2                         = Indication_array[counter++];
  		gDTTD_Ext3                         = Indication_array[counter++];
  		gDTTD_Ext4                         = Indication_array[counter++];
  		gDTTD_Ext5                         = Indication_array[counter++];
  		gDTTD_Ext6                         = Indication_array[counter++];
      
      putValue(env_ASG_NaviSD_DTD_DTDType,gDTTD_Type[gDTTD_DestinationType]);
      putValue(env_ASG_NaviSD_DTD_Distance,gDTTD_DistanceToDestination);
      putValue(env_ASG_NaviSD_DTD_Unit,gDTTD_Unit[gDTTD_DistanceToDestination_Unit]);
      
      if(gDTTD_NavigationTime.TimeType < 3)
        putValue(env_ASG_NaviSD_TTD_TimeInfoType,gDTTD_Nav_Type[gDTTD_NavigationTime.TimeType]);
      else
        putValue(env_ASG_NaviSD_TTD_TimeInfoType,"not supported");
      
      if(gDTTD_NavigationTime.TimeFormat < 2)
         putValue(env_ASG_NaviSD_TTD_NavigationTF,gDTTD_Nav_Format[gDTTD_NavigationTime.TimeFormat]);
      else
        putValue(env_ASG_NaviSD_TTD_NavigationTF,"not supported");
     
      putValue(env_ASG_NaviSD_TTD_Year,gDTTD_NavigationTime.Year + 2000);
      putValue(env_ASG_NaviSD_TTD_Month,gDTTD_NavigationTime.Month);
      putValue(env_ASG_NaviSD_TTD_Day,gDTTD_NavigationTime.Day);
      putValue(env_ASG_NaviSD_TTD_Hour,gDTTD_NavigationTime.Hour);
      putValue(env_ASG_NaviSD_TTD_Minute,gDTTD_NavigationTime.Minute);
  		break;
  	case Error_IND:
  		
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)        //BCL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)   //BPL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)   //BAL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  	default:
  		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver_Indication: invalid indication %d", gBAP_Indication[2]);
  		break;
	}
}

void DistTimeToDestination_Request(byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0]=LSG_NaviSD;                   	//LSG-ID
	requestarray[1]=FctID_DistTimeToDestination;	  //Fct.-ID
	requestarray[2]=request;                        //request type
	
	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver: invalid request %d", request);
		break;
	}
}

void ManeuverDescriptor_1_Indication(dword Indication_array [], int datalength)
{
	byte length =0;
	int i, Offset, y;
  
  y = 0;
  i=0;
  Offset = 3;
	switch (gBAP_Indication[2])
	{
  	case Data_IND: 
  		//Maneuver_1
  		gMD1_MainElement      = Indication_array[Offset++];
  		gMD1_Direction        = Indication_array[Offset++];     
  		gMD1_Z_LevelGuidance  = Indication_array[Offset++];
  		gMD1_NumberOfSidestreets = Indication_array[Offset++];
  		for(i = 0; i < gMD1_NumberOfSidestreets; i++)
  		{
  			gMD1_SideStreets.Direction[i] = Indication_array[Offset++];
  			gMD1_SideStreets.Attributes[i] = Indication_array[Offset++];
  		}
  		gMD1_Picture_Reference = Indication_array[Offset++];
  		gMD1_Picture_Reference += Indication_array[Offset++] * 0x100;
  		gMD1_Ext1 = Indication_array[Offset++];
  		gMD1_Ext2 = Indication_array[Offset++];
  		gMD1_Ext3 = Indication_array[Offset++];
  		
      //panel
      putValue(env_ASG_NaviSD_MD1_MainElement, gMD1_MainElement);
      putValue(env_ASG_NaviSD_MD1_MainElement_s, gMD1_MainElement_s[gMD1_MainElement]);
      putValue(env_ASG_NaviSD_MD1_Direction, gMD1_Direction);
      putValue(env_ASG_NaviSD_MD1_PicRef, gMD1_Picture_Reference);
      
      switch(gMD1_Direction)
      {
        case 0x0:
          putValue(env_ASG_NaviSD_MD1_Direction_s, gMD1_Direction_s[0]);
          break;
        case 0x40:
          putValue(env_ASG_NaviSD_MD1_Direction_s, gMD1_Direction_s[1]);
          break;
        case 0x80:
          putValue(env_ASG_NaviSD_MD1_Direction_s, gMD1_Direction_s[2]);
          break;
        case 0xC0:
          putValue(env_ASG_NaviSD_MD1_Direction_s, gMD1_Direction_s[3]);
          break;
        default:
          putValue(env_ASG_NaviSD_MD1_Direction_s, "not specified");
          break;
      }
      
      if(gMD1_Z_LevelGuidance < 3)
      {
        putValue(env_ASG_NaviSD_MD1_Z_Level, gMD1_Z_LevelGuidance_s[gMD1_Z_LevelGuidance]);
      }
      else
      {
        putValue(env_ASG_NaviSD_MD1_Z_Level, "not supported");
      }
      putValue(env_ASG_NaviSD_MD1_NbrOfSideStr, gMD1_NumberOfSidestreets); 
      
      putValue(env_ASG_NaviSD_MD1_SideStr_Attr1, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dire1, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Attr2, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dire2, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Attr3, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dire3, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Attr4, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dire4, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Attr5, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dire5, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Attr6, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dire6, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Attr7, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dire7, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Attr8, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dire8, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Attr9, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dire9, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Att10, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dir10, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Att11, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dir11, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Att12, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dir12, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Att13, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dir13, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Att14, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dir14, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Att15, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dir15, gMD1_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Att16, gMD1_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD1_SideStr_Dir16, gMD1_SideStreets.Direction[y++]);
      
  		break;
  	case Error_IND:
  		
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)        //BCL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)   //BPL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)   //BAL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  	default:
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: invalid indication %d", gBAP_Indication[2]);
  		break;
	}
}

void ManeuverDescriptor_1_Request(byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	              //LSG-ID
	requestarray[1] =FctID_ManeuverDescriptor_1;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Request: invalid request %d", request);
		break;
	}
}

void ManeuverDescriptor_2_Indication(dword Indication_array [], int datalength)
{
	byte length =0;
	int i, Offset,y ;
  y=0;
  Offset = 3;
	switch (gBAP_Indication[2])
	{
  	case Data_IND: 
  		//Maneuver_2
  		gMD2_MainElement      = Indication_array[Offset++];
  		gMD2_Direction        = Indication_array[Offset++];     
  		gMD2_Z_LevelGuidance  = Indication_array[Offset++];
  		gMD2_NumberOfSidestreets = Indication_array[Offset++];
  		for(i = 0; i < gMD2_NumberOfSidestreets; i++)
  		{
  			gMD2_SideStreets.Direction[i] = Indication_array[Offset++];
  			gMD2_SideStreets.Attributes[i] = Indication_array[Offset++];
  		}
  		gMD2_Picture_Reference = Indication_array[Offset++];
  		gMD2_Picture_Reference += Indication_array[Offset++] * 0x100;
  		gMD2_DistanceToManeuverDesc_1 = Indication_array[Offset++];
  		gMD2_DistanceToManeuverDesc_1 += Indication_array[Offset++] * 100;
  		gMD2_DistanceToManeuverDesc_1 += Indication_array[Offset++] * 10000;
  		gMD2_DistanceToManeuverDesc_1 += Indication_array[Offset++] * 1000000;
  		gMD2_Unit              = Indication_array[Offset++];
  		gMD2_Ext1 = Indication_array[Offset++];
  		gMD2_Ext2 = Indication_array[Offset++];
  		gMD2_Ext3 = Indication_array[Offset++];
  		
      //panel
      putValue(env_ASG_NaviSD_MD2_MainElement, gMD2_MainElement);
      putValue(env_ASG_NaviSD_MD2_MainElement_s, gMD1_MainElement_s[gMD2_MainElement]);
      putValue(env_ASG_NaviSD_MD2_Direction, gMD2_Direction);
      putValue(env_ASG_NaviSD_MD2_PicRef, gMD2_Picture_Reference);
      putValue(env_ASG_NaviSD_MD2_DTMD1, gMD2_DistanceToManeuverDesc_1);
      putValue(env_ASG_NaviSD_MD2_DUnit, gMD2_Unit);
      switch(gMD2_Direction)
      {
        case 0x0:
          putValue(env_ASG_NaviSD_MD2_Direction_s, gMD1_Direction_s[0]);
          break;
        case 0x40:
          putValue(env_ASG_NaviSD_MD2_Direction_s, gMD1_Direction_s[1]);
          break;
        case 0x80:
          putValue(env_ASG_NaviSD_MD2_Direction_s, gMD1_Direction_s[2]);
          break;
        case 0xC0:
          putValue(env_ASG_NaviSD_MD2_Direction_s, gMD1_Direction_s[3]);
          break;
        default:
          putValue(env_ASG_NaviSD_MD2_Direction_s, "not specified");
          break;
      }
      if(gMD2_Z_LevelGuidance < 3)
      {
        putValue(env_ASG_NaviSD_MD2_Z_Level, gMD1_Z_LevelGuidance_s[gMD2_Z_LevelGuidance]);
      }
      else
      {
        putValue(env_ASG_NaviSD_MD2_Z_Level, "not supported");
      }
      putValue(env_ASG_NaviSD_MD2_NbrOfSideStr, gMD2_NumberOfSidestreets); 
      
      putValue(env_ASG_NaviSD_MD2_SideStr_Attr1, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dire1, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Attr2, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dire2, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Attr3, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dire3, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Attr4, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dire4, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Attr5, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dire5, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Attr6, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dire6, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Attr7, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dire7, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Attr8, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dire8, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Attr9, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dire9, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Att10, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dir10, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Att11, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dir11, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Att12, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dir12, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Att13, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dir13, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Att14, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dir14, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Att15, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dir15, gMD2_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Att16, gMD2_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD2_SideStr_Dir16, gMD2_SideStreets.Direction[y++]);
  		break;
  	case Error_IND:
  		
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)        //BCL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)   //BPL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)   //BAL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  	default:
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: invalid indication %d", gBAP_Indication[2]);
  		break;
	}
}

void ManeuverDescriptor_2_Request(byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	              //LSG-ID
	requestarray[1] =FctID_ManeuverDescriptor_2;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Request: invalid request %d", request);
		break;
	}
}

void ManeuverDescriptor_3_Indication(dword Indication_array [], int datalength)
{
	byte length =0;
	int i, Offset, y;
  y=0;
  Offset = 3;
  
	switch (gBAP_Indication[2])
	{
  	case Data_IND: 

  		//Maneuver_3
  		gMD3_MainElement      = Indication_array[Offset++];
  		gMD3_Direction        = Indication_array[Offset++];     
  		gMD3_Z_LevelGuidance  = Indication_array[Offset++];
  		gMD3_NumberOfSidestreets = Indication_array[Offset++];
  		for(i = 0; i < gMD3_NumberOfSidestreets; i++)
  		{
  			gMD3_SideStreets.Direction[i] = Indication_array[Offset++];
  			gMD3_SideStreets.Attributes[i] = Indication_array[Offset++];
  		}
  		gMD3_Picture_Reference = Indication_array[Offset++];
  		gMD3_Picture_Reference += Indication_array[Offset++] * 0x100;
  		gMD3_DistanceToManeuverDesc_1 = Indication_array[Offset++];
  		gMD3_DistanceToManeuverDesc_1 += Indication_array[Offset++] * 100;
  		gMD3_DistanceToManeuverDesc_1 += Indication_array[Offset++] * 10000;
  		gMD3_DistanceToManeuverDesc_1 += Indication_array[Offset++] * 1000000;
  		gMD3_Unit              = Indication_array[Offset++];
  		gMD3_Ext1 = Indication_array[Offset++];
  		gMD3_Ext2 = Indication_array[Offset++];
  		gMD3_Ext3 = Indication_array[Offset++];
  		
      //panel
      putValue(env_ASG_NaviSD_MD3_MainElement, gMD3_MainElement);
      putValue(env_ASG_NaviSD_MD3_MainElement_s, gMD1_MainElement_s[gMD3_MainElement]);
      putValue(env_ASG_NaviSD_MD3_Direction, gMD3_Direction);
      putValue(env_ASG_NaviSD_MD3_PicRef, gMD3_Picture_Reference);
      putValue(env_ASG_NaviSD_MD3_DTMD1, gMD3_DistanceToManeuverDesc_1);
      putValue(env_ASG_NaviSD_MD3_DUnit, gMD3_Unit);
      switch(gMD3_Direction)
      {
        case 0x0:
          putValue(env_ASG_NaviSD_MD3_Direction_s, gMD1_Direction_s[0]);
          break;
        case 0x40:
          putValue(env_ASG_NaviSD_MD3_Direction_s, gMD1_Direction_s[1]);
          break;
        case 0x80:
          putValue(env_ASG_NaviSD_MD3_Direction_s, gMD1_Direction_s[2]);
          break;
        case 0xC0:
          putValue(env_ASG_NaviSD_MD3_Direction_s, gMD1_Direction_s[3]);
          break;
        default:
          putValue(env_ASG_NaviSD_MD3_Direction_s, "not specified");
          break;
      }
      if(gMD3_Z_LevelGuidance < 3)
      {
        putValue(env_ASG_NaviSD_MD3_Z_Level, gMD1_Z_LevelGuidance_s[gMD3_Z_LevelGuidance]);
      }
      else
      {
        putValue(env_ASG_NaviSD_MD3_Z_Level, "not supported");
      }
      putValue(env_ASG_NaviSD_MD3_NbrOfSideStr, gMD3_NumberOfSidestreets);
      
      putValue(env_ASG_NaviSD_MD3_SideStr_Attr1, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dire1, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Attr2, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dire2, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Attr3, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dire3, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Attr4, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dire4, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Attr5, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dire5, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Attr6, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dire6, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Attr7, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dire7, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Attr8, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dire8, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Attr9, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dire9, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Att10, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dir10, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Att11, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dir11, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Att12, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dir12, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Att13, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dir13, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Att14, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dir14, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Att15, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dir15, gMD3_SideStreets.Direction[y++]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Att16, gMD3_SideStreets.Attributes[y]);
      putValue(env_ASG_NaviSD_MD3_SideStr_Dir16, gMD3_SideStreets.Direction[y++]);
  		break;
  	case Error_IND:
  		
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)        //BCL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)   //BPL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)   //BAL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  	default:
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Indication: invalid indication %d", gBAP_Indication[2]);
  		break;
	}
}

void ManeuverDescriptor_3_Request(byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	              //LSG-ID
	requestarray[1] =FctID_ManeuverDescriptor_3;	//Fct.-ID
	requestarray[2] =request;                   //request type
	
	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD ManeuverDescriptor_Request: invalid request %d", request);
		break;
	}
}

void LaneGuidance_Indication(dword Indication_array [], int datalength)
{
	byte mode, direction, shift, recordaddress, transmitpos, length, indexsize, CacheElements;
	word startelement, elements, current_element;
	int i =0, j=0, Offset =0;

	// Init local variables
	mode                    =0;
	direction               =0;
	shift                   =0;
	recordaddress           =0;
	startelement            =0;
	elements                =0;
	current_element         =0;
	transmitpos             =0;
	length                  =0;
	CacheElements =FALSE;

	switch (gBAP_Indication[2])
	{
  	case Data_IND:
  		//get data
  		gLaneGuidance_ASGID =(Indication_array[3] &0xF0) /0x10;
  		gLaneGuidance_TAID  =Indication_array[3] &0x0F;
  		gLaneGuidance_TotalNumListElements =Indication_array[4] ;
  		gLaneGuidance_CurrentCarPosition =Indication_array[5];
  		gLaneGuidance_RecommendedCarPosition =Indication_array[6];
  		/***ArrayHeader***/
  		mode            =(Indication_array[7] &0xF0) /0x10;
  		recordaddress   =Indication_array[7] &0x0F;
  		startelement    =Indication_array[8];
  		elements        =Indication_array[9];
  		Offset = 10;
  		// decode "mode-byte"
  		shift       =mode &0x01;
  		direction   =(mode &0x02)/0x02;
  		transmitpos =(mode &0x04)/0x04;
  		indexsize   =(mode &0x08)/0x08;             

  		if(startelement !=0)
  		{
  			for (i=0;i<NAV_LANEGUIDANCE_ENTRIES;i++)
  			{
  				if(startelement ==gLaneGuidance_Pos[i])  
  				  i = NAV_LANEGUIDANCE_ENTRIES;              
  			}
  		}
  		switch (recordaddress)
  		{ 
  		case 1: //recordaddress =1 -> complete
  			if(0==startelement)
  			{
  				if(FORWARD==direction)  //forward-start
  				{          
  					current_element =startelement;             
  					if (shift ==TRUE) //startelement is next element
  					current_element++;                 

  					for (j=0; j<elements;j++) //copy elements
  					{
  						//check, if elements must be cached and in case find position in array
  						CacheElements =FALSE;
  						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
  						{  
  							//if element already cached, find position in ASG-cache
  							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
  							{    
  								current_element =i; 
  								CacheElements   =TRUE;
  							}
  							//if not already cached, then store element only, if Cache is build-up!
  							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
  							CacheElements   =TRUE;
  						}
  						//Pos
  						if (transmitpos)
  						{   
  							if (CacheElements ==TRUE)
  							gLaneGuidance_Pos[current_element]=Indication_array[Offset++];
  						}
  						//LaneFocus         - Byte
  						if (CacheElements ==TRUE)
  						  gLaneGuidance_Focus=Indication_array[Offset++];
  						//LaneDirection1    - Byte
  						if (CacheElements ==TRUE)
  						  gLaneGuidance_LaneDirection1[current_element] =Indication_array[Offset++];
  						//LaneDirection1    - Byte
  						if (CacheElements ==TRUE)
  						  gLaneGuidance_LaneDirection2[current_element] =Indication_array[Offset++];
  						//GuidanceInfo1&2   - Nibble (request =((gLaneGuidance2_GuidanceInfo1[x] *0x10) &0xF0) +(gLaneGuidance2_GuidanceInfo2[x] &0x0F);)
  						if (CacheElements ==TRUE)
    						gLaneGuidance_GuidanceInfo1[current_element] =(Indication_array[Offset]&0xF0)>>4;
    						gLaneGuidance_GuidanceInfo2[current_element] =Indication_array[Offset++]&0x0F;
  						//LaneMarking_Left/Right  - Nibble
  						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneMarking_left[current_element] =(Indication_array[Offset]&0xF0)>>4;
    						gLaneGuidance_LaneMarking_right[current_element] =Indication_array[Offset]&0x0F;
  						//LaneAttributes    - Bitfield
  						if (CacheElements ==TRUE)
  						  gLaneGuidance_LaneAttributes[current_element] =Indication_array[Offset++];
  						//LaneDescription   - Byte
  						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDescription[current_element] =Indication_array[Offset];
    						Offset++; 
  						//LaneType          - Byte
  						if (CacheElements ==TRUE)
  						  gLaneGuidance_LaneType[current_element] =Indication_array[Offset++];
  						//next element
  						if (CacheElements ==TRUE)
    						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
    						current_element++; //go on with next element  
  					}   //copy data of current element finished
  				}       //forward ends
  				if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
  				{
  					current_element =NAV_LANEGUIDANCE_ENTRIES-1; //NAV_LANEGUIDANCE2_ENTRIES =8, but range: 0...7!
  					for (j=0; j<elements;j++) //copy elements
  					{
  						//check, if elements must be cached and in case find position in array
  						CacheElements =FALSE;
  						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
  						{  
  							//if element already cached, find position in ASG-cache
  							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
  							{    
  								current_element =i; 
  								CacheElements   =TRUE;
  							} 
  							//if not already cached, then store element only, if Cache is build-up!
  							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
  							CacheElements   =TRUE;
  						}
  						//Pos
  						if (transmitpos)
  						{   
  							if (CacheElements ==TRUE)
  							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
  							Offset++;
  						}
  						//LaneFocus         - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_Focus =Indication_array[Offset];
  						Offset++;
  						//LaneDirection1    - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneDirection1[current_element] =Indication_array[Offset];
  						Offset++;
  						//LaneDirection1    - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneDirection2[current_element] =Indication_array[Offset];
  						Offset++;
  						//GuidanceInfo1&2   - Nibble (request =((gLaneGuidance2_GuidanceInfo1[x] *0x10) &0xF0) +(gLaneGuidance2_GuidanceInfo2[x] &0x0F);)
  						if (CacheElements ==TRUE)
  						gLaneGuidance_GuidanceInfo1[current_element] =(Indication_array[Offset]&0xF0)>>4;
  						gLaneGuidance_GuidanceInfo2[current_element] =Indication_array[Offset]&0x0F;
  						Offset++;
  						//LaneMarking_Left/Right  - Nibble
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneMarking_left[current_element] =(Indication_array[Offset]&0xF0)>>4;
  						gLaneGuidance_LaneMarking_right[current_element] =Indication_array[Offset]&0x0F;
  						Offset++;
  						//LaneAttributes    - Bitfield
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneAttributes[current_element] =Indication_array[Offset];
  						Offset++;
  						//LaneDescription   - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneDescription[current_element] =Indication_array[Offset];
  						Offset++;
  						//LaneType          - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneType[current_element] =Indication_array[Offset];
  						Offset++;
  						
  						//next element
  						if (CacheElements ==TRUE)
  						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
  						current_element--;
  					}   //copy data of current element finished                     
  				}       //backward ends
  			}          //startelement=0 ends
  			else if (startelement !=0) //startelement !=0
  			{
  				if(FORWARD==direction)  //forward-start
  				{
  					current_element =startelement; 
  					if (shift ==TRUE) //startelement is next element
  					current_element++;
  					
  					for (j=0; j<elements;j++) //copy elements
  					{
  						//check, if elements must be cached and in case find position in array
  						CacheElements =FALSE;
  						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
  						{  
  							//if element already cached, find position in ASG-cache
  							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
  							{    
  								current_element =i; 
  								CacheElements   =TRUE;
  							}
  							//if not already cached, then store element only, if Cache is build-up!
  							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
  							CacheElements   =TRUE;
  						}
  						//Pos
  						if (transmitpos)
  						{   
  							if (CacheElements ==TRUE)
  							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
  							Offset++;
  						}
  						//LaneFocus         - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_Focus =Indication_array[Offset];
  						Offset++;
  						//LaneDirection1    - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneDirection1[current_element] =Indication_array[Offset];
  						Offset++;
  						//LaneDirection1    - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneDirection2[current_element] =Indication_array[Offset];
  						Offset++;
  						//GuidanceInfo1&2   - Nibble (request =((gLaneGuidance2_GuidanceInfo1[x] *0x10) &0xF0) +(gLaneGuidance2_GuidanceInfo2[x] &0x0F);)
  						if (CacheElements ==TRUE)
  						gLaneGuidance_GuidanceInfo1[current_element] =(Indication_array[Offset]&0xF0)>>4;
  						gLaneGuidance_GuidanceInfo2[current_element] =Indication_array[Offset]&0x0F;
  						Offset++;
  						//LaneMarking_Left/Right  - Nibble
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneMarking_left[current_element] =(Indication_array[Offset]&0xF0)>>4;
  						gLaneGuidance_LaneMarking_right[current_element] =Indication_array[Offset]&0x0F;
  						Offset++;
  						//LaneAttributes    - Bitfield
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneAttributes[current_element] =Indication_array[Offset];
  						Offset++;
  						//LaneDescription   - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneDescription[current_element] =Indication_array[Offset];
  						Offset++;
  						//LaneType          - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneType[current_element] =Indication_array[Offset];
  						Offset++;
  						
  						//next element
  						if (CacheElements ==TRUE)
  						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
  						current_element++; //go on with next element    
  					}   //copy data of current element finished
  				}       //forward ends
  				else if(BACKWARD==direction)
  				{
  					current_element =startelement; 
  					if (shift ==TRUE) //startelement is previous element
  					current_element--;         
  					for (j=0; j<elements;j++) //copy elements
  					{
  						//check, if elements must be cached and in case find position in array
  						CacheElements =FALSE;
  						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
  						{  
  							//if element already cached, find position in ASG-cache
  							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
  							{    
  								current_element =i; 
  								CacheElements   =TRUE;
  							}
  							//if not already cached, then store element only, if Cache is build-up!
  							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
  							CacheElements   =TRUE;
  						}
  						//Pos
  						if (transmitpos)
  						{   
  							if (CacheElements ==TRUE)
  							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
  							Offset++;
  						}
  						//LaneFocus         - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_Focus =Indication_array[Offset];
  						Offset++;
  						//LaneDirection1    - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneDirection1[current_element] =Indication_array[Offset];
  						Offset++;
  						//LaneDirection1    - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneDirection2[current_element] =Indication_array[Offset];
  						Offset++;
  						//GuidanceInfo1&2   - Nibble (request =((gLaneGuidance2_GuidanceInfo1[x] *0x10) &0xF0) +(gLaneGuidance2_GuidanceInfo2[x] &0x0F);)
  						if (CacheElements ==TRUE)
  						gLaneGuidance_GuidanceInfo1[current_element] =(Indication_array[Offset]&0xF0)>>4;
  						gLaneGuidance_GuidanceInfo2[current_element] =Indication_array[Offset]&0x0F;
  						Offset++;
  						//LaneMarking_Left/Right  - Nibble
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneMarking_left[current_element] =(Indication_array[Offset]&0xF0)>>4;
  						gLaneGuidance_LaneMarking_right[current_element] =Indication_array[Offset]&0x0F;
  						Offset++;
  						//LaneAttributes    - Bitfield
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneAttributes[current_element] =Indication_array[Offset];
  						Offset++;
  						//LaneDescription   - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneDescription[current_element] =Indication_array[Offset];
  						Offset++;
  						//LaneType          - Byte
  						if (CacheElements ==TRUE)
  						gLaneGuidance_LaneType[current_element] =Indication_array[Offset];
  						Offset++;
  						
  						//next element
  						if (CacheElements ==TRUE)
  						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
  						current_element--;
  					}   //copy data of current element finished                                 
  				}
  			}          //startelement !=0 ends
  			break;         //recordaddress =1 ends
  		case 15: //recordaddress =15 -> POS 
  			if(0==startelement)
  			{
  				if(FORWARD==direction)  //forward-start
  				{          
  					current_element =startelement;
  					if (shift ==TRUE) //startelement is next element
  					current_element++;                 
  					for (j=0; j<elements;j++) //copy elements
  					{
  						//check, if elements must be cached and in case find position in array
  						CacheElements =FALSE;
  						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
  						{  
  							//if element already cached, find position in ASG-cache
  							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
  							{    
  								current_element =i; 
  								CacheElements   =TRUE;
  							}
  							//if not already cached, then store element only, if Cache is build-up!
  							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
  							CacheElements   =TRUE;
  						}
  						//Pos
  						if (transmitpos)
  						{   
  							if (CacheElements ==TRUE)
  							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
  							Offset++;
  						}
  						//next element
  						if (CacheElements ==TRUE)
  						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
  						current_element++; //go on with next element       
  					}   //copy data of current element finished
  				}       //forward ends
  				if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
  				{
  					current_element =NAV_LANEGUIDANCE_ENTRIES-1; //NAV_LANEGUIDANCE2_ENTRIES =8, but range: 0...7!
  					for (j=0; j<elements;j++) //copy elements
  					{
  						//check, if elements must be cached and in case find position in array
  						CacheElements =FALSE;
  						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
  						{  
  							//if element already cached, find position in ASG-cache
  							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
  							{    
  								current_element =i; 
  								CacheElements   =TRUE;
  							}
  							//if not already cached, then store element only, if Cache is build-up!
  							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
  							CacheElements   =TRUE;
  						}
  						//Pos
  						if (transmitpos)
  						{   
  							if (CacheElements ==TRUE)
  							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
  							Offset++;
  						}
  						//next element
  						if (CacheElements ==TRUE)
  						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
  						current_element--;
  					}   //copy data of current element finished                     
  				}       //backward ends
  			}          //startelement=0 ends
  			else if (startelement !=0) //startelement !=0
  			{
  				if(FORWARD==direction)  //forward-start
  				{
  					current_element =startelement;
  					if (shift ==TRUE) //startelement is next element
  					current_element++;
  					for (j=0; j<elements;j++) //copy elements
  					{
  						//check, if elements must be cached and in case find position in array
  						CacheElements =FALSE;
  						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
  						{  
  							//if element already cached, find position in ASG-cache
  							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
  							{    
  								current_element =i; 
  								CacheElements   =TRUE;
  							}
  							//if not already cached, then store element only, if Cache is build-up!
  							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
  							CacheElements   =TRUE;
  						}
  						//Pos
  						if (transmitpos)
  						{   
  							if (CacheElements ==TRUE)
  							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
  							Offset++;
  						}
  						//next element
  						if (CacheElements ==TRUE)
  						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
  						current_element++; //go on with next element       
  					}   //copy data of current element finished
  				}       //forward ends
  				else if(BACKWARD==direction)
  				{
  					current_element =startelement; 
  					if (shift ==TRUE) //startelement is previous element
  					current_element--;
  					for (j=0; j<elements;j++) //copy elements
  					{
  						//check, if elements must be cached and in case find position in array
  						CacheElements =FALSE;
  						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
  						{  
  							//if element already cached, find position in ASG-cache
  							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
  							{    
  								current_element =i; 
  								CacheElements   =TRUE;
  							}
  							//if not already cached, then store element only, if Cache is build-up!
  							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
  							CacheElements   =TRUE;
  						}
  						//Pos
  						if (transmitpos)
  						{   
  							if (CacheElements ==TRUE)
  							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
  							Offset++;
  						}
  						//next element
  						if (CacheElements ==TRUE)
  						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
  						current_element--;
  					}   //copy data of current element finished                                 
  				}
  			}          //startelement !=0 ends
  			break;       //recordaddress =15 ends    
		}                             
		//Panel
     
		putvalue(env_ASG_NaviSD_LG_ASGID, gLaneGuidance_ASGID);
		putvalue(env_ASG_NaviSD_LG_TAID, gLaneGuidance_TAID);
		putvalue(env_ASG_NaviSD_LG_TotalNrElement, gLaneGuidance_TotalNumListElements);
		putvalue(env_ASG_NaviSD_LG_CurrentCarPos, gLaneGuidance_CurrentCarPosition);
		putvalue(env_ASG_NaviSD_LG_RecommCarPos, gLaneGuidance_RecommendedCarPosition);
		putvalue(env_ASG_NaviSD_LG_AH_start , startelement);
		putvalue(env_ASG_NaviSD_LG_AH_elements , elements);
		putvalue(env_ASG_NaviSD_LG_AH_shift , shift);
		putvalue(env_ASG_NaviSD_LG_AH_Dir , direction);
		putvalue(env_ASG_NaviSD_LG_AH_PosTrans , transmitpos);
		putvalue(env_ASG_NaviSD_LG_AH_IS , indexsize);
		
		break;
	case Changed_IND:
		//get data
		gLaneGuidance_CurrentCarPosition =Indication_array[3];
		gLaneGuidance_RecommendedCarPosition = Indication_array[4];
		/***ArrayHeader***/
		mode            =(Indication_array[5] &0xF0) /0x10;
		recordaddress   =Indication_array[5] &0x0F;
		Offset =6;
		// decode "mode-byte"
		shift       =mode &0x01;
		direction   =(mode &0x02)/0x02;
		transmitpos =(mode &0x04)/0x04;
		indexsize   =(mode &0x08)/0x08;               
		if (indexsize)
		{   
			startelement =Indication_array[Offset];
			Offset++;
			startelement +=(Indication_array[Offset] *0x100);
			Offset++;
			elements =Indication_array[Offset];
			Offset++;
			elements +=(Indication_array[Offset] *0x100);
			Offset++;
		}
		else
		{   
			startelement =Indication_array[Offset];
			Offset++;
			elements =Indication_array[Offset];
			Offset++;
		}           
		if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==255) //check 'full range update'?
		{
      
		}
		else if (datalength>9)
		{
			if(startelement !=0)
			{
				for (i=0;i<NAV_LANEGUIDANCE_ENTRIES;i++)
				{
					if(startelement ==gLaneGuidance_Pos[i])  
					i =NAV_LANEGUIDANCE_ENTRIES;              
				}
			}
			switch (recordaddress)
			{  
    		case 1: //recordaddress =1 -> complete
    			if(0==startelement)
    			{
    				if(FORWARD==direction)  //forward-start
    				{          
    					current_element =startelement;             
    					if (shift ==TRUE) //startelement is next element
    					current_element++;                 

    					for (j=0; j<elements;j++) //copy elements
    					{
    						//check, if elements must be cached and in case find position in array
    						CacheElements =FALSE;
    						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
    						{  
    							//if element already cached, find position in ASG-cache
    							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
    							{    
    								current_element =i; 
    								CacheElements   =TRUE;
    							}
    							//if not already cached, then store element only, if Cache is build-up!
    							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
    							CacheElements   =TRUE;
    						}
    						//Pos
    						if (transmitpos)
    						{   
    							if (CacheElements ==TRUE)
    							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
    							Offset++;
    						}
    						//LaneFocus         - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_Focus =Indication_array[Offset];
    						Offset++;
    						//LaneDirection1    - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDirection1[current_element] =Indication_array[Offset];
    						Offset++;
    						//LaneDirection1    - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDirection2[current_element] =Indication_array[Offset];
    						Offset++;
    						//GuidanceInfo1&2   - Nibble (request =((gLaneGuidance2_GuidanceInfo1[x] *0x10) &0xF0) +(gLaneGuidance2_GuidanceInfo2[x] &0x0F);)
    						if (CacheElements ==TRUE)
    						gLaneGuidance_GuidanceInfo1[current_element] =(Indication_array[Offset]&0xF0)>>4;
    						gLaneGuidance_GuidanceInfo2[current_element] =Indication_array[Offset]&0x0F;
    						Offset++;
    						//LaneMarking_Left/Right  - Nibble
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneMarking_left[current_element] =(Indication_array[Offset]&0xF0)>>4;
    						gLaneGuidance_LaneMarking_right[current_element] =Indication_array[Offset]&0x0F;
    						Offset++;
    						//LaneAttributes    - Bitfield
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneAttributes[current_element] =Indication_array[Offset];
    						Offset++;
    						//LaneDescription   - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDescription[current_element] =Indication_array[Offset];
    						Offset++;
    						//LaneType          - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneType[current_element] =Indication_array[Offset];
    						Offset++;
    						
    						//next element
    						if (CacheElements ==TRUE)
    						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
    						current_element++; //go on with next element  
    					}   //copy data of current element finished
    				}       //forward ends
    				if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
    				{
    					current_element =NAV_LANEGUIDANCE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
    					for (j=0; j<elements;j++) //copy elements
    					{
    						//check, if elements must be cached and in case find position in array
    						CacheElements =FALSE;
    						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
    						{  
    							//if element already cached, find position in ASG-cache
    							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
    							{    
    								current_element =i; 
    								CacheElements   =TRUE;
    							} 
    							//if not already cached, then store element only, if Cache is build-up!
    							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
    							CacheElements   =TRUE;
    						}
    						//Pos
    						if (transmitpos)
    						{   
    							if (CacheElements ==TRUE)
    							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
    							Offset++;
    						}
    						//LaneFocus         - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_Focus =Indication_array[Offset];
    						Offset++;
    						//LaneDirection1    - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDirection1[current_element] =Indication_array[Offset];
    						Offset++;
    						//LaneDirection1    - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDirection2[current_element] =Indication_array[Offset];
    						Offset++;
    						//GuidanceInfo1&2   - Nibble (request =((gLaneGuidance2_GuidanceInfo1[x] *0x10) &0xF0) +(gLaneGuidance2_GuidanceInfo2[x] &0x0F);)
    						if (CacheElements ==TRUE)
    						gLaneGuidance_GuidanceInfo1[current_element] =(Indication_array[Offset]&0xF0)>>4;
    						gLaneGuidance_GuidanceInfo2[current_element] =Indication_array[Offset]&0x0F;
    						Offset++;
    						//LaneMarking_Left/Right  - Nibble
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneMarking_left[current_element] =(Indication_array[Offset]&0xF0)>>4;
    						gLaneGuidance_LaneMarking_right[current_element] =Indication_array[Offset]&0x0F;
    						Offset++;
    						//LaneAttributes    - Bitfield
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneAttributes[current_element] =Indication_array[Offset];
    						Offset++;
    						//LaneDescription   - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDescription[current_element] =Indication_array[Offset];
    						Offset++;//LaneType          - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneType[current_element] =Indication_array[Offset];
    						Offset++;
    						
    						
    						//next element
    						if (CacheElements ==TRUE)
    						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
    						current_element--;
    					}   //copy data of current element finished                     
    				}       //backward ends
    			}          //startelement=0 ends
    			else if (startelement !=0) //startelement !=0
    			{
    				if(FORWARD==direction)  //forward-start
    				{
    					current_element =startelement; 
    					if (shift ==TRUE) //startelement is next element
    					current_element++;
    					
    					for (j=0; j<elements;j++) //copy elements
    					{
    						//check, if elements must be cached and in case find position in array
    						CacheElements =FALSE;
    						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
    						{  
    							//if element already cached, find position in ASG-cache
    							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
    							{    
    								current_element =i; 
    								CacheElements   =TRUE;
    							}
    							//if not already cached, then store element only, if Cache is build-up!
    							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
    							CacheElements   =TRUE;
    						}
    						//Pos
    						if (transmitpos)
    						{   
    							if (CacheElements ==TRUE)
    							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
    							Offset++;
    						}
    						//LaneFocus         - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_Focus =Indication_array[Offset];
    						Offset++;
    						//LaneDirection1    - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDirection1[current_element] =Indication_array[Offset];
    						Offset++;
    						//LaneDirection1    - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDirection2[current_element] =Indication_array[Offset];
    						Offset++;
    						//GuidanceInfo1&2   - Nibble (request =((gLaneGuidance2_GuidanceInfo1[x] *0x10) &0xF0) +(gLaneGuidance2_GuidanceInfo2[x] &0x0F);)
    						if (CacheElements ==TRUE)
    						gLaneGuidance_GuidanceInfo1[current_element] =(Indication_array[Offset]&0xF0)>>4;
    						gLaneGuidance_GuidanceInfo2[current_element] =Indication_array[Offset]&0x0F;
    						Offset++;
    						//LaneMarking_Left/Right  - Nibble
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneMarking_left[current_element] =(Indication_array[Offset]&0xF0)>>4;
    						gLaneGuidance_LaneMarking_right[current_element] =Indication_array[Offset]&0x0F;
    						Offset++;
    						//LaneAttributes    - Bitfield
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneAttributes[current_element] =Indication_array[Offset];
    						Offset++;
    						//LaneDescription   - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDescription[current_element] =Indication_array[Offset];
    						Offset++;
    						//LaneType          - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneType[current_element] =Indication_array[Offset];
    						Offset++;
    						
    						//next element
    						if (CacheElements ==TRUE)
    						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
    						current_element++; //go on with next element    
    					}   //copy data of current element finished
    				}       //forward ends
    				else if(BACKWARD==direction)
    				{
    					current_element =startelement; 
    					if (shift ==TRUE) //startelement is previous element
    					current_element--;         
    					for (j=0; j<elements;j++) //copy elements
    					{
    						//check, if elements must be cached and in case find position in array
    						CacheElements =FALSE;
    						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
    						{  
    							//if element already cached, find position in ASG-cache
    							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
    							{    
    								current_element =i; 
    								CacheElements   =TRUE;
    							}
    							//if not already cached, then store element only, if Cache is build-up!
    							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
    							CacheElements   =TRUE;
    						}
    						//Pos
    						if (transmitpos)
    						{   
    							if (CacheElements ==TRUE)
    							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
    							Offset++;
    						}
    						//LaneFocus         - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_Focus =Indication_array[Offset];
    						Offset++;
    						//LaneDirection1    - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDirection1[current_element] =Indication_array[Offset];
    						Offset++;
    						//LaneDirection1    - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDirection2[current_element] =Indication_array[Offset];
    						Offset++;
    						//GuidanceInfo1&2   - Nibble (request =((gLaneGuidance2_GuidanceInfo1[x] *0x10) &0xF0) +(gLaneGuidance2_GuidanceInfo2[x] &0x0F);)
    						if (CacheElements ==TRUE)
    						gLaneGuidance_GuidanceInfo1[current_element] =(Indication_array[Offset]&0xF0)>>4;
    						gLaneGuidance_GuidanceInfo2[current_element] =Indication_array[Offset]&0x0F;
    						Offset++;
    						//LaneMarking_Left/Right  - Nibble
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneMarking_left[current_element] =(Indication_array[Offset]&0xF0)>>4;
    						gLaneGuidance_LaneMarking_right[current_element] =Indication_array[Offset]&0x0F;
    						Offset++;
    						//LaneAttributes    - Bitfield
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneAttributes[current_element] =Indication_array[Offset];
    						Offset++;
    						//LaneDescription   - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneDescription[current_element] =Indication_array[Offset];
    						Offset++;
    						//LaneType          - Byte
    						if (CacheElements ==TRUE)
    						gLaneGuidance_LaneType[current_element] =Indication_array[Offset];
    						Offset++;
    						
    						//next element
    						if (CacheElements ==TRUE)
    						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
    						current_element--;
    					}   //copy data of current element finished                                 
    				}
    			}          //startelement !=0 ends
    			break;         //recordaddress =1 ends
    		case 15: //recordaddress =15 -> POS 
    			if(0==startelement)
    			{
    				if(FORWARD==direction)  //forward-start
    				{          
    					current_element =startelement;
    					if (shift ==TRUE) //startelement is next element
    					current_element++;                 
    					for (j=0; j<elements;j++) //copy elements
    					{
    						//check, if elements must be cached and in case find position in array
    						CacheElements =FALSE;
    						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
    						{  
    							//if element already cached, find position in ASG-cache
    							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
    							{    
    								current_element =i; 
    								CacheElements   =TRUE;
    							}
    							//if not already cached, then store element only, if Cache is build-up!
    							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
    							CacheElements   =TRUE;
    						}
    						//Pos
    						if (transmitpos)
    						{   
    							if (CacheElements ==TRUE)
    							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
    							Offset++;
    						}
    						//next element
    						if (CacheElements ==TRUE)
    						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
    						current_element++; //go on with next element       
    					}   //copy data of current element finished
    				}       //forward ends
    				if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
    				{
    					current_element =NAV_LANEGUIDANCE_ENTRIES-1; //NAV_LANEGUIDANCE2_ENTRIES =8, but range: 0...7!
    					for (j=0; j<elements;j++) //copy elements
    					{
    						//check, if elements must be cached and in case find position in array
    						CacheElements =FALSE;
    						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
    						{  
    							//if element already cached, find position in ASG-cache
    							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
    							{    
    								current_element =i; 
    								CacheElements   =TRUE;
    							}
    							//if not already cached, then store element only, if Cache is build-up!
    							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
    							CacheElements   =TRUE;
    						}
    						//Pos
    						if (transmitpos)
    						{   
    							if (CacheElements ==TRUE)
    							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
    							Offset++;
    						}
    						//next element
    						if (CacheElements ==TRUE)
    						gLaneGuidance_ListEntryReceptionInformation[current_element] =TRUE;
    						current_element--;
    					}   //copy data of current element finished                     
    				}       //backward ends
    			}          //startelement=0 ends
    			else if (startelement !=0) //startelement !=0
    			{
    				if(FORWARD==direction)  //forward-start
    				{
    					current_element =startelement;
    					if (shift ==TRUE) //startelement is next element
    					current_element++;
    					for (j=0; j<elements;j++) //copy elements
    					{
    						//check, if elements must be cached and in case find position in array
    						CacheElements =FALSE;
    						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
    						{  
    							//if element already cached, find position in ASG-cache
    							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
    							{    
    								current_element =i; 
    								CacheElements   =TRUE;
    							}
    							//if not already cached, then store element only, if Cache is build-up!
    							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
    							CacheElements   =TRUE;
    						}
    						//Pos
    						if (transmitpos)
    						{   
    							if (CacheElements ==TRUE)
    							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
    							Offset++;
    						}
    						//next element
    						if (CacheElements ==TRUE)
    						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
    						current_element++; //go on with next element       
    					}   //copy data of current element finished
    				}       //forward ends
    				else if(BACKWARD==direction)
    				{
    					current_element =startelement; 
    					if (shift ==TRUE) //startelement is previous element
    					current_element--;
    					for (j=0; j<elements;j++) //copy elements
    					{
    						//check, if elements must be cached and in case find position in array
    						CacheElements =FALSE;
    						for (i=0; i<NAV_LANEGUIDANCE_ENTRIES; i++)
    						{  
    							//if element already cached, find position in ASG-cache
    							if((transmitpos ==1) && Indication_array[Offset] ==gLaneGuidance_Pos[i] && gLaneGuidance_ListEntryReceptionInformation[i] ==TRUE)
    							{    
    								current_element =i; 
    								CacheElements   =TRUE;
    							}
    							//if not already cached, then store element only, if Cache is build-up!
    							else if((gLaneGuidance_ListHandlingType !=NAV_LANEGUIDANCE_NOCACHE))
    							CacheElements   =TRUE;
    						}
    						//Pos
    						if (transmitpos)
    						{   
    							if (CacheElements ==TRUE)
    							gLaneGuidance_Pos[current_element]=Indication_array[Offset];
    							Offset++;
    						}
    						//next element
    						if (CacheElements ==TRUE)
    						gLaneGuidance_ListEntryReceptionInformation [current_element] =TRUE;
    						current_element--;
    					}   //copy data of current element finished                                 
    				}
    			}          //startelement !=0 ends
    			break;         //recordaddress =15 ends    
			}
		}
		//Panel     
		putvalue(env_ASG_NaviSD_LG_ASGID, gLaneGuidance_ASGID);
		putvalue(env_ASG_NaviSD_LG_TAID, gLaneGuidance_TAID);
		putvalue(env_ASG_NaviSD_LG_TotalNrElement, gLaneGuidance_TotalNumListElements);
		putvalue(env_ASG_NaviSD_LG_CurrentCarPos, gLaneGuidance_CurrentCarPosition);
		putvalue(env_ASG_NaviSD_LG_RecommCarPos, gLaneGuidance_RecommendedCarPosition);
		putvalue(env_ASG_NaviSD_LG_AH_start , startelement);
		putvalue(env_ASG_NaviSD_LG_AH_elements , elements);
		putvalue(env_ASG_NaviSD_LG_AH_shift , shift);
		putvalue(env_ASG_NaviSD_LG_AH_Dir , direction);
		putvalue(env_ASG_NaviSD_LG_AH_PosTrans , transmitpos);
		putvalue(env_ASG_NaviSD_LG_AH_IS , indexsize);
		break;            
	case Error_IND:	
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD LaneGuidance2_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD LaneGuidance2_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD LaneGuidance2_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD LaneGuidance2_Indication: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD LaneGuidance2_Indication: unknown indication %x", gBAP_Indication[2]);
		break;
	}    
}

void LaneGuidance_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];
	byte Offset;
	word indexsize;

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	indexsize   =0;
	Offset      =0;

	// decode "mode-byte"
	indexsize   =(mode &0x08)/0x08; 

	// Handle request.
	requestarray[0] =LSG_NaviSD;	    //LSG-ID
	requestarray[1] =FctID_LaneGuidance;	//Fct.-ID
	requestarray[2] =request;           //request type

	switch(request)
	{
  	case DataGet_REQ:              
  		requestarray[3] =((gLaneGuidance_ASGID *0x10) &0xF0) +(gLaneGuidance_TAID &0x0F);      
  		/***ArrayHeader***/
  		requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
  		Offset =5;
  		if(indexsize)
  		{
  			requestarray[Offset] =requested_startelement &0x00FF;
  			Offset++;
  			requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
  			Offset++;
  			requestarray[Offset] =elements &0x00FF;
  			Offset++;
  			requestarray[Offset] =(elements &0xFF00) /0x100;
  			Offset++;
  			//writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_16bit %x",indexsize); //debug
  		}
  		else
  		{
  			requestarray[Offset] =requested_startelement;
  			Offset++;
  			requestarray[Offset] =elements;
  			Offset++;
  			//writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_8bit %x",indexsize); //debug
  		}
  		set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
  		break;
  	default:	
  		writelineEx(gError_Trace, 0, "ASG-NaviSD Request_LaneGuidance2: invalid request %d", request);
  		break;
	}
}

void TMCinfo_Indication(dword Indication_array [], int datalength)
{   
	int i =0, Offset =0, length =0;
	for(i=0;i<NAV_TMCINFO_LOCATION_LENGTH; i++) //clear
	  gTMCinfo.location[i] =0;
	for(i=0;i<NAV_TMCINFO_INFOTEXT_LENGTH; i++) //clear
	  gTMCinfo.infotext[i] =0;
	for(i=0;i<NAV_TMCINFO_STREETNAME_LENGTH; i++) //clear
	  gTMCinfo.streetName[i] =0;

	switch (gBAP_Indication[2])
	{
  	case Data_IND:
  		//get data
  		gTMCinfo_Reserve1 =(Indication_array[3] &0xf0) /0x10;
  		gTMCinfo_MessageStatus =Indication_array[3] &0x0f;

  		//StreetName
  		length = Indication_array[4];
  		Offset = 5;
  		for(i=0;i<length;i++)
  		{
  			gTMCinfo.streetName[i] =Indication_array[Offset++];
  		}

  		//Location
  		length = Indication_array[Offset++];
  		for(i=0;i<length;i++)
  		{
  			gTMCinfo.location[i] =Indication_array[Offset++];
  		}

  		//Infotext
  		length = Indication_array[Offset++];
  		for(i=0;i<length;i++)
  			gTMCinfo.infotext[i] =Indication_array[Offset++];
      
  		gTMCinfo.length_value = Indication_array[Offset++];
  		gTMCinfo.length_value +=Indication_array[Offset++] *0x100;
  		gTMCinfo.length_value +=Indication_array[Offset++] *0x10000;
  		gTMCinfo.length_value +=Indication_array[Offset++] *0x1000000;
  		gTMCinfo.length_unit = Indication_array[Offset++];

  		//Panel
      putValue(env_ASG_NaviSD_TMCI_MssgStatus,gTMCinfo_MessageStatus);
  		if(gTMCinfo_MessageStatus < 0x3)
  		  putvalue(env_ASG_NaviSD_TMCI_MssgStatus_s,gTMCinfo_MessageStatus_s[gTMCinfo_MessageStatus]);
  		else
  		  putvalue(env_ASG_NaviSD_TMCI_MS_s,gstring_reserved);
  		
  		putvalue(env_ASG_NaviSD_TMCI_StreetName_s,gTMCinfo.streetName);
  		putvalue(env_ASG_NaviSD_TMCI_Location_s,gTMCinfo.location);
  		putvalue(env_ASG_NaviSD_TMCI_Infotext_s,gTMCinfo.infotext);
  		putvalue(env_ASG_NaviSD_TMCI_Len_Value, gTMCinfo.length_value);
  		if (gTMCinfo.length_unit <0x05)
  		  putvalue(env_ASG_NaviSD_TMCI_Len_Unit_s, gTMCinfo_Length_Unit_s[gTMCinfo.length_unit]);
  		else if (gTMCinfo.length_unit == 0xff)
  		  putvalue(env_ASG_NaviSD_TMCI_Len_Unit_s,gstring_not_supported);
  		else
  		  putvalue(env_ASG_NaviSD_TMCI_Len_Unit_s,gstring_reserved);
  		break;
  	case Error_IND:
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD TMCinfo_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD TMCinfo_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD TMCinfo_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  		writelineEx(gError_Trace, 0, "ASG-NaviSD TMCinfo_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-NaviSD TMCinfo_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
	}
}

void TMCinfo_Request (byte request)
{
	int  i, Offset = 0;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	//LSG-ID
	requestarray[1] =FctID_TMCinfo;	//Fct.-ID
	requestarray[2] =request;       //request type

	switch(request)
	{
	case DataGet_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	case DataSetGet_REQ:
		requestarray[Offset++] =(gTMCinfo_UserConfirmationState &0x0f)*0x10 +(gTMCinfo_Reserve2 &0x0f);
		for(i = 0; i < GTMCINFO_REVERSE3_LENGTH; i++)
		{
			requestarray[Offset++] = gTMCinfo_Reserve3[i];
		}
		set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD TMCinfo_Request: invalid request %d", request);
		break;
	}
}

void RGActDeact_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
	case Processing_IND:
		gNav_RGAD_ASG_ID        = (Indication_array[3] * 0x10 ) & 0xF0;
		gNav_RGAD_Ext1          = Indication_array[3] & 0x0F;
		gNav_RGAD_Resr1 = Indication_array[4];      
		break;
	case Result_IND:
		if(Indication_array[3] <0x0F)
		{
			gNav_RGAD_ASG_ID        = Indication_array[3] * 0x10;
			gNav_RGAD_Ext1          = Indication_array[3] & 0xF0;
			gNav_RG_ActDeact_Result = Indication_array[4];
      
			putvalue(env_ASG_NaviSD_RGActDeact_Res_s, gNav_RG_ActDeact_Result_s[gNav_RG_ActDeact_Result]);   
		}
		else
		putvalue(env_ASG_NaviSD_RGActDeact_Res_s, gstring_reserved);               
		break;
	case Error_IND:
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		  writelineEx(gError_Trace, 0, "ASG-NaviSD RGActDeact_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		  writelineEx(gError_Trace, 0, "ASG-NaviSD RGActDeact_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		  writelineEx(gError_Trace, 0, "ASG-NaviSD RGActDeact_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		{	
			writelineEx(gError_Trace, 0, "ASG-NaviSD RGActDeact_Indication: Application-Error: 0x%x", Indication_array[3]);
			putvalue(env_ASG_NaviSD_RGActDeact_Err,Indication_array[3]);
			
			if (Indication_array[3] ==0)
			putvalue(env_ASG_NaviSD_RGActDeact_Err_s,"no error");
			
			else if((Indication_array[3]-0x40)<17)
			putvalue(env_ASG_NaviSD_RGActDeact_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
			else
			putvalue(env_ASG_NaviSD_RGActDeact_Err_s,gstring_reserved);
		}
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD RGActDeact_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

void RGActDeact_Request(byte request)
{
	int i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init lokal variables
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	    //LSG-ID
	requestarray[1] =FctID_RG_ActDeact; //Fct.-ID
	requestarray[2] =request;

	switch(request)
	{
	case StartResult_REQ:
		requestarray[3] =(gNav_RGAD_ASG_ID * 0x10) + gNav_RGAD_Ext1;
		requestarray[4] =(gNav_ControlType * 0x10) + gNav_CI_Type;
		requestarray[5] = gNav_ControlInformation;
		
		set_status_requestbuffer (requestarray, 6, Bap_ByteSequence);
		break;       
	case AbortResult_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default://error
		writelineEx(gError_Trace, 0,"ASG-NaviSD RGActDeact_Request: unknown request %d", request);
		break;
	}
}

void RepeatLastNavAnnouncement_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
	case Processing_IND:
		gNav_RepeatLastNavAnn_ASGID = Indication_array[3] * 0x10;
		gNav_RepeatLastNavAnn_Ext1  = Indication_array[3] & 0xF0;
		gNav_RepeatLastNavAnn_Resrv1= Indication_array[4];
		break;
	case Result_IND:
		if(Indication_array[3] <0x04)
		{
			gNav_RepeatLastNavAnn_ASGID = Indication_array[3] * 0x10;
			gNav_RepeatLastNavAnn_Ext1  = Indication_array[3] & 0xF0;
			gNav_RepeatLastNavAnn_Result= Indication_array[4];
			putvalue(env_ASG_NaviSD_RepLastNavAnn_Res, gNav_RepeatLastNavAnn_Result_s[gNav_RepeatLastNavAnn_Result]);   
		}
		else
		putvalue(env_ASG_NaviSD_RepLastNavAnn_Res, gstring_reserved);               
		break;
	case Error_IND:
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD RepeatLastNavAnnouncement_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD RepeatLastNavAnnouncement_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD RepeatLastNavAnnouncement_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		{
			writelineEx(gError_Trace, 0, "ASG-NaviSD RepeatLastNavAnnouncement_Indication: Application-Error: 0x%x", Indication_array[3]);
			putvalue(env_ASG_NaviSD_RepLastNavAnn_Err,Indication_array[3]);

			if (Indication_array[3] ==0)
			putvalue(env_ASG_NaviSD_RepLastNavAnn_E_s,"no error");
			else if((Indication_array[3]-0x40)<17)
			putvalue(env_ASG_NaviSD_RepLastNavAnn_E_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
			else
			putvalue(env_ASG_NaviSD_RepLastNavAnn_E_s,gstring_reserved);
		}
		
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD RepeatLastNavAnnouncement_Indication:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

void RepeatLastNavAnnouncement_Request (byte request)
{
	int i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init lokal variables
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	                    //LSG-ID
	requestarray[1] =FctID_RptLastNavAnnouncement;   //Fct.-ID
	requestarray[2] =request;

	switch(request)
	{
	case StartResult_REQ:
		requestarray[3] = (gNav_RepeatLastNavAnn_ASGID * 0x10) + gNav_RepeatLastNavAnn_Ext1;
		set_status_requestbuffer (requestarray, 4, Bap_ByteSequence);
		break;         
	case AbortResult_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default://error
		writelineEx(gError_Trace, 0,"ASG-NaviSD RepeatLastNavAnnouncement_Request: unknown request %d", request);
		break;
	}
}

int LastDestList_GetNextCachedElement (int currentElement,byte direction)
{
	int i=0, nextElement=0;

	switch (direction)
	{
	case NAV_LASTDESTLIST_DISPLAYLIST_FIND_NEXT_ELEMENT:                
		nextElement = ++currentElement;

		if (nextElement<NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE) //start at next element, if next element is not >8
		{
			for(i =nextElement; i<NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE;i++)
			{
				if(gLastDestList_ListEntryReceptionInformation[i] ==TRUE)
				{   
					nextElement =i; 
					i= NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE;
				}
				else
				nextElement =0;
			}
		}
		else    //start at first element
		{
			nextElement =0;

			for(i =nextElement; i<NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE;i++)
			{
				if(gLastDestList_ListEntryReceptionInformation[i] ==TRUE)
				{   
					nextElement =i; 
					i =NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE;
				}   
			}
		}
		break;

	case NAV_LASTDESTLIST_DISPLAYLIST_FIND_PREVIUOS_ELEMENT:
		nextElement = --currentElement;
		if (nextElement ==0 && gLastDestList_ListEntryReceptionInformation[nextElement] ==TRUE)
		nextElement =0;
		else if (nextElement>0) 
		{
			for(i =nextElement; i>0; i--)
			{
				if(gLastDestList_ListEntryReceptionInformation[i] ==TRUE)
				{   
					nextElement =i; 
					i =0;
				}
				else
				nextElement =NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE-1;
			}
		}    
		else    //start at last element
		{
			nextElement =NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE-1;

			for(i =nextElement; i>0; i--)
			{
				if(gLastDestList_ListEntryReceptionInformation[i] ==TRUE)
				{   
					nextElement =i; 
					i =0;
				}
				else if(gLastDestList_ListEntryReceptionInformation[0] ==TRUE)
				nextElement =0;          
			}
		}
		break;

	default:
		break;
	}
	return(nextElement);
}

int LastDestList_GetNextLineInCache (int currentElement,byte direction)
{
	int i=0, nextElement=0;

	switch (direction)
	{
	case FORWARD:
		
		if(currentElement<NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE-1 && currentElement !=5) 
		nextElement = ++currentElement;  
		
		else if (currentElement ==8)            
		nextElement =0;
		else
		nextElement =NAV_LASTDESTLIST_NO_NEXT_POSITION;
		break;

	case BACKWARD:
		if(currentElement<NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE && currentElement !=0 && currentElement !=6) 
		nextElement =--currentElement;
		
		else if (currentElement ==0)            
		nextElement =8;
		
		else
		nextElement =NAV_LASTDESTLIST_NO_NEXT_POSITION;
		break;

	default:
		break;
	}
	return(nextElement);
}

void LastDestList_Indication(dword Indication_array [], int datalength)
{
	byte mode, direction, shift, recordaddress, transmitpos, length, CacheElements, indexsize;
	word startelement, current_element, elements, StartElementInCache;
	int i,j , Offset;
	Offset = 0;
  j = 0;
  i = 0;
	// Init local variables
	mode                    =0;
	direction               =0;
	shift                   =0;
	recordaddress           =0;
	startelement            =0;
	elements                =0;
	current_element         =0;
	transmitpos             =0;
	length                  =0;
	indexsize               =0;
	StartElementInCache     =FALSE;
	CacheElements           =FALSE;

	switch (gBAP_Indication[2])
	{
  	case Data_IND:
  		//get data
  		gLastDestList_ASGID =(Indication_array[3] &0xF0) /0x10;
  		gLastDestList_TAID  =Indication_array[3] &0x0F;
  		
  		gLastDestList_TotalNumListElements =Indication_array[4];

  		/***ArrayHeader***/
  		mode            =(Indication_array[5] &0xF0) /0x10;
  		recordaddress   =Indication_array[5] &0x0F;
  		Offset =6;
  		
  		// decode "mode-byte"
  		shift       =mode &0x01;
  		direction   =(mode &0x02)/0x02;
  		transmitpos =(mode &0x04)/0x04;
  		indexsize   =(mode &0x08)/0x08;              
  		
  		if (indexsize)
  		{   
  			startelement =Indication_array[Offset];
  			Offset++;
  			startelement +=(Indication_array[Offset] *0x100);
  			Offset++;

  			elements =Indication_array[Offset];
  			Offset++;
  			elements +=(Indication_array[Offset] *0x100);
  			Offset++;
  		}
  		else
  		{   
  			startelement =Indication_array[Offset];
  			Offset++;

  			elements =Indication_array[Offset];
  			Offset++;
  		}           

  		switch (recordaddress)
  		{
  		case 0: //recordaddress =0 -> complete record
  			gFavoriteDestList_Pos = Indication_array[Offset++];
  			gFavoriteDestList_DestType = Indication_array[Offset++];
  			for(i = 0; i < NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH; i++)
  			{
  				gLastDestList_Description[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_STREET_LENGTH; i++)
  			{
  				gLastDestList_Street[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_JUNCTION_LENGTH; i++)
  			{
  				gLastDestList_Junction[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_CITY_LENGTH; i++)
  			{
  				gLastDestList_City[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_REGION_LENGTH; i++)
  			{
  				gLastDestList_Region[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_POSCODE_LENGTH; i++)
  			{
  				gLastDestList_PosCode[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_COUNTRY_LENGTH; i++)
  			{
  				gLastDestList_Country[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_COOR_LENGTH; i++)
  			{
  				gLastDestList_Coordinates[i] = Indication_array[Offset++];
  			}
  			
  			gLastDestList_PicRef = Indication_array[Offset++];
  			gLastDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
  			
  			break; //recordaddress =0 ends

  		case 1: //recordaddress =1
  			gLastDestList_Pos[i] = Indication_array[Offset++];
  			gLastDestList_DestType = Indication_array[Offset++];
  			for(i = 0; i < NAV_LASTDESTLIST_DESCRIPTION_LENGTH; i++)
  			{
  				gLastDestList_Description[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_STREET_LENGTH; i++)
  			{
  				gLastDestList_Street[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_JUNCTION_LENGTH; i++)
  			{
  				gLastDestList_Junction[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_CITY_LENGTH; i++)
  			{
  				gLastDestList_City[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_REGION_LENGTH; i++)
  			{
  				gLastDestList_Region[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_POSCODE_LENGTH; i++)
  			{
  				gLastDestList_PosCode[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_COUNTRY_LENGTH; i++)
  			{
  				gLastDestList_Country[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_COOR_LENGTH; i++)
  			{
  				gLastDestList_Coordinates[i] = Indication_array[Offset++];
  			}
  			
  			gLastDestList_PicRef = Indication_array[Offset++];
  			gLastDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
  			break;
  		case 2: //recordaddress =2 
  			
  			gLastDestList_DestType = Indication_array[Offset++];
  			for(i = 0; i < NAV_LASTDESTLIST_DESCRIPTION_LENGTH; i++)
  			{
  				gLastDestList_Description[i] = Indication_array[Offset++];
  			}
  			gLastDestList_PicRef = Indication_array[Offset++];
  			gLastDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
  			break; //recordaddress =2 ends
  		case 3: //recordaddress =3
  			gLastDestList_DestType = Indication_array[Offset++];
  			for(i = 0; i < NAV_LASTDESTLIST_DESCRIPTION_LENGTH; i++)
  			{
  				gLastDestList_Description[i] = Indication_array[Offset++];
  			}
  			break;
  		case 4: //recordaddress =4
  			for(i = 0; i < NAV_LASTDESTLIST_STREET_LENGTH; i++)
  			{
  				gLastDestList_Street[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_JUNCTION_LENGTH; i++)
  			{
  				gLastDestList_Junction[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_CITY_LENGTH; i++)
  			{
  				gLastDestList_City[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_REGION_LENGTH; i++)
  			{
  				gLastDestList_Region[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_POSCODE_LENGTH; i++)
  			{
  				gLastDestList_PosCode[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_COUNTRY_LENGTH; i++)
  			{
  				gLastDestList_Country[i] = Indication_array[Offset++];
  			}
  			
  			for(i = 0; i < NAV_LASTDESTLIST_COOR_LENGTH; i++)
  			{
  				gLastDestList_Coordinates[i] = Indication_array[Offset++];
  			}
  			break;
  		case 5: //recordaddress =1
  			gLastDestList_PicRef = Indication_array[Offset++];
  			gLastDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
  			break;
  		case 15: 
  			gLastDestList_Pos[i] = Indication_array[Offset++];
  			break; //recordaddress =15 ends

  		}
  		
  		//Panel
  		putvalue(env_ASG_NaviSD_LDL_ASGID, gLastDestList_ASGID);
  		putvalue(env_ASG_NaviSD_LDL_TAID, gLastDestList_TAID);
  		putvalue(env_ASG_NaviSD_LDL_TotalNumLE, gLastDestList_TotalNumListElements);
      putvalue(env_ASG_NaviSD_LDL_AH_shift,shift);
      putvalue(env_ASG_NaviSD_LDL_AH_dir,direction);
      putvalue(env_ASG_NaviSD_LDL_AH_PosTrans,transmitpos);
      putvalue(env_ASG_NaviSD_LDL_AH_IS,indexsize);
      putvalue(env_ASG_NaviSD_LDL_AH_RA,recordaddress);
      putvalue(env_ASG_NaviSD_LDL_AH_start,startelement);
      putvalue(env_ASG_NaviSD_LDL_AH_elements,elements);
  		
  		gLastDestList_recordaddress =recordaddress;
  		gLastDestList_transmitpos   =transmitpos;             
  		
  		
  		break;

  	case Changed_IND:
  		/***ArrayHeader***/
  		mode            =(Indication_array[3] &0xF0) /0x10;
  		recordaddress   =Indication_array[3] &0x0F;
  		Offset =4;
  		
  		// decode "mode-byte"
  		shift       = mode &0x01;
  		direction   =(mode &0x02)/0x02;
  		transmitpos =(mode &0x04)/0x04;
  		indexsize   =(mode &0x08)/0x08;              
  		
  		if (indexsize)
  		{   
  			startelement =Indication_array[Offset];
  			Offset++;
  			startelement +=(Indication_array[Offset] *0x100);
  			Offset++;

  			elements =Indication_array[Offset];
  			Offset++;
  			elements +=(Indication_array[Offset] *0x100);
  			Offset++;
  		}
  		else
  		{   
  			startelement =Indication_array[Offset];
  			Offset++;

  			elements =Indication_array[Offset];
  			Offset++;
  		}

  		if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==255) //check 'full range update'?
  		{
  			putvalue(env_ASG_NaviSD_LDL_OnOff, FALSE);
  			putvalue(env_ASG_NaviSD_LDL_ListOpState, "'full range update' received");

  		}
  		else if (datalength>8)
  		{
  			if(startelement !=0)
  			{
  				for (i=0;i<NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE;i++)
  				{
  					if(startelement ==gLastDestList_Pos[i])  
  					i =NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE;              
  				}
  			}           

  			switch (recordaddress)
  			{
  			case 0: //recordaddress =0 -> complete record
  				gFavoriteDestList_Pos = Indication_array[Offset++];
  				gFavoriteDestList_DestType = Indication_array[Offset++];
  				for(i = 0; i < NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH; i++)
  				{
  					gLastDestList_Description[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_STREET_LENGTH; i++)
  				{
  					gLastDestList_Street[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_JUNCTION_LENGTH; i++)
  				{
  					gLastDestList_Junction[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_CITY_LENGTH; i++)
  				{
  					gLastDestList_City[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_REGION_LENGTH; i++)
  				{
  					gLastDestList_Region[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_POSCODE_LENGTH; i++)
  				{
  					gLastDestList_PosCode[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_COUNTRY_LENGTH; i++)
  				{
  					gLastDestList_Country[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_COOR_LENGTH; i++)
  				{
  					gLastDestList_Coordinates[i] = Indication_array[Offset++];
  				}
  				
  				gLastDestList_PicRef = Indication_array[Offset++];
  				gLastDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
  				
  				break; //recordaddress =0 ends

  			case 1: //recordaddress =1
  				gLastDestList_Pos[i] = Indication_array[Offset++];
  				gLastDestList_DestType = Indication_array[Offset++];
  				for(i = 0; i < NAV_LASTDESTLIST_DESCRIPTION_LENGTH; i++)
  				{
  					gLastDestList_Description[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_STREET_LENGTH; i++)
  				{
  					gLastDestList_Street[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_JUNCTION_LENGTH; i++)
  				{
  					gLastDestList_Junction[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_CITY_LENGTH; i++)
  				{
  					gLastDestList_City[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_REGION_LENGTH; i++)
  				{
  					gLastDestList_Region[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_POSCODE_LENGTH; i++)
  				{
  					gLastDestList_PosCode[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_COUNTRY_LENGTH; i++)
  				{
  					gLastDestList_Country[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_COOR_LENGTH; i++)
  				{
  					gLastDestList_Coordinates[i] = Indication_array[Offset++];
  				}
  				
  				gLastDestList_PicRef = Indication_array[Offset++];
  				gLastDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
  				break;
  			case 2: //recordaddress =2 
  				
  				gLastDestList_DestType = Indication_array[Offset++];
  				for(i = 0; i < NAV_LASTDESTLIST_DESCRIPTION_LENGTH; i++)
  				{
  					gLastDestList_Description[i] = Indication_array[Offset++];
  				}
  				gLastDestList_PicRef = Indication_array[Offset++];
  				gLastDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
  				break; //recordaddress =2 ends
  			case 3: //recordaddress =3
  				gLastDestList_DestType = Indication_array[Offset++];
  				for(i = 0; i < NAV_LASTDESTLIST_DESCRIPTION_LENGTH; i++)
  				{
  					gLastDestList_Description[i] = Indication_array[Offset++];
  				}
  				break;
  			case 4: //recordaddress =4
  				for(i = 0; i < NAV_LASTDESTLIST_STREET_LENGTH; i++)
  				{
  					gLastDestList_Street[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_JUNCTION_LENGTH; i++)
  				{
  					gLastDestList_Junction[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_CITY_LENGTH; i++)
  				{
  					gLastDestList_City[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_REGION_LENGTH; i++)
  				{
  					gLastDestList_Region[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_POSCODE_LENGTH; i++)
  				{
  					gLastDestList_PosCode[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_COUNTRY_LENGTH; i++)
  				{
  					gLastDestList_Country[i] = Indication_array[Offset++];
  				}
  				
  				for(i = 0; i < NAV_LASTDESTLIST_COOR_LENGTH; i++)
  				{
  					gLastDestList_Coordinates[i] = Indication_array[Offset++];
  				}
  				break;
  			case 5: //
  				gLastDestList_PicRef = Indication_array[Offset++];
  				gLastDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
  				break;
  			case 15: 
  				gLastDestList_Pos[i] = Indication_array[Offset++];
  				break; //
  			}
  		}
		//Panel
  		putvalue(env_ASG_NaviSD_LDL_ASGID, gLastDestList_ASGID);
  		putvalue(env_ASG_NaviSD_LDL_TAID, gLastDestList_TAID);
  		putvalue(env_ASG_NaviSD_LDL_TotalNumLE, gLastDestList_TotalNumListElements);
      putvalue(env_ASG_NaviSD_LDL_AH_shift,shift);
      putvalue(env_ASG_NaviSD_LDL_AH_dir,direction);
      putvalue(env_ASG_NaviSD_LDL_AH_PosTrans,transmitpos);
      putvalue(env_ASG_NaviSD_LDL_AH_IS,indexsize);
      putvalue(env_ASG_NaviSD_LDL_AH_RA,recordaddress);
      putvalue(env_ASG_NaviSD_LDL_AH_start,startelement);
      putvalue(env_ASG_NaviSD_LDL_AH_elements,elements);
  		break;
  		
  	case Error_IND:
  		
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD LastDestList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD LastDestList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD LastDestList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  		writelineEx(gError_Trace, 0, "ASG-NaviSD LastDestList_Indication: Application-Error: 0x%x", Indication_array[3]);
  		
  		break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-NaviSD LastDestList_Indication: unknown indication %x", gBAP_Indication[2]);
  		break;
	}
}

void LastDestList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];
	byte Offset;
	word indexsize;

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;
	
	// decode "mode-byte"
	indexsize   =(mode &0x08)/0x08; 

	// Handle request.
	requestarray[0] =LSG_NaviSD;	            //LSG-ID
	requestarray[1] =FctID_LastDest_List;	    //Fct.-ID
	requestarray[2] =request;                   //request type

	switch(request)
	{
  	case DataGet_REQ:
  		requestarray[3] =((gLastDestList_ASGID *0x10) &0xF0) +(gLastDestList_TAID &0x0F);
  		/***ArrayHeader***/
  		requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
  		Offset =5;

  		if(indexsize)
  		{
  			requestarray[Offset++] =requested_startelement &0x00FF;
  			requestarray[Offset++] =(requested_startelement &0xFF00) /0x100;

  			requestarray[Offset++] =elements &0x00FF;
  			requestarray[Offset++] =(elements &0xFF00) /0x100;
  		}
  		else
  		{
  			requestarray[Offset++] =requested_startelement;
  			requestarray[Offset++] =elements;
  		}
  		
  		set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
  		break;

  	default:	
  		writelineEx(gError_Trace, 0, "ASG-NaviSD LastDestList_Request: invalid request %d", request);
  		break;
	}
}

void FavoriteDestList_Indication(dword Indication_array[], int datalength)
{
	byte mode, direction, shift, recordaddress, indexsize, transmitpos, length, CacheElements;
	word startelement, elements, StartElementInCache, current_element;
	int i = 0, j = 0, Offset = 0;
  Offset = 0;
  j = 0;
  i = 0;
	// Init local variables
	mode = 0;
	direction = 0;
	shift = 0;
	recordaddress = 0;
	startelement = 0;
	elements = 0;
	current_element = 0;
	transmitpos = 0;
	length = 0;
	indexsize = 0;
	StartElementInCache = FALSE;
	CacheElements = FALSE;

	switch (gBAP_Indication[2])
	{
	case Data_IND:
		//get data
		gFavoriteDestList_ASGID = (Indication_array[3] & 0xF0) / 16;
		gFavoriteDestList_TAID = Indication_array[3] & 0x0F;

		gFavoriteDestList_TotalNumListElements = Indication_array[4];

		/***ArrayHeader***/
		mode = (Indication_array[5] & 0xF0) / 0x10;
		recordaddress = Indication_array[5] & 0x0F;
		Offset = 6;

		// decode "mode-byte"
		shift = mode & 0x01;
		direction = (mode & 0x02) / 0x02;
		transmitpos = (mode & 0x04) / 0x04;
		indexsize = (mode & 0x08) / 0x08;

		// decode "mode-byte"
		shift = mode & 0x01;
		direction = (mode & 0x02) / 0x02;
		transmitpos = (mode & 0x04) / 0x04;
		indexsize = (mode & 0x08) / 0x08;

		if (indexsize)
		{
			startelement = Indication_array[Offset++];
			startelement += (Indication_array[Offset++] * 0x100);

			elements = Indication_array[Offset++];
			elements += (Indication_array[Offset++] * 0x100);
		}
		else
		{
			startelement = Indication_array[Offset++];
			elements = Indication_array[Offset++];
		}

		switch (recordaddress)
		{
		case 0: //recordaddress =0 -> complete record
			gFavoriteDestList_Pos = Indication_array[Offset++];
			gFavoriteDestList_DestType = Indication_array[Offset++];
			for(i = 0; i < NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH; i++)
			{
				gFavoriteDestList_Description[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_STREET_LENGTH; i++)
			{
				gFavoriteDestList_Street[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_JUNCTION_LENGTH; i++)
			{
				gFavoriteDestList_Junction[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_CITY_LENGTH; i++)
			{
				gFavoriteDestList_City[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_REGION_LENGTH; i++)
			{
				gFavoriteDestList_Region[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_POSCODE_LENGTH; i++)
			{
				gFavoriteDestList_PosCode[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_COUNTRY_LENGTH; i++)
			{
				gFavoriteDestList_Country[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_COOR_LENGTH; i++)
			{
				gFavoriteDestList_Coordinates[i] = Indication_array[Offset++];
			}
			
			gFavoriteDestList_PicRef = Indication_array[Offset++];
			gFavoriteDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
			
			break; //recordaddress =0 ends

		case 1: //recordaddress =1
			gFavoriteDestList_Pos = Indication_array[Offset++];
			gFavoriteDestList_DestType = Indication_array[Offset++];
			for(i = 0; i < NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH; i++)
			{
				gFavoriteDestList_Description[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_STREET_LENGTH; i++)
			{
				gFavoriteDestList_Street[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_JUNCTION_LENGTH; i++)
			{
				gFavoriteDestList_Junction[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_CITY_LENGTH; i++)
			{
				gFavoriteDestList_City[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_REGION_LENGTH; i++)
			{
				gFavoriteDestList_Region[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_POSCODE_LENGTH; i++)
			{
				gFavoriteDestList_PosCode[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_COUNTRY_LENGTH; i++)
			{
				gFavoriteDestList_Country[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_COOR_LENGTH; i++)
			{
				gFavoriteDestList_Coordinates[i] = Indication_array[Offset++];
			}
			
			gFavoriteDestList_PicRef = Indication_array[Offset++];
			gFavoriteDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
			break;
		case 2: //recordaddress =2 
			
			gFavoriteDestList_DestType = Indication_array[Offset++];
			for(i = 0; i < NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH; i++)
			{
				gFavoriteDestList_Description[i] = Indication_array[Offset++];
			}
			gFavoriteDestList_PicRef = Indication_array[Offset++];
			gFavoriteDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
			break; //recordaddress =2 ends
		case 3: //recordaddress =3
			gFavoriteDestList_DestType = Indication_array[Offset++];
			for(i = 0; i < NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH; i++)
			{
				gFavoriteDestList_Description[i] = Indication_array[Offset++];
			}
			break;
		case 4: //recordaddress =4
			for(i = 0; i < NAV_FAVORITEDESTLIST_STREET_LENGTH; i++)
			{
				gFavoriteDestList_Street[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_JUNCTION_LENGTH; i++)
			{
				gFavoriteDestList_Junction[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_CITY_LENGTH; i++)
			{
				gFavoriteDestList_City[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_REGION_LENGTH; i++)
			{
				gFavoriteDestList_Region[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_POSCODE_LENGTH; i++)
			{
				gFavoriteDestList_PosCode[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_COUNTRY_LENGTH; i++)
			{
				gFavoriteDestList_Country[i] = Indication_array[Offset++];
			}
			
			for(i = 0; i < NAV_FAVORITEDESTLIST_COOR_LENGTH; i++)
			{
				gFavoriteDestList_Coordinates[i] = Indication_array[Offset++];
			}
			break;
		case 5: //recordaddress =1
			gFavoriteDestList_PicRef = Indication_array[Offset++];
			gFavoriteDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
			break;
		case 15: 
			gFavoriteDestList_Pos = Indication_array[Offset++];
			break; //recordaddress =15 ends

		}
		gFavoriteDestList_recordaddress = recordaddress;
		gFavoriteDestList_transmitpos = transmitpos;

		break;

	case Changed_IND:
		/***ArrayHeader***/
		mode = (Indication_array[3] & 0xF0) / 0x10;
		recordaddress = Indication_array[3] & 0x0F;
		Offset = 4;

		// decode "mode-byte"
		shift = mode & 0x01;
		direction = (mode & 0x02) / 0x02;
		transmitpos = (mode & 0x04) / 0x04;
		indexsize = (mode & 0x08) / 0x08;

		if (indexsize) {
			startelement = Indication_array[Offset];
			Offset++;
			startelement += (Indication_array[Offset] * 0x100);
			Offset++;

			elements = Indication_array[Offset];
			Offset++;
			elements += (Indication_array[Offset] * 0x100);
			Offset++;
		} else {
			startelement = Indication_array[Offset];
			Offset++;

			elements = Indication_array[Offset];
			Offset++;
		}

		if (startelement == 0 && shift == 0 && transmitpos == 0 && recordaddress == 0 && elements == 255) //check 'full range update'?
		{
			putvalue(env_ASG_NaviSD_FDL_OnOff, FALSE);
			putvalue(env_ASG_NaviSD_FDL_ListOpState, "'full range update' received");

		} else if (datalength > 8) {
			if (startelement != 0) {
				for (i = 0; i < NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE; i++) {
					if (startelement == gFavoriteDestList_Pos)
					i = NAV_LASTDESTLIST_ASGCACHE_MAX_SIZE;
				}
			}

			
			switch (recordaddress)
			{
			case 0: //recordaddress =0 -> complete record
				gFavoriteDestList_Pos = Indication_array[Offset++];
				gFavoriteDestList_DestType = Indication_array[Offset++];
				for(i = 0; i < NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH; i++)
				{
					gFavoriteDestList_Description[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_STREET_LENGTH; i++)
				{
					gFavoriteDestList_Street[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_JUNCTION_LENGTH; i++)
				{
					gFavoriteDestList_Junction[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_CITY_LENGTH; i++)
				{
					gFavoriteDestList_City[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_REGION_LENGTH; i++)
				{
					gFavoriteDestList_Region[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_POSCODE_LENGTH; i++)
				{
					gFavoriteDestList_PosCode[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_COUNTRY_LENGTH; i++)
				{
					gFavoriteDestList_Country[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_COOR_LENGTH; i++)
				{
					gFavoriteDestList_Coordinates[i] = Indication_array[Offset++];
				}
				
				gFavoriteDestList_PicRef = Indication_array[Offset++];
				gFavoriteDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
				
				break; //recordaddress =0 ends

			case 1: //recordaddress =1
				gFavoriteDestList_Pos = Indication_array[Offset++];
				gFavoriteDestList_DestType = Indication_array[Offset++];
				for(i = 0; i < NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH; i++)
				{
					gFavoriteDestList_Description[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_STREET_LENGTH; i++)
				{
					gFavoriteDestList_Street[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_JUNCTION_LENGTH; i++)
				{
					gFavoriteDestList_Junction[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_CITY_LENGTH; i++)
				{
					gFavoriteDestList_City[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_REGION_LENGTH; i++)
				{
					gFavoriteDestList_Region[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_POSCODE_LENGTH; i++)
				{
					gFavoriteDestList_PosCode[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_COUNTRY_LENGTH; i++)
				{
					gFavoriteDestList_Country[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_COOR_LENGTH; i++)
				{
					gFavoriteDestList_Coordinates[i] = Indication_array[Offset++];
				}
				
				gFavoriteDestList_PicRef = Indication_array[Offset++];
				gFavoriteDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
				break;
			case 2: //recordaddress =2 
				
				gFavoriteDestList_DestType = Indication_array[Offset++];
				for(i = 0; i < NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH; i++)
				{
					gFavoriteDestList_Description[i] = Indication_array[Offset++];
				}
				gFavoriteDestList_PicRef = Indication_array[Offset++];
				gFavoriteDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
				break; //recordaddress =2 ends
			case 3: //recordaddress =3
				gFavoriteDestList_DestType = Indication_array[Offset++];
				for(i = 0; i < NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH; i++)
				{
					gFavoriteDestList_Description[i] = Indication_array[Offset++];
				}
				break;
			case 4: //recordaddress =4
				for(i = 0; i < NAV_FAVORITEDESTLIST_STREET_LENGTH; i++)
				{
					gFavoriteDestList_Street[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_JUNCTION_LENGTH; i++)
				{
					gFavoriteDestList_Junction[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_CITY_LENGTH; i++)
				{
					gFavoriteDestList_City[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_REGION_LENGTH; i++)
				{
					gFavoriteDestList_Region[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_POSCODE_LENGTH; i++)
				{
					gFavoriteDestList_PosCode[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_COUNTRY_LENGTH; i++)
				{
					gFavoriteDestList_Country[i] = Indication_array[Offset++];
				}
				
				for(i = 0; i < NAV_FAVORITEDESTLIST_COOR_LENGTH; i++)
				{
					gFavoriteDestList_Coordinates[i] = Indication_array[Offset++];
				}
				break;
			case 5: //recordaddress =1
				gFavoriteDestList_PicRef = Indication_array[Offset++];
				gFavoriteDestList_PicRef += (Indication_array[Offset++] & 0xF0 ) / 16;
				break;
			case 15: 
				gFavoriteDestList_Pos = Indication_array[Offset++];
				break; //recordaddress =15 ends
			}
		case Error_IND:
			if (Indication_array[3] < 0x20 && Indication_array[3] != 0) //BCL-error
			  writelineEx(gError_Trace, 0, "ASG-NaviSD FavoriteDestList_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL[Indication_array[3] - 0x10]);
			else if (Indication_array[3] < 0x30 && Indication_array[3] != 0) //BPL-error
			  writelineEx(gError_Trace, 0, "ASG-NaviSD FavoriteDestList_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL[Indication_array[3] - 0x20]);
			else if (Indication_array[3] < 0x40 && Indication_array[3] != 0) //BAL-error
			  writelineEx(gError_Trace, 0, "ASG-NaviSD FavoriteDestList_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL[Indication_array[3] - 0x30]);
			else
			  writelineEx(gError_Trace, 0, "ASG-NaviSD FavoriteDestList_Indication: Application-Error: 0x%x", Indication_array[3]);
			break;
		default:
			writelineEx(gError_Trace, 0, "ASG-NaviSD FavoriteDestList_Indication: unknown indication %x", gBAP_Indication[2]);
			break;
		}
	}
	//Panel
	putvalue(env_ASG_NaviSD_FDL_ASGID, gFavoriteDestList_ASGID);
	putvalue(env_ASG_NaviSD_FDL_TAID, gFavoriteDestList_TAID);
	putvalue(env_ASG_NaviSD_FDL_TotalNumLE, gFavoriteDestList_TotalNumListElements);
	putvalue(env_ASG_NaviSD_FDL_AH_shift, shift);
	putvalue(env_ASG_NaviSD_FDL_AH_dir, direction);
	putvalue(env_ASG_NaviSD_FDL_AH_PosTrans, transmitpos);
	putvalue(env_ASG_NaviSD_FDL_AH_IS, indexsize);
	putvalue(env_ASG_NaviSD_FDL_AH_RA, recordaddress);
	putvalue(env_ASG_NaviSD_FDL_AH_start, startelement);
	putvalue(env_ASG_NaviSD_FDL_AH_elements, elements);
}

void FavoriteDestList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];
	byte Offset;
	word indexsize;

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	  requestarray [i]=0;
	
	// decode "mode-byte"
	indexsize   =(mode &0x08)/0x08; 

	// Handle request.
	requestarray[0] =LSG_NaviSD;	            //LSG-ID
	requestarray[1] =FctID_FavoriteDest_List;	    //Fct.-ID
	requestarray[2] =request;                   //request type

	switch(request)
	{
	case DataGet_REQ:              
		requestarray[3] =((gFavoriteDestList_ASGID *0x10) &0xF0) +(gFavoriteDestList_TAID &0x0F);
		
		/***ArrayHeader***/
		requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
		Offset =5;

		if(indexsize)
		{
			requestarray[Offset] =requested_startelement &0x00FF;
			Offset++;
			requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
			Offset++;  

			requestarray[Offset] =elements &0x00FF;
			Offset++;
			requestarray[Offset] =(elements &0xFF00) /0x100;
			Offset++;       
		}
		else
		{
			requestarray[Offset] =requested_startelement;
			Offset++;

			requestarray[Offset] =elements;
			Offset++;
		}
		
		set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
		break;

	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD FavoriteDestList_Request: invalid request %d", request);
		break;
	}
}

void ListSetup_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2]) // indication
	{
  	case Data_IND:
  		//get data
  		gNav_ListSetup_PreferredDest_List = Indication_array[3];
  		gNav_ListSetup_Ext1   = Indication_array[4];
  		gNav_ListSetup_Ext2   = Indication_array[5];
  		gNav_ListSetup_Ext3   = Indication_array[6];
  		gNav_ListSetup_Ext4   = Indication_array[7];
      
      putValue(env_ASG_NaviSD_LS_PreffList,gNav_ListSetup_PreferredDest_List);
      putValue(env_ASG_NaviSD_LS_PrefList_s, gNav_ListSetup_PreferredDest_List_s[gNav_ListSetup_PreferredDest_List]);
  		break;
  	case Error_IND:
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)	            //BCL-error
  		  writelineEx(gError_Trace, 0, "ASG-NaviSD ListSetup_Indication: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
  		  writelineEx(gError_Trace, 0, "ASG-NaviSD ListSetup_Indication: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
  		  writelineEx(gError_Trace, 0, "ASG-NaviSD ListSetup_Indication: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  		  writelineEx(gError_Trace, 0, "ASG-NaviSD ListSetup_Indication: Application-Error: 0x%x", Indication_array[3]);
  		break;
  	default:
  		writelineEx(gError_Trace, 0, "ASG-NaviSD ListSetup_Indication: invalid indication %d", gBAP_Indication[2]);
  		break;
	}
}

void ListSetup_Request(byte request)
{
	int i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init lokal variables
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	  requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	        //LSG-ID
	requestarray[1] =FctID_ListSetup;  //Fct.-ID
	requestarray[2] =request;

	switch(request)
	{
  	case DataGet_REQ: 			
  		requestarray[3] = gNav_ListSetup_PreferredDest_List;
  		requestarray[4] = gNav_ListSetup_Ext1;
  		requestarray[5] = gNav_ListSetup_Ext2;
  		requestarray[6] = gNav_ListSetup_Ext3;
  		requestarray[7] = gNav_ListSetup_Ext4;
  		
      putValue(env_ASG_NaviSD_LS_PreffList, gNav_ListSetup_PreferredDest_List);
      if(gNav_ListSetup_PreferredDest_List < 4)
      {
        putValue(env_ASG_NaviSD_LS_PrefList_s, gNav_ListSetup_PreferredDest_List_s[gNav_ListSetup_PreferredDest_List]);
      }
      else
      {
        putValue(env_ASG_NaviSD_LS_PrefList_s, "reserved");
      }
  		set_status_requestbuffer (requestarray, 8, Bap_ByteSequence);
  		break;
  	default://error
  		writelineEx(gError_Trace, 0,"ASG-NaviSD ListSetup_Request: invalid request %d", request);
  		break;
	}
}

void MapScale_Indication(dword Indication_array [], int datalength)
{   
	int i =0, Offset =0, length =0, reservedTemp;

	switch (gBAP_Indication[2])
	{
  	case Data_IND:
  		//get data
  		reservedTemp                    = Indication_array[3];
  		gASG_MapScale_AutoZoom          = (Indication_array[4] & 0xF0) / 16;
  		gASG_MapScale_Extention1        = Indication_array[4] & 0x0F;
  		gASG_MapScale_Scale             = Indication_array[5] & 0xFF;
  		gASG_MapScale_Scale             += (Indication_array[6] << 8);
  		gASG_MapScale_Unit              = Indication_array[7];
  		gASG_MapScale_SupportedAutoZoom = Indication_array[8];
  		gASG_MapScale_Extention2        = Indication_array[9];
      
      //panel
      putValue(env_ASG_NaviSD_MS_AutoZoom_h, gASG_MapScale_AutoZoom);
      putValue(env_ASG_NaviSD_MS_Scale , gASG_MapScale_Scale);
      putValue(env_ASG_NaviSD_MS_Unit , gASG_MapScale_Unit);
      putValue(env_ASG_NaviSD_MS_SupportedAutoZ , gASG_MapScale_SupportedAutoZoom);
      
  		break;			
  	case Error_IND:
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
  		  writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_MapScale: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
  		  writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_MapScale: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
  		  writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_MapScale: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  		  writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_MapScale: Application-Error: 0x%x", Indication_array[3]);
  		break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-NaviSD Indication_MapScale: unknown indication %x", gBAP_Indication[2]);
  		break;
	}
}

void MapScale_Request(byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	        //LSG-ID
	requestarray[1] =FctID_MapScale;	//Fct.-ID
	requestarray[2] =request;               //request type
	
	switch(request)
	{
  	case DataGet_REQ:
  		set_status_requestbuffer (requestarray, 3, Bap_Void);
  		break;
  	case DataSetGet_REQ:
  		requestarray[3] = gASG_MapScale_Steps;
  		requestarray[4] = gASG_MapScale_AutoZoom << 4;
  		requestarray[4]+= gASG_MapScale_Extention1 & 00000001;
  		requestarray[5] = 0; // Reserve2
  		requestarray[6] = 0; // Reserve2
  		requestarray[7] = 0; // Reserve3
  		requestarray[8] = 0; // Reserve4
  		requestarray[9] = 0; // Extention2

  		set_status_requestbuffer (requestarray, 10, Bap_ByteSequence);
  		break;
  	default:	
  		writelineEx(gError_Trace, 0, "ASG-NaviSD Request_MapScale: invalid request %d", request);
  		break;
	}
}
void FSG_Setup_Indication(dword Indication_array [], int datalength)
{   
	int i =0, Offset =0, length =0;
	byte byTemp;

	switch (gBAP_Indication[2])
	{
  	case Data_IND:
  		//get data
  		gFSG_Setup_FunctionSupport      = Indication_array[3];
  		gFSG_Setup_FunctionProtection   = Indication_array[4];
  		gFSG_Setup_WebAppState          = (Indication_array[5] & 0xF0 ) / 16 ;
  		gFSG_Setup_Ext1                 = Indication_array[5] & 0x0F;
  		gFSG_Setup_Ext2                 = Indication_array[6];
  		gFSG_Setup_Ext3                 = Indication_array[7];
  		gFSG_Setup_Ext4                 = Indication_array[8];
      
      putValue(env_ASG_NaviSD_Setup_FuncSup, gFSG_Setup_FunctionSupport);
      putValue(env_ASG_NaviSD_Setup_FuncSup_B0,  (gFSG_Setup_FunctionSupport&0x01));
      putValue(env_ASG_NaviSD_Setup_FuncSup_B1, ((gFSG_Setup_FunctionSupport&0x02)/0x02));
      putValue(env_ASG_NaviSD_Setup_FuncSup_B2, ((gFSG_Setup_FunctionSupport&0x04)/0x04));
      putValue(env_ASG_NaviSD_Setup_FuncSup_B3, ((gFSG_Setup_FunctionSupport&0x08)/0x08));
      putValue(env_ASG_NaviSD_Setup_FuncProtec, gFSG_Setup_FunctionProtection);
      putValue(env_ASG_NaviSD_Setup_WebApp, gFSG_Setup_WebAppState);
  		break;			
  	case Error_IND:	
  		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_FSG_Setup: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
  		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_FSG_Setup: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
  		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
  		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_FSG_Setup: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
  		else
  		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_FSG_Setup: Application-Error: 0x%x", Indication_array[3]);
  		break;
  	default:
  		writelineEx(gError_Trace, 0,"ASG-NaviSD Indication_FSG_Setup: unknown indication %x", gBAP_Indication[2]);
  		break;
	}
}

void FSG_Setup_Request(byte request)
{
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	// Handle request.
	requestarray[0] =LSG_NaviSD;	        //LSG-ID
	requestarray[1] =FctID_FSG_Setup;	    //Fct.-ID
	requestarray[2] =request;               //request type
	
	switch(request)
	{
	case DataGet_REQ:		
		set_status_requestbuffer(requestarray, 3, Bap_Void);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD Request_FSG_Setup: invalid request %d", request);
		break;
	}
}

void RequestSync_Video_Indication(dword Indication_array [], int datalength)
{
	switch (gBAP_Indication[2])
	{
	case Processing_IND:
		gReqSyncVideo_AsgId = (Indication_array[3]&0xF0) >>4;
		gReqSyncVideo_Extension1 = Indication_array[3]&0x0F;
		gReqSyncVideo_Reserve1 = Indication_array[4];
		
		putvalue(env_ASG_NaviSD_RSV_AsgId,((Indication_array[3]&0xF0)>>4)); //ASG_ID
		putvalue(env_ASG_NaviSD_RSV_Extension1,(Indication_array[3]&0x0F)); //Extension1
		break;
	case Result_IND:
		gReqSyncVideo_AsgId = (Indication_array[3]&0xF0) >>4;
		gReqSyncVideo_Extension1 = Indication_array[3]&0x0F;
		gReqSyncVideo_Result = Indication_array[4];
		
		putvalue(env_ASG_NaviSD_RSV_AsgId,((Indication_array[3]&0xF0)>>4)); //ASG_ID
		putvalue(env_ASG_NaviSD_RSV_Extension1,(Indication_array[3]&0x0F)); //Extension1
		putvalue(env_ASG_NaviSD_RSV_Result,Indication_array[4]);            //Unit
		break;
	case Error_IND:
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		{
			writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_RequestSync_Video: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		}
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		{
			writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_RequestSync_Video: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		}
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		{
			writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_RequestSync_Video: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		}
		else
		{	
			writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_RequestSync_Video: Application-Error: 0x%x", Indication_array[3]);
			//putvalue(env_ASG_NaviSD_RGActDeact_Err,Indication_array[3]);        
			if (Indication_array[3] ==0)
			{
				//putvalue(env_ASG_NaviSD_RGActDeact_Err_s,"no error");        
			}
			else if((Indication_array[3]-0x40)<17)
			{
				//putvalue(env_ASG_NaviSD_RGActDeact_Err_s,gerror_codes_0x40_0x7F[Indication_array[3]-0x40]);
			}
			else
			{
				//putvalue(env_ASG_NaviSD_RGActDeact_Err_s,gstring_reserved);
			}
		}
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD Indication_RequestSync_Video:: unknown indication %d", gBAP_Indication[2]);
		break;
	}
}

void RequestSync_Video_Request(byte request)
{
	int i;
	dword requestarray [BAP_BUFFER_SIZE];
	byte byTemp;

	// Init lokal variables
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	{
		requestarray [i]=0;
	}

	// Handle request.
	requestarray[0] =LSG_NaviSD;	    //LSG-ID
	requestarray[1] =FctID_RequestSync_Video; //Fct.-ID
	requestarray[2] =request;

	switch(request)
	{
	case StartResult_REQ: 	
		byTemp = 0;
		byTemp = getvalue(env_ASG_NaviSD_RSV_AsgId)*0x10;	
		byTemp += getvalue(env_ASG_NaviSD_RSV_Extension1);	
		requestarray[3] = byTemp;
		requestarray[4] = getvalue(env_ASG_NaviSD_RSV_VideoStreamId);	
		requestarray[5] = getvalue(env_ASG_NaviSD_RSV_Extension2);	
		set_status_requestbuffer (requestarray, 6, Bap_ByteSequence);
		break;                         
	case AbortResult_REQ:
		set_status_requestbuffer (requestarray, 3, Bap_Void);
		break;
	default://error
		writelineEx(gError_Trace, 0,"ASG-NaviSD RequestSync_Video_Request: unknown request %d", request);
		break;
	}
}

void VideoStreams_Indication(dword Indication_array [], int datalength)
{
	byte mode, direction, shift, recordaddress, transmitpos, length, indexsize, CacheElements;
	word startelement, elements, current_element;
	int i =0, j=0, Offset =0;

	// Init local variables
	mode                    =0;
	direction               =0;
	shift                   =0;
	recordaddress           =0;
	startelement            =0;
	elements                =0;
	current_element         =0;
	transmitpos             =0;
	length                  =0;
	CacheElements =FALSE;

	switch (gBAP_Indication[2])
	{
	case Data_IND:
		//get data
		gVideoStreams_ASGID =(Indication_array[3] &0xF0) /0x10;
		gVideoStreams_TAID  =Indication_array[3] &0x0F; 
		gVideoStreams_TotalNumListElements =Indication_array[4];
		/***ArrayHeader***/
		mode            =(Indication_array[5] &0xF0) /0x10;
		recordaddress   =Indication_array[5] &0x0F;
		startelement    =Indication_array[6];
		elements        =Indication_array[7];
		Offset =8;
		// decode "mode-byte"
		shift       =mode &0x01;
		direction   =(mode &0x02)/0x02;
		transmitpos =(mode &0x04)/0x04;
		indexsize   =(mode &0x08)/0x08;             

		if(startelement !=0)
		{
			for (i=0;i<NAV_VIDEOSTREAMS_ENTRIES;i++)
			{
				if(startelement ==gVideoStreams_Pos[i])  
				i =NAV_VIDEOSTREAMS_ENTRIES;              
			}
		}
		switch (recordaddress)
		{ 
		case 1: //recordaddress =1 -> StreamType, IPV6_Address, UDP_Port, URI
			if(0==startelement)
			{
				if(FORWARD==direction)  //forward-start
				{          
					current_element =startelement;             
					if (shift ==TRUE) //startelement is next element
					current_element++;                 

					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//StreamType
						if (CacheElements ==TRUE)
						gVideoStreams_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//UDP_Port
						if (CacheElements ==TRUE)
						gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
						Offset++;
						//URI
						for(i=0; i<NAV_VIDEOSTREAMS_URI_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_Uri[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Uri[current_element][i] =Indication_array[Offset];
							Offset++;
						}       
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
						current_element++; //go on with next element  
					}   //copy data of current element finished
				}       //forward ends
				if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
				{
					current_element =NAV_VIDEOSTREAMS_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							} 
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//StreamType
						if (CacheElements ==TRUE)
						gVideoStreams_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//UDP_Port
						if (CacheElements ==TRUE)
						gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
						Offset++;
						//URI
						for(i=0; i<NAV_VIDEOSTREAMS_URI_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_Uri[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Uri[current_element][i] =Indication_array[Offset];
							Offset++;
						}    
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
						current_element--;
					}   //copy data of current element finished                     
				}       //backward ends
			}          //startelement=0 ends
			else if (startelement !=0) //startelement !=0
			{
				if(FORWARD==direction)  //forward-start
				{
					current_element =startelement; 
					if (shift ==TRUE) //startelement is next element
					current_element++;
					
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//StreamType
						if (CacheElements ==TRUE)
						gVideoStreams_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//UDP_Port
						if (CacheElements ==TRUE)
						gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
						Offset++;
						//URI
						for(i=0; i<NAV_VIDEOSTREAMS_URI_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_Uri[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Uri[current_element][i] =Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
						current_element++; //go on with next element    
					}   //copy data of current element finished
				}       //forward ends
				else if(BACKWARD==direction)
				{
					current_element =startelement; 
					if (shift ==TRUE) //startelement is previous element
					current_element--;         
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//StreamType
						if (CacheElements ==TRUE)
						gVideoStreams_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//UDP_Port
						if (CacheElements ==TRUE)
						gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
						Offset++;
						//URI
						for(i=0; i<NAV_VIDEOSTREAMS_URI_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_Uri[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Uri[current_element][i] =Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
						current_element--;
					}   //copy data of current element finished                                 
				}
			}          //startelement !=0 ends
			break;         //recordaddress =1 ends
		case 2: //recordaddress =2 -> StreamType, IPV6_Address, UDP_Port
			if(0==startelement)
			{
				if(FORWARD==direction)  //forward-start
				{          
					current_element =startelement;
					if (shift ==TRUE) //startelement is next element
					current_element++;                 
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//StreamType
						if (CacheElements ==TRUE)
						gVideoStreams_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//UDP_Port
						if (CacheElements ==TRUE)
						gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
						Offset++;
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE; 
						current_element++; //go on with next element       
					}   //copy data of current element finished
				}       //forward ends
				if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
				{
					current_element =NAV_VIDEOSTREAMS_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!                  
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//StreamType
						if (CacheElements ==TRUE)
						gVideoStreams_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//UDP_Port
						if (CacheElements ==TRUE)
						gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
						Offset++;
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
						current_element--;
					}   //copy data of current element finished                     
				}       //backward ends
			}          //startelement=0 ends
			else if (startelement !=0) //startelement !=0
			{
				if(FORWARD==direction)  //forward-start
				{
					current_element =startelement;
					if (shift ==TRUE) //startelement is next element
					current_element++;         
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//StreamType
						if (CacheElements ==TRUE)
						gVideoStreams_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//UDP_Port
						if (CacheElements ==TRUE)
						gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
						Offset++;
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
						current_element++; //go on with next element       
					}   //copy data of current element finished
				}       //forward ends
				else if(BACKWARD==direction)
				{
					current_element =startelement; 
					if (shift ==TRUE) //startelement is previous element
					current_element--;  
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//StreamType
						if (CacheElements ==TRUE)
						gVideoStreams_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//UDP_Port
						if (CacheElements ==TRUE)
						gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
						Offset++;                
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
						current_element--;
					}   //copy data of current element finished                                 
				}
			}          //startelement !=0 ends
			break;         //recordaddress =2 ends   
		case 15: //recordaddress =15 -> POS 
			if(0==startelement)
			{
				if(FORWARD==direction)  //forward-start
				{          
					current_element =startelement;
					if (shift ==TRUE) //startelement is next element
					current_element++;                 
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
						current_element++; //go on with next element       
					}   //copy data of current element finished
				}       //forward ends
				if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
				{
					current_element =NAV_VIDEOSTREAMS_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
						current_element--;
					}   //copy data of current element finished                     
				}       //backward ends
			}          //startelement=0 ends
			else if (startelement !=0) //startelement !=0
			{
				if(FORWARD==direction)  //forward-start
				{
					current_element =startelement;
					if (shift ==TRUE) //startelement is next element
					current_element++;
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
						current_element++; //go on with next element       
					}   //copy data of current element finished
				}       //forward ends
				else if(BACKWARD==direction)
				{
					current_element =startelement; 
					if (shift ==TRUE) //startelement is previous element
					current_element--;
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gVideoStreams_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
						current_element--;
					}   //copy data of current element finished                                 
				}
			}          //startelement !=0 ends
			break;         //recordaddress =15 ends    
		}                             
		//Panel
		
		/*
	if (gVideoStreams_CallBackReason !=NAV_VIDEOSTREAMS_CALLBACKREASON_NOCALLBACK)
		VideoStreams_ListHandling ();
	else
		VideoStreams_display(recordaddress, transmitpos);         
	*/
		break;
	case Changed_IND:
		//get data
		/***ArrayHeader***/
		mode            =(Indication_array[3] &0xF0) /0x10;
		recordaddress   =Indication_array[3] &0x0F;
		Offset =4;
		// decode "mode-byte"
		shift       =mode &0x01;
		direction   =(mode &0x02)/0x02;
		transmitpos =(mode &0x04)/0x04;
		indexsize   =(mode &0x08)/0x08;               
		if (indexsize)
		{   
			startelement =Indication_array[Offset];
			Offset++;
			startelement +=(Indication_array[Offset] *0x100);
			Offset++;
			elements =Indication_array[Offset];
			Offset++;
			elements +=(Indication_array[Offset] *0x100);
			Offset++;
		}
		else
		{   
			startelement =Indication_array[Offset];
			Offset++;
			elements =Indication_array[Offset];
			Offset++;
		}           
		if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==255) //check 'full range update'?
		{
			/*
		putvalue(env_ASG_NaviSD_LG_OnOff, FALSE);
		putvalue(env_ASG_NaviSD_LG_ListOpState, "'full range update' received");
		*/
		}
		else if (datalength>9)
		{
			if(startelement !=0)
			{
				for (i=0;i<NAV_VIDEOSTREAMS_ENTRIES;i++)
				{
					if(startelement ==gVideoStreams_Pos[i])  
					i =NAV_VIDEOSTREAMS_ENTRIES;              
				}
			}
			switch (recordaddress)
			{  
			case 1: //recordaddress =1 -> StreamType, IPV6_Address, UDP_Port, URI
				if(0==startelement)
				{
					if(FORWARD==direction)  //forward-start
					{          
						current_element =startelement;
						if (shift ==TRUE) //startelement is next element
						current_element++;                 
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//StreamType
							if (CacheElements ==TRUE)
							gVideoStreams_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//UDP_Port
							if (CacheElements ==TRUE)
							gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
							Offset++;
							//URI
							for(i=0; i<NAV_VIDEOSTREAMS_URI_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_Uri[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Uri[current_element][i] =Indication_array[Offset];
								Offset++;
							}       
							//next element                  
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element++; //go on with next element       
						}   //copy data of current element finished
					}       //forward ends
					if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
					{
						current_element =NAV_VIDEOSTREAMS_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//StreamType
							if (CacheElements ==TRUE)
							gVideoStreams_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//UDP_Port
							if (CacheElements ==TRUE)
							gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
							Offset++;
							//URI
							for(i=0; i<NAV_VIDEOSTREAMS_URI_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_Uri[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Uri[current_element][i] =Indication_array[Offset];
								Offset++;
							}       
							//next element
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element--;
						}   //copy data of current element finished                     
					}       //backward ends
				}          //startelement=0 ends
				else if (startelement !=0) //startelement !=0
				{
					if(FORWARD==direction)  //forward-start
					{
						current_element =startelement;
						if (shift ==TRUE) //startelement is next element
						current_element++;  
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//StreamType
							if (CacheElements ==TRUE)
							gVideoStreams_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//UDP_Port
							if (CacheElements ==TRUE)
							gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
							Offset++;
							//URI
							for(i=0; i<NAV_VIDEOSTREAMS_URI_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_Uri[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Uri[current_element][i] =Indication_array[Offset];
								Offset++;
							}       
							//next element                  
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element++; //go on with next element       
						}   //copy data of current element finished
					}       //forward ends
					else if(BACKWARD==direction)
					{
						current_element =startelement; 

						if (shift ==TRUE) //startelement is previous element
						current_element--;
						
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//StreamType
							if (CacheElements ==TRUE)
							gVideoStreams_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//UDP_Port
							if (CacheElements ==TRUE)
							gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
							Offset++;
							//URI
							for(i=0; i<NAV_VIDEOSTREAMS_URI_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_Uri[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Uri[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//next element
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element--;
						}   //copy data of current element finished                                 
					}
				}          //startelement !=0 ends
				break;         //recordaddress =1 ends
			case 2: //recordaddress =2 -> StreamType, IPV6_Address, UDP_Port
				if(0==startelement)
				{
					if(FORWARD==direction)  //forward-start
					{          
						current_element =startelement;
						if (shift ==TRUE) //startelement is next element
						current_element++;                 
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//StreamType
							if (CacheElements ==TRUE)
							gVideoStreams_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//UDP_Port
							if (CacheElements ==TRUE)
							gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
							Offset++;     
							//next element                  
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element++; //go on with next element       
						}   //copy data of current element finished
					}       //forward ends
					if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
					{
						current_element =NAV_VIDEOSTREAMS_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//StreamType
							if (CacheElements ==TRUE)
							gVideoStreams_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//UDP_Port
							if (CacheElements ==TRUE)
							gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
							Offset++;
							//next element
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element--;
						}   //copy data of current element finished                     
					}       //backward ends
				}          //startelement=0 ends
				else if (startelement !=0) //startelement !=0
				{
					if(FORWARD==direction)  //forward-start
					{
						current_element =startelement;
						if (shift ==TRUE) //startelement is next element
						current_element++;  
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//StreamType
							if (CacheElements ==TRUE)
							gVideoStreams_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//UDP_Port
							if (CacheElements ==TRUE)
							gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
							Offset++;
							//next element                  
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element++; //go on with next element       
						}   //copy data of current element finished
					}       //forward ends
					else if(BACKWARD==direction)
					{
						current_element =startelement; 

						if (shift ==TRUE) //startelement is previous element
						current_element--;
						
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//StreamType
							if (CacheElements ==TRUE)
							gVideoStreams_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_VIDEOSTREAMS_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//UDP_Port
							if (CacheElements ==TRUE)
							gVideoStreams_UdpPort[current_element] =Indication_array[Offset];
							Offset++;
							//next element
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element--;
						}   //copy data of current element finished                                 
					}
				}          //startelement !=0 ends   
				break;         //recordaddress =2 ends
			case 15: //recordaddress =15 -> Pos
				if(0==startelement)
				{
					if(FORWARD==direction)  //forward-start
					{          
						current_element =startelement;
						if (shift ==TRUE) //startelement is next element
						current_element++;                 
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//next element                  
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element++; //go on with next element       
						}   //copy data of current element finished
					}       //forward ends
					if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
					{
						current_element =NAV_VIDEOSTREAMS_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//next element
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element--;
						}   //copy data of current element finished                     
					}       //backward ends
				}          //startelement=0 ends
				else if (startelement !=0) //startelement !=0
				{
					if(FORWARD==direction)  //forward-start
					{
						current_element =startelement;
						if (shift ==TRUE) //startelement is next element
						current_element++;  
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//next element                  
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element++; //go on with next element       
						}   //copy data of current element finished
					}       //forward ends
					else if(BACKWARD==direction)
					{
						current_element =startelement; 

						if (shift ==TRUE) //startelement is previous element
						current_element--;
						
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_VIDEOSTREAMS_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gVideoStreams_Pos[i] && gVideoStreams_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								
								//if not already cached, then store element only, if Cache is build-up!
								else if((gVideoStreams_ListHandlingType !=NAV_VIDEOSTREAMS_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gVideoStreams_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//next element
							if (CacheElements ==TRUE)
							gVideoStreams_ListEntryReceptionInformation [current_element] =TRUE;
							current_element--;
						}   //copy data of current element finished                                 
					}
				}          //startelement !=0 ends   
				break;         //recordaddress =2 ends
			}
		}
		break;            
	case Error_IND:	
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_VideoStreams: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_VideoStreams: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_VideoStreams: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_VideoStreams: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD Indication_VideoStreams: unknown indication %x", gBAP_Indication[2]);
		break;
	}
  
	putvalue(env_ASG_NaviSD_VS_AsgId, gVideoStreams_ASGID);
	putvalue(env_ASG_NaviSD_VS_TAID, gVideoStreams_TAID);
	putvalue(env_ASG_NaviSD_VS_TNLE, gVideoStreams_TotalNumListElements);
	putvalue(env_ASG_NaviSD_VS_AH_Shift, shift);
	putvalue(env_ASG_NaviSD_VS_AH_Dir, direction);
	putvalue(env_ASG_NaviSD_VS_AH_TransPos, transmitpos);
	putvalue(env_ASG_NaviSD_VS_AH_IndexSize, indexsize);
	putvalue(env_ASG_NaviSD_VS_AH_RecAddress, recordaddress);
	putvalue(env_ASG_NaviSD_VS_AH_Start, startelement);
	putvalue(env_ASG_NaviSD_VS_AH_Elements, elements);
}

void VideoStreams_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];
	byte Offset;
	word indexsize;

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	indexsize   =0;
	Offset      =0;

	// decode "mode-byte"
	indexsize   =(mode &0x08)/0x08; 

	// Handle request.
	requestarray[0] =LSG_NaviSD;	    //LSG-ID
	requestarray[1] =FctID_VideoStreams;	//Fct.-ID
	requestarray[2] =request;           //request type

	switch(request)
	{
	case DataGet_REQ:              
		requestarray[3] =((gVideoStreams_ASGID *0x10) &0xF0) +(gVideoStreams_TAID &0x0F);      
		/***ArrayHeader***/
		requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
		Offset =5;
		if(indexsize)
		{
			requestarray[Offset] =requested_startelement &0x00FF;
			Offset++;
			requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
			Offset++;  
			requestarray[Offset] =elements &0x00FF;
			Offset++;
			requestarray[Offset] =(elements &0xFF00) /0x100;
			Offset++;       
			//writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_16bit %x",indexsize); //debug
		}
		else
		{
			requestarray[Offset] =requested_startelement;
			Offset++;
			requestarray[Offset] =elements;
			Offset++;
			//writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_8bit %x",indexsize); //debug
		}
		set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD Request_VideoStreams: invalid request %d", request);
		break;
	}
}

void Picture_Indication(dword Indication_array [], int datalength)
{
	byte mode, direction, shift, recordaddress, transmitpos, length, indexsize, CacheElements;
	word startelement, elements, current_element;
	int i =0, j=0, Offset =0;

	// Init local variables
	mode                    =0;
	direction               =0;
	shift                   =0;
	recordaddress           =0;
	startelement            =0;
	elements                =0;
	current_element         =0;
	transmitpos             =0;
	length                  =0;
	CacheElements =FALSE;

	write("Debug: Indication_Picture -> ind-type=%d",gBAP_Indication[2]);

	switch (gBAP_Indication[2])
	{
	case Data_IND:
		//get data
		gPicture_ASGID =(Indication_array[3] &0xF0) /0x10;
		gPicture_TAID  =Indication_array[3] &0x0F; 
		gPicture_TotalNumListElements =Indication_array[4];
		/***ArrayHeader***/
		mode            =(Indication_array[5] &0xF0) /0x10;
		recordaddress   =Indication_array[5] &0x0F;
		startelement    =Indication_array[6];
		elements        =Indication_array[7];
		Offset =8;
		// decode "mode-byte"
		shift       =mode &0x01;
		direction   =(mode &0x02)/0x02;
		transmitpos =(mode &0x04)/0x04;
		indexsize   =(mode &0x08)/0x08;             

		if(startelement !=0)
		{
			for (i=0;i<NAV_PICTURE_ENTRIES;i++)
			{
				if(startelement ==gPicture_Pos[i])  
				i =NAV_PICTURE_ENTRIES;              
			}
		}
		switch (recordaddress)
		{ 
		case 1: //recordaddress =1 -> StreamType, IPV6_Address, TCP_Port, URI
			if(0==startelement)
			{
				if(FORWARD==direction)  //forward-start
				{          
					current_element =startelement;             
					if (shift ==TRUE) //startelement is next element
					current_element++;                 

					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_PICTURE_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gPicture_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//PictureType
						if (CacheElements ==TRUE)
						gPicture_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_PICTURE_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gPicture_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gPicture_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//TCP_Port
						if (CacheElements ==TRUE)
						gPicture_TcpPort[current_element] =Indication_array[Offset];
						Offset++;
						//URI
						for(i=0; i<NAV_PICTURE_URI_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gPicture_Uri[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gPicture_Uri[current_element][i] =Indication_array[Offset];
							Offset++;
						}       
						//next element
						if (CacheElements ==TRUE)
						gPicture_ListEntryReceptionInformation [current_element] =TRUE;
						current_element++; //go on with next element  
					}   //copy data of current element finished
				}       //forward ends
				if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
				{
					current_element =NAV_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_PICTURE_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							} 
							//if not already cached, then store element only, if Cache is build-up!
							else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gPicture_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//PictureType
						if (CacheElements ==TRUE)
						gPicture_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_PICTURE_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gPicture_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gPicture_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//TCP_Port
						if (CacheElements ==TRUE)
						gPicture_TcpPort[current_element] =Indication_array[Offset];
						Offset++;
						//URI
						for(i=0; i<NAV_PICTURE_URI_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gPicture_Uri[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gPicture_Uri[current_element][i] =Indication_array[Offset];
							Offset++;
						}    
						//next element
						if (CacheElements ==TRUE)
						gPicture_ListEntryReceptionInformation [current_element] =TRUE;
						current_element--;
					}   //copy data of current element finished                     
				}       //backward ends
			}          //startelement=0 ends
			else if (startelement !=0) //startelement !=0
			{
				if(FORWARD==direction)  //forward-start
				{
					current_element =startelement; 
					if (shift ==TRUE) //startelement is next element
					current_element++;
					
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_PICTURE_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gPicture_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//PictureType
						if (CacheElements ==TRUE)
						gPicture_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_PICTURE_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gPicture_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gPicture_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//TCP_Port
						if (CacheElements ==TRUE)
						gPicture_TcpPort[current_element] =Indication_array[Offset];
						Offset++;
						//URI
						for(i=0; i<NAV_PICTURE_URI_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gPicture_Uri[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gPicture_Uri[current_element][i] =Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gPicture_ListEntryReceptionInformation [current_element] =TRUE;
						current_element++; //go on with next element    
					}   //copy data of current element finished
				}       //forward ends
				else if(BACKWARD==direction)
				{
					current_element =startelement; 
					if (shift ==TRUE) //startelement is previous element
					current_element--;         
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_PICTURE_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gPicture_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//PictureType
						if (CacheElements ==TRUE)
						gPicture_Type[current_element] =Indication_array[Offset];
						Offset++;
						//IPv6Address
						for(i=0; i<NAV_PICTURE_IPADDRESS_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gPicture_IpAddress[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gPicture_IpAddress[current_element][i] =Indication_array[Offset];
							Offset++;
						} 
						//TCP_Port
						if (CacheElements ==TRUE)
						gPicture_TcpPort[current_element] =Indication_array[Offset];
						Offset++;
						//URI
						for(i=0; i<NAV_PICTURE_URI_LENGTH;i++) //clear
						{
							if (CacheElements ==TRUE)
							gPicture_Uri[current_element][i] =0; 
						}
						length =Indication_array[Offset];
						Offset++;                
						for(i=0; i<length;i++) //copy data
						{   
							if (CacheElements ==TRUE)
							gPicture_Uri[current_element][i] =Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gPicture_ListEntryReceptionInformation [current_element] =TRUE;
						current_element--;
					}   //copy data of current element finished                                 
				}
			}          //startelement !=0 ends
			break;         //recordaddress =1 ends
		case 15: //recordaddress =15 -> POS 
			if(0==startelement)
			{
				if(FORWARD==direction)  //forward-start
				{          
					current_element =startelement;
					if (shift ==TRUE) //startelement is next element
					current_element++;                 
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_PICTURE_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gPicture_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gPicture_ListEntryReceptionInformation [current_element] =TRUE;
						current_element++; //go on with next element       
					}   //copy data of current element finished
				}       //forward ends
				if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
				{
					current_element =NAV_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_PICTURE_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gPicture_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gPicture_ListEntryReceptionInformation [current_element] =TRUE;
						current_element--;
					}   //copy data of current element finished                     
				}       //backward ends
			}          //startelement=0 ends
			else if (startelement !=0) //startelement !=0
			{
				if(FORWARD==direction)  //forward-start
				{
					current_element =startelement;
					if (shift ==TRUE) //startelement is next element
					current_element++;
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_PICTURE_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gPicture_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gPicture_ListEntryReceptionInformation [current_element] =TRUE;
						current_element++; //go on with next element       
					}   //copy data of current element finished
				}       //forward ends
				else if(BACKWARD==direction)
				{
					current_element =startelement; 
					if (shift ==TRUE) //startelement is previous element
					current_element--;
					for (j=0; j<elements;j++) //copy elements
					{
						//check, if elements must be cached and in case find position in array
						CacheElements =FALSE;
						for (i=0; i<NAV_PICTURE_ENTRIES; i++)
						{  
							//if element already cached, find position in ASG-cache
							if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
							{    
								current_element =i; 
								CacheElements   =TRUE;
							}
							//if not already cached, then store element only, if Cache is build-up!
							else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
							CacheElements   =TRUE;
						}
						//Pos
						if (transmitpos)
						{   
							if (CacheElements ==TRUE)
							gPicture_Pos[current_element]=Indication_array[Offset];
							Offset++;
						}
						//next element
						if (CacheElements ==TRUE)
						gPicture_ListEntryReceptionInformation [current_element] =TRUE;
						current_element--;
					}   //copy data of current element finished                                 
				}
			}          //startelement !=0 ends
			break;         //recordaddress =15 ends    
		}                             
		
		/*
	if (gPicture_CallBackReason !=NAV_PICTURE_CALLBACKREASON_NOCALLBACK)
		Picture_ListHandling ();
	else
		Picture_display(recordaddress, transmitpos);         
	*/
		break;
	case Changed_IND:
		//get data
		/***ArrayHeader***/
		mode            =(Indication_array[3] &0xF0) /0x10;
		recordaddress   =Indication_array[3] &0x0F;
		Offset =4;
		// decode "mode-byte"
		shift       =mode &0x01;
		direction   =(mode &0x02)/0x02;
		transmitpos =(mode &0x04)/0x04;
		indexsize   =(mode &0x08)/0x08;               
		if (indexsize)
		{   
			startelement =Indication_array[Offset];
			Offset++;
			startelement +=(Indication_array[Offset] *0x100);
			Offset++;
			elements =Indication_array[Offset];
			Offset++;
			elements +=(Indication_array[Offset] *0x100);
			Offset++;
		}
		else
		{   
			startelement =Indication_array[Offset];
			Offset++;
			elements =Indication_array[Offset];
			Offset++;
		}           
		if(startelement ==0 && shift==0 && transmitpos==0 && recordaddress==0 && elements==255) //check 'full range update'?
		{
			/*
		putvalue(env_ASG_NaviSD_LG_OnOff, FALSE);
		putvalue(env_ASG_NaviSD_LG_ListOpState, "'full range update' received");
		*/
		}
		else if (datalength>9)
		{
			if(startelement !=0)
			{
				for (i=0;i<NAV_PICTURE_ENTRIES;i++)
				{
					if(startelement ==gPicture_Pos[i])  
					i =NAV_PICTURE_ENTRIES;              
				}
			}
			switch (recordaddress)
			{  
			case 1: //recordaddress =1 -> StreamType, IPV6_Address, TCP_Port, URI
				if(0==startelement)
				{
					if(FORWARD==direction)  //forward-start
					{          
						current_element =startelement;             
						if (shift ==TRUE) //startelement is next element
						current_element++;                 

						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_PICTURE_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gPicture_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//PictureType
							if (CacheElements ==TRUE)
							gPicture_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_PICTURE_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gPicture_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gPicture_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//TCP_Port
							if (CacheElements ==TRUE)
							gPicture_TcpPort[current_element] =Indication_array[Offset];
							Offset++;
							//URI
							for(i=0; i<NAV_PICTURE_URI_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gPicture_Uri[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gPicture_Uri[current_element][i] =Indication_array[Offset];
								Offset++;
							}       
							//next element
							if (CacheElements ==TRUE)
							gPicture_ListEntryReceptionInformation [current_element] =TRUE;
							current_element++; //go on with next element  
						}   //copy data of current element finished
					}       //forward ends
					if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
					{
						current_element =NAV_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_PICTURE_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								} 
								//if not already cached, then store element only, if Cache is build-up!
								else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gPicture_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//PictureType
							if (CacheElements ==TRUE)
							gPicture_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_PICTURE_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gPicture_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gPicture_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//TCP_Port
							if (CacheElements ==TRUE)
							gPicture_TcpPort[current_element] =Indication_array[Offset];
							Offset++;
							//URI
							for(i=0; i<NAV_PICTURE_URI_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gPicture_Uri[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gPicture_Uri[current_element][i] =Indication_array[Offset];
								Offset++;
							}    
							//next element
							if (CacheElements ==TRUE)
							gPicture_ListEntryReceptionInformation [current_element] =TRUE;
							current_element--;
						}   //copy data of current element finished                     
					}       //backward ends
				}          //startelement=0 ends
				else if (startelement !=0) //startelement !=0
				{
					if(FORWARD==direction)  //forward-start
					{
						current_element =startelement; 
						if (shift ==TRUE) //startelement is next element
						current_element++;
						
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_PICTURE_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gPicture_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//PictureType
							if (CacheElements ==TRUE)
							gPicture_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_PICTURE_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gPicture_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gPicture_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//TCP_Port
							if (CacheElements ==TRUE)
							gPicture_TcpPort[current_element] =Indication_array[Offset];
							Offset++;
							//URI
							for(i=0; i<NAV_PICTURE_URI_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gPicture_Uri[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gPicture_Uri[current_element][i] =Indication_array[Offset];
								Offset++;
							}
							//next element
							if (CacheElements ==TRUE)
							gPicture_ListEntryReceptionInformation [current_element] =TRUE;
							current_element++; //go on with next element    
						}   //copy data of current element finished
					}       //forward ends
					else if(BACKWARD==direction)
					{
						current_element =startelement; 
						if (shift ==TRUE) //startelement is previous element
						current_element--;         
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_PICTURE_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gPicture_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//PictureType
							if (CacheElements ==TRUE)
							gPicture_Type[current_element] =Indication_array[Offset];
							Offset++;
							//IPv6Address
							for(i=0; i<NAV_PICTURE_IPADDRESS_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gPicture_IpAddress[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gPicture_IpAddress[current_element][i] =Indication_array[Offset];
								Offset++;
							} 
							//TCP_Port
							if (CacheElements ==TRUE)
							gPicture_TcpPort[current_element] =Indication_array[Offset];
							Offset++;
							//URI
							for(i=0; i<NAV_PICTURE_URI_LENGTH;i++) //clear
							{
								if (CacheElements ==TRUE)
								gPicture_Uri[current_element][i] =0; 
							}
							length =Indication_array[Offset];
							Offset++;                
							for(i=0; i<length;i++) //copy data
							{   
								if (CacheElements ==TRUE)
								gPicture_Uri[current_element][i] =Indication_array[Offset];
								Offset++;
							}
							//next element
							if (CacheElements ==TRUE)
							gPicture_ListEntryReceptionInformation [current_element] =TRUE;
							current_element--;
						}   //copy data of current element finished                                 
					}
				}          //startelement !=0 ends
				break;         //recordaddress =1 ends
			case 15: //recordaddress =15 -> POS 
				if(0==startelement)
				{
					if(FORWARD==direction)  //forward-start
					{          
						current_element =startelement;
						if (shift ==TRUE) //startelement is next element
						current_element++;                 
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_PICTURE_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gPicture_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//next element
							if (CacheElements ==TRUE)
							gPicture_ListEntryReceptionInformation [current_element] =TRUE;
							current_element++; //go on with next element       
						}   //copy data of current element finished
					}       //forward ends
					if(BACKWARD==direction && shift==TRUE)  //backward-start and shift=TRUE -> Start at last element in array
					{
						current_element =NAV_PICTURE_ENTRIES-1; //NAV_VIDEOSTREAMS_ENTRIES =8, but range: 0...7!
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_PICTURE_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gPicture_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//next element
							if (CacheElements ==TRUE)
							gPicture_ListEntryReceptionInformation [current_element] =TRUE;
							current_element--;
						}   //copy data of current element finished                     
					}       //backward ends
				}          //startelement=0 ends
				else if (startelement !=0) //startelement !=0
				{
					if(FORWARD==direction)  //forward-start
					{
						current_element =startelement;
						if (shift ==TRUE) //startelement is next element
						current_element++;
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_PICTURE_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gPicture_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//next element
							if (CacheElements ==TRUE)
							gPicture_ListEntryReceptionInformation [current_element] =TRUE;
							current_element++; //go on with next element       
						}   //copy data of current element finished
					}       //forward ends
					else if(BACKWARD==direction)
					{
						current_element =startelement; 
						if (shift ==TRUE) //startelement is previous element
						current_element--;
						for (j=0; j<elements;j++) //copy elements
						{
							//check, if elements must be cached and in case find position in array
							CacheElements =FALSE;
							for (i=0; i<NAV_PICTURE_ENTRIES; i++)
							{  
								//if element already cached, find position in ASG-cache
								if((transmitpos ==1) && Indication_array[Offset] ==gPicture_Pos[i] && gPicture_ListEntryReceptionInformation[i] ==TRUE)
								{    
									current_element =i; 
									CacheElements   =TRUE;
								}
								//if not already cached, then store element only, if Cache is build-up!
								else if((gPicture_ListHandlingType !=NAV_PICTURE_NOCACHE))
								CacheElements   =TRUE;
							}
							//Pos
							if (transmitpos)
							{   
								if (CacheElements ==TRUE)
								gPicture_Pos[current_element]=Indication_array[Offset];
								Offset++;
							}
							//next element
							if (CacheElements ==TRUE)
							gPicture_ListEntryReceptionInformation [current_element] =TRUE;
							current_element--;
						}   //copy data of current element finished                                 
					}
				}          //startelement !=0 ends
				break;         //recordaddress =15 ends    
			}
		}
		break;            
	case Error_IND:	
		if(Indication_array[3]<0x20 && Indication_array[3] !=0)				//BCL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_Picture: BCL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BCL [Indication_array[3]-0x10]);
		else if(Indication_array[3]<0x30 && Indication_array[3] !=0)			//BPL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_Picture: BPL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BPL [Indication_array[3]-0x20]);				
		else if(Indication_array[3]<0x40 && Indication_array[3] !=0)			//BAL-error
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_Picture: BAL-Error: 0x%x - %s", Indication_array[3], gerror_codes_BAL [Indication_array[3]-0x30]);
		else
		writelineEx(gError_Trace, 0, "ASG-NaviSD Indication_Picture: Application-Error: 0x%x", Indication_array[3]);
		break;
	default:
		writelineEx(gError_Trace, 0,"ASG-NaviSD Indication_Picture: unknown indication %x", gBAP_Indication[2]);
		break;
	}  
  
	//Panel
	putvalue(env_ASG_NaviSD_Pic_AsgId, gPicture_ASGID);
	putvalue(env_ASG_NaviSD_Pic_TAID, gPicture_TAID);
	putvalue(env_ASG_NaviSD_Pic_TNLE, gPicture_TotalNumListElements);
	putvalue(env_ASG_NaviSD_Pic_AH_Shift, shift);
	putvalue(env_ASG_NaviSD_Pic_AH_Dir, direction);
	putvalue(env_ASG_NaviSD_Pic_AH_TransPos, transmitpos);
	putvalue(env_ASG_NaviSD_Pic_AH_IndexSize, indexsize);
	putvalue(env_ASG_NaviSD_Pic_AH_RecAddress, recordaddress);
	putvalue(env_ASG_NaviSD_Pic_AH_Start, startelement);
	putvalue(env_ASG_NaviSD_Pic_AH_Elements, elements);
}

void Picture_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements)
{   
	int  i;
	dword requestarray [BAP_BUFFER_SIZE];
	byte Offset;
	word indexsize;

	// Init local variables. 
	for(i=0;i<BAP_BUFFER_SIZE;i++)
	requestarray [i]=0;

	indexsize   =0;
	Offset      =0;

	// decode "mode-byte"
	indexsize   =(mode &0x08)/0x08; 

	// Handle request.
	requestarray[0] =LSG_NaviSD;	    //LSG-ID
	requestarray[1] =FctID_Picture;	//Fct.-ID
	requestarray[2] =request;           //request type

	switch(request)
	{
	case DataGet_REQ:              
		requestarray[3] =((gPicture_ASGID *0x10) &0xF0) +(gPicture_TAID &0x0F);      
		/***ArrayHeader***/
		requestarray[4] =((mode *0x10) &0xF0) +(recordaddress &0x0F);          
		Offset =5;
		if(indexsize)
		{
			requestarray[Offset] =requested_startelement &0x00FF;
			Offset++;
			requestarray[Offset] =(requested_startelement &0xFF00) /0x100;
			Offset++;  
			requestarray[Offset] =elements &0x00FF;
			Offset++;
			requestarray[Offset] =(elements &0xFF00) /0x100;
			Offset++;       
			//writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_16bit %x",indexsize); //debug
		}
		else
		{
			requestarray[Offset] =requested_startelement;
			Offset++;
			requestarray[Offset] =elements;
			Offset++;
			//writeEX(gBAP_Trace, 0, "ASG_Request_indexSize_8bit %x",indexsize); //debug
		}
		set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
		break;
	default:	
		writelineEx(gError_Trace, 0, "ASG-NaviSD Request_Picture: invalid request %d", request);
		break;
	}
}
/*@!Encoding:1252*/
void panelColorControl(int envValue, char fct[], char panel[], char control[])
{
	if(envValue)
	{
		SetControlBackColor(panel, fct, gRGB_white);
		enableControl(panel, control, TRUE); 
	}
	else
	{
		SetControlBackColor(panel, fct, gRGB_red);
		enableControl(panel, control, FALSE);
	}
}

void BAP_DLL_SetRxData()
{
	int i;
	byte gRxBuffer[1500];
	for(i=0;i<gUdpSocketCnt;i++)
	{
		UdpReceiveFrom(gUdpSockets[i].Handle, gRxBuffer, 0);
	}
}

void CloseUdpSocket()
{
	int i;
	const long  INVALID_SOCKET =    ~0;
	for(i=0;i<gUdpSocketCnt;i++)
	{
		if(gUdpSockets[i].Handle != INVALID_SOCKET)
		{
			UdpClose(gUdpSockets[i].Handle);
			gUdpSockets[i].Handle = INVALID_SOCKET;
		}
	}
}

BAP_CAN_TX_Request()	// Function to send BAP data over CAN.
{
	int i, test_I,debugVar;
	byte DestIp[16], TX_Data[1500], TX_Data_FR[10], send_result;
	dword TX_Header[13];			// Header
	message 0x100 TX_Message;	// dummy-message, Adresse wird noch modifiziert
  debugVar=0;
	TX_Header[2] = 1500; // max-Length of TX_Data
	// Pollen ueber die Queue, die von der DLL zur Verfuegung gestellt wird
	// Diese Daten muessen ueber den CAN Bus gesendet werden
	while (BAP180_GetTxData(NODE_INDEX,TX_Header,TX_Data) == 0)
	{
		if(canethdecider == 2)
		{
			TX_Message.CAN = TX_Header[1]; 		//CAN channel
			TX_Message.ID = TX_Header[3]; 	  //Can ID
			TX_Message.DataLength = TX_Header[2]; 		// received length
			
			for (i=0; i<TX_Message.DataLength; i++) 
			{	//CAN data-bytes
				TX_Message.byte(i) = TX_Data[i];
			}
			TX_Message.EDL = 0;
			TX_Message.BRS = 0;
			if(TX_Header[4] & 2)  TX_Message.EDL = 1;
			if(TX_Header[4] & 4)  TX_Message.BRS = 1;
			output(TX_Message);					//send CAN message
			
			//Versions Output
			if(TX_Data[0] == 0x40 && TX_Data[1] == 0x00 && TX_Header[2] == 4)
			{
				writelineEx(gBAP_Trace, 0,"Major Version: %i, Minor Version: %i", TX_Data[2], TX_Data[3]);
			}       
		}
		else if(canethdecider == 1)
		{
			for(i=0; i<8;i++)
			{
				DestIp[2*i]   = (byte)(TX_Header[i+4]>>8);
				DestIp[2*i+1] = (byte)(TX_Header[i+4]&0xFF);
			}
			
			for (i=0; i<TX_Header[2]; i++) 
			{	//CAN data-bytes
				TX_Data.byte(i) = TX_Data[i];
			}
			send_result = UdpSendTo(gUdpSockets[TX_Header[3]-1].Handle, DestIp, TX_Header[12], TX_Data, TX_Header[2]);
			
			if (send_result != 0)
			{
				writeLineEx(0,3, "UdpSendTo failed, error code %d, last error %d", send_result, IpGetLastError());
			}
		}
		TX_Header[2] = 1500; 
	} 
} /* end of function */

void EthernetCreateSocket()
{ 
	int index;
	dword i, j, Header[200], val, VlanId, VlanPrio, ifIndex;
	byte ipv6_adapter_adresses[5][16];
	byte ipv6_temp[16];
	byte ipv6_zero[16]; 
	int i_i;

	gUdpSocketCnt = 0;
	Header[0] = 1;
	if(BAP180_GetEthConfig(NODE_INDEX, Header) == 0)
	{
		for(i_i=0; i_i < 15; i_i++)
		{
			write("De ___%d__ %d",i_i, Header[i_i]);
		}
		for(i=1;i<=3;i++)
		{
			if(IpGetAdapterAddress(i, ipv6_adapter_adresses, 5) == 0)
			{
				val = IpGetAdapterAddressCount(i, 28);
				for(j=0;j<val;j++)
				{
					IpRemoveAdapterAddress(i, ipv6_adapter_adresses[j], 64);
				}
			}
			else
			{
				break;
			}
		}
		index=0;
		ifIndex = 1;
		
		VlanId = Header[index++];
		VlanPrio = Header[index++];
		writelineex(0, 1, "VLAN ID: %d", VlanId);
		writelineex(0, 1, "VLAN Prio: %d", VlanPrio);
		if(VlanId != 0xFFFF)
		ifIndex = 2;

		gUdpSocketCnt = Header[index++];
		for(i=0; i<gUdpSocketCnt;i++)
		{
			gUdpSockets[i].Id = Header[index++];
			for(j=0;j<8;j++)
			{
				ipv6_temp[j*2]   = Header[index]>>8;
				ipv6_temp[j*2+1] = Header[index++]&0xFF;
			}

			IpAddAdapterAddress(ifIndex, ipv6_temp, 64);

			if(ipv6_temp[0] == 0xFF)
			gUdpSockets[i].Handle = UdpOpen( ipv6_zero, Header[index++]);
			else
			gUdpSockets[i].Handle = UdpOpen( ipv6_temp, Header[index++]);

			if (gUdpSockets[i].Handle == ~0){
				writelineex(0, 3, "Error: could not create Udp socket! %d", IpGetLastError());
			}else{

				writelineex(0, 1, "Udp socket is opened successfully.");

				if(ipv6_temp[0] == 0xFF)
				{
					if(IpJoinMulticastGroup(gUdpSockets[i].Handle, ifIndex, ipv6_temp) != 0)
					writelineex(0, 3, "IpJoinMulticastGroup failed.");
				}

				if(IpSetMulticastInterface ( gUdpSockets[i].Handle, ifIndex) != 0)
				writelineex(0, 3, "IpSetMulticastInterface failed");
			}
		}
	}
	else{
		writelineex(0, 3, "Error: BAP180_GetEthConfig failed!");
	}
}

void set_status_requestbuffer(dword Request_array [], int length, byte BAPDataType)
{
	int bufferline = 0, i;

	bufferline = get_requestbuffer_line();

	for(i = 0; i < length; i++)
	{
		gBAP_Request[bufferline][i] = Request_array[i];
	}

	gBAP_Requestbuffer_status[bufferline] = length;
	gBAP_Requestbuffer_BAPDataTyp[bufferline] = BAPDataType;
}