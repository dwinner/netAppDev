/*@!Encoding:1252*/
includes
{
    // new global access functions for reading ini-file settings, format conversion
    #include "util.CIN"
}

// PERF: Supports some performance tests:
// - pointer sweep
// - MFL rotation combined with carousel rotation
// - Radio list scrolling and switch to next (right) BAP client and back
// - 'Fahrzeug' <-> MFA switch
// Rev:
// HeWi: 12.04.2011: control via CAn message 0x666 (Power Switch ON/OFF added)
//                   (merged wih ThBa implementation)
// HeWi: 18.04.2011: typical scenarios added
// HeWi: 07.12.2012: Reading the pre-defined values in ini-file moved to a new function
//                   (vPERF_ReadInitValues()) which will be called every time when 
//                   PERF 'Start# button is pressed

variables
{
    // define here the global vars and definitions
    // remember the different configurations for AUDI and VW

    // the ini file name
    char PERF_cIniFileName[ 21 ]   = "Models\\Perf\\Perf.ini";
    // a handle to this file
    dword PERF_IniFileHandle = 0;
    // the log file name
    char PERF_cLogFileName[ 23 ]   = "Logs\\PerfLog.txt";
    // a handle to this file
    dword PERF_LogFileHandle = 0;
    // text buffer for log file
    char PERF_cLogBuffer[ 100 ];
    // system Date and Time
    char PERF_cTimeBuffer[64];

    // **** car models *****
    // see PERF.ini
    const MODEL_AUDI_COLOR = 0;
    const MODEL_VW_COLOR = 1;

    // define here the car model
    //const PERF_iCarModel = MODEL_AUDI_COLOR;
    int PERF_iCarModel = MODEL_VW_COLOR;      // overwritten by PERF.ini

    // **** FlipCards and Carousel members *****
    // values are overwritten by PERF.ini file
    // AUDI:10 FlipCards from 'Reichweite' to end of role
    int PERF_iMflMaxFlipCardsAudi = 9;    // overwritten by PERF.ini
    // VW : 9 FlipCards from 'Reichweite' to 'Reichweite'
    int PERF_iMflMaxFlipCardsVW = 8;      // overwritten by PERF.ini
    // number of carousel members
    int PERF_iCarouselMembersAudi = 4;      // overwritten by PERF.ini
    int PERF_iCarouselMembersVW = 6;        // overwritten by PERF.ini

    // **** general definitions ****
    // boolean
    const FALSE = 0;
    const TRUE  = 1;

    // Performance scenarios
    const PERF_NO_SCENARIO  = 1;
    const PERF_SCENARIO_11  = 2;
    const PERF_SCENARIO_12  = 3;
    const PERF_SCENARIO_21  = 4;
    const PERF_SCENARIO_22  = 5;
    const PERF_SCENARIO_3   = 6;

    // define function states
    const PERF_INIT             = 1;    // initialize the function
    const PERF_STOP             = 2;    // stop the function
    const PERF_DEINIT           = 3;    // de-initialize function
    const PERF_INITIALIZED      = 4;    // function initialized
    const PERF_DEINITIALIZED    = 5;    // function de-initialized
    const PERF_RUNNING          = 6;    // function running
    const PERF_STOPPED          = 7;    // function stopped

    // cyclic run control timer definitions
    int PERF_iCyclicRunControlTime = 1000;  // 1 s for test
    // 0: stop running the prefromance test
    // 1: start performance tests now
    byte PERF_boPerformanceTestsRunning = FALSE;

    // start time
    // 1: Seconds (0 - 60)
    // 2: Minutes (0 - 60)
    // 3: Hours (0 - 24)
    // 4: Day of month (1 - 31)
    // 5: Month (0 - 11)
    // 6: Year (starting with 1900)
    // 7: Day of week (0 - 7)
    // 8: Day of Year (0 - 365)
    // 9: Flag for daylight saving time (0 - 1, 1 = daylight saving time)
    long PERF_lDateTimeStart[ 9 ];
    // run time in seconds
    long PERF_lRunTimeInSeconds = 0;

    // MFL defintions
    // define the MFL buttons
    const MFL_NO_BUTTON         = 0;
    const MFL_OK_BUTTON         = 1;
    const MFL_MENU_DOWN_BUTTON  = 2;
    const MFL_MENU_UP_BUTTON    = 3;
    const MFL_KEY_DOWN_BUTTON   = 4;
    const MFL_KEY_UP_BUTTON     = 5;

    // timing
    // delay time before releasing of a button
    const MFL_BUTTON_RELEASE_TIME = 10;      // ms
    // delay time before releasing the OK button
    const OK_BUTTON_RELEASE_TIME = 10;       // ms
    // additional delay time for application waiting for releasing a MFL key
    const PERF_MFL_SHORT_DELAY = 20;   // ms
    // contains the last pressed MFL button
    int iMflButtonLastPressed; 

    // **** timer definitions ****
    // performs a MFL button pressure
    msTimer msPERF_MflButtonTimer;
    // cyclic 'run control' timer
    msTimer msPERF_CyclicRunControlTimer;
    // cyclic trigger of carousel
    msTimer msPERF_CarouselRotationTimer;
    // cyclic trigger of MFA rotation
    msTimer msPERF_MflRotationTimer;
    // cyclic trigger of Pointer sweep
    msTimer msPERF_PointerSweepTimer;
    // cyclic timer for Radio list activation
    msTimer msPERF_RadioListTimer;
    // cyclic timer for Dimming sweep
    msTimer msPERF_SweepDimmingTimer;
    // cyclic toggle tumer for warnings
    msTimer msPERF_WarningsToggleTimer;
    // cyclic scrolling of MFA (boardcomputer)
    msTimer msPERF_MfaScrollingTimer;
    // Kl15 toogling
    msTimer msPERF_Kl15ToggleTimer;

    // **** Test functions states (PERF_INITIALIZED, PERF_DEINITIALIZED) and running states (PERF_RUNNING, PERF_STOPPED) ****
    // pointer sweep
    byte bPointerSweepState = PERF_DEINITIALIZED;
    byte bPointerSweepRunningState = PERF_STOPPED;
    // Turn Lights
    byte bTurnLightsState = PERF_DEINITIALIZED;
    byte bTurnLightsRunningState = PERF_STOPPED;
    // tank and KMT
    byte bTankKmtState = PERF_DEINITIALIZED;
    byte bTankKmtRunningState = PERF_STOPPED;
    // Dimming
    byte bDimmingSweepState = PERF_DEINITIALIZED;
    byte bDimmingSweepRunningState = PERF_STOPPED;
 
    // only one performance scenario is selected
    byte bScenarioState = PERF_DEINITIALIZED;
    byte bScenarioRunningState = PERF_STOPPED;
 
    // MFL rotation
    byte bMFLRotationState = PERF_DEINITIALIZED;
    byte bMFLRotationRunningState = PERF_STOPPED;
    // Carousel running
    byte bCarouselState = PERF_DEINITIALIZED;
    byte bCarouselRunningState = PERF_STOPPED;
    // Radio list running
    byte bRadioListState = PERF_DEINITIALIZED;
    byte bRadioListRunningState = PERF_STOPPED;
    // Kl15 toggling
    byte bKl15TooglingState = PERF_DEINITIALIZED;

    //  **** Pointer sweep ****
    int PERF_iPointerSweepCyclicTime = 2000;

    // For Pointer Sweep: Revolution
    int PERF_iRpmStart = 0;                  // overwritten by PERF.ini
    int PERF_iRpmEnd = 6000;                 // overwritten by PERF.ini
    int PERF_iRpmSteps = 100;                // overwritten by PERF.ini
    int PERF_iRpmTime = 200;                 // overwritten by PERF.ini

    // For Pointer Sweep: Speed
    int PERF_iSpeedStart = 0;                // overwritten by PERF.ini
    int PERF_iSpeedEnd = 240;                // overwritten by PERF.ini
    int PERF_iSpeedSteps = 100;              // overwritten by PERF.ini
    int PERF_iSpeedTime = 200;               // overwritten by PERF.ini

    // For Pointer Sweep: Temp
    long PERF_lTempSteps;
    long PERF_lTempMax = 142.5;              // overwritten by PERF.ini
    int PERF_iTempMin = 50;                  // overwritten by PERF.ini
    int PERF_iTempSteps = 10;                // overwritten by PERF.ini
    int PERF_iTempDefaultValue = 90;         // overwritten by PERF.ini

    // **** Dimming
    int PERF_DimmingCycle               = 0;
    // 58xd
    int PERF_iDimmingKl58xdStep         = 0;
    int PERF_iDimmingKl58xdMax          = 0;
    int PERF_iDimmingKl58xdMin          = 0;
    int PERF_iDimmingKl58xdValue        = 0;
    int PERF_iDimmingKl58xdValueStart   = 0;
    int PERF_iDimmingKl58xdValueDefault = 0;
    byte PERF_DimmingKl58xdDirection    = 0;
    // 58xt
    int PERF_iDimmingKl58xtStep         = 0;
    int PERF_iDimmingKl58xtMax          = 0;
    int PERF_iDimmingKl58xtMin          = 0;
    int PERF_DimmingKl58xtValue         = 0;
    int PERF_iDimmingKl58xtValueStart   = 0;
    int PERF_iDimmingKl58xtValueDefault = 0;
    byte PERF_DimmingKl58xtDirection    = 0;

    // *** Performance scenarios
    int PERF_ActualScenario;

    // **** Performance scenario 1.1
    // default (start) cycle time
    int PERF_iToggleWarningsStartCycle = 2000;  // ms
    // start with LED ON state
    int PERF_WarningsToggleState = 1;
    // toggle counter
    int PERF_ToggleCnt = 0;
    // warning table
    const MAX_WARNINGS = 4;
    const MAX_WARNINGS_LENGTH = 30;
    char PERF_WarningTable[ MAX_WARNINGS ][ MAX_WARNINGS_LENGTH ] =  
         { "KCAN_WIV_Oeldr_Warn_Motor", "KCAN_MO_OBD2_Lampe", "KCAN_BEM_Generatordiagnose",
           "KCAN_ZV_HD_offen" };
    // active time before this warning will be switched OFF, related to PERF_WarningTable
    int PERF_WarningOnDelayTimeTable[ MAX_WARNINGS ] = 
         { 2000, 1000, 3000, 
           3000 };
    // active time before next warning will be switched ON, related to PERF_WarningTable
    int PERF_WarningOffDelayTimeTable[ MAX_WARNINGS ] = 
         { 500, 500, 500, 
           500 };

    // **** Performance Scenario 1.2
    int   PERF_iToggleKl15Cycle = 100;
    int   PERF_iKl15ToggleDuration = 2000;
    const MAX_NUMBER_OF_TOGGLE_CYCLES = 5;
    const MAX_NUMBER_OF_DURATIONS = 4;
    dword PERF_dwKl15ToggleCyclesTable[MAX_NUMBER_OF_TOGGLE_CYCLES];
    dword PERF_dwKl15ToggleDurationTable[MAX_NUMBER_OF_DURATIONS];
    int   PERF_iCurKl15ToggleCycleIdx = 0;
    int   PERF_iCurKl15ToggleDurationIdx = 0;
    //byte  PERF_ChangeKl15Cycle = 0;
    //byte  PERF_ChangeKl15Duration = 0;
    int   PERF_iCycleCounter = 0;
    byte  bKl15On = 1;
    byte  bKl15Off = 0;


    // **** Performance scenario 2.1
    // scrolling cycle MFA
    int PERF_iMfaScrollingCycleTime = 2000;  // ms
    // delay time before pressing the OK button
    int PERF_iMfaScrollingWaitBeforeOkTime = 800;  // ms
    // direction
    const PERF_MFA_SCROLL_LIST_DOWN = 0;     // 0 := scroll down
    const PERF_MFA_SCROLL_LIST_UP = 1;       // 1 := scroll up
    // number of scroll up or down    
    const PERF_MFA_SCROLL_UP_DOWN_MAX = 2;
    // counts the 'up'-'down' button pressures
    int PERF_iMfaListScrollCnt;
    // state 'up' or 'down'
    int PERF_iMfaScrollState;

    // **** Performance scenario 2.2
    // Radio timing: staying time for a list element 
    int PERF_iRadioStayInListEntryTime = 1000; // overwritten by PERF.ini

    // **** Performance scenario 3

    // **** MFL rotation ****
    int PERF_iMflRotationCyclicTime = 2000; // overwritten by PERF.ini

    int PERF_iMflKeyStrokesUp;              // number of strokes for up role
    int PERF_iMflKeyStrokesDown;            // number of strokes for down role
    int PERF_iMflWheelKeyStrokes;           // counts the button strokes
    // up-down direction
    byte PERF_boMflWheelUpDownDirection;     // 0 : down, 1 : up
    // if key stroke is active, release it after some 100 ms
    byte PERF_PERF_boMflWheelButtonHasBeenPressed;
    // 1 if one up/down rotations has been finished
    byte PERF_boMflWheelRotationFinished;
    // Mfl wheel rotation
    const MFL_WHEEL_DOWN = 0;
    const MFL_WHEEL_UP = 1;

    //  **** Carousel rotation ****
    int PERF_iCarouselRotationCyclicTime = 5000;   // overwritten by PERF.ini

    int PERF_iCarouselMembers;          
    int PERF_iCarouselKeyStroke;        // counts the strokes
    // if key stroke is active, release it after some 100 ms
    byte PERF_boCarouselButtonHasBeenPressed;
    // 1 if BC is the active display and should be rotate
    byte PERF_boCarouselBcActiveAndRotate;
    // 1 if one carousel rotation has been finished
    byte PERF_boCarouselRotationFinished;

    //  **** Radio list scrolling and BAP client changing  ****
    // Radio list and BAP state maschine
    const BAP_RADIO_SCROLL               = 0;
    const BAP_RADIO_SELECT_BAP_CLIENT_UP = 1;
    const BAP_RADIO_SELECT_RADIO         = 2;
    const BAP_RADIO_GOTO_RADIO           = 3;
    const BAP_RADIO_IN_THE_RADIO         = 4;
    // central state maschine handling switch between Radio and BAP client
    int PERF_iRadioBapState;

    // Radio list scrolling
    const RADIO_SCROLL_LIST_DOWN      = 0;
    const RADIO_SCROLL_LIST_DOWN_ONLY = 1;    // only scrolling down the radio list
    const RADIO_SCROLL_LIST_FINISHED  = 2;
    const RADIO_SCROLL_LIST_STOPPED   = 3;
    // state maschine when radio list srolling
    int PERF_iRadioScrollState;

    // BAP rotation
    int PERF_iBapRadioCyclicTime                      = 1000; // overwritten by PERF.ini
    // Radio timing: next BAP action
    int PERF_iRadioListStayInRadioBeforeScrollingTime = 2000; // overwritten by PERF.ini
    // BAP shown for this delay time
    int PERF_iRadioStayInBapClientUpTime              = 2000; // overwritten by PERF.ini

    // max count of scroll downs
    int PERF_iRadioListEntries = 10;
    // counts the 'down' button pressures
    int PERF_iRadioListScrollDownCnt;

    // max count of scroll downs
    // 0 := no scrolling when MFA display is active
    // n := n scroll downs when MFA display is active
    int PERF_iMfaScrollDownMax = 0;  // no scrolling in MFA (Boardcomputer)

    // Fzg MFA change and BAP rotation
    int PERF_iFzgMfaCyclicTime       = 1000;
    // MFA timing: staying time for a list element 
    int PERF_iMfaStayInListEntryTime = 1000;
    // MFA timing: next BAP action
    int PERF_iMfaListStayInBeforeScrollingTime = 4000;
    // BAP shown for this delay time
    int PERF_iMfaStayInBapClientTime = 2000;

    // **** ****
}

on start
{

    // get parameters from ini-file : PERF.ini
    // After a CANoe simulation STOPPED and STARTED cycle the new parameters are active

    // open the INI file
    PERF_IniFileHandle = openFileRead( PERF_cIniFileName, 0 /* ASCCII */ );
    if( PERF_IniFileHandle == 0 )
    {
        write("PERF: ERROR: cannot open File Perf.ini");
        putValue( ENV_PERF_HelpBox, "ERROR: cannot open Perf.ini" );
        SetControlBackColor( "PERF", "EnvVar:ENV_PERF_HelpBox", MakeRGB( 255, 0, 0 ) );
        fileClose( PERF_IniFileHandle );
    }
    else
    {
        // it's open
    }

    // the pre-defined values from ini-files are read now when the PERF function will be started
    // PERF panel : Start - Stop : radio button OFF 

    // ´gray OFF' to status field
    putValue( ENV_PERF_StartSwitchDisplay, "OFF" );
    SetControlBackColor( "PERF", "EnvVar:ENV_PERF_StartSwitchDisplay", MakeRGB( 192, 192, 192 ) );
    // help text
    putValue( ENV_PERF_HelpBox, "Performance switch is OFF" );

    // a scenario is not selected
    PERF_ActualScenario = PERF_NO_SCENARIO;
    putValue( ENV_PERF_ScenarioTableBox, PERF_NO_SCENARIO );
    putValue( ENV_PERF_ScenarioDescription_1, "a scenario is not selected" );

    // preset the start time, needed before running CallAllOnEnvVar()
    getLocalTime( PERF_lDateTimeStart );

    // run all envVar's (are not automatically called when environment variables are written while in Start context) 
    CallAllOnEnvVar(); 
}

on stopMeasurement
{
    // close Parameter input file, if present
    if( PERF_IniFileHandle != 0 )
    {
        fileClose( PERF_IniFileHandle );
    }

    // if 'Start - Stop' key is still activated (performance measurement is running)
    if( @ENV_PERF_StartSwitch == 1 )
    {
        @ENV_PERF_StartSwitch = 0;    // stop it
    }
     
    // and de-init all test functions
    vPERF_MeasurementDeInit();

    // close LOG file, if present
    if( PERF_LogFileHandle != 0 )
    {
        fileClose( PERF_LogFileHandle );
    }

    write("PERF: Performance stopped!");
    putValue( ENV_PERF_HelpBox, "Performance stopped" );
}

on timer msPERF_CyclicRunControlTimer
{
    // cyclic check of the 'Start - Stop' switch
    // 0: stop running of the selected performance tests
    // 1: start of the selected performance tests
    if( PERF_boPerformanceTestsRunning == TRUE )
    {
        // the performance tests are started

        // **** the 'Basic Load' section

        // **** Pointer sweep
        
        if( ( bPointerSweepState == PERF_INITIALIZED ) && ( bPointerSweepRunningState == PERF_STOPPED ) )
        {
            // start cyclic pionter sweep
            bPointerSweepRunningState = PERF_RUNNING;

            // this will starts the pointer sweep. The PointerSweepTimer isn't needed for
            // speed and revolution pointer sweep. The sweep is proccessed by the CANoe simulation
            putValue( ENV_SpeedSweep, 1 );         // start speed pointer sweep
            putValue( ENV_RPMSweep, 1 );           // start revolution pointer sweep

            // start cyclic timer                
            write( "PERF: start PointerSweepTimer: refresh cycle = %d", PERF_iPointerSweepCyclicTime );
            if( isTimerActive( msPERF_PointerSweepTimer ) )
            {
                cancelTimer( msPERF_PointerSweepTimer );
            }
            setTimer( msPERF_PointerSweepTimer, PERF_iPointerSweepCyclicTime );
            putValue( ENV_PERF_PointerBox, "'Pointer' sweep running" );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Pointer (speed, rev) sweep running: cycle time = %d\n", PERF_iPointerSweepCyclicTime );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }
        }

        // **** Turn lights blinking
        if( ( bTurnLightsState == PERF_INITIALIZED ) && ( bTurnLightsRunningState == PERF_STOPPED ) )
        {
            // start cyclic 'Turn Lights' blinking
            bTurnLightsRunningState = PERF_RUNNING;

            // uses 'RBS_Sweep:Blinkmodi_02' CANoe node
            write( "PERF: start 'Turn Lights' ON, needs 'RBS_Sweep:Blinkmodi_02' CANoe node" );
            putValue( KCAN_BM_Warnblinken, 1 );

            putValue( ENV_PERF_TurnLightsBox, "'Turn Lights' running" );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: 'Turn Lights' running\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }
        }

        // **** Tank and KMT
        if( ( bTankKmtState == PERF_INITIALIZED ) && ( bTankKmtRunningState == PERF_STOPPED ) )
        {
            // start static 'Tank + KMT'
            bTankKmtRunningState = PERF_RUNNING;

            // as both tank and KMT are driven statically nothing to do

            putValue( ENV_PERF_TankKmtBox, "'Tank + KMT' running" );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: 'Tank + KMT' (static) running\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }
        }

        // **** Dimming
        if( ( bDimmingSweepState == PERF_INITIALIZED ) && ( bDimmingSweepRunningState == PERF_STOPPED ) )
        {
            // start cyclic 'Dimming' sweep
            bDimmingSweepRunningState = PERF_RUNNING;

            // start cyclic timer                
            write( "PERF: start msPERF_SweepDimmingTimer: refresh cycle = %d", PERF_DimmingCycle );
            if( isTimerActive( msPERF_SweepDimmingTimer ) )
            {
                cancelTimer( msPERF_SweepDimmingTimer );
            }
            setTimer( msPERF_SweepDimmingTimer, PERF_DimmingCycle );
            putValue( ENV_PERF_DimmingSweepBox, "'Dimming' sweep running" );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: 'Dimming' sweep running: cycle time = %d\n", PERF_DimmingCycle );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }
        }

        // **** end 'Basic Load' section

        // **** the performance scenarios
        //write( "PERF: start performance scenarios: bScenarioState = %d, bScenarioRunningState = %d", 
        //       bScenarioState, bScenarioRunningState );
        if( ( bScenarioState == PERF_INITIALIZED ) && ( bScenarioRunningState == PERF_STOPPED ) )
        {
            switch( @ENV_PERF_ScenarioTableBox )
            {
                case PERF_NO_SCENARIO:
                    putValue( ENV_PERF_ScenarioDescription_1, "no scenario running" );
                    break;

                case PERF_SCENARIO_11:
                    // Warnungstoggeln:
                    //    Öldruckwarnung 
                    //    Caroutline
                    //    Blinkende LED
                    //    OBD-LED
                    //    Generatorwarnung

                    // start the toggling
                    if( isTimerActive( msPERF_WarningsToggleTimer ) )
                    {
                        cancelTimer( msPERF_WarningsToggleTimer );
                    }
                    setTimer( msPERF_WarningsToggleTimer, PERF_iToggleWarningsStartCycle );
                    // update running state
                    bScenarioRunningState = PERF_RUNNING;


                    putValue( ENV_PERF_ScenarioDescription_2, "Warnings toggle" );
                    putValue( ENV_PERF_ScenarioDescription_1, "Scenario 1.1 running" );

                    // log
                    if( PERF_LogFileHandle != 0)
                    {
                        snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Scenario 1.1 running\n" );
                        filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                    }
                    break;

                case PERF_SCENARIO_12:
                    // Kl15 toggling
                    // start the toggling
                    if( isTimerActive( msPERF_Kl15ToggleTimer ) )
                    {
                        cancelTimer( msPERF_Kl15ToggleTimer );
                    }
                    setTimer( msPERF_Kl15ToggleTimer, PERF_iToggleKl15Cycle );

                    // update running state
                    bScenarioRunningState = PERF_RUNNING;


                    putValue( ENV_PERF_ScenarioDescription_2, "Kl15 toggle" );
                    putValue( ENV_PERF_ScenarioDescription_1, "Scenario 1.2 running" );

                    // log
                    if( PERF_LogFileHandle != 0)
                    {
                        snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Scenario 1.2 running\n" );
                        filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                    }
                    break;

                case PERF_SCENARIO_21:
                    // Tastenbedienung innerhalb eines Views:
                    // MFA scrollen 2-mal hoch<->runter -> 2-mal ok, ..

                    // start scrolling
                    if( isTimerActive( msPERF_MfaScrollingTimer ) )
                    {
                        cancelTimer( msPERF_MfaScrollingTimer );
                    }
                    setTimer( msPERF_MfaScrollingTimer, PERF_iMfaScrollingCycleTime );
                    // update running state
                    bScenarioRunningState = PERF_RUNNING;


                    putValue( ENV_PERF_ScenarioDescription_2, "MFA scrolling 2x up-down" );
                    putValue( ENV_PERF_ScenarioDescription_1, "Scenario 2.1 running" );

                    // log
                    if( PERF_LogFileHandle != 0)
                    {
                        snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Scenario 2.1 running\n" );
                        filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                    }
                    break;

                case PERF_SCENARIO_22:
                    // Tastenbedienung -> innerhalb eines Views:
                    // Scrollen in Radioliste -> eine Richtung (BAP), unendlich
              
                    // start cyclic timer                
                    // check if cyclic timer is still running
                    if( isTimerActive( msPERF_RadioListTimer ) )
                    {
                        cancelTimer( msPERF_RadioListTimer );
                    }
                    setTimer( msPERF_RadioListTimer, PERF_iBapRadioCyclicTime );
                    // update running state
                    bScenarioRunningState = PERF_RUNNING;

                    // start radio list rotation
                    bRadioListRunningState = PERF_RUNNING;

                    putValue( ENV_PERF_ScenarioDescription_2, "Radio list rotation" );
                    putValue( ENV_PERF_ScenarioDescription_1, "Scenario 2.2 running" );

                    // log
                    if( PERF_LogFileHandle != 0)
                    {
                        snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Scenario 2.2 running\n" );
                        filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                    }
                    break;

                case PERF_SCENARIO_3:
                    // Tastenbedienung -> Viewwechsel (BC):
                    // Carousel (VW) bzw. Menürolle (AUDI: Reiter)

                    // start cyclic timer                
                    write( "PERF: start CarouselRotationTimer: refresh cycle = %d", PERF_iCarouselRotationCyclicTime );
                    // check if cyclic timer is still running
                    if( isTimerActive( msPERF_CarouselRotationTimer ) )
                    {
                        cancelTimer( msPERF_CarouselRotationTimer );
                    }
                    setTimer( msPERF_CarouselRotationTimer, PERF_iCarouselRotationCyclicTime );
                    // update running state
                    bScenarioRunningState = PERF_RUNNING;

                    // Carousel rotation
                    bCarouselRunningState = PERF_RUNNING;
                    
                    putValue( ENV_PERF_ScenarioDescription_2, "Carousel running" );

                    // BC rotation
                    bMFLRotationRunningState = PERF_RUNNING;

                    // start cyclic timer                
                    write( "PERF: start MflRotationTmer: refresh cycle = %d", PERF_iMflRotationCyclicTime );
                    // check if cyclic timer is still running
                    if( isTimerActive( msPERF_MflRotationTimer ) )
                    {
                        cancelTimer( msPERF_MflRotationTimer );
                    }
                    setTimer( msPERF_MflRotationTimer, PERF_iMflRotationCyclicTime );
 
                    putValue( ENV_PERF_ScenarioDescription_3, "BC role running" );
                    putValue( ENV_PERF_ScenarioDescription_1, "Scenario 3 running" );

                    // log
                    if( PERF_LogFileHandle != 0)
                    {
                        snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Scenario 3 running\n" );
                        filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                    }
                    break;

                default:
                    write( "PERF: UNKNOWN performance scenario" );
                    putValue( ENV_PERF_ScenarioDescription_1, "UNKNOWN performance scenario" );

                    // log
                    if( PERF_LogFileHandle != 0)
                    {
                        snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: UNKNOWN performance scenario\n" );
                        filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                    }
                    break;
            }   // end switch
        }

        // **** end performance scenarios

        //******* refresh this timer ******************************************

        setTimer( msPERF_CyclicRunControlTimer, PERF_iCyclicRunControlTime );
    }
    else
    {
        // stop the 'run control'
        cancelTimer( msPERF_CyclicRunControlTimer );
    }
}

on envVar ENV_PERF_StartSwitch
{
    // starts and stops the performance tests

    int boDebug_StartSwitch = 1;   // 1 := debug output enabled

    // date and time when measurement has been stopped
    long PERF_lDateTimeStop[ 9 ];
    long PERF_lStartTimeInSeconds;
    long PERF_lStopTimeInSeconds;

    // state change only when button has been pressed
    if( @ENV_PERF_StartSwitch == 1 )
    {
        // start performance measurement
        write( "PERF: Performance measurement started!" );

        // refresh the pre-defined values (from ini file)
        vPERF_ReadInitValues();

        // ´green ON' to status field
        putValue( ENV_PERF_StartSwitchDisplay, "ON" );
        SetControlBackColor( "PERF", "EnvVar:ENV_PERF_StartSwitchDisplay", MakeRGB( 0, 255, 0 ) );

        // start performance tests now
        PERF_boPerformanceTestsRunning = TRUE;
        // time stamp
        getLocalTimeString( PERF_cTimeBuffer );
        // and save date and time for calculating run time when measurements stopps
        getLocalTime( PERF_lDateTimeStart );
        // init
        vPERF_MeasurementInit();

        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance started at: " );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "%s\n", PERF_cTimeBuffer );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }
    }
    else
    {
        // get time stamp
        getLocalTimeString( PERF_cTimeBuffer );
        // save the stop time for calculation of run time
        getLocalTime( PERF_lDateTimeStop );

        write( "PERF: Performance measurement stopped!" );

        // ´gray OFF' to status field
        putValue( ENV_PERF_StartSwitchDisplay, "OFF" );
        SetControlBackColor( "PERF", "EnvVar:ENV_PERF_StartSwitchDisplay", MakeRGB( 192, 192, 192 ) );

        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance stopped at: " );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "%s\n", PERF_cTimeBuffer );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }

        // calculate the run time (from start to stop)
        // debug
        if( boDebug_StartSwitch )
        { 
            write( "PERF: start: years %d, day of the year %d, hours %d, minutes %d, seconds %d",
                   PERF_lDateTimeStart[ 5 ], PERF_lDateTimeStart[ 7 ], PERF_lDateTimeStart[ 2 ],
                   PERF_lDateTimeStart[ 1 ], PERF_lDateTimeStart[ 0 ] );
            write( "PERF: stop: years %d, day of the year %d, hours %d, minutes %d, seconds %d",
                   PERF_lDateTimeStop[ 5 ], PERF_lDateTimeStop[ 7 ], PERF_lDateTimeStop[ 2 ],
                   PERF_lDateTimeStop[ 1 ], PERF_lDateTimeStop[ 0 ] );
        }
        // start time in seconds
        PERF_lStartTimeInSeconds = ( ( ( PERF_lDateTimeStart[ 5 ] * 365 ) + PERF_lDateTimeStart[ 7 ] ) * 86400 ) + 
                                   ( PERF_lDateTimeStart[ 2 ] * 3600 ) +
                                   ( PERF_lDateTimeStart[ 1 ] * 60 ) +
                                   PERF_lDateTimeStart[ 0 ];
        // stop time in seconds
        PERF_lStopTimeInSeconds = ( ( ( PERF_lDateTimeStop[ 5 ] * 365 ) + PERF_lDateTimeStop[ 7 ] ) * 86400 ) + 
                                  ( PERF_lDateTimeStop[ 2 ] * 3600 ) +
                                  ( PERF_lDateTimeStop[ 1 ] * 60 ) +
                                  PERF_lDateTimeStop[ 0 ];
        // run time
        PERF_lRunTimeInSeconds = PERF_lStopTimeInSeconds - PERF_lStartTimeInSeconds;

        // stop (but not de-init) performance tests
        PERF_boPerformanceTestsRunning = FALSE;
        vPERF_MeasurementStop();
    }
}

on timer msPERF_CarouselRotationTimer
{
    // calculated delay time for next state
    int iDelayTime;
    int boDebug_CyclicCarouselRotationTimer = 0;   // 1 := debug output enabled
   
    if( bCarouselRunningState == PERF_RUNNING )
    {
        if( boDebug_CyclicCarouselRotationTimer )
            write( "PERF: Carousel rotation" );

        // still running
        putValue( ENV_PERF_ScenarioDescription_2, "Carousel rotation" );

        if( PERF_boCarouselButtonHasBeenPressed == 1 )
        {
            // a carousel button was pressed, release it now
            putValue( ENV_KeyMenuUpState, 0 );
            PERF_boCarouselButtonHasBeenPressed = 0;    // clear

            // after one carousel rotation the active display should be the BC display
            if( PERF_boCarouselRotationFinished == 1 )   // the BC display
            {
                // lock the carousel
                PERF_boCarouselRotationFinished = 0;

                // stop carousel cyclic timer
                cancelTimer( msPERF_CarouselRotationTimer );
                putValue( ENV_PERF_ScenarioDescription_2, "Carousel rotation halted" );

                // the BC is the active display and can now will be rotated
                PERF_boCarouselBcActiveAndRotate = 1;
                putValue( ENV_PERF_ScenarioDescription_3, "BC role rotation released" );

                // press the MFL OK wheel button, go fast into BAP client
                vPERF_PressMflButton( MFL_OK_BUTTON, OK_BUTTON_RELEASE_TIME );

                // check if delay time for next state is defined correctly
                iDelayTime = vPERF_CheckDelayTime( PERF_iMflRotationCyclicTime,
                                                   OK_BUTTON_RELEASE_TIME );
                // start a new MFL role rotation cycle
                if( isTimerActive( msPERF_MflRotationTimer ) )
                {
                    cancelTimer( msPERF_MflRotationTimer );
                }
                setTimer( msPERF_MflRotationTimer, iDelayTime );
            }
            else
            {
                // restart the normal carousel cycle
                setTimer( msPERF_CarouselRotationTimer, PERF_iCarouselRotationCyclicTime );
            }
        }
        else
        {   
            // normal rotation, not releasing a button pressure

            // but do not proccess if the BC display is rotate
            if( PERF_boCarouselBcActiveAndRotate != 1)
            {
                // press the up button     
                PERF_boCarouselButtonHasBeenPressed = 1;    // button pressed
                putValue( ENV_KeyMenuUpState, 1 );
                // restart timer, button release time
                setTimer( msPERF_CarouselRotationTimer, MFL_BUTTON_RELEASE_TIME );

                if( ++PERF_iCarouselKeyStroke < PERF_iCarouselMembers )
                {
                    // carousel not finished
                    if( boDebug_CyclicCarouselRotationTimer )
                        write( "PERF: select next carousel %d", PERF_iCarouselKeyStroke );
                }
                else
                {
                    if( boDebug_CyclicCarouselRotationTimer )
                        write( "PERF: One carousel rotation finished" );
                    // rotate the carousel, if max carousel member reached restart the counter
                    PERF_boCarouselRotationFinished = 1;
                    PERF_iCarouselKeyStroke = 0;
                }
            }
        }
    }
}

on timer msPERF_MflRotationTimer
{
    int boDebug_CyclicMflRotationTimer = 0;   // 1 := debug output enabled
     
    if( bMFLRotationRunningState == PERF_RUNNING )
    {
        if( boDebug_CyclicMflRotationTimer )
            write( "PERF: BC role rotation" );

        // still running
        putValue( ENV_PERF_ScenarioDescription_3, "BC role rotation" );
      
        // a down/up rotation cycle has been finished -> the carousel can be released
        if( PERF_boMflWheelRotationFinished == 1 )
        {            
            if( boDebug_CyclicMflRotationTimer )
                write( "PERF: BC role finished" );
            // one down/up cycle has been finished 
            PERF_boMflWheelRotationFinished = 0;   
                
            // stop MFL cyclic timer
            cancelTimer( msPERF_MflRotationTimer );
            putValue( ENV_PERF_ScenarioDescription_3, "BC role rotation halted" );
                
            PERF_boCarouselBcActiveAndRotate = 0;    // release the carousel
            // start carousel cyclic timer
            if( isTimerActive( msPERF_CarouselRotationTimer ) )
            {
                cancelTimer( msPERF_CarouselRotationTimer );
            }
            setTimer( msPERF_CarouselRotationTimer, PERF_iCarouselRotationCyclicTime );

            putValue( ENV_PERF_ScenarioDescription_2, "Carousel rotation released" );

            // no 
        }
        else
        {
            // no end of MFL role rotation cycle
            // no MFL button was pressed -> proccess with MFL button

            // flip the BC only if enabled by carousel, BC selected
            if( PERF_boCarouselBcActiveAndRotate == 1 )
            {
                // press up/down wheel button     
                if( PERF_boMflWheelUpDownDirection == MFL_WHEEL_DOWN )
                {
                    // down direction
                    if( boDebug_CyclicMflRotationTimer )
                        write( "PERF: BC role DOWN, key hits %d, max keys %d", PERF_iMflWheelKeyStrokes, PERF_iMflKeyStrokesUp );
                    
                    if( PERF_iMflWheelKeyStrokes < PERF_iMflKeyStrokesDown )
                    {
                        vPERF_PressMflButton( MFL_KEY_DOWN_BUTTON, MFL_BUTTON_RELEASE_TIME );
                        PERF_iMflWheelKeyStrokes++;
                        // restart timer for normal proccessing the next flip-card 
                        setTimer( msPERF_MflRotationTimer, PERF_iMflRotationCyclicTime );
                    }
                    else
                    {   
                        if( boDebug_CyclicMflRotationTimer )
                            write( "PERF: BC role DOWN limit reached" );
                        // limit reached
                        PERF_boMflWheelUpDownDirection = MFL_WHEEL_UP;   // from now on UP
                        switch( PERF_iCarModel )
                        {
                            case MODEL_AUDI_COLOR:
                                // change the direction but don't press a button
                                /* no break */
                            case MODEL_VW_COLOR:
                                // change the direction but don't press a button
                                PERF_iMflWheelKeyStrokes = 0;    // resets counter
                                break;
                        }
                        // restart timer for fast proccessing the start of a new flip-card cycle 
                        setTimer( msPERF_MflRotationTimer, PERF_MFL_SHORT_DELAY );
                    }
                }
                else
                {
                    // up direction
                    if( boDebug_CyclicMflRotationTimer )
                        write( "PERF: BC role UP, key hits %d, max keys %d", PERF_iMflWheelKeyStrokes, PERF_iMflKeyStrokesUp );

                    if( PERF_iMflWheelKeyStrokes < PERF_iMflKeyStrokesUp )
                    {
                        vPERF_PressMflButton( MFL_KEY_UP_BUTTON, MFL_BUTTON_RELEASE_TIME );
                        PERF_iMflWheelKeyStrokes++;
                        // restart timer for normal proccessing the next flip-card 
                        setTimer( msPERF_MflRotationTimer, PERF_iMflRotationCyclicTime );
                    }
                    else
                    {
                        // one complete up-/down rotation has been finished
                        PERF_boMflWheelRotationFinished = 1;
                        PERF_boMflWheelUpDownDirection = MFL_WHEEL_DOWN;   // from now on DOWN
                        switch( PERF_iCarModel )
                        {
                            case MODEL_AUDI_COLOR:
                                // change the direction but don't press a button
                                PERF_iMflWheelKeyStrokes = 0;    // resets counter
                                // after the initial role we add the 'Date' FlipCard
                                PERF_iMflKeyStrokesDown = PERF_iMflMaxFlipCardsAudi + 1;
                                break;
                            case MODEL_VW_COLOR:
                                // change the direction but don't press a button
                                PERF_iMflWheelKeyStrokes = 0;    // resets counter
                                break;
                        }
                        // restart timer for fast proccessing the start of a new flip-card cycle 
                        setTimer( msPERF_MflRotationTimer, PERF_MFL_SHORT_DELAY );
                    }
                }
            }
        }
    }
}

on timer msPERF_PointerSweepTimer
{
    // Code re-used from SweepPointer_timer
	long Drehzahl;
    long Speedo_val;
    long Temp_val;	

    if( bPointerSweepRunningState == PERF_RUNNING )
    {
        // still running

        // Speed Pointer Sweep, proccessed by 'Speed + RPM' CANoe panel 

        // Revolution Pointer Sweep, proccessed by 'Speed + RPM' CANoe panel

        // Temperature Sweep
 //  //         Temp_val = getValue( eMO_ITM_Kuehlmittel_TempS );   // actual temperature
        if( ( ( Temp_val + PERF_lTempSteps ) < PERF_iTempMin ) || 
            ( ( Temp_val + PERF_lTempSteps ) > PERF_lTempMax ) )
	    {
            PERF_lTempSteps = -PERF_lTempSteps;
        }
        // setting new value
 //  //         putValue( eMO_ITM_Kuehlmittel_TempS, Temp_val + PERF_lTempSteps );
 //  //         //write( "PERF: eMO_ITM_Kuehlmittel_TempS %d", Temp_val + PERF_lTempSteps );

        // refresh
        setTimer( msPERF_PointerSweepTimer, PERF_iPointerSweepCyclicTime );
    }
}

vPERF_MeasurementInit()
{
    // initializes
    // contains the last pressed MFL button
    iMflButtonLastPressed = MFL_NO_BUTTON; 

    // pointer sweep
    bPointerSweepState = PERF_DEINITIALIZED;
    bPointerSweepRunningState = PERF_STOPPED;
    // Turn lights blinking
    bTurnLightsState= PERF_DEINITIALIZED;
    bTurnLightsRunningState = PERF_STOPPED;
    // Tank and KMT
    bTankKmtState= PERF_DEINITIALIZED;
    bTankKmtRunningState = PERF_STOPPED;
    // Dimming
    bDimmingSweepState= PERF_DEINITIALIZED;
    bDimmingSweepRunningState = PERF_STOPPED;
    // MFL rotation
    bMFLRotationState = PERF_DEINITIALIZED;
    bMFLRotationRunningState = PERF_STOPPED;
    // Carousel running
    bCarouselState = PERF_DEINITIALIZED;
    bCarouselRunningState = PERF_STOPPED;
    // Radio list running
    bRadioListState = PERF_DEINITIALIZED;
    bRadioListRunningState = PERF_STOPPED;

    // log
    if( PERF_LogFileHandle != 0)
    {
        snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Initializing started\n" );
        filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
    }
        
    // check the car model
    switch( PERF_iCarModel )
    {
        case MODEL_AUDI_COLOR:
            write( "PERF: Car model: AUDI Color" );
            write( "PERF: PERF_iMflMaxFlipCardsAudi %d", PERF_iMflMaxFlipCardsAudi );
            write( "PERF: PERF_iCarouselMembersAudi %d", PERF_iCarouselMembersAudi );
            putValue( ENV_PERF_HelpBox, "Car model: AUDI Color" );
            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF:   Car model: AUDI Color\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF:   Flip cards: %d\n", PERF_iMflMaxFlipCardsAudi );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF:   Carousels: %d\n", PERF_iCarouselMembersAudi );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }
            break;

        case MODEL_VW_COLOR:
            write( "PERF: Car model: VW Color" );
            write( "PERF: PERF_iMflMaxFlipCardsVW %d", PERF_iMflMaxFlipCardsVW );
            write( "PERF: PERF_iCarouselMembersVW %d", PERF_iCarouselMembersVW );
            putValue( ENV_PERF_HelpBox, "Car model: VW Color" );
            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF:   Car model: VW Color\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF:   Flip cards: %d\n", PERF_iMflMaxFlipCardsVW );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF:   Carousels: %d\n", PERF_iCarouselMembersVW );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }
            break;
    }

    // initializes the test functions if they are enabled

    // **** the 'Basic Load' section

    // 'Pointer' (speed and revolution) sweep
    if( @ENV_PERF_PointerSweepSwitch == 1 )
    {
        // prepare test environment
        vPERF_PointerSweep( PERF_INIT );
    }

    // 'Turn Lights' blinking
    if( @ENV_PERF_TurnLightsSwitch == 1 )
    {
        // prepare test environment
        vPERF_TurnLightsBlinking( PERF_INIT );
    }

    // 'Tank + KMT' static
    if( @ENV_PERF_TankKmtSwitch == 1 )
    {
        // prepare test environment
        vPERF_TankKmt( PERF_INIT );
    }

    // 'Dimming' (speed and revolution)
    if( @ENV_PERF_DimmingSweepSwitch == 1 )
    {
        // prepare test environment
        vPERF_DimmingSweep( PERF_INIT );
    }

    // **** end 'Basic Load' section

    // **** the performance scenarios

    bScenarioState = PERF_DEINITIALIZED;    // only one scenario will be selected

    switch( @ENV_PERF_ScenarioTableBox )
    {
        case PERF_NO_SCENARIO:
            write( "PERF: no performance scenario" );
            putValue( ENV_PERF_ScenarioDescription_1, "a scenario is not selected" );
            putValue( ENV_PERF_ScenarioDescription_2, "" );
            putValue( ENV_PERF_ScenarioDescription_3, "" );
            putValue( ENV_PERF_ScenarioDescription_4, "" );
            putValue( ENV_PERF_ScenarioDescription_5, "" );
            putValue( ENV_PERF_ScenarioDescription_6, "" );
        break;

        case PERF_SCENARIO_11:
            vPERF_Scenario11( PERF_INIT );
            break;

        case PERF_SCENARIO_12:
            vPERF_Scenario12( PERF_INIT );
            break;

        case PERF_SCENARIO_21:
            vPERF_Scenario21( PERF_INIT );
            break;

        case PERF_SCENARIO_22:
            vPERF_Scenario22( PERF_INIT );
            break;

        case PERF_SCENARIO_3:
            vPERF_Scenario3( PERF_INIT );
            break;

        default:
            write( "PERF: UNKNOWN performance scenario" );
            putValue( ENV_PERF_ScenarioDescription_1, "UNKNOWN performance scenario" );
            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: ERROR: UNKNOWN performance scenario: %d\n", @ENV_PERF_ScenarioTableBox );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }
            break;
    }   // end switch

// **** end performance scenarios

    // check if cyclic 'run control' timer is still running
    if( isTimerActive( msPERF_CyclicRunControlTimer ) )
    {
        cancelTimer( msPERF_CyclicRunControlTimer );
    }
    // start the cyclic 'run control' timer
    write( "PERF: start CyclicRunControlTimer: refresh cycle = %d", PERF_iCyclicRunControlTime );
    setTimer( msPERF_CyclicRunControlTimer, PERF_iCyclicRunControlTime );
}

vPERF_MeasurementStop()
{
    // stop all (running or not) test cases

    // run time to output window and log-file
    write( "PERF: test duration: %d seconds", PERF_lRunTimeInSeconds );
    // log
    if( PERF_LogFileHandle != 0)
    {
        snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: test duration: %d seconds\n",
                  PERF_lRunTimeInSeconds  );
        filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
    }

    // **** the 'Basic Load' section

    // 'Pointer' (speed and revolution) sweep
    if( @ENV_PERF_PointerSweepSwitch == 1 )
    {
        vPERF_PointerSweep( PERF_STOP );
    }

    // 'Turn Lights' blinking
    if( @ENV_PERF_TurnLightsSwitch == 1 )
    {
        vPERF_TurnLightsBlinking( PERF_STOP );
    }

    // 'Tank + KMT' static
    if( @ENV_PERF_TankKmtSwitch == 1 )
    {
        vPERF_TankKmt( PERF_STOP );
    }

    // 'Dimming' (speed and revolution)
    if( @ENV_PERF_DimmingSweepSwitch == 1 )
    {
        vPERF_DimmingSweep( PERF_STOP );
    }

    // **** end 'Basic Load' section

    // **** the performance scenarios

    switch( @ENV_PERF_ScenarioTableBox )
    {
        case PERF_NO_SCENARIO:
            write( "PERF: no performance scenario" );
            putValue( ENV_PERF_ScenarioDescription_1, "a scenario is not selected" );
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "run time: %d seconds", PERF_lRunTimeInSeconds );
            putValue( ENV_PERF_ScenarioDescription_2, PERF_cLogBuffer );
            break;

        case PERF_SCENARIO_11:
            vPERF_Scenario11( PERF_STOP );
            break;

        case PERF_SCENARIO_12:
            vPERF_Scenario12( PERF_STOP );

        case PERF_SCENARIO_21:
            vPERF_Scenario21( PERF_STOP );
            break;

        case PERF_SCENARIO_22:
            vPERF_Scenario22( PERF_STOP );
            break;

        case PERF_SCENARIO_3:
            vPERF_Scenario3( PERF_STOP );
            break;

        default:
            write( "PERF: UNKNOWN performance scenario" );
            putValue( ENV_PERF_ScenarioDescription_1, "UNKNOWN performance scenario" );
            break;
    }   // end switch
    
    // **** end performance scenarios

    // help text
    putValue( ENV_PERF_HelpBox, "Performance switch is OFF" );
}

on timer msPERF_MflButtonTimer
{
    // release the MFL button
    switch( iMflButtonLastPressed )
    {
        case MFL_OK_BUTTON:
            putValue( ENV_KeyOkWheelLeftState, 0 );
            break;
        case MFL_MENU_DOWN_BUTTON:
            putValue( ENV_KeyMenuDownState, 0 );
            break;
        case MFL_MENU_UP_BUTTON:
            putValue( ENV_KeyMenuUpState, 0 );
            break;
        case MFL_KEY_DOWN_BUTTON:
            // down direction
            switch( PERF_iCarModel )
            {
                case MODEL_AUDI_COLOR:
                    putValue( ENV_KeyWheelEventCodeLeft_M1, 0 );
                    break;
                case MODEL_VW_COLOR:
                    putValue( ENV_KeyDownState, 0 );
                    break;
            }
            break;
        case MFL_KEY_UP_BUTTON:
            // up direction
            switch( PERF_iCarModel )
            {   
                case MODEL_AUDI_COLOR:
                    putValue( ENV_KeyWheelEventCodeLeft_P1, 0 );
                    break;
                case MODEL_VW_COLOR:
                    putValue( ENV_KeyUpState, 0 );
                    break;
            }
            break;
        default:
            // wrong MFL button is pressed
            putValue( ENV_PERF_HelpBox, "Warning: MFL button not supported" );
            break;
    }

    // release the button reminder
    iMflButtonLastPressed = MFL_NO_BUTTON;
}

on envVar ENV_PERF_PointerSweepSwitch
{
    if( @ENV_PERF_PointerSweepSwitch == 1 )
    {
        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Basic load: 'Pointer' sweep enabled\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }

        // prepare test environment
        vPERF_PointerSweep( PERF_INIT );
    }
    else
    {
        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Basic load: 'Pointer' sweep disabled\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }

        // stop it
        vPERF_PointerSweep( PERF_STOP );

        // set panel switch 'Pointer Sweep' OFF
        putValue( ENV_PERF_PointerSweepSwitch, FALSE );

        putValue( ENV_PERF_PointerBox, "'Pointer' sweep de-initialized" );

        // update state
        bPointerSweepState = PERF_DEINITIALIZED;
    }
}

on timer msPERF_RadioListTimer
{
    // scoll down the RADIO list
    // change to one BAP item up and activate fast with OK button
    // go one BAP item back to RADIO and scroll down list
    // prepare: start with RADIO screen

    int boDebug_CyclicRadioListTimer = 0;   // 1 := debug output enabled

    // calculated delay time for next state
    int iDelayTime;

    if( bRadioListRunningState == PERF_RUNNING )
    {
        switch( PERF_iRadioBapState )
        {
            case BAP_RADIO_SCROLL:
                // scoll the radio list
                if( boDebug_CyclicRadioListTimer )
                    write( "PERF: Radio list scrolling" ); 
        
                switch( PERF_iRadioScrollState )
                {
                    case RADIO_SCROLL_LIST_DOWN_ONLY:   // scrolling down, no change to other BAP client
                        // scrolling down the radio list depends an the car type
                        switch( PERF_iCarModel )
                        {
                            case MODEL_AUDI_COLOR:
                                // only up-/down' scrolling available
                                // when 'endless' scrolling down the empty list entries can be selected

                                // restart down-/up cycle if a complete down- and up-cycle has been finished
                                if( PERF_iRadioListScrollDownCnt >= ( 2 * ( PERF_iRadioListEntries - 1 ) ) )
                                {
                                    // restart with a new up-/down cycle
                                    PERF_iRadioListScrollDownCnt = 0;
                                }
                                if( PERF_iRadioListScrollDownCnt < ( PERF_iRadioListEntries - 1 ) )
                                {
                                    // scrolling down
                                    if( boDebug_CyclicRadioListTimer )
                                        write( "PERF: Radio list scroll down" ); 
                                    // sroll down 1 step
                                    vPERF_PressMflButton( MFL_KEY_DOWN_BUTTON, MFL_BUTTON_RELEASE_TIME );
                                    // next down button
                                    PERF_iRadioListScrollDownCnt++;
                                }
                                else
                                {
                                    // scrolling up
                                    if( boDebug_CyclicRadioListTimer )
                                        write( "PERF: Radio list scroll up" ); 
                                    // sroll up 1 step
                                    vPERF_PressMflButton( MFL_KEY_UP_BUTTON, MFL_BUTTON_RELEASE_TIME );
                                    // next down button
                                    PERF_iRadioListScrollDownCnt++;
                                }
                                break;
                            case MODEL_VW_COLOR:
                                // 'endless' scrolling down available 
                                if( boDebug_CyclicRadioListTimer )
                                    write( "PERF: Radio list scroll down" ); 
                                // sroll down 1 step
                                vPERF_PressMflButton( MFL_KEY_DOWN_BUTTON, MFL_BUTTON_RELEASE_TIME );
                                break;
                        }
                        // check if delay time for next state is defined correctly
                        iDelayTime = vPERF_CheckDelayTime( PERF_iRadioStayInListEntryTime,
                                                           MFL_BUTTON_RELEASE_TIME );
                        // restart cyclic timer with staying some 100 ms in this list entry
                        setTimer( msPERF_RadioListTimer, iDelayTime );
                        break;

                    case RADIO_SCROLL_LIST_DOWN:    // scrolling the list
                        // check if list has been scrolled down
                        if( PERF_iRadioListScrollDownCnt < PERF_iRadioListEntries )
                        {
                            if( boDebug_CyclicRadioListTimer )
                                write( "PERF: Radio list scroll down" ); 
                            // sroll down 1 step
                            vPERF_PressMflButton( MFL_KEY_DOWN_BUTTON, MFL_BUTTON_RELEASE_TIME );
                            // next down button
                            PERF_iRadioListScrollDownCnt++;
                            // check if delay time for next state is defined correctly in ini-file
                            iDelayTime = vPERF_CheckDelayTime( PERF_iRadioStayInListEntryTime,
                                                               MFL_BUTTON_RELEASE_TIME );
                            // restart cyclic timer with staying some 100 ms in this list entry
                            setTimer( msPERF_RadioListTimer, iDelayTime );
                        }
                        else
                        {
                            if( boDebug_CyclicRadioListTimer )
                                write( "PERF: Radio list finished" ); 

                            // list finished -> prepare BAP client change
                            PERF_iRadioScrollState = RADIO_SCROLL_LIST_FINISHED;
                            PERF_iRadioListScrollDownCnt = 0;            // resets list down counter
                            // restart cyclic timer
                            setTimer( msPERF_RadioListTimer, iDelayTime );  // fast repeat
                        } 
                        break;

                    case RADIO_SCROLL_LIST_FINISHED:    // change to next BAP client
                        if( boDebug_CyclicRadioListTimer )
                            write( "PERF: select BAP (up) client" ); 
                        
                        // if radio list has been finished go one step up with BAP
                        PERF_iRadioBapState = BAP_RADIO_SELECT_BAP_CLIENT_UP;
                        
                        // carousel 1 step up            
                        vPERF_PressMflButton( MFL_MENU_UP_BUTTON, MFL_BUTTON_RELEASE_TIME );

                        // next internal scroll state
                        PERF_iRadioScrollState = RADIO_SCROLL_LIST_DOWN;
                        // restart cyclic timer with releasing button
                        setTimer( msPERF_RadioListTimer, MFL_BUTTON_RELEASE_TIME + PERF_MFL_SHORT_DELAY );
                        break;

                    default:
                        break;
                }  // end switch
                break;

            case BAP_RADIO_SELECT_BAP_CLIENT_UP:    // go into BAP client
                if( boDebug_CyclicRadioListTimer )
                    write( "PERF: go into BAP client" ); 

                // go into BAP, pressing OK button
                vPERF_PressMflButton( MFL_OK_BUTTON, OK_BUTTON_RELEASE_TIME /* ms release time */ );
                // next state
                PERF_iRadioBapState = BAP_RADIO_SELECT_RADIO;
                // check if delay time for next state is defined correctly in ini-file
                iDelayTime = vPERF_CheckDelayTime( PERF_iRadioStayInBapClientUpTime,
                                                   OK_BUTTON_RELEASE_TIME );
                // wait some 100 ms, restart cyclic timer with normal cyclic time
                setTimer( msPERF_RadioListTimer, iDelayTime );
                break;

            case BAP_RADIO_SELECT_RADIO:
                if( boDebug_CyclicRadioListTimer )
                    write( "PERF: select Radio list" ); 

                // go one BAP step down to RADIO client
                vPERF_PressMflButton( MFL_MENU_DOWN_BUTTON, MFL_BUTTON_RELEASE_TIME /* ms release time */ );
                // next state
                PERF_iRadioBapState = BAP_RADIO_GOTO_RADIO;
                // wait until MFL button has been released
                setTimer( msPERF_RadioListTimer, MFL_BUTTON_RELEASE_TIME + PERF_MFL_SHORT_DELAY );
                break;

            case BAP_RADIO_GOTO_RADIO:
                if( boDebug_CyclicRadioListTimer )
                    write( "PERF: goto into Radio client" ); 

                // go into BAP, pressing OK button
                vPERF_PressMflButton( MFL_OK_BUTTON, OK_BUTTON_RELEASE_TIME /* ms release time */ );
                // next state
                PERF_iRadioBapState = BAP_RADIO_SCROLL;     // now scrolling the list can start
                // next internal scroll state
                PERF_iRadioScrollState = RADIO_SCROLL_LIST_DOWN;
                // check if delay time for next state is defined correctly in ini-file
                iDelayTime = vPERF_CheckDelayTime( PERF_iRadioListStayInRadioBeforeScrollingTime,
                                                   OK_BUTTON_RELEASE_TIME );
                // stay for few seconds in this BAP state
                setTimer( msPERF_RadioListTimer, iDelayTime );
                break;

            default:
                // wrong case, continue with RADIO screen
                write( "RADIO list: wrong test case" );
                putValue( ENV_PERF_RadioListBox, "Radio list has wrong test case" );

                PERF_iRadioBapState = BAP_RADIO_SCROLL;
                // next internal scroll state
                PERF_iRadioScrollState = RADIO_SCROLL_LIST_DOWN;
                // restart cyclic timer
                setTimer( msPERF_RadioListTimer, PERF_iRadioListStayInRadioBeforeScrollingTime + PERF_MFL_SHORT_DELAY );
                break;
        }  // end switch 
    }
    else
    {
    }
}

vPERF_BapRadioList( int State )
{
    switch( State )
    {
        case PERF_INIT:
            // initializes BAP- RADIO list scrolling
            //write( "PERF: init msPERF_RadioListTimer" );
            putValue( ENV_PERF_RadioListBox, "Prepare Radio list" );

            // counts the 'down' button pressures
            PERF_iRadioListScrollDownCnt = 0;
            // Radio list and BAP state maschine
            PERF_iRadioBapState = BAP_RADIO_SCROLL;    // when test started the RADIO must be in the display
            // internal scrolling state maschine
            PERF_iRadioScrollState = RADIO_SCROLL_LIST_DOWN;
    
            putValue( ENV_PERF_RadioListBox, "Radio list ready" );
            bRadioListState = PERF_INITIALIZED;
            break;

        case PERF_DEINIT:
            // de-initializing BAP- RADIO list scrolling
            cancelTimer( msPERF_RadioListTimer );
            bRadioListState = 0;

            // write( "PERF: msPERF_RadioListTimer de-activated" );
            bRadioListState = PERF_DEINITIALIZED;
            bRadioListRunningState = PERF_STOPPED;

            // set panel switch 'Radio List' OFF
            putValue( ENV_PERF_RadioListSwitch, FALSE );

            putValue( ENV_PERF_RadioListBox, "Radio list de-init" );
            break;

        default:
            break;
    }
}

vPERF_PointerSweep( int State )
{
    switch( State )
    {
        case PERF_INIT:
            // initializes pointer sweep
            putValue( ENV_PERF_PointerBox, "Initialize 'Pointer' sweep" );

            // clear Speedometer sweep settings
            putValue( ENV_SpeedSweep, 0 );         // stop speed pointer sweep, must be started in msPERF_CyclicRunControlTimer()
            putValue( ENV_SpeedRandom, 0 );        // stop random
            putValue( ENV_SpeedSingleSteps, 0 );
            putValue( ENV_SpeedInputIsMetric, 1 );
            putValue( ENV_SpeedStart, PERF_iSpeedStart );
            putValue( ENV_SpeedEnd, PERF_iSpeedEnd );
            putValue( ENV_SpeedSteps, PERF_iSpeedSteps );
            putValue( ENV_SpeedTime, PERF_iSpeedTime );
            putValue( ENV_Speed, 0 );              // starts from 0
            // Speedometer settings end

            // Revolution sweep settings
            putValue( ENV_RPMSweep, 0 );           // stop revolution pointer sweep, must be started in msPERF_CyclicRunControlTimer()
            putValue( ENV_RPMRandom, 0 );          // stops random
            putValue( ENV_RPMStart, PERF_iRpmStart );
            putValue( ENV_RPMEnd, PERF_iRpmEnd );
            putValue( ENV_RPMSteps, PERF_iRpmSteps );
            putValue( ENV_RPMTime, PERF_iRpmTime );
            putValue( KCAN_MO_Anzeigedrehz, 0 );   // starts from 0
            // Revolution sweep settings end

            putValue( ENV_PERF_PointerBox, "'Pointer' sweep initialized" );
            // update state
            bPointerSweepState = PERF_INITIALIZED;
            break;

        case PERF_STOP:
            // stop cyclic sweep timer
            cancelTimer( msPERF_PointerSweepTimer );

            //write( "PERF: Pointer sweep disabled" );
            // deactivate speed pointer sweep
            putValue( ENV_SpeedSweep, 0 );         // stops sweep

            putValue( ENV_SpeedRandom, 0 );        // stop random
            putValue( ENV_SpeedSingleSteps, 0 );
            putValue( ENV_SpeedInputIsMetric, 1 );
            putValue( ENV_SpeedStart, PERF_iSpeedStart );
            putValue( ENV_SpeedEnd, PERF_iSpeedEnd );
            putValue( ENV_SpeedSteps, PERF_iSpeedSteps );
            putValue( ENV_SpeedTime, PERF_iSpeedTime );
            putValue( ENV_Speed, 0 );              // starts from 0

            // deactivate revolution pointer sweep
            // Revolution sweep settings
            putValue( ENV_RPMSweep, 0 );           // stops sweep

            putValue( ENV_RPMRandom, 0 );          // stops random
            putValue( ENV_RPMStart, PERF_iRpmStart );
            putValue( ENV_RPMEnd, PERF_iRpmEnd );
            putValue( ENV_RPMSteps, PERF_iRpmSteps );
            putValue( ENV_RPMTime, PERF_iRpmTime );
            putValue( KCAN_MO_Anzeigedrehz, 0 );   // starts from 0

            putValue( ENV_PERF_PointerBox, "'Pointer' sweep stopped" );

            // update state
            bPointerSweepRunningState = PERF_STOPPED;
            break;

        default:
            break;
    }
}

vPERF_PressMflButton( int iMflButton,     /* one of the MFL buttons */
                      int iReleaseTime    /* delay before releasing the button in ms */)
{
    // press one MFL button, starts msTimer and release MFL button when msTimmer expires
    // only one MFL button may be pressed

    if( iMflButtonLastPressed != MFL_NO_BUTTON )
    {
        // a MFL button is still pressed
        // maybe an overrun of OK button pressure
        putValue( ENV_PERF_HelpBox, "Warning: OK button overrun" );
    }

    // check if MFL button release msTimer is still running
    if( isTimerActive( msPERF_MflButtonTimer ) )
    {
        // maybe an overrun of OK button pressure
        putValue( ENV_PERF_HelpBox, "Warning: OK button overrun" );

        // stop a running OK button release timer
        cancelTimer( msPERF_MflButtonTimer );
    }

    // press the MFL button
    switch( iMflButton )
    {
        case MFL_OK_BUTTON:
            putValue( ENV_KeyOkWheelLeftState, 1 );
            break;
        case MFL_MENU_DOWN_BUTTON:
            putValue( ENV_KeyMenuDownState, 1 );
            break;
        case MFL_MENU_UP_BUTTON:
            putValue( ENV_KeyMenuUpState, 1 );
            break;
        case MFL_KEY_DOWN_BUTTON:
            // down direction
            switch( PERF_iCarModel )
            {
                case MODEL_AUDI_COLOR:
                    putValue( ENV_KeyWheelEventCodeLeft_M1, 1 );
                    break;
                case MODEL_VW_COLOR:
                    putValue( ENV_KeyDownState, 1 );
                    break;
            }
            break;
        case MFL_KEY_UP_BUTTON:
            // up direction
            switch( PERF_iCarModel )
            {   
                case MODEL_AUDI_COLOR:
                    putValue( ENV_KeyWheelEventCodeLeft_P1, 1 );
                    break;
                case MODEL_VW_COLOR:
                    putValue( ENV_KeyUpState, 1 );
                    break;
            }
            break;
        default:
            // wrong MFL button is pressed
            putValue( ENV_PERF_HelpBox, "Warning: MFL button not supported" );
            break;
    }
    // set reminder for pressed MFL button
    iMflButtonLastPressed = iMflButton; 
    // prepare timer for releasing the MFL button
    setTimer( msPERF_MflButtonTimer, iReleaseTime );
}

int vPERF_CheckDelayTime( int iWaitForNextState,        /* planned delay time for next state entry */
                          int iWaitForButtonPerformed)  /* time for performing a MFL button */
{
    // check if delay time for next state is defined correctly
    // protecting an overrun of state maschines
    
    int iDelayTime;

    if( iWaitForNextState < ( iWaitForButtonPerformed + PERF_MFL_SHORT_DELAY ) )
    {
        // delay time for next state is too small
        // stay for few seconds in this BAP state
        iDelayTime = iWaitForButtonPerformed + PERF_MFL_SHORT_DELAY;
    }
    else
    {
        // stay for few seconds in this BAP state
        iDelayTime = iWaitForNextState;
    } 
    return iDelayTime;
}

on message PERF_Control
{
    switch( this.PerfActive )
    {
      case 0:
        putValue( ENV_PERF_StartSwitch, 0 );
        putValue( ENV_PERF_ScenarioTableBox, PERF_NO_SCENARIO );
        break;
      case 1: // PERF_NO_SCENARIO
        putValue( ENV_PERF_BasicLoadSwitch, 0 );
        putValue( ENV_PERF_BasicLoadSwitch, 1 );
        putValue( ENV_PERF_ScenarioTableBox, PERF_NO_SCENARIO );
        putValue( ENV_PERF_StartSwitch, 1 );
        break;
      case 2: // PERF_SCENARIO_11
        putValue( ENV_PERF_BasicLoadSwitch, 0 );
        putValue( ENV_PERF_BasicLoadSwitch, 1 );
        putValue( ENV_PERF_ScenarioTableBox, PERF_SCENARIO_11 );
        putValue( ENV_PERF_StartSwitch, 1 );
        break;
      case 3: // PERF_SCENARIO_12
        putValue( ENV_PERF_BasicLoadSwitch, 0 );
        putValue( ENV_PERF_BasicLoadSwitch, 1 );
        putValue( ENV_PERF_ScenarioTableBox, PERF_SCENARIO_12 );
        putValue( ENV_PERF_StartSwitch, 1 );
        break;
      case 4: // PERF_SCENARIO_21
        putValue( ENV_PERF_BasicLoadSwitch, 0 );
        putValue( ENV_PERF_BasicLoadSwitch, 1 );
        putValue( ENV_PERF_ScenarioTableBox, PERF_SCENARIO_21 );
        putValue( ENV_PERF_StartSwitch, 1 );
        break;
      case 5: // PERF_SCENARIO_22
        putValue( ENV_PERF_BasicLoadSwitch, 0 );
        putValue( ENV_PERF_BasicLoadSwitch, 1 );
        putValue( ENV_PERF_ScenarioTableBox, PERF_SCENARIO_22 );
        putValue( ENV_PERF_StartSwitch, 1 );
        break;
      case 6: // PERF_SCENARIO_3
        putValue( ENV_PERF_BasicLoadSwitch, 0 );
        putValue( ENV_PERF_BasicLoadSwitch, 1 );
        putValue( ENV_PERF_ScenarioTableBox, PERF_SCENARIO_3 );
        putValue( ENV_PERF_StartSwitch, 1 );
        break;
      default:
        putValue( ENV_PERF_StartSwitch, 0 );
        putValue( ENV_PERF_ScenarioTableBox, PERF_NO_SCENARIO );
        break;
    }
}

on envVar ENV_PERF_BasicLoadSwitch
{
    if( @ENV_PERF_BasicLoadSwitch == 1 )
    {
        // enabling 'Basic Load' switch will also enable:
        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Basic Load enabled\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }
        putValue( ENV_PERF_PointerSweepSwitch, 1 );
        putValue( ENV_PERF_TurnLightsSwitch, 1 );
        putValue( ENV_PERF_TankKmtSwitch, 1 );
        putValue( ENV_PERF_DimmingSweepSwitch, 1 );
    }
    else
    {
        // disabling 'Basic Load' switch will also disable:
        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Basic Load disabled\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
       }
        putValue( ENV_PERF_PointerSweepSwitch, 0 );
        putValue( ENV_PERF_TurnLightsSwitch, 0 );
        putValue( ENV_PERF_TankKmtSwitch, 0 );
        putValue( ENV_PERF_DimmingSweepSwitch, 0 );
    }
}

on envVar ENV_PERF_TurnLightsSwitch
{
    if( @ENV_PERF_TurnLightsSwitch == 1 )
    {
        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Basic load: 'Turn Lights' blinking enabled\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }

        // prepare test environment
        vPERF_TurnLightsBlinking( PERF_INIT );
    }
    else
    {
        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Basic load: 'Turn Lights' blinking disabled\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }

        // stop it
        vPERF_TurnLightsBlinking( PERF_STOP );

        // set panel switch 'TurnLights' OFF
        putValue( ENV_PERF_TurnLightsSwitch, FALSE );
        
        putValue( ENV_PERF_TurnLightsBox, "'Turn Lights' de-initialized" );

        // update state
        bTurnLightsState = PERF_DEINITIALIZED;
    }
}

vPERF_TurnLightsBlinking( int State )
{
    switch( State )
    {
        case PERF_INIT:
            // initialize Turn Light blinking
            putValue( ENV_PERF_TurnLightsBox, "Initialize 'Turn Lights'" );

            // init nothing todo: 'Warnblinken' uses 'RBS_Sweep:Blinkmodi_02' CANoe node

            // initializes pointer sweep
            putValue( ENV_PERF_TurnLightsBox, "'Turn Lights' initialized" );

            // update state
            bTurnLightsState = PERF_INITIALIZED;
            break;

        case PERF_STOP:
            // uses 'RBS_Sweep:Blinkmodi_02' CANoe node
            write( "PERF: stop Warnblinken" );
            putValue( KCAN_BM_Warnblinken, 0 );

            putValue( ENV_PERF_TurnLightsBox, "'Turn Lights' blinking stopped" );

            // update state
            bTurnLightsRunningState = PERF_STOPPED;
            break;

        default:
            break;
    }
}

on envVar ENV_PERF_TankKmtSwitch
{
    if( @ENV_PERF_TankKmtSwitch == 1 )
    {
        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Basic load: 'Tank + KMT' enabled\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }

        // prepare test environment
        vPERF_TankKmt( PERF_INIT );
    }
    else
    {
        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Basic load: 'Tank + KMT' disabled\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }

        // stop it
        vPERF_TankKmt( PERF_STOP );

        // set panel switch 'Tank + KMT' OFF
        putValue( ENV_PERF_TankKmtSwitch, FALSE );
        
        putValue( ENV_PERF_TankKmtBox, "'Tank + KMT' de-initialized" );

        // update state
        bTankKmtState = PERF_DEINITIALIZED;
    }
}

vPERF_TankKmt( int State )
{
    switch( State )
    {
        case PERF_INIT:
            putValue( ENV_PERF_TankKmtBox, "Initialize 'Tank + KMT'" );
    
            // as both tank and KMT are driven statically nothing to do
            // initialize Tank
            // no possibility to influence the tank sensor

            // and KMT (static)
 //  //             putValue( eMO_ITM_Kuehlmittel_TempS, PERF_iTempDefaultValue );   // default temperature

            putValue( ENV_PERF_TankKmtBox, "'Tank + KMT' initialized" );

            // update state
            bTankKmtState = PERF_INITIALIZED;

            break;

        case PERF_STOP:
            // as both tank and KMT are driven statically nothing to do

            // as both tank and KMT are driven statically nothing to do

            putValue( ENV_PERF_TankKmtBox, "'Tank + KMT' stopped" );

            // update state
            bTankKmtRunningState = PERF_STOPPED;
            break;

        default:
            break;
    }
}

on envVar ENV_PERF_DimmingSweepSwitch
{
    if( @ENV_PERF_DimmingSweepSwitch == 1 )
    {
        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Basic load: 'Dimming' sweep enabled\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }

        // prepare test environment
        vPERF_DimmingSweep( PERF_INIT );
    }
    else
    {
        // log
        if( PERF_LogFileHandle != 0)
        {
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Basic load: 'Dimming' sweep disabled\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }

        // stop it
        vPERF_DimmingSweep( PERF_STOP );

        // set panel switch 'Dimming' OFF
        putValue( ENV_PERF_DimmingSweepSwitch, FALSE );
        
        putValue( ENV_PERF_DimmingSweepBox, "'Dimming' sweep de-initialized" );

        // update state
        bDimmingSweepState = PERF_DEINITIALIZED;
    }
}

vPERF_DimmingSweep( int State )
{
    switch( State )
    {
        case PERF_INIT:
            // prepare dimming sweep display, pointer and scale
            putValue( ENV_PERF_DimmingSweepBox, "Initialize 'Dimming'" );
    
            // 58xd: Scale and Display
            PERF_iDimmingKl58xdValue = PERF_iDimmingKl58xdValueDefault;
            //write( "PERF: PERF_INIT: KCAN_DI_KL_58xd %d", PERF_iDimmingKl58xdValue );
            PERF_DimmingKl58xdDirection = 0;          // upcount

            // Pointer ilumination
            PERF_DimmingKl58xtValue = PERF_iDimmingKl58xtValueStart;
            //write( "PERF: PERF_INIT: KCAN_DI_KL_58xt %d", PERF_DimmingKl58xtValue );
            PERF_DimmingKl58xtDirection = 0;          // upcount

            putValue( ENV_PERF_DimmingSweepBox, "'Dimming' sweep initialized" );

            // update state
            bDimmingSweepState = PERF_INITIALIZED;
            break;

        case PERF_STOP:
            // stop dimming sweep display, pointer and scale
            cancelTimer( msPERF_SweepDimmingTimer );
            putValue( KCAN_DI_KL_58xd, PERF_iDimmingKl58xdValueDefault );
            
            // Pointer ilumination
            //write( "PERF: PERF_STOP: KCAN_DI_KL_58xt %d", PERF_iDimmingKl58xtValueDefault );
            putValue( KCAN_DI_KL_58xt, PERF_iDimmingKl58xtValueDefault );

            putValue( ENV_PERF_DimmingSweepBox, "'Dimming' sweep stopped" );

            // update state
            bDimmingSweepRunningState = PERF_STOPPED;
            break;

        default:
            break;
    }
}

on envVar ENV_PERF_ScenarioTableBox
{
    write( "PERF: actual scenario = %d, new scenario = %d", PERF_ActualScenario, getValue( ENV_PERF_ScenarioTableBox ) );

    // if the scenario has been changed while the performance test is running
    if( PERF_ActualScenario != getValue( ENV_PERF_ScenarioTableBox ) )
    {
        // stop the last 'running' scenario
        switch( PERF_ActualScenario )
        {
            case PERF_NO_SCENARIO:
                // there was no scenario selected before, nothing to do
                break;

            case PERF_SCENARIO_11:
                vPERF_Scenario11( PERF_STOP );
                break;

            case PERF_SCENARIO_12:
                vPERF_Scenario12( PERF_STOP );
                break;

            case PERF_SCENARIO_21:
                vPERF_Scenario21( PERF_STOP );
                break;

            case PERF_SCENARIO_22:
                vPERF_Scenario22( PERF_STOP );
                break;

            case PERF_SCENARIO_3:
                vPERF_Scenario3( PERF_STOP );
                break;

            default:
                write( "PERF: UNKNOWN performance scenario" );
                putValue( ENV_PERF_ScenarioDescription_1, "UNKNOWN performance scenario" );
                break;
        }
    }

    // clear the scenario info box
    putValue( ENV_PERF_ScenarioDescription_2, "" );
    putValue( ENV_PERF_ScenarioDescription_3, "" );
    putValue( ENV_PERF_ScenarioDescription_4, "" );
    putValue( ENV_PERF_ScenarioDescription_5, "" );
    putValue( ENV_PERF_ScenarioDescription_6, "" );

    // log
    if( PERF_LogFileHandle != 0)
    {
        snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Select a new scenario: " );
        filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
    }

    switch( @ENV_PERF_ScenarioTableBox )
    {
        case PERF_NO_SCENARIO:
            // log
            if( PERF_LogFileHandle != 0)
            {
                // append the new scenario to log-file
                filePutString( "nothing \n", elCount( "nothing \n" ), PERF_LogFileHandle );
            }

            write( "PERF: no performance scenario" );
            putValue( ENV_PERF_ScenarioDescription_1, "a scenario is not selected" );
            // stop all other scenarios
            PERF_ActualScenario = PERF_NO_SCENARIO; 
            break;

        case PERF_SCENARIO_11:
            // log
            if( PERF_LogFileHandle != 0)
            {
                // append the new scenario to log-file
                filePutString( "1\n", elCount( "2.1\n" ), PERF_LogFileHandle );
            }

            write( "PERF: performance scenario 1.1" );
            putValue( ENV_PERF_ScenarioDescription_1, "performance scenario 1.1" );
            vPERF_Scenario11( PERF_INIT );
            PERF_ActualScenario = PERF_SCENARIO_11; 
            break;

        case PERF_SCENARIO_12:
            // log
            if( PERF_LogFileHandle != 0)
            {
                // append the new scenario to log-file
                filePutString( "1\n", elCount( "2.1\n" ), PERF_LogFileHandle );
            }

            write( "PERF: performance scenario 1.2" );
            putValue( ENV_PERF_ScenarioDescription_1, "performance scenario 1.2" );
            vPERF_Scenario12( PERF_INIT );
            PERF_ActualScenario = PERF_SCENARIO_12; 
            break;

        case PERF_SCENARIO_21:
            // log
            if( PERF_LogFileHandle != 0)
            {
                // append the new scenario to log-file
                filePutString( "2.1\n", elCount( "2.1\n" ), PERF_LogFileHandle );
            }

            write( "PERF: performance scenario 2.1" );
            putValue( ENV_PERF_ScenarioDescription_1, "performance scenario 2.1" );
            vPERF_Scenario21( PERF_INIT );
            PERF_ActualScenario = PERF_SCENARIO_21; 
            break;

        case PERF_SCENARIO_22:
            // log
            if( PERF_LogFileHandle != 0)
            {
                // append the new scenario to log-file
                filePutString( "2.2\n", elCount( "2.2\n" ), PERF_LogFileHandle );
            }

            write( "PERF: performance scenario 2.2" );
            putValue( ENV_PERF_ScenarioDescription_1, "performance scenario 2.2" );
            vPERF_Scenario22( PERF_INIT );
            PERF_ActualScenario = PERF_SCENARIO_22; 
            break;

        case PERF_SCENARIO_3:
            // log
            if( PERF_LogFileHandle != 0)
            {
                // append the new scenario to log-file
                filePutString( "3\n", elCount( "3\n" ), PERF_LogFileHandle );
            }

            write( "PERF: performance scenario 3" );
            putValue( ENV_PERF_ScenarioDescription_1, "performance scenario 3" );
            vPERF_Scenario3( PERF_INIT );
            PERF_ActualScenario = PERF_SCENARIO_3; 
            break;

        default:
            // log
            if( PERF_LogFileHandle != 0)
            {
                // append the new scenario to log-file
                filePutString( "UNKNOWN performance scenario\n", elCount( "UNKNOWN performance scenario\n" ), PERF_LogFileHandle );
            }

            write( "PERF: UNKNOWN performance scenario" );
            putValue( ENV_PERF_ScenarioDescription_1, "UNKNOWN performance scenario" );
            break;
    }   // end switch
}

vPERF_Scenario11( int State )
{
    // Warnungstoggeln:
    //    Öldruckwarnung 
    //    Caroutline
    //    Blinkende LED
    //    OBD-LED
    //    Generatorwarnung

    char cWarning[ MAX_WARNINGS_LENGTH ];   // contains warning string
    int iWarning;                           // warnings index

    switch( State )
    {
        case PERF_INIT:
            //write( "PERF: init performance scenario 1" );
            putValue( ENV_PERF_ScenarioDescription_1, "Initialize performance scenario 1.1" );
            putValue( ENV_PERF_ScenarioDescription_2, "Warnings toggle initialized" );
            putValue( ENV_PERF_ScenarioDescription_3, "" );
            putValue( ENV_PERF_ScenarioDescription_4, "" );
            putValue( ENV_PERF_ScenarioDescription_5, "" );
            putValue( ENV_PERF_ScenarioDescription_6, "" );

            // clear toggle counter
            PERF_ToggleCnt = 0;

            // append the new scenario to log-file
            putValue( ENV_PERF_ScenarioDescription_1, "Performance scenario 1.1 initialized" );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance scenario 1.1 initialized\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: - eWIV_Oeldr_Warn_MotorS\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: - eMO_OBD2_LampeS\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: - eBEM_GeneratordiagnoseS\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: - eZV_HS_offenS\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }

            // update state
            bScenarioState = PERF_INITIALIZED;
            break;

        case PERF_STOP:
            cancelTimer( msPERF_WarningsToggleTimer );
            // update state
            bScenarioRunningState = PERF_STOPPED;

            for( iWarning = 0; iWarning < MAX_WARNINGS; iWarning++ )
            {
                // warning from warnings table
                strncpy( cWarning, PERF_WarningTable[ PERF_ToggleCnt ], MAX_WARNINGS_LENGTH);
                // warning OFF
                putValue( cWarning, 0 );
            }

            putValue( ENV_PERF_ScenarioDescription_1, "Performance scenario 1.1 stopped" );
            putValue( ENV_PERF_ScenarioDescription_2, "Warnings toggle stopped" );
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "run time: %d seconds", PERF_lRunTimeInSeconds );
            putValue( ENV_PERF_ScenarioDescription_3, PERF_cLogBuffer );
            
            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance scenario 1.1 stopped\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }

            break;

        default:
            break;
    }
}

vPERF_Scenario21( int State )
{
    // Tastenbedienung innerhalb eines Views:
    // MFA scrollen 2-mal hoch<->runter -> 2-mal ok, ..

    switch( State )
    {
        case PERF_INIT:
            //write( "PERF: performance scenario 2.1" );
            putValue( ENV_PERF_ScenarioDescription_1, "Initialize performance scenario 2.1" );
            putValue( ENV_PERF_ScenarioDescription_2, "" );
            putValue( ENV_PERF_ScenarioDescription_3, "" );
            putValue( ENV_PERF_ScenarioDescription_4, "" );
            putValue( ENV_PERF_ScenarioDescription_5, "" );
            putValue( ENV_PERF_ScenarioDescription_6, "" );

            // counts the 'down' button pressures
            PERF_iMfaListScrollCnt = 0;
            // internal scrolling state maschine
            PERF_iMfaScrollState = PERF_MFA_SCROLL_LIST_DOWN;

            putValue( ENV_PERF_ScenarioDescription_2, "MFA scrolling 2x up-down initialized" );

            // append the new scenario to log-file
            putValue( ENV_PERF_ScenarioDescription_1, "Performance scenario 2.1 initialized" );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance scenario 2.1 initialized\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: - MFA scrolling 2-up, 2-down, endless\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }

            // update state
            bScenarioState = PERF_INITIALIZED;
            break;

        case PERF_STOP:
            cancelTimer( msPERF_MfaScrollingTimer );
            // update state
            bScenarioRunningState = PERF_STOPPED;

            // clears all (hanging) MFL buttons
            vPERF_ClearMflButtons();

            putValue( ENV_PERF_ScenarioDescription_1, "Performance scenario 2.1 stopped" );
            putValue( ENV_PERF_ScenarioDescription_2, "MFA scrolling 2x up-down stopped" );
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "run time: %d seconds", PERF_lRunTimeInSeconds );
            putValue( ENV_PERF_ScenarioDescription_3, PERF_cLogBuffer );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance scenario 2.1 stopped\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }

            break;

        default:
            break;
    }
}

vPERF_Scenario22( int State )
{
    // Tastenbedienung -> innerhalb eines Views:
    // Scrollen in Radioliste -> eine Richtung (BAP), unendlich

    switch( State )
    {
        case PERF_INIT:
            //write( "PERF: performance scenario 2.2" );
            putValue( ENV_PERF_ScenarioDescription_1, "Initialize performance scenario 2.2" );
            // initializes RADIO list scrolling
            putValue( ENV_PERF_ScenarioDescription_2, "Prepare Radio list" );
            putValue( ENV_PERF_ScenarioDescription_3, "" );
            putValue( ENV_PERF_ScenarioDescription_4, "" );
            putValue( ENV_PERF_ScenarioDescription_5, "" );
            putValue( ENV_PERF_ScenarioDescription_6, "" );

            // counts the 'down' button pressures
            PERF_iRadioListScrollDownCnt = 0;
            // Radio list and BAP state maschine: only down scrolling
            PERF_iRadioBapState = BAP_RADIO_SCROLL;    // when test started the RADIO must be in the display
            // internal scrolling state maschine
            PERF_iRadioScrollState = RADIO_SCROLL_LIST_DOWN_ONLY;
    
            putValue( ENV_PERF_ScenarioDescription_2, "Radio list initialized" );

            // append the new scenario to log-file
            putValue( ENV_PERF_ScenarioDescription_1, "Performance scenario 2.2 initialized" );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance scenario 2.2 initialized\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }

            // update state
            bScenarioState = PERF_INITIALIZED;
            break;

        case PERF_STOP:
            // de-initializing BAP- RADIO list scrolling
            cancelTimer( msPERF_RadioListTimer );
            // update state
            bScenarioRunningState = PERF_STOPPED;
            
            //bRadioListState = PERF_DEINITIALIZED;
            bRadioListRunningState = PERF_STOPPED;

            // clears all (hanging) MFL buttons
            vPERF_ClearMflButtons();

            putValue( ENV_PERF_ScenarioDescription_1, "Performance scenario 2.2 stopped" );
            putValue( ENV_PERF_ScenarioDescription_2, "Radio list stopped" );
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "run time: %d seconds", PERF_lRunTimeInSeconds );
            putValue( ENV_PERF_ScenarioDescription_3, PERF_cLogBuffer );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance scenario 2.2 stopped\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                // scrolling the radio list depends on the car model
                if( PERF_iCarModel == MODEL_AUDI_COLOR )
                {
                    // only up-/down' scrolling available
                    snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: - Radio list scrolling up and down\n" );
                    filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                }
                else
                {
                    // endless scrolling down
                    snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: - Radio list scrolling down, endless\n" );
                    filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                }
            }

            break;

        default:
            break;
    }
}

vPERF_Scenario3( int State )
{
    // Tastenbedienung -> Viewwechsel:
    // Carousel (VW) bzw. Menürolle (AUDI: Reiter)

    switch( State )
    {
        case PERF_INIT:
            //write( "PERF: performance scenario 3" );
            putValue( ENV_PERF_ScenarioDescription_1, "Initialize performance scenario 3" );
            // *** initializes Carousel rotation
            putValue( ENV_PERF_ScenarioDescription_2, "Prepare Carousel rotation" );
            putValue( ENV_PERF_ScenarioDescription_3, "" );
            putValue( ENV_PERF_ScenarioDescription_4, "" );
            putValue( ENV_PERF_ScenarioDescription_5, "" );
            putValue( ENV_PERF_ScenarioDescription_6, "" );

            PERF_boCarouselButtonHasBeenPressed = 0;     // no button pressed
            PERF_boCarouselBcActiveAndRotate = 1;        // BC display is active and should be rotated
            PERF_boCarouselRotationFinished = 0;         // 1 carousel rotation has not been finished
            switch( PERF_iCarModel )
            {
                case MODEL_AUDI_COLOR:
                    PERF_iCarouselMembers = PERF_iCarouselMembersAudi;
                    break;
                case MODEL_VW_COLOR:
                    PERF_iCarouselMembers = PERF_iCarouselMembersVW;
                    break;
            }
            putValue( ENV_PERF_ScenarioDescription_2, "Carousel rotation initialized" );

            // *** initializes BC role rotation
            putValue( ENV_PERF_ScenarioDescription_3, "Prepare BC role rotation" );

            PERF_boMflWheelUpDownDirection = MFL_WHEEL_DOWN;     // first direction is down
            PERF_PERF_boMflWheelButtonHasBeenPressed = 0;             // no button was pressed
            PERF_boMflWheelRotationFinished = 0;                 // up/down rotation has not been finished
            switch( PERF_iCarModel )
            {
                case MODEL_AUDI_COLOR:
                    PERF_iMflWheelKeyStrokes = 0;
                    // consider the 'Date' FlipCard 
                    PERF_iMflKeyStrokesUp   = PERF_iMflMaxFlipCardsAudi + 1;
                    PERF_iMflKeyStrokesDown = PERF_iMflMaxFlipCardsAudi;
                    break;
                case MODEL_VW_COLOR:
                    PERF_iMflWheelKeyStrokes = 0;
                    // initial keystrokes for up and down direction
                    PERF_iMflKeyStrokesUp = PERF_iMflMaxFlipCardsVW;
                    // for initial up role one more button must pressed for activationg role
                    PERF_iMflKeyStrokesDown = PERF_iMflMaxFlipCardsVW + 1;
                    break;
            }

            putValue( ENV_PERF_ScenarioDescription_3, "BC role initialized" );
            bMFLRotationState = PERF_INITIALIZED;

            // append the new scenario to log-file
            putValue( ENV_PERF_ScenarioDescription_1, "Performance scenario 3 initialized" );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance scenario 3 initialized\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                // MFL rotation alternate with carousel rotation
                if( PERF_iCarModel == MODEL_AUDI_COLOR )
                {
                    // small BS role rotation (n-times down, n-times up), alternate with carousel rotation
                    snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: - small BC role rotation alternate with carousel\n" );
                    filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                }
                else
                {
                    // MFL rotation (n-times down, n-times up), alternate with carousel rotation
                    snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: - MFL (flip cards) rotation alternate with carousel\n" );
                    filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                }
            }

            // update state
            bScenarioState = PERF_INITIALIZED;
            break;

        case PERF_STOP:
            // *** stop carousel cyclic timer
            cancelTimer( msPERF_CarouselRotationTimer );
            //bCarouselState = PERF_DEINITIALIZED;
            bCarouselRunningState = PERF_STOPPED;
            putValue( ENV_PERF_ScenarioDescription_2, "Carousel rotation stopped" );

            // *** stop MFL cyclic timer
            if( isTimerActive( msPERF_MflRotationTimer ) )
                cancelTimer( msPERF_MflRotationTimer );
            // update state
            bScenarioRunningState = PERF_STOPPED;
    
            // clears all (hanging) MFL buttons
            vPERF_ClearMflButtons();

            bMFLRotationRunningState = PERF_STOPPED;
            putValue( ENV_PERF_ScenarioDescription_3, "BC role stopped" );

            putValue( ENV_PERF_ScenarioDescription_1, "Performance scenario 3 stopped" );
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "run time: %d seconds", PERF_lRunTimeInSeconds );
            putValue( ENV_PERF_ScenarioDescription_4, PERF_cLogBuffer );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance scenario 3 stopped\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }

            break;

        default:
            break;
    }
}

vPERF_MeasurementDeInit()
{
    // stop and de-activate all (running or not) test cases

    // **** the 'Basic Load' section

    // 'Pointer' sweep
    vPERF_PointerSweep( PERF_STOP );
    bPointerSweepState = PERF_DEINITIALIZED;

    // 'Turn Lights' blinking
    vPERF_TurnLightsBlinking( PERF_STOP );
    bTurnLightsState = PERF_DEINITIALIZED;

    // 'Tank and KMT' static
    vPERF_TankKmt( PERF_STOP );
    bTankKmtState = PERF_DEINITIALIZED;

    // 'Dimming' sweep
    vPERF_DimmingSweep( PERF_STOP );
    bDimmingSweepState = PERF_DEINITIALIZED;

    // **** end 'Basic Load' section

    // **** the performance scenarios

    switch( @ENV_PERF_ScenarioTableBox )
    {
        case PERF_NO_SCENARIO:
            write( "PERF: no performance scenario" );
            putValue( ENV_PERF_ScenarioDescription_1, "a scenario is not selected" );
            break;

        case PERF_SCENARIO_11:
            vPERF_Scenario11( PERF_STOP );
            break;

        case PERF_SCENARIO_12:
            vPERF_Scenario12( PERF_STOP );

        case PERF_SCENARIO_21:
            vPERF_Scenario21( PERF_STOP );
            break;

        case PERF_SCENARIO_22:
            vPERF_Scenario22( PERF_STOP );
            break;

        case PERF_SCENARIO_3:
            vPERF_Scenario3( PERF_STOP );
            break;

        default:
            write( "PERF: UNKNOWN performance scenario" );
            putValue( ENV_PERF_ScenarioDescription_1, "UNKNOWN performance scenario" );
            break;
    }   // end switch

    bScenarioState = PERF_DEINITIALIZED;

    // **** end performance scenarios

    // help text
    putValue( ENV_PERF_HelpBox, "Performance switch is OFF" );
}

on envVar ENV_PERF_Logging
{
    // enables logging of test states and results
    // older log files will be overwritten !

	if( getValue( ENV_PERF_Logging ) == 1 )
	{
        putValue( ENV_PERF_HelpBox, "Logging ON" );
        putValue( ENV_PERF_LoggingDisplay, "Logging ON" );

        // open the ini-file
        PERF_LogFileHandle = openFileWrite( PERF_cLogFileName, 0 /* ASCII */ );
        if( PERF_LogFileHandle == 0 )
        {
            write( "PERF: ERROR: cannot open File PerfLog.txt" );
            putValue( ENV_PERF_HelpBox, "ERROR: cannot open PerfLog.txt" );
            fileClose( PERF_LogFileHandle );
        }
        else
        {
            // write LOG header to file
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Filename: PerfLog.txt\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            // log start of logging
            getLocalTimeString( PERF_cTimeBuffer );
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Time:     %s\n", PERF_cTimeBuffer );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
        }
    }
    else
    {
        // close LOG file
        write( "PERF: Logging OFF" );
        putValue( ENV_PERF_HelpBox, "close LOG file" );
        putValue( ENV_PERF_LoggingDisplay, "Logging OFF" );

        // log
        if( PERF_LogFileHandle != 0)
        {
            // logging
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: PerfLog.txt is closing now\n" );
            filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );

            fileClose( PERF_LogFileHandle );
        }
    }

    // write back setting
    if( PERF_IniFileHandle != 0 )
    {
        writeProfileInt( "COMMON_SETTINGS", "PERF_LOGGING_CONTROL", getValue( ENV_PERF_Logging ), PERF_cIniFileName );
    }
}

on timer msPERF_SweepDimmingTimer
{
    // dimming sweep of scale-, display-ilumination 
    //write( "PERF: 1 PERF_iDimmingKl58xdValue %d", PERF_iDimmingKl58xdValue );
    if( PERF_DimmingKl58xdDirection == 0 )
    {
        PERF_iDimmingKl58xdValue += PERF_iDimmingKl58xdStep;
        if( PERF_iDimmingKl58xdValue > PERF_iDimmingKl58xdMax )
        {
            PERF_iDimmingKl58xdValue = PERF_iDimmingKl58xdMax;
            PERF_DimmingKl58xdDirection = 1; //downcount
        }
    }
    else
    {
        PERF_iDimmingKl58xdValue -= PERF_iDimmingKl58xdStep;
        if( PERF_iDimmingKl58xdValue < PERF_iDimmingKl58xdMin )
        {
            PERF_iDimmingKl58xdValue = PERF_iDimmingKl58xdMin;
            PERF_DimmingKl58xdDirection = 0; //upcount
        }
    }

    //write( "PERF: 2 PERF_iDimmingKl58xdValue %d", PERF_iDimmingKl58xdValue );
    putValue( KCAN_DI_KL_58xd, PERF_iDimmingKl58xdValue );

    // **** dimming pointer ilumination 

    //write( "PERF: 1 PERF_DimmingKl58xtValue %d", PERF_DimmingKl58xtValue );
    if( PERF_DimmingKl58xtDirection == 0 )
    {
        PERF_DimmingKl58xtValue += PERF_iDimmingKl58xtStep;
        if( PERF_DimmingKl58xtValue > PERF_iDimmingKl58xtMax )
        {
            PERF_DimmingKl58xtValue = PERF_iDimmingKl58xtMax;
            PERF_DimmingKl58xtDirection = 1; //downcount
        }
    }
    else
    {
        PERF_DimmingKl58xtValue -= PERF_iDimmingKl58xtStep;
        if( PERF_DimmingKl58xtValue < PERF_iDimmingKl58xtMin )
        {
            PERF_DimmingKl58xtValue = PERF_iDimmingKl58xtMin;
            PERF_DimmingKl58xtDirection = 0; //upcount
        }
    }
 
    //write( "PERF: msPERF_SweepDimmingTimer: PERF_DimmingKl58xtValue %d", PERF_DimmingKl58xtValue );
    putValue( KCAN_DI_KL_58xt, PERF_DimmingKl58xtValue );

    // **** restart timer
    if( PERF_DimmingCycle == 0 )
    {
        write( "   ERROR    Perf.ini not loaded, Simulation stopped ! ");
        stop();
    }    
    setTimer( msPERF_SweepDimmingTimer, PERF_DimmingCycle);
}

on timer msPERF_WarningsToggleTimer
{
    char cWarning[ MAX_WARNINGS_LENGTH ];
    int iWarningOnOffDelay;
    int boDebug_WarningsToggleTimer = 0;   // 1 := debug output enabled

    // consider array size
    if( PERF_ToggleCnt >= MAX_WARNINGS )
    {
        // restart from first warning entry
        PERF_ToggleCnt = 0;
    }

    // warning from warnings table
    strncpy( cWarning, PERF_WarningTable[ PERF_ToggleCnt ], MAX_WARNINGS_LENGTH);

    // new state
    if( PERF_WarningsToggleState )
	{
	    // warning ON
        // active time before this warning will be switched OFF
        iWarningOnOffDelay = PERF_WarningOnDelayTimeTable[ PERF_ToggleCnt ];
        if( boDebug_WarningsToggleTimer )
            write( "PERF: cWarning %s, ON, delay %d", cWarning, iWarningOnOffDelay );

        // warning ON
        putvalue( cWarning, 1 );

        // next OFF
        PERF_WarningsToggleState = 0;
    }
    else
    {
        // warning OFF
        // active time before next warning will be switched ON
        iWarningOnOffDelay = PERF_WarningOffDelayTimeTable[ PERF_ToggleCnt ];
        if( boDebug_WarningsToggleTimer )
            write( "PERF: cWarning %s, OFF, delay %d", cWarning, iWarningOnOffDelay );

        // warning OFF
        putvalue( cWarning, 0 );

        // next ON
        PERF_WarningsToggleState = 1;
        
        // next warning
        PERF_ToggleCnt++;
    }

    // refresh timer
    setTimer( msPERF_WarningsToggleTimer, iWarningOnOffDelay );
}

on timer msPERF_MfaScrollingTimer
{
    // start with 'Boardcomputer' at display
    // scroll down 2 times, press OK button immediately after 2. down
    // scroll up 2 times, press OK button immediately after 2. up
    // repeat

    int boDebug_MfaScrollingTimer = 0;   // 1 := debug output enabled
    
    switch( PERF_iMfaScrollState )
    {
        case PERF_MFA_SCROLL_LIST_DOWN:    // scrolling the MFA list down
            if( boDebug_MfaScrollingTimer )
                write( "PERF: MFA scroll down, count %d", PERF_iMfaListScrollCnt );
            // check if list has been scrolled down
            if( PERF_iMfaListScrollCnt < ( PERF_MFA_SCROLL_UP_DOWN_MAX - 1 ) )
            {
                // sroll down one more step
                vPERF_PressMflButton( MFL_KEY_DOWN_BUTTON, MFL_BUTTON_RELEASE_TIME );
                // next down button
                PERF_iMfaListScrollCnt++;
                // restart cyclic timer
                if( boDebug_MfaScrollingTimer )
                    write( "PERF: scroll repeat time %d", PERF_iMfaScrollingCycleTime );
                setTimer( msPERF_MfaScrollingTimer, PERF_iMfaScrollingCycleTime );
            }
            else if( PERF_iMfaListScrollCnt == ( PERF_MFA_SCROLL_UP_DOWN_MAX - 1) )
            {   
                // last button press in down direction
                if( boDebug_MfaScrollingTimer )
                    write( "PERF: last down button" );
                // sroll down one more step
                vPERF_PressMflButton( MFL_KEY_DOWN_BUTTON, MFL_BUTTON_RELEASE_TIME );
                // next down button
                PERF_iMfaListScrollCnt++;
                // restart cyclic timer
                if( boDebug_MfaScrollingTimer )
                    write( "PERF: scroll repeat time %d", PERF_iMfaScrollingWaitBeforeOkTime );
                // wait some 100 ms before pressing the OK button to enter the flip-card
                setTimer( msPERF_MfaScrollingTimer, PERF_iMfaScrollingWaitBeforeOkTime );
            }
            else
            {
                // finish down sequence with a OK button
                if( boDebug_MfaScrollingTimer )
                    write( "PERF: MFA scroll down, OK button" );
                // press OK button
                vPERF_PressMflButton( MFL_OK_BUTTON, MFL_BUTTON_RELEASE_TIME );
                // list finished -> prepare BAP client change
                PERF_iMfaScrollState = PERF_MFA_SCROLL_LIST_UP;
                PERF_iMfaListScrollCnt = 0; // resets up/down counter
                // restart cyclic timer
                if( boDebug_MfaScrollingTimer )
                    write( "PERF: scroll repeat time %d", PERF_iMfaScrollingCycleTime );
                setTimer( msPERF_MfaScrollingTimer, PERF_iMfaScrollingCycleTime );

            }
            break;

        default:    // scrolling the MFA list up
            if( boDebug_MfaScrollingTimer )
                write( "PERF: MFA scroll up, count %d", PERF_iMfaListScrollCnt );
            // check if list has been scrolled down
            if( PERF_iMfaListScrollCnt < ( PERF_MFA_SCROLL_UP_DOWN_MAX - 1 ) )
            {
                // sroll up one more step
                vPERF_PressMflButton( MFL_KEY_UP_BUTTON, MFL_BUTTON_RELEASE_TIME );
                // next up button
                PERF_iMfaListScrollCnt++;
                // restart cyclic timer
                if( boDebug_MfaScrollingTimer )
                    write( "PERF: scroll repeat time %d", PERF_iMfaScrollingCycleTime );
                setTimer( msPERF_MfaScrollingTimer, PERF_iMfaScrollingCycleTime );
            }
            else if( PERF_iMfaListScrollCnt == ( PERF_MFA_SCROLL_UP_DOWN_MAX - 1) )
            {   
                // last button press in up direction
                if( boDebug_MfaScrollingTimer )
                    write( "PERF: last up button" );
                // sroll down one more step
                vPERF_PressMflButton( MFL_KEY_UP_BUTTON, MFL_BUTTON_RELEASE_TIME );
                // next down button
                PERF_iMfaListScrollCnt++;
                // restart cyclic timer
                if( boDebug_MfaScrollingTimer )
                    write( "PERF: scroll repeat time %d", PERF_iMfaScrollingWaitBeforeOkTime );
                // wait some 100 ms before pressing the OK button to enter the flip-card
                setTimer( msPERF_MfaScrollingTimer, PERF_iMfaScrollingWaitBeforeOkTime );
            }
            else
            {
                // finish up sequence with a OK button
                if( boDebug_MfaScrollingTimer )
                    write( "PERF: MFA scroll up, OK button" );
                // press OK button
                vPERF_PressMflButton( MFL_OK_BUTTON, MFL_BUTTON_RELEASE_TIME );
                // list finished -> prepare BAP client change
                PERF_iMfaScrollState = PERF_MFA_SCROLL_LIST_DOWN;
                PERF_iMfaListScrollCnt = 0; // resets up/down counter
                // restart cyclic timer
                if( boDebug_MfaScrollingTimer )
                    write( "PERF: scroll repeat time %d", PERF_iMfaScrollingCycleTime );
                setTimer( msPERF_MfaScrollingTimer, PERF_iMfaScrollingCycleTime );
            }
            break;
    }   // end switch
}

on envVar ENV_PERF_CarModel
{
    // update panel
    switch( @ENV_PERF_CarModel )
    {
        case MODEL_AUDI_COLOR:
            putValue( ENV_PERF_CarModelDisplay, "AUDI" );
            putValue( ENV_PERF_HelpBox, "Car model: AUDI Color" );
            PERF_iCarModel = MODEL_AUDI_COLOR;
            break;
        case MODEL_VW_COLOR:
            putValue( ENV_PERF_CarModelDisplay, "VW" );
            putValue( ENV_PERF_HelpBox, "Car model: VW Color" );
            PERF_iCarModel = MODEL_VW_COLOR;
            break;
        default:
            // error msg but set to VW
            write( "PERF: wrong car model! %d", @ENV_PERF_CarModel );
            putValue( ENV_PERF_HelpBox, "Wrong Car model: use VW" );
            putValue( ENV_PERF_CarModelDisplay, "VW" );
            PERF_iCarModel = MODEL_VW_COLOR;
            break;
    }
    
    // write back setting
    if( PERF_IniFileHandle != 0 )
    {
        writeProfileInt( "CAR_MODEL", "CAR_MODEL", getValue( ENV_PERF_CarModel ), PERF_cIniFileName );
    }
}

vPERF_ClearMflButtons()
{
    // clears all (hanging) MFL buttons
    
    putValue( ENV_KeyMenuState, 0 );
    putValue( ENV_KeyOkWheelLeftState, 0 );
    putValue( ENV_KeyMenuDownState, 0 );
    putValue( ENV_KeyMenuUpState, 0 );
    switch( PERF_iCarModel )
    {
        case MODEL_AUDI_COLOR:
            putValue( ENV_KeyWheelEventCodeLeft_M1, 0 );
            putValue( ENV_KeyWheelEventCodeLeft_P1, 0 );
            break;
        case MODEL_VW_COLOR:
            putValue( ENV_KeyDownState, 0 );
            putValue( ENV_KeyUpState, 0 );
            break;
    }
    iMflButtonLastPressed = 0; 
}

vPERF_ReadInitValues( )
{
    // read the pre-defined parameters

    if( PERF_IniFileHandle != 0 )
    {
        // logging to a file is enabled/disabled
        // may be overwritten by panel control
        @ENV_PERF_Logging = getProfileInt( "COMMON_SETTINGS", "PERF_LOGGING_CONTROL", 0, PERF_cIniFileName );

        // the car model
        @ENV_PERF_CarModel = getProfileInt( "CAR_MODEL", "CAR_MODEL", 0, PERF_cIniFileName );

        // number of used FlipCards
        PERF_iMflMaxFlipCardsAudi = getProfileInt( "FLIP_CARDS", "MFL_MAX_FLIP_CARDS_AUDI", 0, PERF_cIniFileName );
        // number of used FlipCards
        PERF_iMflMaxFlipCardsVW = getProfileInt( "FLIP_CARDS", "MFL_MAX_FLIP_CARDS_VW", 0, PERF_cIniFileName );

        // number of used carousel members
        PERF_iCarouselMembersAudi = getProfileInt( "CAROUSEL_MEMBERS", "CAROUSEL_MEMBERS_AUDI", 0, PERF_cIniFileName );
        // number of used carousel members
        PERF_iCarouselMembersVW = getProfileInt( "CAROUSEL_MEMBERS", "CAROUSEL_MEMBERS_VW", 0, PERF_cIniFileName );

        // cyclic refresh time for running control
        PERF_iCyclicRunControlTime = getProfileInt( "CYCLIC_CONTROL", "CYCLIC_RUN_CONTROL_TIME", 0, PERF_cIniFileName );
        if( PERF_iCyclicRunControlTime < 100 )
        {   write( "PERF: ERROR: wrong CYCLIC_RUN_CONTROL_TIME in ini file" ); PERF_iCyclicRunControlTime = 100; } 

        // pointer sweep
        PERF_iPointerSweepCyclicTime = getProfileInt( "POINTER_SWEEP", "POINTER_SWEEP_CYCLIC_TIME", 0, PERF_cIniFileName );
        if( PERF_iPointerSweepCyclicTime < 100 )
        {   write( "PERF: ERROR: wrong POINTER_SWEEP_CYCLIC_TIME in ini file" ); PERF_iPointerSweepCyclicTime = 100; } 

        // For Pointer Sweep: Revolution
        PERF_iRpmStart = getProfileInt( "POINTER_SWEEP", "RPM_START", 0, PERF_cIniFileName );
        PERF_iRpmEnd = getProfileInt( "POINTER_SWEEP", "RPM_END", 0, PERF_cIniFileName );
        PERF_iRpmSteps = getProfileInt( "POINTER_SWEEP", "RPM_STEPS", 0, PERF_cIniFileName );
        PERF_iRpmTime = getProfileInt( "POINTER_SWEEP", "RPM_TIME", 0, PERF_cIniFileName );

        // For Pointer Sweep: Speed
        PERF_iSpeedStart = getProfileInt( "POINTER_SWEEP", "SPEED_START", 0, PERF_cIniFileName );
        PERF_iSpeedEnd = getProfileInt( "POINTER_SWEEP", "SPEED_END", 0, PERF_cIniFileName );
        PERF_iSpeedSteps = getProfileInt( "POINTER_SWEEP", "SPEED_STEPS", 0, PERF_cIniFileName );
        PERF_iSpeedTime = getProfileInt( "POINTER_SWEEP", "SPEED_TIME", 0, PERF_cIniFileName );

        // Pointer Temp static
        PERF_iTempDefaultValue = getProfileInt( "POINTER_SWEEP", "TEMP_DEFAULT", 0, PERF_cIniFileName );

        // For Pointer Sweep: Temp
        PERF_lTempMax = getProfileInt( "POINTER_SWEEP", "TEMP_MAX", 0, PERF_cIniFileName );
        PERF_iTempMin = getProfileInt( "POINTER_SWEEP", "TEMP_MIN", 0, PERF_cIniFileName );
        PERF_iTempSteps = getProfileInt( "POINTER_SWEEP", "TEMP_STEPS", 0, PERF_cIniFileName );

        // MFL rotation
        PERF_iMflRotationCyclicTime = getProfileInt( "MFL_ROTATION", "MFL_ROTATION_CYCLIC_TIME", 0, PERF_cIniFileName );
        if( PERF_iMflRotationCyclicTime < 100 )
        {   write( "PERF: ERROR: wrong MFL_ROTATION_CYCLIC_TIME in ini file" ); PERF_iMflRotationCyclicTime = 100; } 

        // Carousel rotation
        PERF_iCarouselRotationCyclicTime = getProfileInt( "CAROUSEL_ROTATION", "CAROUSEL_ROTATION_CYCLIC_TIME", 0, PERF_cIniFileName );
        if( PERF_iCarouselRotationCyclicTime < 100 )
        {   write( "PERF: ERROR: wrong CAROUSEL_ROTATION_CYCLIC_TIME in ini file" ); PERF_iCarouselRotationCyclicTime = 100; } 

        // BAP Radio scrolling
        // BAP rotation
        PERF_iBapRadioCyclicTime = getProfileInt( "RADIO_SCROLLING", "RADIO_LIST_CYCLIC_TIME", 0, PERF_cIniFileName );
        if( PERF_iBapRadioCyclicTime < 100 )
        {   write( "PERF: ERROR: wrong RADIO_LIST_CYCLIC_TIME in ini file" ); PERF_iBapRadioCyclicTime = 100; } 

        // Radio timing: staying time for a list element 
        PERF_iRadioStayInListEntryTime = getProfileInt( "RADIO_SCROLLING", "RADIO_STAY_IN_LIST_ENTRY_TIME", 0, PERF_cIniFileName );
        if( PERF_iRadioStayInListEntryTime < 100 )
        {   write( "PERF: ERROR: wrong RADIO_STAY_IN_LIST_ENTRY_TIME in ini file" ); PERF_iRadioStayInListEntryTime = 100; } 

        // Radio timing: next BAP action
        PERF_iRadioListStayInRadioBeforeScrollingTime = getProfileInt( "RADIO_SCROLLING", "RADIO_LIST_STAY_IN_RADIO_BEFORE_SCROLLING_TIME", 0, PERF_cIniFileName );
        if( PERF_iRadioListStayInRadioBeforeScrollingTime < 100 )
        {   write( "PERF: ERROR: wrong RADIO_LIST_STAY_IN_RADIO_BEFORE_SCROLLING_TIME in ini file" ); PERF_iRadioListStayInRadioBeforeScrollingTime = 100; } 

        // BAP shown for this delay time
        PERF_iRadioStayInBapClientUpTime = getProfileInt( "RADIO_SCROLLING", "RADIO_STAY_IN_BAP_CLIENT_UP_TIME", 0, PERF_cIniFileName );
        if( PERF_iRadioStayInBapClientUpTime < 100 )
        {   write( "PERF: ERROR: wrong RADIO_STAY_IN_BAP_CLIENT_UP_TIME in ini file" ); PERF_iRadioStayInBapClientUpTime = 100; } 

        // max count of scroll downs
        PERF_iRadioListEntries = getProfileInt( "RADIO_SCROLLING", "RADIO_LIST_ENTRIES", 0, PERF_cIniFileName );

        // MFA scrolling
        // delay time for scrolling
        PERF_iMfaScrollingCycleTime = getProfileInt( "MFA_SCROLLING", "PERF_MFA_SCROLLING_CYCLE", 0, PERF_cIniFileName );
        if( PERF_iMfaScrollingCycleTime < 100 )
        {   write( "PERF: ERROR: wrong PERF_MFA_SCROLLING_CYCLE in ini file" ); PERF_iMfaScrollingCycleTime = 100; } 

        // wait befor pressing the OK button
        PERF_iMfaScrollingWaitBeforeOkTime = getProfileInt( "MFA_SCROLLING", "PERF_MFA_SCROLLING_BEFORE_OK", 0, PERF_cIniFileName );
        if( PERF_iMfaScrollingWaitBeforeOkTime < 100 )
        {   write( "PERF: ERROR: wrong PERF_MFA_SCROLLING_BEFORE_OK in ini file" ); PERF_iMfaScrollingWaitBeforeOkTime = 100; } 

        // no scrolling in MFA (Boardcomputer)
        PERF_iMfaScrollDownMax = getProfileInt( "MFA_SCROLLING", "MFA_SCROLL_DOWN_MAX", 0, PERF_cIniFileName );
        // Fzg MFA change and BAP rotation
        PERF_iFzgMfaCyclicTime = getProfileInt( "MFA_SCROLLING", "FZG_MFA_CYCLIC_TIME", 0, PERF_cIniFileName );
        if( PERF_iFzgMfaCyclicTime < 100 )
        {   write( "PERF: ERROR: wrong FZG_MFA_CYCLIC_TIME in ini file" ); PERF_iFzgMfaCyclicTime = 100; } 

        // MFA timing: staying time for a list element 
        PERF_iMfaStayInListEntryTime = getProfileInt( "MFA_SCROLLING", "MFA_STAY_IN_LIST_ENTRY_TIME", 0, PERF_cIniFileName );
        if( PERF_iMfaStayInListEntryTime < 100 )
        {   write( "PERF: ERROR: wrong MFA_STAY_IN_LIST_ENTRY_TIME in ini file" ); PERF_iMfaStayInListEntryTime = 100; } 

        // MFA timing: next BAP action
        PERF_iMfaListStayInBeforeScrollingTime = getProfileInt( "MFA_SCROLLING", "MFA_LIST_STAY_IN_BEFORE_SCROLLING_TIME", 0, PERF_cIniFileName );
        if( PERF_iMfaListStayInBeforeScrollingTime < 100 )
        {   write( "PERF: ERROR: wrong MFA_LIST_STAY_IN_BEFORE_SCROLLING_TIME in ini file" ); PERF_iMfaListStayInBeforeScrollingTime = 100; } 

        // BAP shown for this delay time
        PERF_iMfaStayInBapClientTime = getProfileInt( "MFA_SCROLLING", "MFA_STAY_IN_BAP_CLIENT_TIME", 0, PERF_cIniFileName );
        if( PERF_iMfaStayInBapClientTime < 100 )
        {   write( "PERF: ERROR: wrong MFA_STAY_IN_BAP_CLIENT_TIME ini file" ); PERF_iMfaStayInBapClientTime = 100; } 

        // 'Basic Load' is enabled when starting
        putValue( ENV_PERF_BasicLoadSwitch, getProfileInt( "COMMON_SETTINGS", "PERF_BASIC_LOAD", 0, PERF_cIniFileName ) );

        // Values for DIMMING sweep
        PERF_DimmingCycle = getProfileInt( "DIMMING", "PERF_DIMMINGCYCLE", 0, PERF_cIniFileName );
        if( PERF_DimmingCycle < 100 )   // protect
            PERF_DimmingCycle = 100;    // ms
        // Kl58xd
        PERF_iDimmingKl58xdValueStart = getProfileInt( "DIMMING", "PERF_DIMMING_KL58XD_VALUE_START", 0, PERF_cIniFileName );
        PERF_iDimmingKl58xdValueDefault = getProfileInt( "DIMMING", "PERF_DIMMING_KL58XD_VALUE_DEFAULT", 0, PERF_cIniFileName );
        PERF_iDimmingKl58xdMax = getProfileInt( "DIMMING", "PERF_DIMMING_KL58XD_MAX", 0, PERF_cIniFileName );
        PERF_iDimmingKl58xdMin = getProfileInt( "DIMMING", "PERF_DIMMING_KL58XD_MIN", 0, PERF_cIniFileName );
        PERF_iDimmingKl58xdStep = getProfileInt( "DIMMING", "PERF_DIMMING_KL58XD_STEP", 0, PERF_cIniFileName );
        // Kl58xt
        PERF_iDimmingKl58xtValueStart = getProfileInt( "DIMMING", "PERF_DIMMING_KL58XT_VALUE_START", 0, PERF_cIniFileName );
        PERF_iDimmingKl58xtValueDefault = getProfileInt( "DIMMING", "PERF_DIMMING_KL58XT_VALUE_DEFAULT", 0, PERF_cIniFileName );
        PERF_iDimmingKl58xtMax = getProfileInt( "DIMMING", "PERF_DIMMING_KL58XT_MAX", 0, PERF_cIniFileName );
        PERF_iDimmingKl58xtMin = getProfileInt( "DIMMING", "PERF_DIMMING_KL58XT_MIN", 0, PERF_cIniFileName );
        PERF_iDimmingKl58xtStep = getProfileInt( "DIMMING", "PERF_DIMMING_KL58XT_STEP", 0, PERF_cIniFileName );

        // scenario 2.1: toggle warnings
        PERF_iToggleWarningsStartCycle = getProfileInt( "WARNINGS", "PERF_TOGGLE_WARNINGS_START_CYCLE", 0, PERF_cIniFileName );

        // Kl15 toggling
        getProfileDwordArray("KL15TOGGLE", "KL15On_TimeTable", PERF_dwKl15ToggleCyclesTable, PERF_cIniFileName );
        getProfileDwordArray("KL15TOGGLEDURATION", "KL15_HoldTable", PERF_dwKl15ToggleDurationTable, PERF_cIniFileName );

    } // end if ini file
}

vPERF_Scenario12 (int State)
{
    switch( State )
    {
        case PERF_INIT:
            //write( "PERF: init performance scenario 1" );
            putValue( ENV_PERF_ScenarioDescription_1, "Initialize performance scenario 1.2" );
            putValue( ENV_PERF_ScenarioDescription_2, "Kl15 toggle initialized" );
            putValue( ENV_PERF_ScenarioDescription_3, "" );
            putValue( ENV_PERF_ScenarioDescription_4, "" );
            putValue( ENV_PERF_ScenarioDescription_5, "" );
            putValue( ENV_PERF_ScenarioDescription_6, "" );

            // append the new scenario to log-file
            putValue( ENV_PERF_ScenarioDescription_1, "Performance scenario 1.2 initialized" );

            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance scenario 1.2 initialized\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: - eZAS_Kl_15S\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }

            // update state
            bScenarioState = PERF_INITIALIZED;
            PERF_iToggleKl15Cycle = PERF_dwKl15ToggleCyclesTable[0];
            PERF_iKl15ToggleDuration = PERF_dwKl15ToggleDurationTable[0];
            break;

        case PERF_STOP:
            cancelTimer( msPERF_Kl15ToggleTimer );

            if(!(@KCAN_ZAS_Kl_15))
            {
             putValue(KCAN_ZAS_Kl_15,bKl15On);
            }

            // update state
            bScenarioRunningState = PERF_STOPPED;

            putValue( ENV_PERF_ScenarioDescription_1, "Performance scenario 1.2 stopped" );
            snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "run time: %d seconds", PERF_lRunTimeInSeconds );
            putValue( ENV_PERF_ScenarioDescription_3, PERF_cLogBuffer );
            
            // log
            if( PERF_LogFileHandle != 0)
            {
                snprintf( PERF_cLogBuffer, elcount( PERF_cLogBuffer ), "PERF: Performance scenario 1.2 stopped\n" );
                filePutString( PERF_cLogBuffer, elCount( PERF_cLogBuffer ), PERF_LogFileHandle );
            }

            break;

        default:
            break;
    }

}

on timer msPERF_Kl15ToggleTimer
{
    if( getValue( KCAN_ZAS_Kl_15 ) )
    {
        putValue( KCAN_ZAS_Kl_15, bKl15Off );
    }
    else
    {
        putValue( KCAN_ZAS_Kl_15, bKl15On );
    }

    if(( PERF_iCycleCounter * PERF_iToggleKl15Cycle) >= PERF_iKl15ToggleDuration)
    {
        PERF_iCurKl15ToggleCycleIdx++; // next cycle time
        PERF_iCycleCounter = 0; // reset cycle counter

        // if the last cycle is done go back to the first one
        if( PERF_iCurKl15ToggleCycleIdx >= MAX_NUMBER_OF_TOGGLE_CYCLES )
        {
            PERF_iCurKl15ToggleCycleIdx = 0;
            PERF_iCurKl15ToggleDurationIdx++; // next duration time
            // if the last duration time is done go back to the first one 
            if( PERF_iCurKl15ToggleDurationIdx >= MAX_NUMBER_OF_DURATIONS )
            {
                PERF_iCurKl15ToggleDurationIdx = 0;
            }

            PERF_iKl15ToggleDuration = PERF_dwKl15ToggleDurationTable[PERF_iCurKl15ToggleDurationIdx];
        }
        // assign cycle time value
        PERF_iToggleKl15Cycle = PERF_dwKl15ToggleCyclesTable[PERF_iCurKl15ToggleCycleIdx];
    }
 
    PERF_iCycleCounter++;

    // **** restart timer
    if( PERF_iToggleKl15Cycle == 0 )
    {
        write( "   ERROR    Perf.ini not loaded, Simulation stopped ! ");
        stop();
    }
    setTimer( msPERF_Kl15ToggleTimer, PERF_iToggleKl15Cycle);
}

