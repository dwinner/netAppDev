/*@!Encoding:1252*/
includes
{
    #include "..\..\_DLL\latest_BAP_DLL.cin"
}

/********************************************************************************/ 
/*  Author:      Christian Franz                                                */ 
/*  Department:  IAV, EI-S55                                                    */   
/*  Email (IAV): Christian.Franz@IAV.de                                         */
/*  Email (VW):  extern.Christian.Franz@Volkswagen.de                           */
/*  Phone:       +49-5371-805-2920                                              */
/*  Mobil:       +49 152 29125473                                               */ 
/*                                                                              */ 
/*  Substitute:  Martin Wuschke                                                 */ 
/*  Department:  VW, EEFI/4                                                     */ 
/*  Phone:       +49-5361-9-30109                                               */ 
/*                                                                              */ 
/*  Purpose:   CANoe simulation for stand alone Navigation secondary Display    */ 
/********************************************************************************/ 

/* Global variables for the NaviSD CANoe BAP simulation */
variables 
{
    const REQUESTBUFFER_LINES =  100;
    const BAP_BUFFER_SIZE     = 4000;

    char dbc_path[255]  = "BAP\\_DBC\\BAP_V9.04F.dbc";                    //relative path for dbc-file        //BAP_only_MQB_MLBevo_v1.50.dbc";  //                                    
    char xml_path[255]  = "BAP\\NavigationSD_DF44_man\\XML\\BAP_SW17_MIB2_Std_MQB_V1_85_F_mod.xml";        //relative path for xml-file
    
    int gBAP_Requestbuffer_status [REQUESTBUFFER_LINES];                //datalength
    int gBAP_Requestbuffer_BAPDataTyp [REQUESTBUFFER_LINES];            //data type

    dword gBAP_Indication [BAP_BUFFER_SIZE];                                //Bap-Indication-buffer
    dword gBAP_Request [REQUESTBUFFER_LINES] [BAP_BUFFER_SIZE];            //ringbuffer for BAP-Request

    int gwrite_requestbuffer_line   = 0;                                    //next free position
    int gstatus_requestbuffer       = 0;                                    //next position to send

    // adresses of output windows
    //IssueList #216 15S1 update 17.01.2014
    //dword gBAP_Trace, gError_Trace, gLaneGuidance_writeWindow, gLastDestList_writeWindow, gFavoriteDestList_writeWindow, gNavBook_writeWindow, gAddressList_writeWindow;
    dword gBAP_Trace, gError_Trace, gLaneGuidance_writeWindow, gLastDestList_writeWindow, gFavoriteDestList_writeWindow, gNavBook_writeWindow, gAddressList_writeWindow,gPOIList_writeWindow;    
    // Timers
    mstimer TaskTimer;                                                    //timer for BAP-Task
    mstimer StartFSG_Timer;                                             //timer for start simulation FSG
    byte gStartFSGTimer_handling = 0;
    mstimer Powerontimer;
    
    const gBAP_datalength_error = 0x41;                                                                

    // general values for readable code
    const FALSE             =0;
    const TRUE              =1;
    const NULL              =0x00;
    const VALID             =0x01;
    const INVALID           =0x00;
    const FORWARD           =0;
    const BACKWARD          =1;
    char empty_string [3]   ={0,0,0};

    char gstring_reserved [10]      = "reserved";
    char gstring_defect [10]        = "defect";
    char gstring_not_supported [20] = "not supported";
    char gstring_unknown [10]       = "unknown";
    
    //BAP Data Type 
    const Bap_Void            = 0;
    const Bap_UInt8           = 1;
    const Bap_UInt16          = 2;
    const Bap_UInt32          = 3;
    const Bap_ByteSequence    = 4;
    const Bap_Error           = 5;
    const Bap_Acknowledge     = 6;

    //BAP request types (FSG)
    const Data_REQ            = 0x03;
    const DataAck             = 0x0A;
    const Changed_REQ         = 0x04;
    const Processing_REQ      = 0x08;
    const Result_REQ          = 0x09;
    const Invalid_REQ         = 0x1F;  // Interne Kennzeichnung fuer einen ungueltigen Request

    //eigene Error-Definition
    const Error_REQ=0x55;


    //BAP indication types (FSG)
    const DataSetGet_IND      = 0x06;
    const DataSet_IND         = 0x07;
    const DataGet_IND         = 0x08;
    const Acknowledge_Ind     = 0x09;
    const Processing_CNF      = 0x0A;
    const Start_IND           = 0x0B;
    const StartResult_IND     = 0x0C;
    const Abort_IND           = 0x0D;       
    const Invalid_IND         = 0x1F;  // Interne Kennzeichnung fuer eine ungueltige Indication

 
     //eigene Error-Definition
    const Error_IND = 0x55;

    // node index and LSG-IDs
    dword NODE_INDEX;

    const LSG_NaviSD          = 0x32;

    // BAP and LSG-Version information (these are not used, just informations; see XML-file for current definitions!)
    const BAP_VERSION_MAJOR = 0x03;
    const BAP_VERSION_MINOR = 0x00;
    const LSG_CLASS_1       = LSG_NaviSD;
    const LSG_SUBCLASS_1    = 0x00;
    const LSG_VERSION_MAJOR = 0x04;
    //IssueList #216 15S1 update 17.01.2014
    const LSG_VERSION_MINOR = 0x01;

    // BAP and BAL error codes
    const BAP_NO_ERROR               =0x00;

    const BAP_BAL_OUT_OF_RANGE       = 0x41;
    const BAP_BAL_TEMP_NOT_AVAILABLE = 0x42;
    const BAP_BAL_MAX_DL_EXCEEDED    = 0x43;
    const BAP_BAL_UNIT_MISMATCH      = 0x44;

    // Error codes from BAP API (refer to BAP manual)
    const BAP_ERR_OK = 0x00;

    // Function-IDs

    // common function-IDs
    const FctID_GetAll             = 0x01;
    const FctID_BAP_Config         = 0x02;
    const FctID_FunctionList       = 0x03;
    const FctID_HeartBeat          = 0x04;
    const FctID_FSG_Control        = 0x0D;
    //IssueList #216 15S1 update 17.01.2014
    //const FctID_FSG_Setup      = 0x0E;
    const FctID_FSG_OperationState = 0x0F;

    // specific function-IDs
    const FctID_CompassInfo                         = 0x10;
    const FctID_RG_Status                           = 0x11;
    const FctID_DistanceToNextManeuver              = 0x12;
    const FctID_CurrentPositionInfo                 = 0x13;
    const FctID_TurnToInfo                          = 0x14;
    const FctID_DistanceToDestination               = 0x15;
    const FctID_TimeToDestination                   = 0x16;
    const FctID_ManeuverDescriptor                  = 0x17;
    const FctID_LaneGuidance                        = 0x18;
    const FctID_TMCinfo                             = 0x19;
    const FctID_MagnetFieldZone                     = 0x1A;
    const FctID_Calibration                         = 0x1B;
    const FctID_ASGcapabilities                     = 0x1C;
    const FctID_LastDest_List                       = 0x1D;
    const FctID_FavoriteDest_List                   = 0x1E;
    const FctID_PreferredDestList                   = 0x1F;
    const FctID_NavBook                             = 0x20;
    const FctID_Address_List                        = 0x21;
    const FctID_RG_ActDeact                         = 0x22;
    const FctID_RepeatLastNavAnnouncement           = 0x23;
    const FctID_VoiceGiudance                       = 0x24;
    const FctID_FunctionSynchronisation             = 0x25;
    const FctID_InfoStates                          = 0x26;
    const FctID_ActiveRgType                        = 0x27;
    const FctID_TrafficBlock_Indication             = 0x28;
    const FctID_GetNextListPos                      = 0x29;
    const FctID_NbSpeller                           = 0x2A;
    const FctID_MapColorAndType_Indication          = 0x2B;
    const FctID_MapViewAndOrientation_Indication    = 0x2C;
    const FctID_MapScale_Indication                 = 0x2D;
    const FctID_DestinationInfo_Indication          = 0x2E;
    const FctID_Altitude_Indication                 = 0x2F;  
    const FctID_OnlineNavigationState               = 0x30;
    const FctID_ExitView                            = 0x31;
    const FctID_SemidynamicRouteGuidance_Indication = 0x32;
    const FctID_POI_Search                          = 0x33;
    const FctID_POI_List                            = 0x34;
    const FctID_FSG_Setup                           = 0x35;
    const FctID_Map_Preasentation                   = 0x36;
    const FctID_ManeuverState                       = 0x37;
    const FctID_ETC_Status                          = 0x38;


    // FSG specific global variables and consts.


    /***FunctionList***/
    byte gFunctionList[8] ={0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0};

    /***FSG-OperationState***/

    const NAV_OPSTATE_NORMAL        = 0x00;
    const NAV_OPSTATE_OFF           = 0x01;
    const NAV_OPSTATE_INITIALIZING  = 0x03;
    const NAV_OPSTATE_DEFECT        = 0x0F;

    byte  gFSG_OperationState       = 0;


    /***CompassInfo***/

    const N     = 0x00;
    const NNO   = 0x01;
    const NO    = 0x02;
    const ONO   = 0x03;
    const O     = 0x04;
    const OSO   = 0x05;
    const SO    = 0x06;
    const SSO   = 0x07;
    const S     = 0x08;
    const SSW   = 0x09;
    const SW    = 0x0A;
    const WSW   = 0x0B;
    const W     = 0x0C;
    const WNW   = 0x0D;
    const NW    = 0x0E;
    const NNW   = 0x0F;
    
    byte gCI_Direction_Symbolic = 0;
    word gCI_Direction_Angle    = 0;


    /***RG_Status***/

    const NAV_RGSTATUS_RG_NOT_ACTIVE = 0x00;
    const NAV_RGSTATUS_RG_ACTIVE     = 0x01;
    const NAV_RGSTATUS_NOT_SUPPORTED = 0xFF;

    byte gRG_Status=0;

    /***DistanceToNextManeuver***/

    dword gDTNM_Distance=0;

    const NAV_DTNM_UNIT_METERS          = 0x00;
    const NAV_DTNM_UNIT_KILOMETERS      = 0x01;
    const NAV_DTNM_UNIT_YARDS           = 0x02;
    const NAV_DTNM_UNIT_FEET            = 0x03;
    const NAV_DTNM_UNIT_MILES           = 0x04;
    const NAV_DTNM_UNIT_QUARTERMILE     = 0x05;
    const NAV_DTNM_UNIT_NOT_SUPPORTED   = 0xFF;

    byte gDTNM_Unit =0;

    const NAV_DTNM_BGONOFF_NOT_DISPLAYED    =0x00;
    const NAV_DTNM_BGONOFF_DISPLAYED        =0x01;
    const NAV_DTNM_BGONOFF_NOT_SUPPORTED    =0xFF;

    byte gDTNM_BargraphOnOff        =0;
    byte gDTNM_Bargraph             =0;
    byte gDTNM_ValidityInformation  =0;


    /***CurrentPositionInfo***/

    const NAV_POSITIONINFO_LENGTH =97;

    char gCurrentPositionInfo_PositionInfo[NAV_POSITIONINFO_LENGTH];

    
    /***TurnToInfo***/

    const NAV_TURNTOINFO_TURNTOINFO_LENGTH =76;
    
    char gTurnToInfo_TurnToInfo[NAV_TURNTOINFO_TURNTOINFO_LENGTH];
    
    const NAV_TURNTOINFO_SIGNPOST_LENGTH =31;

    char gTurnToInfo_SignPost[NAV_TURNTOINFO_SIGNPOST_LENGTH];


    /***DistanceToDestination***/

    dword  gDTD_Distance =0;

    const NAV_DTD_UNIT_METERS          =0x00;
    const NAV_DTD_UNIT_KILOMETERS      =0x01;
    const NAV_DTD_UNIT_YARDS           =0x02;
    const NAV_DTD_UNIT_FEET            =0x03;
    const NAV_DTD_UNIT_MILES           =0x04;
    const NAV_DTD_UNIT_QUARTERMILE     =0x05;
    const NAV_DTD_UNIT_NOT_SUPPORTED   =0xFF;
    
    byte gDTD_Unit=0; 
    byte gDTD_ValidityInformation =0;
    //MR 76047 
    byte gDTD_DTDType =0;
    
    /***TimeToDestination***/

    const NAV_TTD_TIT_TIMETODESTINATION =0x00;
    const NAV_TTD_TIT_ARRIVALTIME       =0x01;
    const NAV_TTD_TIT_NOT_SUPPORTED     =0xFF;

    byte gTTD_TimeInfoType =0;

    const NAV_TTD_NTF_24H =0x00;
    const NAV_TTD_NTF_12H =0x01;

    byte gTTD_NavigationTimeFormat  =0;  
    byte gTTD_Minute                =0;
    byte gTTD_Hour                  =0;
    byte gTTD_Day                   =0;      
    byte gTTD_Month                 =0;
    byte gTTD_Year                  =0;

    const NAV_TTD_VI_MIN     =0;
    const NAV_TTD_VI_HOUR    =0;
    const NAV_TTD_VI_DAY     =0;
    const NAV_TTD_VI_MONTH   =0;
    const NAV_TTD_VI_YEAR    =0;    

    byte gTTD_ValidityInformation =0;

    /***ManeuverDescriptor***/

    const NAV_MD_ME_NOSYMBOL                    = 0x00;
    const NAV_MD_ME_NOINFO                      = 0x01;
    const NAV_MD_ME_DIRECTIONTODESTINATION      = 0x02;
    const NAV_MD_ME_ARRIVED                     = 0x03;
    const NAV_MD_ME_NEARDESTINATION             = 0x04;
    const NAV_MD_ME_ARRIVEDDESTINATIONOFFRAOAD  = 0x05;
    const NAV_MD_ME_OFFROAD                     = 0x06;
    const NAV_MD_ME_OFFMAP                      = 0x07;
    const NAV_MD_ME_NOROUTE                     = 0x08;
    const NAV_MD_ME_CALCROUTE                   = 0x09;
    const NAV_MD_ME_RECALCROUTE                 = 0x0A;
    const NAV_MD_ME_FOLLOWSTREET                = 0x0B;
    const NAV_MD_ME_CHANGELANE                  = 0x0C;
    const NAV_MD_ME_TURN                        = 0x0D;
    const NAV_MD_ME_TURNONMAINROAD              = 0x0E;
    const NAV_MD_ME_EXITRIGHT                   = 0x0F;
    const NAV_MD_ME_EXITLEFT                    = 0x10;
    const NAV_MD_ME_SERVICEROADRIGHT            = 0x11;
    const NAV_MD_ME_SERVICEROADLEFT             = 0x12;
    const NAV_MD_ME_FORK2                       = 0x13;
    const NAV_MD_ME_FORK3                       = 0x14;
    const NAV_MD_ME_ROUNDABOUTTRSRIGHT          = 0x15;
    const NAV_MD_ME_ROUNDABOUTTRSLEFT           = 0x16;
    const NAV_MD_ME_SQUARETRSRIGHT              = 0x17;
    const NAV_MD_ME_SQUARETRSLEFT               = 0x18;
    const NAV_MD_ME_UTURNE                      = 0x19;
    const NAV_MD_ME_EXITROUNDABOUTTRSRIGHT      = 0x1A;
    const NAV_MD_ME_EXITROUNDABOUTTRSLEFT       = 0x1B;
    const NAV_MD_ME_PREPARETURN                 = 0x1C;
    const NAV_MD_ME_PREPAREROUNDABOUT           = 0x1D;
    const NAV_MD_ME_PREPARESQUARE               = 0x1E;
    const NAV_MD_ME_PREPAREUTURN                = 0x1F;
    const NAV_MD_ME_DIRECTIONTOWAYPOINT         = 0x20;
    const NAV_MD_ME_EXITRIGHTRAMP               = 0x21;
    const NAV_MD_ME_EXITLEFTRAMP                = 0x22;
    const NAV_MD_ME_MICHIGANTURN                = 0x23;
    const NAV_MD_ME_DOUBLETURN                  = 0x24;

    byte gMD_MainElement_1 =0;
    byte gMD_MainElement_2 =0;
    byte gMD_MainElement_3 =0;
    
    byte gMD_Direction_1 =0;
    byte gMD_Direction_2 =0;
    byte gMD_Direction_3 =0;

    const NAV_MD_ZL_NO_ZLGUIDANCE   =0x00;
    const NAV_MD_ZL_UP              =0x01;
    const NAV_MD_ZL_DOWN            =0x01;
    const NAV_MD_ZL_NOT_SUPPORTED   =0xFF;

    byte gMD_ZLevelGuidance_1 =0;
    byte gMD_ZLevelGuidance_2 =0;
    byte gMD_ZLevelGuidance_3 =0;


    byte gMD_Sidestreet_1 [255];
    byte gMD_Sidestreet_2 [255];
    byte gMD_Sidestreet_3 [255];

    /***TMCinfo***/

    byte gTMCinfo_MessageID =0;

    const NAV_TMCINFO_MS_NOMESSAGE           =0x00;
    const NAV_TMCINFO_MSPRES_REQ             =0x01;
    const NAV_TMCINFO_MESSAGE_PRES_CONFIRMED =0x03;
    
    byte gTMCinfo_MessageStatus             =0;
    char gTMCinfo_MessageStatus_s[4][40]    ={  "no message",
                                                "presentation request for new message",
                                                "reserved",
                                                "message presentation confirmed"};

    const NAV_TMCINFO_NO_MESSAGE_WAITING        =0x00;
    const NAV_TMCINFO_1_MESSAGE_WAITING         =0x01;
    const NAV_TMCINFO_SEVERAL_MESSAGES_WAITING  =0x02;
    byte gTMCinfo_MessageWaitingIndication      =0;
    byte gTMCinfo_Reserve1  =0x00;
    byte gTMCinfo_Reserve2  =0x00;
    byte gTMCinfo_Priority  =0;
    
    const NAV_STREETNAME_LENGTH =61;
    char gTMCinfo_StreetName[NAV_STREETNAME_LENGTH];

    const NAV_LOCATION_LENGTH =61;
    char gTMCinfo_Location[NAV_LOCATION_LENGTH];

    const NAV_INFOTEXT_LENGTH =121;
    char gTMCinfo_Infotext[NAV_INFOTEXT_LENGTH];

    byte gTMCinfo_Length_Validity   =0;
    byte gTMCinfo_Length_Bit0       =0;

    dword gTMCinfo_Length_Value     =0;

    const NAV_TMCINFO_UNIT_METERS          =0x00;
    const NAV_TMCINFO_UNIT_KILOMETERS      =0x01;
    const NAV_TMCINFO_UNIT_YARDS           =0x02;
    const NAV_TMCINFO_UNIT_FEET            =0x03;
    const NAV_TMCINFO_UNIT_MILES           =0x04;
    const NAV_TMCINFO_UNIT_NOT_SUPPORTED   =0xFF;

    byte gTMCinfo_Length_Unit =0;


    /***MagnetFieldZone***/

    byte gNaviSD_MFZone        =0;
    char gNaviSD_MFZone_s[16][10] = { "reserved",
                                    "zone 1",
                                    "zone 2",
                                    "zone 3",
                                    "zone 4",
                                    "zone 5",
                                    "zone 6",
                                    "zone 7",
                                    "zone 8",
                                    "zone 9",
                                    "zone 10",
                                    "zone 11",
                                    "zone 12",
                                    "zone 13",
                                    "zone 14",
                                    "zone 15"};


    /***Calibration***/
    
    const NAV_CALIBRATION_CALIBRATED            =0x00;
    const NAV_CALIBRATION_CALIBRATION_ACTIVE    =0x01;
    const NAV_CALIBRATION_INTERFERING_FILED        =0x02;
    const NAV_CALIBRATION_NOT_SUPPORTED         =0xFF;

    byte gNaviSD_CalibrationState   =0;

    char gNaviSD_CalibrationState_s[3][20] ={   "calibrated",
                                                "calibrated active",
                                                "interfering field"};


    /***ASGcapabilities***/
    
    const NAV_ASGCAPABILITIES_2D    =0x00;
    const NAV_ASGCAPABILITIES_25D   =0x01;

    byte gNaviSD_ASGcap_PresentationCapabilities        =0;
    byte gNaviSD_ASGcap_PresentationCapabilities_bit0   =0;
    char gNaviSD_ASGcap_PresentationCapabilities_bit0_s[2][40] ={  "2D symbol presentation",
                                                                   "2.5D symbol presentation"};

    byte gNaviSD_ASGcap_FurtherCapabilities             =0;

    
    /***PrefererredDestList***/

    const NAV_PREFERREDDESTLIST_NOLIST_PREFERRED  =0x00;
    const NAV_PREFERREDDESTLIST_LASTDEST_LIST     =0x01;
    const NAV_PREFERREDDESTLIST_FAVORITEDEST_LIST =0x02;
    const NAV_PREFERREDDESTLIST_NAVBOOK           =0x03;

    byte gNaviSD_PrefDestList_ListType =NAV_PREFERREDDESTLIST_NOLIST_PREFERRED;

    
    /***VoiceGuidance***/

    const NAV_VOICEGUIDANCE_ON_FULL     =0x00;
    const NAV_VOICEGUIDANCE_OFF         =0x01;
    const NAV_VOICEGUIDANCE_ON_REDUCED  =0x02;

    byte gNaviSD_VoiceGuidance_State =0;
    //IssueList #216 15S1 update 17.01.2014
    char gNaviSD_VoiceGuidance_State_s[4][40] ={    "ON (full/complete announcements)",
                                                    "OFF",
                                                    "ON (reduced announcements/mode)",
                                                    "ON (reduced announcement traffic)"};

    /***FunctionSynchronisation***/
    byte gNaviSD_FunctionSynchronisation_FctList[8];
    
    byte gNaviSD_FunctionSynchronisation_FctList_Bit16 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit17 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit18 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit19 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit20 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit21 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit22 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit23 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit24 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit25 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit26 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit27 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit29 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit30 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit31 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit32 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit33 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit34 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit36 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit38 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit39 =FALSE;
    byte gNaviSD_FunctionSynchronisation_FctList_Bit40 =FALSE;

    /***InfoStates***/

    const NAV_INFOSATES_NOERROR               =0x00;
    const NAV_INFOSATES_MEDIUM_INSERTED       =0x01;
    const NAV_INFOSATES_DATABASE_CORRUPTED    =0x02;
    const NAV_INFOSATES_NO_GPS_AVAILABLE      =0x03;

    byte gNAV_InfoStates    =0;

    /***ActiveRgType***/

    const NAV_ACTIVERGTYPE_RGI           =0x00;
    const NAV_ACTIVERGTYPE_MOST          =0x01;
    const NAV_ACTIVERGTYPE_CONMPASS      =0x02;
    const NAV_ACTIVERGTYPE_ASG_DEFAULT   =0xFF;

    byte gNAV_ActiveRgType_RGType =NAV_ACTIVERGTYPE_RGI;
    //IssueList #216 15S1 update 17.01.2014
    //MR 76047 
    char gNAV_ActiveRgType_RGType_s[6][12] ={   "RGI",
                                                "MOST- KDK",
                                                "compass",
                                                "MOST- Map",
                                                "LVDS - Map",
                                                "LVDS - KDK"};
    char gNAV_ActiveRgType_RGType_0xFF_s[40]= "apply ASG default RG Presentation";

    /***TrafficBlock_Indication***/
    const NAV_TRAFFICBLOCK_NO_TMC_SYMBOL                 =0x00;    
    
    byte gNAV_TrafficBlock_Ind_TMCSymbol    =0;


       //Arrays
    //values for reading *.csv-file
    const NAV_DEFAULT_LIST  =0;
    const NAV_EXTERNAL_LIST =1;
    //IssueList 142
    //const NAV_FILENAME_SIZE =50;
    const NAV_FILENAME_SIZE =100;
    const NAV_BUFFERSIZE    =0xFFFF;
    const NAV_TEXTLENGTH    =500;

    //IssueList #216 15S1 update 17.01.2014   -start
    //------------------------------------------------------------------------------------
    //---------- Propertys DF 1.41
    //------------------------------------------------
    /***MapColorAndType***/

    byte gMCAT_Cact     = 0x00;
    byte gMCAT_AMTact   = 0x00;
    byte gMCAT_MMSact   = 0x00;
    byte gMCAT_SMT      = 0x00;
    int temp1           = 0;
    int temp2           = 0;
    int temp3           = 0;


    //------------------------------------------------
    /***MapViewAndOrientation***/
    byte gMVAO_MVact    = 0x00;
    byte gMVAO_SMVact   = 0x00;
    byte gMVAO_SMVsact  = 0x00;
    byte gMVAO_SSMVact  = 0x00;
    byte gMVAO_MVisact  = 0x00;
    byte gMVAO_Modact   = 0x00;
    byte gMVAO_MOact    = 0x00;
    int tempMVAO_1      = 0;
    int tempMVAO_2      = 0;
    int tempMVAO_3      = 0;



    //------------------------------------------------
    /***MapScale***/
    byte gMS_unitact    = 0x00;
    byte gMS_AZact      = 0x00;
    int tempMS_1        = 0;   
    int tempMS_2        = 0;   

    //------------------------------------------------
    /***DestinationInfo***/
    byte gDI_POIact         = 0x00;
    byte gDI_Latitudeact    = 0x00;
    byte gDI_Longditudeact  = 0x00;
    byte gDI_TNOSact        = 0x00;
    byte gDI_StOvact        = 0x00;
    const DESTINFO_POIDES_LENGTH =61;
    char gDI_POIDes[DESTINFO_POIDES_LENGTH];
    const DESTINFO_STREET_LENGTH =128;
    char gDI_Street[DESTINFO_STREET_LENGTH];
    const DESTINFO_TOWN_LENGTH =61;
    char gDI_Town[DESTINFO_TOWN_LENGTH];
    const DESTINFO_STATE_LENGTH =61;
    char gDI_State[DESTINFO_STATE_LENGTH];
    const DESTINFO_POSTALCODE_LENGTH =22;
    char gDI_PostalC[DESTINFO_POSTALCODE_LENGTH];
    const DESTINFO_COUNTRY_LENGTH =61;
    char gDI_Country[DESTINFO_COUNTRY_LENGTH];
    int tempDI              = 0;

    //------------------------------------------------
    /***Altitude***/
    byte gAlt_Unitact       = 0x00;
    word gAlt_Altact        = 0x0000;
    int gAlt_modByBut       = 0;

    //------------------------------------------------
    /***OnlineNavigationState***/
    byte gONS_Stateact      = 0x00;
    byte gONS_ONSact        = 0x00;
    byte gONS_prog          = 0x00;
    int tempONS             = 0;
    int tempONS2            = 0;


    //------------------------------------------------
    /***ExitView***/
    byte gEV_Variact        = 0x00;
    word gEV_EVIDact        = 0x00;
    int tempEV              = 0;

    //------------------------------------------------
    /***SemidynamicRouteGuidance***/
    byte gSDRG_NDTD_Unitact = 0x00;
    byte gSDRG_NDTD_TyODact = 0x00;
    byte gSDRG_NTTD_TITact  = 0x00;
    byte gSDRG_NTTD_NTFact  = 0x00;
    int tempSDRG1           = 0;
    int tempSDRG2           = 0;
    int tempSDRG3           = 0;
    int tempSDRG4           = 0;


    //------------------------------------------------
    /***POI_Search***/
    byte gPOIS_STact        = 0x00;
    byte gPOIS_POISRact     = 0x00;
    byte gPOIS_POITyact     = 0x00;
    int tempPOIS_1          = 0;
    int tempPOIS_2          = 0;
    int tempPOIS_3          = 0;


    //------------------------------------------------
    /***POI_List***/
    const NAV_POILIST_ENTRIES =254;
    byte gPOIList_ListEntryValidInformation [NAV_POILIST_ENTRIES]; //indicates the existence of the "record element" 
    
    byte gPOIList_DirectionSymbolic[NAV_POILIST_ENTRIES];
    int gPOIList_Pos[NAV_POILIST_ENTRIES];
    int gPOIList_POIType[NAV_POILIST_ENTRIES];
    const NAV_POILIST_POITYPE_NOPOI             =0x00;
    const NAV_POILIST_POITYPE_ALLRESTAURANTS    =0x03;
    const NAV_POILIST_POITYPE_COURT             =0x2A;
    const NAV_POILIST_POITYPE_DINNINGSHOPPING   =0x2D;
    const NAV_POILIST_POITYPE_CORPORATIONS      =0x27;
    const NAV_POILIST_POITYPE_CITYHALL          =0x1D;

    byte gPOIList_DistanceType[NAV_POILIST_ENTRIES];
    dword gPOIList_Distance[NAV_POILIST_ENTRIES];
    byte gPOIList_Unit[NAV_POILIST_ENTRIES];
    int gPOIList_AddressType[NAV_POILIST_ENTRIES];
  
    const NAV_POILIST_MAINDESCRIPTION_LENGTH =91;
    char gPOIList_MainDescription [NAV_POILIST_ENTRIES][NAV_POILIST_MAINDESCRIPTION_LENGTH];
    const NAV_POILIST_STREET_LENGTH =91;
    char gPOIList_Street [NAV_POILIST_ENTRIES][NAV_POILIST_STREET_LENGTH];
    const NAV_POILIST_CITY_LENGTH =91;
    char gPOIList_City [NAV_POILIST_ENTRIES][NAV_POILIST_CITY_LENGTH];
    const NAV_POILIST_POSTALCODE_LENGTH =22;
    char gPOIList_PostalCode [NAV_POILIST_ENTRIES][NAV_POILIST_POSTALCODE_LENGTH];

    byte gPOIListLine_sum =0;
    byte gPOIList_TotalNumListElements =0;
    byte gPOIList_ASGID    =0;
    byte gPOIList_TAID     =0;
    dword requestarrayPOIListGlobal [BAP_BUFFER_SIZE];
    word offsetPOIListGlobal;

    char gPOIList_CSV_filename[NAV_FILENAME_SIZE];
    int tempID =0;
    int gID_POIact;
    //------------------------------------------------
    /***FSG_Setup***/



    //------------------------------------------------
    /***Map_Presentation***/
    //MR 76047 
     //------------------------------------------------
    /***ManeuverState***/
    int tempMS          = 0;
    int gMS_StateAct    = 0;

    //------------------------------------------------
    /***ETC_Statis***/
    int temp_CardStatus         = 0;
    int temp_Extension1         = 0;
    
//IssueList #216 15S1 update 17.01.2014   -end

    //Methods
    /***RG_ActDeact***/
    mstimer RGActDeact_Timer;
    mstimer RGActDeact_MethodHandling_Timer;
    word gNav_RG_ActDeact_TimerTime             =1500;
    word gNav_RG_ActDeact_MethodHandling_Time   =150;   
    byte gNav_RG_ActDeact_MethodHandling        =0;

    byte gNav_RGActDeact_Status      =0;    //flag for status of the method (0=not activ, 1=activ)

    byte gNav_RG_ActDeact_Result     =0;
    const NAV_RGACTDEACT_SUCCESSFUL                        =0x00;
    const NAV_RGACTDEACT_NOTSUCCESSFUL                     =0x01;
    const NAV_RGACTDEACT_ABORT_SUCCESSFUL                  =0x02;            
    const NAV_RGACTDEACT_ABORT_NOT_SUCCESSFUL              =0x03;
    const NAV_RGACTDEACT_NOTSUCCESSFUL_CI_NOT_MATCH        =0x06;
    const NAV_RGACTDEACT_NOTSUCCESSFUL_DEST_ADDR_REFINED   =0x07;
    //IssueList #216 15S1 update 17.01.2014
    const NAV_RGACTDEACT_NOTSUCCESSFUL_HOME_ADDR_NOT_SPEC  =0x08;
    const NAV_RGACTDEACT_NOTSUCCESSFUL_SEL_ROUTE_FSG       =0x09;
    const NAV_RGACTDEACT_NOTSUCCESSFUL_SEL_HOME_ADDR_FSG   =0x0A;
    const NAV_RGACTDEACT_NOTSUCCESSFUL_NO_NAV_DATA         =0x0B;
            
    byte gNav_RGActDeact_ControlType            =0;
    const NAV_STARTROUTEGUIDANCE                =0;   
    //IssueList #216 15S1 update 17.01.2014
    char gNav_RGActDeact_ControlType_s[6][25]   ={  "start route guidance",
                                                    "stop route guidance",
                                                    "supend route guidance",
                                                    "resume route guidance",
                                                    "reserved",
                                                    "reserved"};

    byte gNav_RGActDeact_CI_Type                =0;
    const NAV_RGACTDEACT_INVALID                =0;
    //IssueList #216 15S1 update 17.01.2014
    char gNav_RGActDeact_CI_Type_s[8][40]       ={  "invalid",
                                                    "LastDestinations_List",
                                                    "FavoriteDestinations_List",
                                                    "TEL addressbook",
                                                    "home",
                                                    "NavBook",
                                                    "semidynamicRoute",
                                                    "POI_List"};

    word gNav_RGActDeact_ControlInformation    =0;

    /***RepeatLastNavAnnouncement***/
    mstimer RepeatLastNavAnn_Timer;
    word gNav_RepeatLastNavAnn_TimerTime    =1000;
    
    byte gNav_RepeatLastNavAnn_Result               =0;
    const NAV_REPEATLASTNAVANN_SUCCESSFUL           =0x00;
    const NAV_REPEATLASTNAVANN_NOT_SUCCESSFUL       =0x01;
    const NAV_REPEATLASTNAVANN_ABORT_SUCCESSFUL     =0x02;
    const NAV_REPEATLASTNAVANN_ABORT_NOT_SUCCESSFUL =0x03;

    byte gNav_RepeatLastNavAnn_Status       =0;
    
    /***GetNextListPos***/
    mstimer GetNextListPos_Timer;
    word gNav_GetNextListPos_TimerTime    =1000;

    byte gNav_GetNextListPos_Result       =0;
    const NAV_GETNEXTLISTPOS_SUCCESSFUL           =0x00;
    const NAV_GETNEXTLISTPOS_NOT_SUCCESSFUL       =0x01;
    const NAV_GETNEXTLISTPOS_ABORT_SUCCESSFUL     =0x02;
    const NAV_GETNEXTLISTPOS_ABORT_NOT_SUCCESSFUL =0x03;

    byte  gNav_GetNextListPos_ListType      =0;   
    char  gNav_GetNextListPos_ListType_s[4][30] ={  "LastDestinations_List",
                                                "FavoriteDestinations_List",
                                                "NavBook",
                                                "Address_List"};

    word gNav_GetNextListPos_currentPos =0;
    word gNav_GetNextListPos_Offset     =0;
    word gNav_GetNextListPos_nextPos    =0;
    word gNav_GetNextListPos_absListPos =0;

    byte gNav_GetNextListPos_Status     =0;

    /***NbSpeller***/
    mstimer NbSpeller_Timer;
    word gNav_NbSpeller_TimerTime    =1000;

    byte gNav_NbSpeller_Result       =0;
    const NAV_NBSPELLER_SUCCESSFUL           =0x00;
    const NAV_NBSPELLER_NOT_SUCCESSFUL       =0x01;
    const NAV_NBSPELLER_ABORT_SUCCESSFUL     =0x02;
    const NAV_NBSPELLER_ABORT_NOT_SUCCESSFUL =0x03;

    byte gNav_NbSpeller_Mode            =0;
    const NAV_NBSPELLER_MATCHSPELLER    =0x00;
    char gNav_NbSpeller_Mode_s[3][20]   ={  "MatchSpeller",
                                            "next character",
                                            "previous character"};

    const NAV_SEARCHSTRING_LENGTH =51;
    char gNav_NbSpeller_SearchString[NAV_SEARCHSTRING_LENGTH];

    word gNav_NbSpeller_MatchingEntries =0;
    word gNav_NbSpeller_Pos             =0;

    byte gNav_NbSpeller_Status     =0;



   
    /***LaneGuidance***/
    byte gLaneGuidance_ASGID    =0;
    byte gLaneGuidance_TAID     =0;

    const NAV_LANEGUIDANCE_NOTDISPLAYED =0x00;
    const NAV_LANEGUIDANCE_DISPLAY      =0x01;
    byte gLaneGuidance_LaneGuidanceOnOff =NAV_LANEGUIDANCE_NOTDISPLAYED;
    
    //IssueList #54
    //const NAV_LANEGUIDANCE_ENTRIES =9;
    const NAV_LANEGUIDANCE_ENTRIES =10;

    byte gLaneGuidance_Pos [NAV_LANEGUIDANCE_ENTRIES];

    const NAV_LANEGUIDANCE_STRAIGHT =0x00;
    const NAV_LANEGUIDANCE_LEFT     =0x40;
    const NAV_LANEGUIDANCE_BACK     =0x80;
    const NAV_LANEGUIDANCE_RIGHT    =0xC0;
    byte gLaneGuidance_LaneDirection [NAV_LANEGUIDANCE_ENTRIES];    
    char gLaneGuidance_LaneDirection_STRAIGHT[10] = "straight";   
    char gLaneGuidance_LaneDirection_LEFT[10] = "left";
    char gLaneGuidance_LaneDirection_BACK[10] = "back";
    char gLaneGuidance_LaneDirection_RIGHT[10] = "right";

    const NAV_LANESIDESTREETS_LENGTH =17;
    char gLaneGuidance_LaneSidestreets [NAV_LANEGUIDANCE_ENTRIES][NAV_LANESIDESTREETS_LENGTH];
    
    const NAV_LANETYPE_UNSPECIFIC           =0x00;
    const NAV_LANETYPE_NORMAL               =0x01;
    const NAV_LANETYPE_BLOCKED              =0x02;
    const NAV_LANETYPE_FORBIDDEN            =0x03;
    const NAV_LANETYPE_RESTRICTED           =0x04;
    const NAV_LANETYPE_BREAKDOWN            =0x05;
    const NAV_LANETYPE_DYNAMICCONTROLLED    =0x06;
    const NAV_LANETYPE_CARPOOLS             =0x07;
    const NAV_LANETYPE_BUSLANE              =0x08;
    const NAV_LANETYPE_BYCICLELANE          =0x09;
    const NAV_LANETYPE_TAXILANE             =0x0A;
    const NAV_LANETYPE_TRUCKLANE            =0x0B;
    const NAV_LANETYPE_BUSBICYCLELANE       =0x0C;
    const NAV_LANETYPE_BUSTAXILANE          =0x0D;             
    const NAV_LANETYPE_TAXIBICYCLELANE      =0x0E;
    const NAV_LANETYPE_BUSTAXIBICYCLELANE   =0x0F;
    const NAV_LANETYPE_GREENSTRIP           =0x10;
    const NAV_LANETYPE_TRAMWAYNORMAL        =0x12;
    const NAV_LANETYPE_TRAMWAYSEPERATED     =0x13;
    const NAV_LANETYPE_EXITLANE             =0x14;   
    const NAV_LANETYPE_ENTERLANE            =0x15;
    const NAV_LANETYPE_TOLLLANE             =0x16;
    const NAV_LANETYPE_FURTHERLANESLEFT     =0x17;
    const NAV_LANETYPE_FURTHERLANESRIGHT    =0x18;
    const NAV_LANETYPE_HIDELANE             =0x19;
    byte gLaneGuidance_LaneType [NAV_LANEGUIDANCE_ENTRIES];
    char gLaneGuidance_LaneType_s[26][50] ={"unspecific lane type",
                                            "normal lane",
                                            "lane blocked",
                                            "lane forbidden",
                                            "lane restricted",
                                            "breakdown lane",
                                            "dynamic controlled",
                                            "car pools",
                                            "bus lane",
                                            "bicycle lane",
                                            "taxi lane",
                                            "truck lane",
                                            "bus & bicycle lane",
                                            "bus & taxi lane",
                                            "taxi & bicycle lane",
                                            "bus, taxi & bicycle lane",
                                            "green strip",
                                            "reserved",
                                            "tramway on normal road",
                                            "separated tramway",
                                            "exit lane",
                                            "enter lane",
                                            "toll lane",
                                            "further lanes on the left hand side",
                                            "further lanes on the right hand side",
                                            "hide lane"};

    const NAV_LANEMARKINGLEFT_NOLANE            =0x0;
    const NAV_LANEMARKINGLEFT_SOLIDDIVIDERLINE  =0x1;
    const NAV_LANEMARKINGLEFT_DASHEDDIVIDERLINE =0x2;
    byte gLaneGuidance_LaneMarking_left [NAV_LANEGUIDANCE_ENTRIES];     //upper nibble  
    char gLaneGuidance_LaneMarking_left_s[3][50] = {    "no lane marking at the left border of the lane",
                                                        "solid divider line",
                                                        "dashed divider line"};

    const NAV_LANEMARKINGRIGHT_NOLANE            =0x0;
    const NAV_LANEMARKINGRIGHT_SOLIDDIVIDERLINE  =0x1;
    const NAV_LANEMARKINGRIGHT_DASHEDDIVIDERLINE =0x2; 
    byte gLaneGuidance_LaneMarking_right [NAV_LANEGUIDANCE_ENTRIES];    //lower nibble
    char gLaneGuidance_LaneMarking_right_s[3][50] = {   "no lane marking at the right border of the lane",
                                                        "solid divider line",
                                                        "dashed divider line"};

    const NAV_LANEDESCRIPTION_AVAILABLE             =0x0;
    const NAV_LANEDESCRIPTION_MERGINGTOLEFT         =0x1;
    const NAV_LANEDESCRIPTION_MERGINGTORIGHT        =0x2;
    const NAV_LANEDESCRIPTION_ENDINGLATER           =0x3;
    const NAV_LANEDESCRIPTION_FORBIDDEN             =0x4;
    const NAV_LANEDESCRIPTION_EXPANDINGTOLEFT       =0x5;
    const NAV_LANEDESCRIPTION_EXPANDINGTORIGHT      =0x6;
    const NAV_LANEDESCRIPTION_AVAILABLELATER        =0x7;
    const NAV_LANEDESCRIPTION_MULTIPLEADDITIONAL    =0x8;
    const NAV_LANEDESCRIPTION_MULTIPLECONTINUATION  =0x9;
    const NAV_LANEDESCRIPTION_BEGINSINMIDDLE        =0xA;
    const NAV_LANEDESCRIPTION_NOTSUPPORTED          =0xF;
    byte gLaneGuidance_LaneDescription [NAV_LANEGUIDANCE_ENTRIES];      //upper nibble
    char gLaneGuidance_LaneDescription_s[11][50] ={ "lane available",
                                                    "lane merging to left",
                                                    "lane merging to right",
                                                    "lane ending later",
                                                    "forbidden lane",
                                                    "lane expanding to left",
                                                    "lane expanding to right",
                                                    "lane available later",
                                                    "multiple additional lane begin",
                                                    "multiple continuation with lane ends",
                                                    "lane begins in the middle"};

    const NAV_GUIDANCEINFO_NOTRECOMMENDEDLANE       =0x0;
    const NAV_GUIDANCEINFO_RECOMMENDEDLANE          =0x1;
    const NAV_GUIDANCEINFO_BESTRECOMMENDATION       =0x2;
    byte gLaneGuidance_GuidanceInfo [NAV_LANEGUIDANCE_ENTRIES];         //lower nibble
    char gLaneGuidance_GuidanceInfo_s[3][30] ={ "not recommended lane",
                                                "recommended lane",
                                                "best recommendation"};

    byte gLaneGuidance_ListEntryValidInformation [NAV_LANEGUIDANCE_ENTRIES]; //indicates the existence of the "record element" 
    byte gLaneGuidanceLine_sum =0;
    
    char gLaneGuidance_CSV_filename[NAV_FILENAME_SIZE];

    /***LastDestList***/
    byte gLastDestList_ASGID    =0;
    byte gLastDestList_TAID     =0;

    byte gLastDestList_TotalNumListElements =0;

    const NAV_LASTDESTLIST_ENTRIES =254;

    byte gLastDestList_Pos [NAV_LASTDESTLIST_ENTRIES];
    
    const NAV_LASTDESTLIST_POITYPE_NOPOI            =0x00;
    const NAV_LASTDESTLIST_POITYPE_AIRPORT          =0x02;
    const NAV_LASTDESTLIST_POITYPE_BUSSTATION       =0x14;
    const NAV_LASTDESTLIST_POITYPE_CLOTHINGSTORE    =0x21;
    const NAV_LASTDESTLIST_POITYPE_EMERGENCY        =0x32;
    const NAV_LASTDESTLIST_POITYPE_HARBOR           =0x4A;
    const NAV_LASTDESTLIST_POITYPE_HOSPITAL         =0x52;
    const NAV_LASTDESTLIST_POITYPE_PARKING          =0x67;
    const NAV_LASTDESTLIST_POITYPE_CARREPAIRSHOPVW  =0x95;
    const NAV_LASTDESTLIST_POITYPE_UNKOWN           =0xFF;
    const NAV_LASTDESTLIST_POITYPE_CAMPING          =0x15;
    const NAV_LASTDESTLIST_POITYPE_COURT            =0x2A;    
    const NAV_LASTDESTLIST_POITYPE_GASSTATION       =0x3F;
    const NAV_LASTDESTLIST_POITYPE_HEALTHCARE       =0x4D;
    const NAV_LASTDESTLIST_POITYPE_SHOESTORES       =0x7B;
    const NAV_LASTDESTLIST_POITYPE_PARKS            =0x69;
    const NAV_LASTDESTLIST_POITYPE_LIBRARY          =0x57;
    byte gLastDestList_POIType [NAV_LASTDESTLIST_ENTRIES];
    //IssueList #216 15S1 update 17.01.2014
    char gLastDestList_POIType_s [166][35] ={   "no POI",   
                                                "Accommodation",
                                                "Airport",
                                                "all restaurants",
                                                "Amusement Park",
                                                "Apparel",
                                                "ATM (cashpoint)",
                                                "Attraction",
                                                "Automobile Club",
                                                "Banking and Shopping",
                                                "Banking",
                                                "Banquet-Halls",
                                                "Bars and Lounge",
                                                "Boating",
                                                "Bookstore",
                                                "Border Cross",
                                                "Bowling",
                                                "Broadcasting",
                                                "Business and Service",
                                                "Business",
                                                "Busstation",
                                                "Camping",
                                                "Car and Travel",
                                                "Car Track",
                                                "Car Train",
                                                "Car Service",
                                                "Car Wash",
                                                "Casino",
                                                "Cemetry",
                                                "Cityhall",
                                                "coffee",
                                                "Commuter Railstaion",
                                                "Cleaning Launch",
                                                "Clothing Store",
                                                "Communication",
                                                "Community Center",
                                                "Computer Hardware-Software",
                                                "Convenience Store",
                                                "Convention Center",
                                                "Corporations",
                                                "Corporations Public Places",
                                                "Culture Facility",
                                                "Court",
                                                "Department Store",
                                                "Dining and Entertainment",
                                                "Dinning Shopping",
                                                "Discount Store",
                                                "Education",
                                                "Electronics",
                                                "Embassy",
                                                "Emergency",
                                                "Emergency and Public",
                                                "Entertainment",
                                                "Fast Food",
                                                "Ferry",
                                                "Fire Department",
                                                "Flooring and Carpeting",
                                                "Flower and Jewelry",
                                                "Food and Beverage",
                                                "Funeral Director",
                                                "Furniture",
                                                "Games, Music and Video",
                                                "Garden and other",
                                                "Gasstation",
                                                "Gasstation DieselGasstation LPG",
                                                "General",
                                                "Gifts and Leisure",
                                                "Gifts- Antiques and Arts",
                                                "Glass and Window",
                                                "Golfing",
                                                "Goverment",
                                                "Grocery Stores",
                                                "Guesthouse",
                                                "Hair and Beauty",
                                                "Harbor",
                                                "Hardware and Lumber",
                                                "Health and Fitness",
                                                "Health- Care",
                                                "Highrise- BLDG",
                                                "Home and Improvment",
                                                "Home Center",
                                                "Home Service",
                                                "Hospital ",
                                                "Hotel / Motel",
                                                "Iceskating",
                                                "Insurance",
                                                "Karaokay",
                                                "Library",
                                                "LIQ-Gas-Station",
                                                "Major-Appliance",
                                                "Mens-Apparel",
                                                "Monument",
                                                "Motorway Exit",
                                                "Motorway Cross",
                                                "Motorway Service",
                                                "Movie-Theater",
                                                "Moving and Storage",
                                                "Museum",
                                                "Nightclubs",
                                                "Optical",
                                                "Restaurant",
                                                "Park and Fitness",
                                                "Park and Ride",
                                                "Parking",
                                                "Parking Garage",
                                                "Parks",
                                                "Performing-Arts",
                                                "Personal- Service",
                                                "Pharmacies",
                                                "Photographer",
                                                "Place or workship",
                                                "Police Station",
                                                "Post Office",
                                                "Public Places",
                                                "Publisher",
                                                "Railway Station",
                                                "Recreation",
                                                "Rentel Service",
                                                "Repair",
                                                "Rest-Area",
                                                "Retirement Nursing",
                                                "Search",
                                                "Service",
                                                "Shoe Stores",
                                                "Shopping Center",
                                                "Skiing",
                                                "Social Service",
                                                "Speciality-Clothing",
                                                "Speciality-Store",
                                                "Speciality-Food",
                                                "Speciality-Food",
                                                "Sports",
                                                "Sport Airport",
                                                "Sports-Complex",
                                                "Tailor",
                                                "Tax-Service",
                                                "Tool-Booth",
                                                "Tourist Attraction",
                                                "Tourist Information",
                                                "Train Station",
                                                "Transportation",
                                                "Travel",
                                                "Travel-Agent",
                                                "University",
                                                "Utilities",
                                                "Variety-Store",
                                                "Wine and Liquor",
                                                "Womens Apparel",
                                                "Winery",
                                                "car repair shop - VW",
                                                "car repair shop - Audi",
                                                "car repair shop - Seat",
                                                "car repair shop - Skoda",
                                                "car repair shop - VW Nutzfahrzeuge",
                                                "car repair shop - Bentley",
                                                "car repair shop - Bugatti",
                                                "car repair shop - Lamborghini",
                                                "car repair shop - Scania",
                                                "car repair shop - MAN",
                                                "car repair shop - Porsche",
                                                "electrical service station",
                                                "Diesel fuel station",
                                                "CNG fuel station",
                                                "rest area (Autohof)",
                                                "rest area with WC",
                                                "motorway service area"};   

    const NAV_LASTDESTLIST_DESCRIPTION_LENGTH =97;
    char gLastDestList_Description [NAV_LASTDESTLIST_ENTRIES][NAV_LASTDESTLIST_DESCRIPTION_LENGTH];
    
    byte gLastDestList_ListEntryValidInformation [NAV_LASTDESTLIST_ENTRIES]; //indicates the existence of the "record element" 
    
    byte gLastDestListLine_sum =0;
       
    char gLastDestList_CSV_filename[NAV_FILENAME_SIZE];

    /***FavoriteDestList***/
    byte gFavoriteDestList_ASGID    =0;
    byte gFavoriteDestList_TAID     =0;

    byte gFavoriteDestList_TotalNumListElements =0;

    const NAV_FAVORITEDESTLIST_ENTRIES =254;
          
    byte gFavoriteDestList_Pos [NAV_FAVORITEDESTLIST_ENTRIES];
    
    const NAV_FAVORITEDESTLIST_POITYPE_NOPOI            =0x00;
    const NAV_FAVORITEDESTLIST_POITYPE_CARWASH          =0x1A;
    const NAV_FAVORITEDESTLIST_POITYPE_COMMUNITYCENTER  =0x23;
    const NAV_FAVORITEDESTLIST_POITYPE_CEMETRY          =0x1C;
    const NAV_FAVORITEDESTLIST_POITYPE_BORDERCROSS      =0x0F;
    const NAV_FAVORITEDESTLIST_POITYPE_AUTOMOBILECLUB   =0x08;
    const NAV_FAVORITEDESTLIST_POITYPE_ELECTRONICS      =0x30;
    const NAV_FAVORITEDESTLIST_POITYPE_GUESTHOUSE       =0x48;
    const NAV_FAVORITEDESTLIST_POITYPE_INSURANCE        =0x55;
    const NAV_FAVORITEDESTLIST_POITYPE_OPTICAL          =0x63;
    const NAV_FAVORITEDESTLIST_POITYPE_PHOTOGRAPHER     =0x6D;
    const NAV_FAVORITEDESTLIST_POITYPE_RESTAREA         =0x77;    
    const NAV_FAVORITEDESTLIST_POITYPE_TOOLBOOTH        =0x88;
    const NAV_FAVORITEDESTLIST_POITYPE_UTILITIES        =0x90;

    byte gFavoriteDestList_POIType [NAV_FAVORITEDESTLIST_ENTRIES];
    //IssueList #216 15S1 update 17.01.2014
    char gFavoriteDestList_POIType_s [166][35] ={   "no POI",   
                                                    "Accommodation",
                                                    "Airport",
                                                    "all restaurants",
                                                    "Amusement Park",
                                                    "Apparel",
                                                    "ATM (cashpoint)",
                                                    "Attraction",
                                                    "Automobile Club",
                                                    "Banking and Shopping",
                                                    "Banking",
                                                    "Banquet-Halls",
                                                    "Bars and Lounge",
                                                    "Boating",
                                                    "Bookstore",
                                                    "Border Cross",
                                                    "Bowling",
                                                    "Broadcasting",
                                                    "Business and Service",
                                                    "Business",
                                                    "Busstation",
                                                    "Camping",
                                                    "Car and Travel",
                                                    "Car Track",
                                                    "Car Train",
                                                    "Car Service",
                                                    "Car Wash",
                                                    "Casino",
                                                    "Cemetry",
                                                    "Cityhall",
                                                    "coffee",
                                                    "Commuter Railstaion",
                                                    "Cleaning Launch",
                                                    "Clothing Store",
                                                    "Communication",
                                                    "Community Center",
                                                    "Computer Hardware-Software",
                                                    "Convenience Store",
                                                    "Convention Center",
                                                    "Corporations",
                                                    "Corporations Public Places",
                                                    "Culture Facility",
                                                    "Court",
                                                    "Department Store",
                                                    "Dining and Entertainment",
                                                    "Dinning Shopping",
                                                    "Discount Store",
                                                    "Education",
                                                    "Electronics",
                                                    "Embassy",
                                                    "Emergency",
                                                    "Emergency and Public",
                                                    "Entertainment",
                                                    "Fast Food",
                                                    "Ferry",
                                                    "Fire Department",
                                                    "Flooring and Carpeting",
                                                    "Flower and Jewelry",
                                                    "Food and Beverage",
                                                    "Funeral Director",
                                                    "Furniture",
                                                    "Games, Music and Video",
                                                    "Garden and other",
                                                    "Gasstation",
                                                    "Gasstation DieselGasstation LPG",
                                                    "General",
                                                    "Gifts and Leisure",
                                                    "Gifts- Antiques and Arts",
                                                    "Glass and Window",
                                                    "Golfing",
                                                    "Goverment",
                                                    "Grocery Stores",
                                                    "Guesthouse",
                                                    "Hair and Beauty",
                                                    "Harbor",
                                                    "Hardware and Lumber",
                                                    "Health and Fitness",
                                                    "Health- Care",
                                                    "Highrise- BLDG",
                                                    "Home and Improvment",
                                                    "Home Center",
                                                    "Home Service",
                                                    "Hospital ",
                                                    "Hotel / Motel",
                                                    "Iceskating",
                                                    "Insurance",
                                                    "Karaokay",
                                                    "Library",
                                                    "LIQ-Gas-Station",
                                                    "Major-Appliance",
                                                    "Mens-Apparel",
                                                    "Monument",
                                                    "Motorway Exit",
                                                    "Motorway Cross",
                                                    "Motorway Service",
                                                    "Movie-Theater",
                                                    "Moving and Storage",
                                                    "Museum",
                                                    "Nightclubs",
                                                    "Optical",
                                                    "Restaurant",
                                                    "Park and Fitness",
                                                    "Park and Ride",
                                                    "Parking",
                                                    "Parking Garage",
                                                    "Parks",
                                                    "Performing-Arts",
                                                    "Personal- Service",
                                                    "Pharmacies",
                                                    "Photographer",
                                                    "Place or workship",
                                                    "Police Station",
                                                    "Post Office",
                                                    "Public Places",
                                                    "Publisher",
                                                    "Railway Station",
                                                    "Recreation",
                                                    "Rentel Service",
                                                    "Repair",
                                                    "Rest-Area",
                                                    "Retirement Nursing",
                                                    "Search",
                                                    "Service",
                                                    "Shoe Stores",
                                                    "Shopping Center",
                                                    "Skiing",
                                                    "Social Service",
                                                    "Speciality-Clothing",
                                                    "Speciality-Store",
                                                    "Speciality-Food",
                                                    "Sport-Goods",
                                                    "Sports",
                                                    "Sport Airport",
                                                    "Sports-Complex",
                                                    "Tailor",
                                                    "Tax-Service",
                                                    "Tool-Booth",
                                                    "Tourist Attraction",
                                                    "Tourist Information",
                                                    "Train Station",
                                                    "Transportation",
                                                    "Travel",
                                                    "Travel-Agent",
                                                    "University",
                                                    "Utilities",
                                                    "Variety-Store",
                                                    "Wine and Liquor",
                                                    "Womens Apparel",
                                                    "Winery",
                                                    "car repair shop - VW",
                                                    "car repair shop - Audi",
                                                    "car repair shop - Seat",
                                                    "car repair shop - Skoda",
                                                    "car repair shop - VW Nutzfahrzeuge",
                                                    "car repair shop - Bentley",
                                                    "car repair shop - Bugatti",
                                                    "car repair shop - Lamborghini",
                                                    "car repair shop - Scania",
                                                    "car repair shop - MAN",
                                                    "car repair shop - Porsche",
                                                    "electrical service station",
                                                    "Diesel fuel station",
                                                    "CNG fuel station",
                                                    "rest area (Autohof)",
                                                    "rest area with WC",
                                                    "motorway service area"};      

    const NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH =97;
    char gFavoriteDestList_Description [NAV_FAVORITEDESTLIST_ENTRIES][NAV_LASTDESTLIST_DESCRIPTION_LENGTH];
    
    byte gFavoriteDestList_ListEntryValidInformation [NAV_FAVORITEDESTLIST_ENTRIES]; //indicates the existence of the "record element" 
    
    byte gFavoriteDestListLine_sum =0;
       
    char gFavoriteDestList_CSV_filename[NAV_FILENAME_SIZE];

    /***NavBook***/
    byte gNavBook_ASGID    =0;
    byte gNavBook_TAID     =0;

    word gNavBook_TotalNumListElements =0;

    const NAV_NAVBOOK_ENTRIES =254;

    word gNavBook_Pos [NAV_NAVBOOK_ENTRIES];  

    const NAV_NAVBOOK_LASTNAME_LENGTH =61;
    char gNavBook_LastName [NAV_NAVBOOK_ENTRIES][NAV_NAVBOOK_LASTNAME_LENGTH];

    const NAV_NAVBOOK_FIRSTNAME_LENGTH =61;
    char gNavBook_FirstName [NAV_NAVBOOK_ENTRIES][NAV_NAVBOOK_FIRSTNAME_LENGTH];
    
    byte gNavBook_ListEntryValidInformation [NAV_NAVBOOK_ENTRIES]; //indicates the existence of the "record element" 
    
    byte gNavBookLine_sum =0;
       
    char gNavBook_CSV_filename[NAV_FILENAME_SIZE];

    /***Address_List***/
    byte gAddressList_ASGID    =0;
    byte gAddressList_TAID     =0;

    word gAddressList_TotalNumListElements  =0;
    byte gAddressList_OtherListType         =0;
    word gAddressList_OtherListReference    =0;

    const NAV_ADDRESSLIST_ENTRIES =254;
    
    word gAddressList_Pos [NAV_ADDRESSLIST_ENTRIES];  

    const NAV_ADDRESSLIST_LASTNAME_LENGTH =61;
    char gAddressList_LastName [NAV_ADDRESSLIST_ENTRIES][NAV_ADDRESSLIST_LASTNAME_LENGTH];

    const NAV_ADDRESSLIST_FIRSTNAME_LENGTH =61;
    char gAddressList_FirstName [NAV_ADDRESSLIST_ENTRIES][NAV_ADDRESSLIST_FIRSTNAME_LENGTH];

    const NAV_ADDRESSLIST_STREET_LENGTH =61;
    char gAddressList_Street [NAV_ADDRESSLIST_ENTRIES][NAV_ADDRESSLIST_STREET_LENGTH];

    const NAV_ADDRESSLIST_CITY_LENGTH =61;
    char gAddressList_City [NAV_ADDRESSLIST_ENTRIES][NAV_ADDRESSLIST_CITY_LENGTH];

    const NAV_ADDRESSLIST_REGION_LENGTH =61;
    char gAddressList_Region [NAV_ADDRESSLIST_ENTRIES][NAV_ADDRESSLIST_REGION_LENGTH];

    const NAV_ADDRESSLIST_POSTALCODE_LENGTH =22;
    char gAddressList_PostalCode [NAV_ADDRESSLIST_ENTRIES][NAV_ADDRESSLIST_POSTALCODE_LENGTH];
    
    const NAV_ADDRESSLIST_COUNTRY_LENGTH =61;
    char gAddressList_Country [NAV_ADDRESSLIST_ENTRIES][NAV_ADDRESSLIST_COUNTRY_LENGTH];

    const NAV_ADDRESSLIST_COORDINATES_LENGTH =61;
    char gAddressList_Coordinates [NAV_ADDRESSLIST_ENTRIES][NAV_ADDRESSLIST_COORDINATES_LENGTH];

    const NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH =61;
    char gAddressList_POIDescription [NAV_ADDRESSLIST_ENTRIES][NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH];

    const NAV_ADDRESSLIST_POITYPE_NOPOI             =0x00;
    const NAV_ADDRESSLIST_POITYPE_ALLRESTAURANTS    =0x03;
    const NAV_ADDRESSLIST_POITYPE_COURT             =0x2A;
    const NAV_ADDRESSLIST_POITYPE_DINNINGSHOPPING   =0x2D;
    const NAV_ADDRESSLIST_POITYPE_CORPORATIONS      =0x27;
    const NAV_ADDRESSLIST_POITYPE_CITYHALL          =0x1D;
    const NAV_ADDRESSLIST_POITYPE_CARTRAIN          =0x18;
    const NAV_ADDRESSLIST_POITYPE_TRAVEL            =0x8D;
    const NAV_ADDRESSLIST_POITYPE_TRANSPORTATION    =0x8C;
    const NAV_ADDRESSLIST_POITYPE_SPORTGOODS        =0x82;
    const NAV_ADDRESSLIST_POITYPE_CARMAN            =0x9E;
    const NAV_ADDRESSLIST_POITYPE_UNKNOWN           =0xFF;
    const NAV_ADDRESSLIST_POITYPE_LIQGASSTATION     =0x58;
    const NAV_ADDRESSLIST_POITYPE_MAJORAPPLICANCE   =0x59;
    const NAV_ADDRESSLIST_POITYPE_PUBLISHER         =0x72;
    const NAV_ADDRESSLIST_POITYPE_SOCIALSERVICE     =0x7E;
    const NAV_ADDRESSLIST_POITYPE_GLASSANDWINDOW    =0x44;
    const NAV_ADDRESSLIST_POITYPE_FUNERALDIRECTOR   =0x3B;
    byte gAddressList_POIType[NAV_ADDRESSLIST_ENTRIES];
    //IssueList #216 15S1 update 17.01.2014
    char gAddressList_POIType_s [166][50] ={ "no POI",
                                            "Accommodation",
                                            "Airport",
                                            "all restaurants",
                                            "Amusement Park",
                                            "Apparel",
                                            "ATM (cashpoint)",
                                            "Attraction",
                                            "Automobile Club",
                                            "Banking and Shopping",
                                            "Banking",
                                            "Banquet-Halls",
                                            "Bars and Lounge",
                                            "Boating",
                                            "Bookstore",
                                            "Border Cross",
                                            "Bowling",
                                            "Broadcasting",
                                            "Business and Service",
                                            "Business",
                                            "Busstation",
                                            "Camping",
                                            "Car and Travel",
                                            "Car Track",
                                            "Car Train",
                                            "Car Service",
                                            "Car Wash",
                                            "Casino",
                                            "Cemetry",
                                            "Cityhall",
                                            "coffee",
                                            "Commuter Railstaion",
                                            "Cleaning Launch",
                                            "Clothing Store",
                                            "Communication",
                                            "Community Center",
                                            "Computer Hardware-Software",
                                            "Convenience Store",
                                            "Convention Center",
                                            "Corporations",
                                            "Corporations Public Places",
                                            "Culture Facility",
                                            "Court",
                                            "Department Store",
                                            "Dining and Entertainment",
                                            "Dinning Shopping",
                                            "Discount Store",
                                            "Education",
                                            "Electronics",
                                            "Embassy",
                                            "Emergency",
                                            "Emergency and Public",
                                            "Entertainment",
                                            "Fast Food",
                                            "Ferry",
                                            "Fire Department",
                                            "Flooring and Carpeting",
                                            "Flower and Jewelry",
                                            "Food and Beverage",
                                            "Funeral Director",
                                            "Furniture",
                                            "Games, Music and Video",
                                            "Garden and other",
                                            "Gasstation",
                                            "Gasstation DieselGasstation LPG",
                                            "General",
                                            "Gifts and Leisure",
                                            "Gifts- Antiques and Arts",
                                            "Glass and Window",
                                            "Golfing",
                                            "Goverment",
                                            "Grocery Stores",
                                            "Guesthouse",
                                            "Hair and Beauty",
                                            "Harbor",
                                            "Hardware and Lumber",
                                            "Health and Fitness",
                                            "Health- Care",
                                            "Highrise- BLDG",
                                            "Home and Improvment",
                                            "Home Center",
                                            "Home Service",
                                            "Hospital",
                                            "Hotel / Motel",
                                            "Iceskating",
                                            "Insurance",
                                            "Karaokay",
                                            "Library",
                                            "LIQ-Gas-Station",
                                            "Major-Appliance",
                                            "Mens-Apparel",
                                            "Monument",
                                            "Motorway Exit",
                                            "Motorway Cross",
                                            "Motorway Service",
                                            "Movie-Theater",
                                            "Moving and Storage",
                                            "Museum",
                                            "Nightclubs",
                                            "Optical",
                                            "Restaurant",
                                            "Park and Fitness",
                                            "Park and Ride",
                                            "Parking",
                                            "Parking Garage",
                                            "Parks",
                                            "Performing-Arts",
                                            "Personal- Service",
                                            "Pharmacies",
                                            "Photographer",
                                            "Place or workship",
                                            "Police Station",
                                            "Post Office",
                                            "Public Places",
                                            "Publisher",
                                            "Railway Station",
                                            "Recreation",
                                            "Rentel Service",
                                            "Repair",
                                            "Rest-Area",
                                            "Retirement Nursing",
                                            "Search",
                                            "Service",
                                            "Shoe Stores",
                                            "Shopping Center",
                                            "Skiing",
                                            "Social Service",
                                            "Speciality-Clothing",
                                            "Speciality-Store",
                                            "Speciality-Food",
                                            "Sport-Goods",
                                            "Sports",
                                            "Sport Airport",
                                            "Sports-Complex",
                                            "Tailor",
                                            "Tax-Service",
                                            "Tool-Booth",
                                            "Tourist Attraction",
                                            "Tourist Information",
                                            "Train Station",
                                            "Transportation",
                                            "Travel",
                                            "Travel-Agent",
                                            "University",
                                            "Utilities",
                                            "Variety-Store",
                                            "Wine and Liquor",
                                            "Womens Apparel",
                                            "Winery",
                                            "Winery",
                                            "car repair shop - Audi",
                                            "car repair shop - Seat",
                                            "car repair shop - Skoda",
                                            "car repair shop - VW Nutzfahrzeuge",
                                            "car repair shop - Bentley",
                                            "car repair shop - Bugatti",
                                            "car repair shop - Lamborghini",
                                            "car repair shop - Scania",
                                            "car repair shop - MAN",
                                            "car repair shop - Porsche",
                                            "electrical service station",
                                            "Diesel fuel station",
                                            "CNG fuel station",
                                            "rest area (Autohof)",
                                            "rest area with WC",
                                            "motorway service area"};       

    const NAV_ADDRESSLIST_ADDRESSTYPE_PRIVATE               =0x00;
    const NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPRIVATE       =0x01;
    const NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPARCELADDRESS =0x02;
    byte gAddressList_AddressType[NAV_ADDRESSLIST_ENTRIES];
    char gAddressList_AddressType_s[3][30]={    "private",
                                                "business",
                                                "business - parcel address"};

    byte gAddressList_ListEntryValidInformation [NAV_ADDRESSLIST_ENTRIES]; //indicates the existence of the "record element" 
    
    byte gAddressListLine_sum =0;
       
    char gAddressList_CSV_filename[NAV_FILENAME_SIZE];
    // ****** others.... *****
    
    byte gErrorCode;

    byte gNaviSD_PowerOnOff =FALSE;
    const POWER_OFF =0x00;
    const POWER_ON    =0x01;

    byte gBAP_Init =FALSE;

    char gstring_PowerOnOff [2][4]={"Off",
                                       "On"};
   
    dword gRGB_red;
    dword gRGB_yellow;
    dword gRGB_green;
    dword gRGB_grey;
    dword gRGB_white;

     //IssueList #9
    long Navi_HBdata[2];

    //IssueList #74
    byte gNaviFctList_0x22_TimeOut=0;
    byte gNaviFctList_0x29_TimeOut=0;
    byte gNaviFctList_0x2A_TimeOut=0;
    byte gNaviFctList_0x23_TimeOut=0;

    //IssueList #68
    const NAVIMAXPROCESSINGTIME = 180;
    Timer gNaviFctList_0x22_ProcessingTimer;
    Timer gNaviFctList_0x29_ProcessingTimer;
    Timer gNaviFctList_0x2A_ProcessingTimer;
    Timer gNaviFctList_0x23_ProcessingTimer;
    
    byte gNaviFctList_0x22_Processing_flg=0;
    byte gNaviFctList_0x29_Processing_flg=0;
    byte gNaviFctList_0x2A_Processing_flg=0;
    byte gNaviFctList_0x23_Processing_flg=0;

    //IssueList #119
    byte TTD_VI[8];

    //IssueList #76  MR49870
    //LastDestList
    //delete
    word gLDL_Pos_insDel [NAV_LASTDESTLIST_ENTRIES][2];
    byte gLDL_InvalidDel[NAV_LASTDESTLIST_ENTRIES];
    byte gLDL_DelInvalidCtr,gLDL_DelValidCtr;
    byte gLDL_Send[NAV_LASTDESTLIST_ENTRIES][1];
    word gLDL_totalDELctr;

    //insert
    byte gLDL_InvalidIns[NAV_LASTDESTLIST_ENTRIES];
    byte gLDL_InsInvalidCtr,gLDL_InsValidCtr;
    word gLDL_TotalElem, gLDL_CSVtotalElem;
    //VAGH-10511    
    byte ASGID, TAID;
} /* end of variables section */

on preStart
{
    char Path[255];
    char BAPVersion [200];
    
    // create write window for BAP communication
    gBAP_Trace  =writecreate("BAP-Trace NaviSD");                                
    
    // clear BAP trace window
    writeclear(gBAP_Trace);                                                    
    
    // error window for BAP communication
    gError_Trace=writecreate("NaviSD Error");                                    
    writeclear(gError_Trace);                                                

    gLaneGuidance_writeWindow =writecreate("NaviSD LaneGuidance_Array");
    writeclear(gLaneGuidance_writeWindow);
    
    gLastDestList_writeWindow =writecreate("NaviSD LastDestList_Array");
    writeclear(gLastDestList_writeWindow);

    gFavoriteDestList_writeWindow =writecreate("NaviSD FavoriteDestList_Array");
    writeclear(gFavoriteDestList_writeWindow);

    gNavBook_writeWindow =writecreate("NaviSD NavBook_Array");
    writeclear(gNavBook_writeWindow);
    
    gAddressList_writeWindow =writecreate("NaviSD AddressList_Array");
    writeclear(gAddressList_writeWindow);
    
    //IssueList #216 15S1 update 17.01.2014
    gPOIList_writeWindow =writecreate("NaviSD POIList_Array");
    writeclear(gPOIList_writeWindow);

    //clear CAPL-window in write-window
    writeclear(1);                                                            

    //get version from Stack
    Bap170_GetVersions(BAPVersion, 200);
    write(" ");
    write("***************************************************");
    write(BAPVersion);
    write("***************************************************");
    write(" ");
    
    
    write("***************************************************");
    write("FSG-NaviSD function catalog: 'BAP-FC_NAV-SD_P30DF44_v2.41_E4.pdf'");
    write("FSG-NaviSD MSCs: 'BAP-MSCs_NAV-SD_P30DF44_v2.41_E4.pdf'");
    write("***************************************************");
    

    // Create Node
    NODE_INDEX=Bap170_CreateNode();

    // Debug info
    // write("NODE_INDEX = 0x%x", NODE_INDEX); 

    // Load DBC and XML files. 
    write("*********************************************************************************");

    //load dbc-file
    getAbsFilePath(dbc_path, Path, 255);
    write("FSG-NaviSD: Loading BAP_DBC-File: '%s'", Path);
   
    if(Bap170_LoadDBC(NODE_INDEX, 1, Path) != BAP_ERR_OK)                        
        writelineEx(gError_Trace, 0, "FSG-NaviSD Fehler beim Laden: '%s', Path");

    //load xml-file 
    getAbsFilePath(xml_path, Path, 255);
    write("FSG-NaviSD: Load BAP-XML-File: '%s'", Path);
    
    if (Bap170_LoadConfig(NODE_INDEX, Path, "") != BAP_ERR_OK) 
        writelineEx(gError_Trace, 0, "FSG-NaviSD: Fehler beim Laden: '%s' !", Path);       
    write("*********************************************************************************");
    write("");

    // BAP DLL: Add CAN channel: BAP channel 1 is mapped to CAN card channel 1.
    Bap170_AddCanMap(NODE_INDEX, 1, 1);
    
} /* end of method */

on start
{    
    //Power on//off
    gBAP_Init =0;
    gNaviSD_PowerOnOff =0;
    
    //Panel
    // closePanel("FSG_NaviSD_Properties_1");
    // closePanel("FSG_NaviSD_Properties_2");
    // closePanel("FSG_NaviSD_Properties_3");
    // closePanel("FSG_NaviSD_Methods");
    // closePanel("FSG_NaviSD_0x1D - LastDest_List_(array)");
    // closePanel("FSG_NaviSD_0x18 - LaneGuidance_(array)");
    // closePanel("FSG_NaviSD_0x1E - FavoriteDest_List_(array)");
    // closePanel("FSG_NaviSD_0x20 - NavBook_(array)");
    // closePanel("FSG_NaviSD_0x21 - AddressList_(array)");
    //IssueList #216 15S1 update 17.01.2014
    // closePanel("FSG_Properties_4");
    // closePanel("FSG_NaviSD_MainPanel");
    // closePanel("MethodMIB2FSG");
    // closePanel("POI_List_FSG2");
    
    //openPanel("NaviSD_MainPanel");                              
}

on stopMeasurement
{
    Bap170_Shutdown(NODE_INDEX,LSG_NaviSD);
}

on timer TaskTimer
{
    Bap170_Task(NODE_INDEX);    //DLL-Task
    
    BAP_DLL_Indication();
    
    BAP_DLL_Request();
    
    if (getValue(eSendEnabled))
    {
        BAP_CAN_TX_Request();
    }

    setTimer(TaskTimer, 10);    //restart BAP-DLL-Timer
}

BAP_CAN_TX_Request()    // Function to send BAP data over CAN.
{
    int i;
    byte TX_Data[8];            // CAN data 
    dword TX_Header[3];            // CAN header 
    message 0x100 TX_Message;    // dummy message 

    TX_Header[2] = 8; // max-Length of TX_Data

    // Get BAP data in CAN format from DLL.
    while (Bap170_CAN_GetTxDat(NODE_INDEX,TX_Header,TX_Data) == 0) // as long as data are to be sent...
    {
        TX_Message.CAN = TX_Header[0]; // CAN channel
        TX_Message.ID  = TX_Header[1]; // CAN ID
        TX_Message.DLC = TX_Header[2]; // received length from BAP-DLL. 

        // CAN data bytes
        for (i=0; i < TX_Message.DLC; i++) 
        {
            TX_Message.byte(i) = TX_Data[i];
        }

        output(TX_Message); // send CAN message
        
        TX_Message.CAN = 2; // CAN channel
        output(TX_Message); // send CAN message

        
        TX_Message.CAN = 3; // CAN channel
        output(TX_Message); // send CAN message

        
                
        TX_Message.CAN = 4; // CAN channel
        output(TX_Message); // send CAN message


        // Correct bug on CAPL CAN interface.
        // Rewrite length information (max length). 
        TX_Header[2] = 8; // max. length of TX data.

    } /* end of: while (Bap170_CAN_GetTxDat(NODE_INDEX,TX_Header,TX_Data) == 0) */
} /* end of function */

BAP_DLL_Indication()
{
    int i, length, datalength, temp;
    byte Indication_data[BAP_BUFFER_SIZE];    //indication data from DLL
    dword Indication_header[6];                //indication header from DLL
    byte BAP_data_type;

    //init lokal variables
    length          =0;
    datalength      =0;
    temp            =0;
    BAP_data_type   =0;

    for(i=0;i<6;i++)
        Indication_header[i]=0;

    for(i=0;i<BAP_BUFFER_SIZE;i++)
        Indication_data[i]=0;
    //********************

    Indication_header[4] =BAP_BUFFER_SIZE;                                            //BAP-Stack needs this information for successful BAP_GetIndication 

    temp=Bap170_GetInd(NODE_INDEX, Indication_header, Indication_data);                //get BAP-Indication data from DLL
    //write("BAP_GetIndication: %d", temp);                                            //debug
    
    if(temp==0)
    {
        //read header
        gBAP_Indication[0]=Indication_header[0];                                    //LSG-ID
        gBAP_Indication[1]=Indication_header[1];                                    //Function-ID
        gBAP_Indication[2]=Indication_header[2];                                    //indication

        BAP_data_type=Indication_header[3];                                            //BAP data type
    //    writelineEx(gBAP_Trace, 0, "Data-Type: %d", BAP_data_type);                    //debug
        
        switch(BAP_data_type)
        {
            case Bap_Void:
                datalength=3;
                writelineEx(gBAP_Trace, 0, "FSG-Indication: ");                        //BAL-Trace
                for (i=0;i<datalength;i++)                                            //BAL-Trace
                    writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);                //BAL-Trace

                BAP_Indication(datalength);                                                    //evaluate BAP-Indication data
            break;
            
            case Bap_UInt8:
                gBAP_Indication[3]=Indication_header[5];                            //unit8-value
                
                datalength=4;
                
                /*writelineEx(gBAP_Trace, 0, "Indication_header:");                    //debug
                    for (i=0;i<6;i++)                                                    //debug
                        writeEX(gBAP_Trace, 0, " %x",Indication_header [i]);            //debug
                */        
                writelineEx(gBAP_Trace, 0, "FSG-Indication: ");                        //BAL-Trace
                
                for (i=0;i<datalength;i++)                                            //BAL-Trace
                    writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);                //BAL-Trace

                BAP_Indication(datalength);                                                    //evaluate BAP-Indication data
            break;
            
            case Bap_UInt16:
                gBAP_Indication[3]=Indication_header[5];                            //unit16-value
                
                datalength=4;
                
                /*writelineEx(1, 0, "Indication_header:");                            //debug
                    for (i=0;i<6;i++)                                                    //debug
                        writeEX(1, 0, " %x",Indication_header [i]);                        //debug
                */
                writelineEx(gBAP_Trace, 0, "FSG Indication: ");                        //BAL-Trace
                
                for (i=0;i<datalength;i++)                                            //BAL-Trace
                    writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);                //BAL-Trace

                BAP_Indication(datalength);                                                    //evaluate BAP-Indication data
            break;
            
            case Bap_UInt32:
                gBAP_Indication[3]=Indication_header[5];                            //unit32-value
                
                datalength=4;
                
                /*writelineEx(1, 0, "Indication_header:");                            //debug
                    for (i=0;i<6;i++)                                                    //debug
                        writeEX(1, 0, " %x",Indication_header [i]);                        //debug
                */
                
                writelineEx(gBAP_Trace, 0, "FSG Indication: ");                        //BAL-Trace
                
                for (i=0;i<datalength;i++)                                            //BAL-Trace
                    writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);                //BAL-Trace

                BAP_Indication(datalength);                                                    //evaluate BAP-Indication data
            break;
            
            case Bap_ByteSequence:                                                    //BAP-data-type is byte sequence
                //read datalength
                length      =Indication_header[4];                                        //length of date-array
                datalength  =length+3;                                                //length of indication-array

                //read data-array
                for(i=0;i<length;i++)
                    gBAP_Indication[i+3]=Indication_data[i];

                /*writelineEx(gBAP_Trace, 0, "Indication_header:");                    //debug
                for (i=0;i<6;i++)                                                    //debug
                    writeEX(gBAP_Trace, 0, " %x",Indication_header [i]);            //debug
        
                writelineEx(gBAP_Trace, 0, "Indication_data:");                        //debug
                for (i=0;i<length;i++)                                                //debug
                    writeEX(gBAP_Trace, 0, " %x",Indication_data [i]);                //debug
                */
                                
                writelineEx(gBAP_Trace, 0, "FSG-Indication: ");                        //BAL-Trace
                
                for (i=0;i<datalength;i++)                                            //BAL-Trace
                {
                    writeEX(gBAP_Trace, 0, " %x",gBAP_Indication[i]);                //BAL-Trace
                    
                    if(i>20)
                    {
                        i=datalength;
                        writeEX(gBAP_Trace, 0, "...");
                    }
                }

                BAP_Indication(datalength);                                                    //evaluate BAP-Indication data
            break;
            
            case Bap_Acknowledge: //not used, only at BAP 3.1
            break;
            
            case Bap_Error:
                gBAP_Indication[2]  =Error_IND;                                        //internal indication-value for error
                gBAP_Indication[3]  =Indication_header[5];                            //error-code
                datalength          =4;                                                //length of indication-array
                
                writelineEx(gBAP_Trace, 0, "FSG-Error-Indication: ");                //BAL-Trace
                writeEX(gBAP_Trace, 0, "LSG-ID: 0x%x   ",gBAP_Indication[0]);        //BAL-Trace
                writeEX(gBAP_Trace, 0, "Fct-ID: 0x%x   ",gBAP_Indication[1]);        //BAL-Trace
                //writeEX(gBAP_Trace, 0, "Opcode: 0x%x   ",gBAP_Indication[2]);        //BAL-Trace
                writeEX(gBAP_Trace, 0, "Error-Code: 0x%x   ",gBAP_Indication[3]);    //BAL-Trace

                BAP_Indication(datalength);                                                    //evaluate BAP-Indication data
            break;
            
            default:
                writelineEx(gError_Trace, 0, "FSG BAP_DLL_Indication: invalid BAP-Data-Type: %d", BAP_data_type);
            break;
        }
    }
}

BAP_DLL_Request ()
{
int i, datalength;
byte temp;
byte Request_data[BAP_BUFFER_SIZE];    //Request data for DLL
dword Request_header[6];    //Request header for DLL
byte error;                    //data-error-flag (Gerusch)

//init lokal variables
    datalength=0;
    temp=0;
    error=1;

    for(i=0;i<6;i++)
        Request_header[i]=0;

    for(i=0;i<BAP_BUFFER_SIZE;i++)
        Request_data[i]=0;
//********************

   
    if(gBAP_Requestbuffer_status [gstatus_requestbuffer]>0)                            //if ready to send
    {
    //    writelineEx(gBAP_Trace, 0, "DataTyp: %d", gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer]);
        switch(gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer])
        { 
            case Bap_Void:
                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];                    //LSG-ID
                Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];                    //Function-ID
                Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];                    //request
                Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];    //BAP data type
                Request_header[4]=0;                                                        //not used
                Request_header[5]=0;                                                        //not used
            break;
            case Bap_UInt8:
                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];                    //LSG-ID
                Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];                    //Function-ID
                Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];                    //request
                Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];    //BAP data type
                Request_header[4]=0;                                                        //not used
                Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];                    //unit8-value
            break;
            case Bap_UInt16:
                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];                    //LSG-ID
                Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];                    //Function-ID
                Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];                    //request
                Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];    //BAP data type
                Request_header[4]=0;                                                        //not used
                Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];                    //unit16-value
            break;
            case Bap_UInt32:
                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];                    //LSG-ID
                Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];                    //Function-ID
                Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];                    //request
                Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];    //BAP data type
                Request_header[4]=0;                                                        //not used
                Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];                    //unit32-value
            break;
            case Bap_ByteSequence:                    //BAP-data-type is byte sequence
                datalength=gBAP_Requestbuffer_status [gstatus_requestbuffer]-3;

                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];                    //LSG-ID
                Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];                    //Function-ID
                Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];                    //request
                Request_header[3]=Bap_ByteSequence;                                            //BAP data type
                Request_header[4]=datalength;                                                //length of date-array

                //data-array for BAP-DLL funcion 'BAP_Request'
                for(i=0;i<datalength;i++)
                    Request_data[i]=gBAP_Request[gstatus_requestbuffer] [i+3];


/*                writelineEx(1, 0, "Request_header:");                            //debug
                for (i=0;i<6;i++)                                                //debug
                    writeEX(1, 0, " %x",Request_header [i]);                    //debug
                
                writelineEx(1, 0, "Request_data:");                                //debug
                for (i=0;i<datalength;i++)                                        //debug
                    writeEX(1, 0, " %x",Request_data [i]);                        //debug
*/
            break;
            case Bap_Acknowledge:// not used only BAP 3.1
            break;
            case Bap_Error:
                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0]=gBAP_Request [gstatus_requestbuffer][0];                    //LSG-ID
                Request_header[1]=gBAP_Request [gstatus_requestbuffer][1];                    //Function-ID
                Request_header[2]=gBAP_Request [gstatus_requestbuffer][2];                    //request
                Request_header[3]=gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];    //BAP data type
                Request_header[4]=0;                                                        //not used
                Request_header[5]=gBAP_Request [gstatus_requestbuffer][3];                    //error code
            break;
            default:
                writelineEx(gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer]);
                error=0;
            break;            
        }
        
        if(error)                                                                            //no data-error
        {
            temp=Bap170_Request(NODE_INDEX, Request_header, Request_data);                    //send data to BAP-DLL
        
            if(temp==0)                                                                        //BAP-Request succesful                                            
            {
            /*    writelineEx(gBAP_Trace, 0, "FSG-Request:    ");                                //BAL-Trace        
                for (i=0;i<gBAP_Requestbuffer_status [gstatus_requestbuffer];i++)            //BAL-Trace    
                    writeEX(gBAP_Trace, 0, " %x",gBAP_Request [gstatus_requestbuffer] [i]);    //BAL-Trace    
            //    write("Send buffer-element %d to BAP-DLL", gstatus_requestbuffer);             //debug*/
            }
            else                                                                            //BAP-Request error
            {
                writelineEx(gBAP_Trace, 0, "FSG Error BAP_Request, errorcode: %x. FSG-Request:",temp);                //debug
                for (i=0;i<gBAP_Requestbuffer_status [gstatus_requestbuffer];i++)                                    //debug
                    writeEX(gBAP_Trace, 0, " %x",gBAP_Request [gstatus_requestbuffer] [i]);                            //debug
            }
        }

        gBAP_Requestbuffer_status [gstatus_requestbuffer]=0;        //reset position status -> free position 
        gBAP_Requestbuffer_BAPDataTyp [gstatus_requestbuffer]=0;    //reset BAP-datatyp of sendet buffer element

        //delete sendet request buffer elements
        for(i=0;i<BAP_BUFFER_SIZE;i++)
            gBAP_Request [gstatus_requestbuffer] [i]=0;                //delete sended array
        
        if (gstatus_requestbuffer<(REQUESTBUFFER_LINES-1))            //last element of buffer is not reached    
            gstatus_requestbuffer++;
        else                                                        //last element of buffer is reached
            gstatus_requestbuffer=0;
    }
}

BAP_Indication(int datalength)
{
    switch(gBAP_Indication[0])
    {
        case LSG_NaviSD:
                NaviSD_functions(datalength); 
         break;

        default:
            write("error BAP_Indication: invalid/unhandled LSG-ID %x", gBAP_Indication[0]);
    }
}

NaviSD_functions(int datalength)    
{
    dword requestarray [BAP_BUFFER_SIZE];

    switch (gBAP_Indication[1]) // function-ID
    {
        case FctID_FSG_OperationState:
            FSG_OperationState_Indication(gBAP_Indication, datalength);
        break;
        case FctID_CompassInfo:
            CompassInfo_Indication(gBAP_Indication, datalength);
        break;
        case FctID_RG_Status:
            RG_Status_Indication(gBAP_Indication, datalength);
        break;
        case FctID_DistanceToNextManeuver:
            DistanceToNextManeuver_Indication(gBAP_Indication, datalength);
        break;    
        case FctID_CurrentPositionInfo:
            CurrentPositionInfo_Indication(gBAP_Indication, datalength);
        break;
        case FctID_TurnToInfo:
            TurnToInfo_Indication(gBAP_Indication, datalength);
        break;
        case FctID_DistanceToDestination:
            DistanceToDestination_Indication(gBAP_Indication, datalength);
        break;
        case FctID_TimeToDestination:
            TimeToDestination_Indication(gBAP_Indication, datalength);
        break;        
        case FctID_ManeuverDescriptor:
            ManeuverDescriptor_Indication(gBAP_Indication, datalength);
        break;    
        case FctID_LaneGuidance:
            LaneGuidance_Indication(gBAP_Indication, datalength);
        break;
        case FctID_TMCinfo:
            TMCinfo_Indication(gBAP_Indication, datalength);
        break;
        case FctID_MagnetFieldZone:
            MagnetFieldZone_Indication(gBAP_Indication, datalength);
        break;    
        case FctID_Calibration:
            Calibration_Indication(gBAP_Indication, datalength);
        break;
        case FctID_ASGcapabilities:
            ASGcapabilities_Indication(gBAP_Indication, datalength);
        break;
        case FctID_LastDest_List:
            LastDestList_Indication(gBAP_Indication, datalength);
        break;
        case FctID_FavoriteDest_List:
            FavoriteDestList_Indication(gBAP_Indication, datalength);
        break;
        case FctID_PreferredDestList:
            PreferredDestList_Indication(gBAP_Indication, datalength);
        break;
        case FctID_NavBook:
            NavBook_Indication(gBAP_Indication, datalength);
        break;
        case FctID_Address_List:
            AddressList_Indication(gBAP_Indication, datalength);
        break;
        case FctID_VoiceGiudance:
            VoiceGuidance_Indication(gBAP_Indication, datalength);
        break;
        case FctID_InfoStates:
            InfoStates_Indication(gBAP_Indication, datalength);
        break;
        case FctID_ActiveRgType:
            ActiveRgType_Indication(gBAP_Indication, datalength);
        break;
        case FctID_TrafficBlock_Indication:
            TrafficBlock_Ind_Indication(gBAP_Indication, datalength);
        break;
        case FctID_RG_ActDeact:
            RGActDeact_Indication(gBAP_Indication, datalength);
        break;
        case FctID_RepeatLastNavAnnouncement:
            RepeatLastNavAnnouncement_Indication(gBAP_Indication, datalength);
        break;
        case FctID_GetNextListPos:
            GetNextListPos_Indication(gBAP_Indication, datalength);
        break;
        case FctID_NbSpeller:
            NbSpeller_Indication(gBAP_Indication, datalength);
        break;
    //Updates from J.Karl 07.11.2013
        case FctID_MapColorAndType_Indication:
            MapColorAndType_Indication(gBAP_Indication, datalength);
        break;
        case FctID_MapViewAndOrientation_Indication:
            MapViewAndOrientation_Indication(gBAP_Indication, datalength);
        break;
        case FctID_MapScale_Indication:
            MapScale_Indication(gBAP_Indication, datalength);
        break;
        case FctID_DestinationInfo_Indication:
            DestinationInfo_Indication(gBAP_Indication, datalength);
        break;
        case FctID_Altitude_Indication:
            Altitude_Indication(gBAP_Indication, datalength);
        break;
    //IssueList #216 15S1 update 17.01.2014
    case FctID_OnlineNavigationState:
            OnlineNaviState_Indication(gBAP_Indication, datalength);     
        break;
        case FctID_ExitView:
            ExitView_Indication(gBAP_Indication, datalength);
        break;
        case FctID_SemidynamicRouteGuidance_Indication:
            SemidynamicRouteGuidance_Indication(gBAP_Indication, datalength);
        break;
        //IssueList #216 15S1 update 17.01.2014
    case FctID_POI_Search:
            POI_Search_Indication(gBAP_Indication, datalength);
        break;
        case FctID_POI_List:
            POIList_Indication(gBAP_Indication, datalength);        
        break;
        case FctID_FSG_Setup:
            FSG_Setup_Indication(gBAP_Indication, datalength);        
        break;
        case FctID_Map_Preasentation:
            MapPresentation_Indication(gBAP_Indication, datalength);
        break;
    //MR 76047 
        case FctID_ManeuverState:
            Indication_ManeuverState(gBAP_Indication, datalength);
        break;
        case FctID_ETC_Status:
            Indication_ETC_Status(gBAP_Indication, datalength);
        break;
        default:
            write("FSG-NaviSD NaviSD_functions: invalid funcion-ID %x", gBAP_Indication[1]);
            
            // send error message.
            requestarray[0] =LSG_NaviSD;                    //LSG-ID
            requestarray[1] =gBAP_Indication[1];            //Fct.-ID
            requestarray[2] =Error_REQ;                     //request type
            requestarray[3] =BAP_BAL_TEMP_NOT_AVAILABLE;    //errorcode
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
    }    
}

BAP_Set_Cache()    //initialize BAP-FSG-Cache
{
    int Offset;
    dword Cache_Request_Header[6];
    byte  Cache_Request_Data[255];
    byte  i, error=0;
    
    /***FctID_FunctionList***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;            //LSG-ID
    Cache_Request_Header[1] =FctID_FunctionList;    //Fct-ID
    Cache_Request_Header[2] =0;                        //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;        //data-type
    Cache_Request_Header[4] =8;                        //length
    Cache_Request_Header[5] =0;                        //ignored

    for(i = 0; i < 8; i++)
        Cache_Request_Data[i] =gFunctionList[i];
        
    Fct_initSendBuf("FunctionList", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

    //IssueList #9
       /***FSG-HeartBeat***/
    //header
    Cache_Request_Header[0] = LSG_NaviSD;                    //LSG-ID
    Cache_Request_Header[1] = FctID_HeartBeat;        //Fct-ID
    Cache_Request_Header[2] = 0;                            //ignored
    Cache_Request_Header[3] = Bap_UInt8;                    //data-type
    Cache_Request_Header[4] = 0;                            //ignored
    if (getValue(env_FSG_Navi_HB_button))
    Cache_Request_Header[5] = getValue(env_FSG_Navi_HB_input);
    else
    Cache_Request_Header[5] = 0;

    Navi_HBdata[0] = LSG_NaviSD;
    Navi_HBdata[1] = Cache_Request_Header[5];
    
    
    ChangeConfig(0x00,Navi_HBdata);
    Fct_initSendBuf("Heartbeat", Cache_Request_Header, Cache_Request_Data);

    /***FSG-OperationState***/
    //header
    Cache_Request_Header[0] = LSG_NaviSD;                    //LSG-ID
    Cache_Request_Header[1] = FctID_FSG_OperationState;        //Fct-ID
    Cache_Request_Header[2] = 0;                            //ignored
    Cache_Request_Header[3] = Bap_UInt8;                    //data-type
    Cache_Request_Header[4] = 0;                            //ignored
    Cache_Request_Header[5] = gFSG_OperationState;          //unit8- value 
    
    Fct_initSendBuf("FctID_FSG_OperationState", Cache_Request_Header, Cache_Request_Data);

    /***CompassInfo***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_CompassInfo;            //Fct-ID
    Cache_Request_Header[2] =0;                            //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;            //data-type
    Cache_Request_Header[4] =3;                            //length
    Cache_Request_Header[5] =0;                                 //ignored 
    
    Cache_Request_Data[0]   =gCI_Direction_Symbolic;
    Cache_Request_Data[1]   =gCI_Direction_Angle & 0x00ff;
    Cache_Request_Data[2]   =(gCI_Direction_Angle & 0xff00)/0x100;
    
    Fct_initSendBuf("FctID_CompassInfo", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

    /***RG_Status***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_RG_Status;              //Fct-ID
    Cache_Request_Header[2] =0;                            //ignored
    Cache_Request_Header[3] =Bap_UInt8;                    //data-type
    Cache_Request_Header[4] =0;                            //ignored
    Cache_Request_Header[5] =gRG_Status;                   //unit8- value 
    
    Fct_initSendBuf("FctID_RG_Status", Cache_Request_Header, Cache_Request_Data);

    /***DistanceToNextManeuver***/
    Cache_Request_Header[0] =LSG_NaviSD;                    //LSG-ID
    Cache_Request_Header[1] =FctID_DistanceToNextManeuver;    //Fct-ID
    Cache_Request_Header[2] =0;                                //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;                //data-type
    Cache_Request_Header[4] =8;                                //length
    Cache_Request_Header[5] =0;                              //ignored

    Cache_Request_Data[0]   =gDTNM_Distance & 0xff;
    Cache_Request_Data[1]   =(gDTNM_Distance & 0xff00)/0x100;
    Cache_Request_Data[2]   =(gDTNM_Distance & 0xff0000)/0x10000;
    Cache_Request_Data[3]   =(gDTNM_Distance & 0xff000000)/0x1000000;
    Cache_Request_Data[4]   =gDTNM_Unit;
    Cache_Request_Data[5]   =gDTNM_BargraphOnOff;
    Cache_Request_Data[6]   =gDTNM_Bargraph;
    Cache_Request_Data[7]   =gDTNM_ValidityInformation;

    Fct_initSendBuf("FctID_DistanceToNextManeuver", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

    /***CurrentPositionInfo***/
    Cache_Request_Header[0] =LSG_NaviSD;                    //LSG-ID
    Cache_Request_Header[1] =FctID_CurrentPositionInfo;        //Fct-ID
    Cache_Request_Header[2] =0;                                //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;                //data-type
    Cache_Request_Header[4] =1+strlen(gCurrentPositionInfo_PositionInfo);                                //length
    Cache_Request_Header[5] =0;                              //ignored
    Offset=0;

    Cache_Request_Data[Offset]=strlen(gCurrentPositionInfo_PositionInfo); 
    Offset++;

    for(i=0; i<strlen(gCurrentPositionInfo_PositionInfo); i++)
    {
            Cache_Request_Data[Offset] =gCurrentPositionInfo_PositionInfo[i];
            Offset++;
    }

    Fct_initSendBuf("FctID_CurrentPositionInfo", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

    /***TurnToInfo***/
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_TurnToInfo;            //Fct-ID
    Cache_Request_Header[2] =0;                            //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;            //data-type
    Cache_Request_Header[4] =2+strlen(gTurnToInfo_TurnToInfo)+strlen(gTurnToInfo_SignPost);                            //length
    Cache_Request_Header[5] =0;                          //ignored
    Offset=0;
    
    Cache_Request_Data[Offset]=strlen(gTurnToInfo_TurnToInfo); 
    Offset++;

    for(i=0; i<strlen(gTurnToInfo_TurnToInfo); i++)
    {
            Cache_Request_Data[Offset] =gTurnToInfo_TurnToInfo[i];
            Offset++;
    } 
    
    Cache_Request_Data[Offset]=strlen(gTurnToInfo_SignPost); 
    Offset++;
   
    for(i=0; i<strlen(gTurnToInfo_SignPost); i++)
    {
            Cache_Request_Data[Offset] =gTurnToInfo_SignPost[i];
            Offset++;
    }

    Fct_initSendBuf("FctID_TurnToInfo", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

    /***DistanceToDestination***/
    Cache_Request_Header[0] =LSG_NaviSD;                    //LSG-ID
    Cache_Request_Header[1] =FctID_DistanceToDestination;    //Fct-ID
    Cache_Request_Header[2] =0;                                //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;                //data-type
    Cache_Request_Header[4] =6;                                //length
    Cache_Request_Header[5] =0;                              //ignored

    Cache_Request_Data[0]   =gDTD_Distance & 0xff;
    Cache_Request_Data[1]   =(gDTD_Distance & 0xff00)/0x100;
    Cache_Request_Data[2]   =(gDTD_Distance & 0xff0000)/0x10000;
    Cache_Request_Data[3]   =(gDTD_Distance & 0xff000000)/0x1000000;
    Cache_Request_Data[4]   =gDTD_Unit; 
    //MR 76047 
    Cache_Request_Data[5]   =gDTD_ValidityInformation & (gDTD_DTDType << 4);    

    Fct_initSendBuf("FctID_DistanceToDestination", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

    /***TimeToDestination***/
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_TimeToDestination;    //Fct-ID
    Cache_Request_Header[2] =0;                            //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;            //data-type
    Cache_Request_Header[4] =7;                            //length
    Cache_Request_Header[5] =0;                          //ignored
       
    Cache_Request_Data[0]   =(gTTD_TimeInfoType *0x10) +gTTD_NavigationTimeFormat; 
    Cache_Request_Data[1]   =gTTD_Minute; 
    Cache_Request_Data[2]   =gTTD_Hour; 
    Cache_Request_Data[3]   =gTTD_Day; 
    Cache_Request_Data[4]   =gTTD_Month; 
    Cache_Request_Data[5]   =gTTD_Year;
    Cache_Request_Data[6]   =gTTD_ValidityInformation; 

    Fct_initSendBuf("FctID_TimeToDestination", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

    /***ManeuverDescriptor***/
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_ManeuverDescriptor;    //Fct-ID
    Cache_Request_Header[2] =0;                            //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;            //data-type
    Cache_Request_Header[4] =12;                        //length
    Cache_Request_Header[5] =0;                          //ignored

    Cache_Request_Data[0]   =gMD_MainElement_1; 
    Cache_Request_Data[1]   =gMD_Direction_1; 
    Cache_Request_Data[2]   =gMD_ZLevelGuidance_1; 
    Cache_Request_Data[3]   =0; 
    Cache_Request_Data[4]   =gMD_MainElement_2; 
    Cache_Request_Data[5]   =gMD_Direction_2; 
    Cache_Request_Data[6]   =gMD_ZLevelGuidance_2; 
    Cache_Request_Data[7]   =0;  
    Cache_Request_Data[8]   =gMD_MainElement_3; 
    Cache_Request_Data[9]   =gMD_Direction_3; 
    Cache_Request_Data[10]  =gMD_ZLevelGuidance_3; 
    Cache_Request_Data[11]  =0; 

    Fct_initSendBuf("FctID_ManeuverDescriptor", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;
    
    /***TMCinfo***/
    Cache_Request_Header[0] = LSG_NaviSD;                    //LSG-ID
    Cache_Request_Header[1] = FctID_TMCinfo;                //Fct-ID
    Cache_Request_Header[2] = 0;                            //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;                //data-type
    Cache_Request_Header[4] = 12+strlen(gTMCinfo_StreetName)+strlen(gTMCinfo_Location)+strlen(gTMCinfo_Infotext);//length
    Cache_Request_Header[5] = 0;                              //ignored

    //ID/Status
    Cache_Request_Data[0] =(gTMCinfo_MessageID & 0xF) *0x10 + (gTMCinfo_MessageStatus & 0x0f);    
   
    //waiting indication
    Cache_Request_Data[Offset] =gTMCinfo_MessageWaitingIndication;
        
    //Priority
    Cache_Request_Data[Offset] =gTMCinfo_Priority;
    Offset =3;

    //StreetName
    Cache_Request_Data[Offset]=strlen(gTMCinfo_StreetName);
    Offset++;

    for(i=0;i<strlen(gTMCinfo_StreetName);i++)
    {
         Cache_Request_Data[Offset] =gTMCinfo_StreetName[i];
         Offset++;
    }
    
    //Location
    Cache_Request_Data[Offset]=strlen(gTMCinfo_Location);
    Offset++;

    for(i=0;i<strlen(gTMCinfo_Location);i++)
    {
         Cache_Request_Data[Offset] =gTMCinfo_Location[i];
         Offset++;
    }
    
    //Infotext
    Cache_Request_Data[Offset]=strlen(gTMCinfo_Infotext);
    Offset++;

    for(i=0;i<strlen(gTMCinfo_Infotext);i++)
    {
         Cache_Request_Data[Offset] =gTMCinfo_Infotext[i];
         Offset++;
    }
    
    //Length_Validity
    Cache_Request_Data[Offset] =gTMCinfo_Length_Validity;
    Offset++;
    
    //Length_Value
    Cache_Request_Data[Offset] =gTMCinfo_Length_Value & 0xff;
    Offset++;
    Cache_Request_Data[Offset] =(gTMCinfo_Length_Value & 0xff00)/0x100;
    Offset++;
    Cache_Request_Data[Offset] =(gTMCinfo_Length_Value & 0xff0000)/0x10000;
    Offset++; 
    Cache_Request_Data[Offset] =(gTMCinfo_Length_Value & 0xff000000)/0x1000000;
    Offset++;
    
    //Length_Unit
    Cache_Request_Data[Offset] =gTMCinfo_Length_Unit;
    Offset++;

    Fct_initSendBuf("FctID_TMCinfo", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

    /***MagnetFieldZone***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_MagnetFieldZone;        //Fct-ID
    Cache_Request_Header[2] =0;                            //ignored
    Cache_Request_Header[3] =Bap_UInt8;                    //data-type
    Cache_Request_Header[4] =0;                            //ignored
    Cache_Request_Header[5] =gNaviSD_MFZone;               //unit8- value 
    
    Fct_initSendBuf("FctID_MagnetFieldZone", Cache_Request_Header, Cache_Request_Data);

    /***Calibration***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_Calibration;            //Fct-ID
    Cache_Request_Header[2] =0;                            //ignored
    Cache_Request_Header[3] =Bap_UInt8;                    //data-type
    Cache_Request_Header[4] =0;                            //ignored
    Cache_Request_Header[5] =gNaviSD_CalibrationState;  //unit8- value 
    
    Fct_initSendBuf("FctID_Calibration", Cache_Request_Header, Cache_Request_Data);

    /***ASGcapabilities***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_ASGcapabilities;        //Fct-ID
    Cache_Request_Header[2] =0;                            //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;            //data-type
    Cache_Request_Header[4] =1;                            //length
    Cache_Request_Header[5] =0;                         //ignored
    
    Cache_Request_Data[0]   =(gNaviSD_ASGcap_PresentationCapabilities &0x0F) *0x10 +gNaviSD_ASGcap_FurtherCapabilities &0x0F;        //unit8- value 
    
    Fct_initSendBuf("FctID_ASGcapabilities", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

    /***PreferredDestList***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                    //LSG-ID
    Cache_Request_Header[1] =FctID_PreferredDestList;        //Fct-ID
    Cache_Request_Header[2] =0;                                //ignored
    Cache_Request_Header[3] =Bap_UInt8;                        //data-type
    Cache_Request_Header[4] =0;                                //ignored
    Cache_Request_Header[5] =gNaviSD_PrefDestList_ListType; //unit8- value 
    
    Fct_initSendBuf("FctID_PreferredDestList", Cache_Request_Header, Cache_Request_Data);

    /****VoiceGuidance***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                    //LSG-ID
    Cache_Request_Header[1] =FctID_VoiceGiudance;            //Fct-ID
    Cache_Request_Header[2] =0;                                //ignored
    Cache_Request_Header[3] =Bap_UInt8;                        //data-type
    Cache_Request_Header[4] =0;                                //ignored
    Cache_Request_Header[5] =gNaviSD_VoiceGuidance_State;   //unit8- value 
    
    Fct_initSendBuf("FctID_VoiceGiudance", Cache_Request_Header, Cache_Request_Data);

    /***FunctionSynchronisation***/
    //header
    Cache_Request_Header[0] = LSG_NaviSD;                        //LSG-ID
    Cache_Request_Header[1] = FctID_FunctionSynchronisation;    //Fct-ID
    Cache_Request_Header[2] = 0;                                //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;                    //data-type
    Cache_Request_Header[4] = 8;                                //length
    Cache_Request_Header[5] = 0;                                //ignored

    for(i=0; i<8; i++)
        Cache_Request_Data[i] =gNaviSD_FunctionSynchronisation_FctList[i];

    Fct_initSendBuf("FunctionSynchronisation", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;


    /***InfoStates***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_InfoStates;            //Fct-ID
    Cache_Request_Header[2] =0;                            //ignored
    Cache_Request_Header[3] =Bap_UInt8;                    //data-type
    Cache_Request_Header[4] =0;                            //ignored
    Cache_Request_Header[5] =gNAV_InfoStates;           //unit8- value
    
    Fct_initSendBuf("FctID_InfoStates", Cache_Request_Header, Cache_Request_Data);

    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

    /***ActiveRgType***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                    //LSG-ID
    Cache_Request_Header[1] =FctID_ActiveRgType;            //Fct-ID
    Cache_Request_Header[2] =0;                                //ignored
    Cache_Request_Header[3] =Bap_UInt8;                        //data-type
    Cache_Request_Header[4] =0;                                //ignored
    Cache_Request_Header[5] =gNAV_ActiveRgType_RGType;      //unit8- value 
    
    Fct_initSendBuf("FctID_ActiveRgType", Cache_Request_Header, Cache_Request_Data);

    /***TrafficBlock_Indication***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                        //LSG-ID
    Cache_Request_Header[1] =FctID_TrafficBlock_Indication;     //Fct-ID
    Cache_Request_Header[2] =0;                                    //ignored
    Cache_Request_Header[3] =Bap_UInt8;                            //data-type
    Cache_Request_Header[4] =0;                                    //ignored
    Cache_Request_Header[5] =gNAV_TrafficBlock_Ind_TMCSymbol;   //unit8- value 
    
    Fct_initSendBuf("FctID_TrafficBlock_Indication", Cache_Request_Header, Cache_Request_Data);
//Updates from J.Karl 07.11.2013
    /***MapColorAndType***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_MapColorAndType_Indication;        //Fct-ID
    Cache_Request_Header[2] =0;                            //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;            //data-type
    Cache_Request_Header[4] =4;                            //length
    Cache_Request_Header[5] =0;                         //ignored
    
     for(i = 0; i < 4; i++)
        Cache_Request_Data[i]=0;
    
    Fct_initSendBuf("FctID_MapColorAndType", Cache_Request_Header, Cache_Request_Data);

    /***MapViewAndOrientation***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_MapViewAndOrientation_Indication;        //Fct-ID
    Cache_Request_Header[2] =0;                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;        //data-type
    Cache_Request_Header[4] =7;                    //length
    Cache_Request_Header[5] =0;                                 //ignored
    
     for(i = 0; i < 7; i++)
        Cache_Request_Data[i]=0;
    
    Fct_initSendBuf("FctID_MapViewAndOrientation", Cache_Request_Header, Cache_Request_Data);

    /***MapScale***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_MapScale_Indication;    //Fct-ID
    Cache_Request_Header[2] =0;                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;        //data-type
    Cache_Request_Header[4] =6;                    //length
    Cache_Request_Header[5] =0;                                 //ignored
    
     for(i = 0; i < 6; i++)
        Cache_Request_Data[i]=0;
    
    Fct_initSendBuf("FctID_MapScale", Cache_Request_Header, Cache_Request_Data);


     /***DestinationInfo***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_DestinationInfo_Indication;    //Fct-ID
    Cache_Request_Header[2] =0;                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;        //data-type
    Cache_Request_Header[4] =1; //405                     //length
    Cache_Request_Header[5] =0;                                 //ignored
    
//     for(i = 0; i < 255; i++)   // 405
        Cache_Request_Data[0]=0;
//    
    Fct_initSendBuf("FctID_DestinationInfo", Cache_Request_Header, Cache_Request_Data);

     /***Altitude***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_Altitude_Indication;    //Fct-ID
    Cache_Request_Header[2] =0;                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;        //data-type
    Cache_Request_Header[4] =3;                    //length
    Cache_Request_Header[5] =0;                                 //ignored
    
     for(i = 0; i < 3; i++)
        Cache_Request_Data[i]=0;
    
    Fct_initSendBuf("FctID_Altitude", Cache_Request_Header, Cache_Request_Data);

//IssueList #216 15S1 update 17.01.2014
    /***OnlineNavigationState***/
    //header    
    Cache_Request_Header[0] =LSG_NaviSD;                        //LSG-ID
    Cache_Request_Header[1] =FctID_OnlineNavigationState;       //Fct-ID
    Cache_Request_Header[2] =0;                                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;                        //data-type
    Cache_Request_Header[4] =3;                                    //ignored
    Cache_Request_Header[5] =0;   //unit8- value 
    
    Fct_initSendBuf("FctID_OnlineNavigationState", Cache_Request_Header, Cache_Request_Data);
    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;    



    /***Exitview***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                        //LSG-ID
    Cache_Request_Header[1] =FctID_ExitView;                    //Fct-ID
    Cache_Request_Header[2] =0;                                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;                    //data-type
    Cache_Request_Header[4] =3;                                    //ignored
    Cache_Request_Header[5] =0;                                 //unit8- value 
    
    Fct_initSendBuf("FctID_ExitView", Cache_Request_Header, Cache_Request_Data);
    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

     /***SemidynamicRouteGuidance***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                //LSG-ID
    Cache_Request_Header[1] =FctID_SemidynamicRouteGuidance_Indication;    //Fct-ID
    Cache_Request_Header[2] =0;                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;        //data-type
    Cache_Request_Header[4] =16;                    //length
    Cache_Request_Header[5] =0;                                 //ignored
    
     for(i = 0; i < 16; i++)
        Cache_Request_Data[i]=0;
    
    Fct_initSendBuf("FctID_SemidynamicRouteGuidance", Cache_Request_Header, Cache_Request_Data);
  /***POI_Search***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                        //LSG-ID
    Cache_Request_Header[1] =FctID_POI_Search;                  //Fct-ID
    Cache_Request_Header[2] =0;                                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;                    //data-type
    Cache_Request_Header[4] =2;                                    //ignored
    Cache_Request_Header[5] =0;                                 //unit8- value 
    
    Fct_initSendBuf("FctID_POI_Search", Cache_Request_Header, Cache_Request_Data);
    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;



    /***POI_List***/
    //header
/*    Cache_Request_Header[0] =LSG_NaviSD;                        //LSG-ID
    Cache_Request_Header[1] =FctID_POI_List;                    //Fct-ID
    Cache_Request_Header[2] =0;                                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;                        //data-type
    Cache_Request_Header[4] =1829;                                    //ignored
    Cache_Request_Header[5] =0;   //unit8- value 
    
    Fct_initSendBuf("FctID_POI_List", Cache_Request_Header, Cache_Request_Data);
    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;

*/

    /***FSG_Setup***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                        //LSG-ID
    Cache_Request_Header[1] =FctID_FSG_Setup;                   //Fct-ID
    Cache_Request_Header[2] =0;                                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;                            //data-type
    Cache_Request_Header[4] =6;                                    //ignored
    Cache_Request_Header[5] =0;                                 //unit8- value        
    
    Fct_initSendBuf("FctID_FSG_Setup", Cache_Request_Header, Cache_Request_Data);
    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;




    /***Map_Presentation***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                        //LSG-ID
    Cache_Request_Header[1] =FctID_Map_Preasentation;           //Fct-ID
    Cache_Request_Header[2] =0;                                    //ignored
    Cache_Request_Header[3] =Bap_UInt8;                            //data-type
    Cache_Request_Header[4] =0;                                    //ignored
    Cache_Request_Header[5] =0;   //unit8- value 
    
    Fct_initSendBuf("FctID_Map_Preasentation", Cache_Request_Header, Cache_Request_Data);
    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;



    //MR 76047 
    /***ManeuverState***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                        //LSG-ID
    Cache_Request_Header[1] =FctID_ManeuverState;               //Fct-ID
    Cache_Request_Header[2] =0;                                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;                  //data-type
    Cache_Request_Header[4] =4;                                    //ignored
    Cache_Request_Header[5] =0;                                 //unit8- value 
    
    Fct_initSendBuf("FctID_ManeuverState", Cache_Request_Header, Cache_Request_Data);
    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;




    /***ETC_Status***/
    //header
    Cache_Request_Header[0] =LSG_NaviSD;                        //LSG-ID
    Cache_Request_Header[1] =FctID_ETC_Status   ;               //Fct-ID
    Cache_Request_Header[2] =0;                                    //ignored
    Cache_Request_Header[3] =Bap_ByteSequence;                  //data-type
    Cache_Request_Header[4] =2;                                    //ignored-length
    Cache_Request_Header[5] =0;                                 //unit8- value 
    
    Fct_initSendBuf("FctID_ETC_Status", Cache_Request_Header, Cache_Request_Data);
    for(i = 0; i < 255; i++)
        Cache_Request_Data[i] =0;
}

set_status_requestbuffer (dword Request_array [], int length, byte BAPDataType)
{
    int bufferline = 0, i;

    bufferline = get_requestbuffer_line();

    for(i = 0; i < length; i++)
        gBAP_Request[bufferline][i] = Request_array[i];

    gBAP_Requestbuffer_status[bufferline] = length;
    gBAP_Requestbuffer_BAPDataTyp[bufferline] = BAPDataType;
}

byte get_requestbuffer_line()    //function to reserve memory in request-ring-buffer
{
    int line;

    //init lokal variables
    line=0;
    //********************    
    
    line=gwrite_requestbuffer_line;                            //next free element in ring-buffer
    if(gwrite_requestbuffer_line<(REQUESTBUFFER_LINES-1))    //last element of ring-buffer is not reached
        gwrite_requestbuffer_line++;
    else                                                    //last element of ring-buffer is reached
        gwrite_requestbuffer_line=0;
    
    return (line);                                            //return position of free ring-buffer element
}

Shutdown_NaviSD()
{
    //Timer
    canceltimer(Powerontimer);
    canceltimer(TaskTimer);
    canceltimer(StartFSG_Timer);
    canceltimer(RGActDeact_Timer);

    putvalue(env_NaviSD_Config_SWConfig,empty_string);
    putvalue(env_NaviSD_Config_DBC,empty_string);

    //FSG-OperationState
    putValue(env_NaviSD_FSG_OP_State, NAV_OPSTATE_OFF);

    //CompassInfo
    putValue(env_NaviSD_Direction_Symbolik,0);
    putValue(env_NaviSD_Direction_Angle, 0);

    //RouteGuidance_Status
    putValue(env_NaviSD_RG_Status, 0);
    
    //MR48598
    gRG_Status =getValue(env_NaviSD_RG_Status);
    RG_Status_Request(Data_REQ,0); //send status


    //DistanceToNextManeuver
    putValue(env_NaviSD_DTNM_Distance, 0);
    putValue(env_NaviSD_DTNM_Unit, 0);
    putValue(env_NaviSD_DTNM_BG_ON_OFF, 0);
    putValue(env_NaviSD_DTNM_BG, 0);

    //CurrentPositionInfo
    putValue(env_NaviSD_PositionInfo, empty_string);

    //TurnToInfo
    putValue(env_NaviSD_TTI_TurnToInfo, empty_string);
    putValue(env_NaviSD_TTI_SignPost, empty_string);

    //DistanceToDestination        
    putValue(env_NaviSD_DTD_Distance, 0);
    putValue(env_NaviSD_DTD_Unit, 0);
    putValue(env_NaviSD_DTD_ValidityInfo, 0);

    //TimeToDestination
    putValue(env_NaviSD_TTD_TimeInfoType, 0);
    putValue(env_NaviSD_TTD_NavigationTF, 0);
    putValue(env_NaviSD_TTD_Minute, 0);
    putValue(env_NaviSD_TTD_Hour, 0);
    putValue(env_NaviSD_TTD_Day, 0);
    putValue(env_NaviSD_TTD_Month, 0);
    putValue(env_NaviSD_TTD_Year, 0);

    //ManeuverDescriptor
    putvalue(env_NaviSD_MD_MainElement1, 0);
    putvalue(env_NaviSD_MD_MainElement2, 0);
    putvalue(env_NaviSD_MD_MainElement3, 0);

    putvalue(env_NaviSD_MD_Direction1, 0);
    putvalue(env_NaviSD_MD_Direction2, 0);
    putvalue(env_NaviSD_MD_Direction3, 0);

    putvalue(env_NaviSD_MD_Z_Level1, 0);
    putvalue(env_NaviSD_MD_Z_Level2, 0);
    putvalue(env_NaviSD_MD_Z_Level3, 0);

    putvalue(env_NaviSD_MD_Sidestreet1, gMD_Sidestreet_1);
    putvalue(env_NaviSD_MD_Sidestreet2, gMD_Sidestreet_2);
    putvalue(env_NaviSD_MD_Sidestreet3, gMD_Sidestreet_3);
   
    //TMCinfo
    putvalue(env_NaviSD_TMCI_MessageID, 0);
    putvalue(env_NaviSD_TMCI_MS, 0);
    putvalue(env_NaviSD_TMCI_MS_s, empty_string);
    putvalue(env_NaviSD_TMCI_MessageWaitInd, 0);
    putvalue(env_NaviSD_TMCI_Priority, 0);
    putvalue(env_NaviSD_TMCI_StreetName, empty_string);
    putvalue(env_NaviSD_TMCI_Location, empty_string);
    putvalue(env_NaviSD_TMCI_Infotext, empty_string);
    putvalue(env_NaviSD_TMCI_Length_Validity, 0);
    putvalue(env_NaviSD_TMCI_Length_Value, 0);
    putvalue(env_NaviSD_TMCI_Length_Unit, 0);

    //MagnetFieldZone
    putValue(env_NaviSD_MFZone_Zone_set, 1);
    putValue(env_NaviSD_MFZone_Zone_s, empty_string);

    //Calibration
    putValue(env_NaviSD_CaliState_set, NAV_CALIBRATION_CALIBRATED);
    putValue(env_NaviSD_CaliState_s, empty_string);

    //ASGcapabilities
    putvalue(env_NaviSD_ASGcap_Pres_s, empty_string);
    putvalue(env_NaviSD_ASGcap_Pres,0);

    //PrefererredDestList
    putvalue(env_NaviSD_PrefDeLis_Type, 0);

    //VoiceGuidance
    putvalue(env_NaviSD_VG_State_s, empty_string);
    putvalue(env_NaviSD_VG_State,NAV_VOICEGUIDANCE_ON_FULL);

    //FunctionSynchronisation
    putvalue(env_NaviSD_FctSync_Bit16_CI, 0);
    putvalue(env_NaviSD_FctSync_Bit17_RGS,0);
    putvalue(env_NaviSD_FctSync_Bit18_DTNM,0);
    putvalue(env_NaviSD_FctSync_Bit19_CPI,0);
    putvalue(env_NaviSD_FctSync_Bit20_TTI,0);
    putvalue(env_NaviSD_FctSync_Bit21_DTD,0);
    putvalue(env_NaviSD_FctSync_Bit22_TTD,0);
    putvalue(env_NaviSD_FctSync_Bit23_MD,0);
    putvalue(env_NaviSD_FctSync_Bit24_LG,0);
    putvalue(env_NaviSD_FctSync_Bit25_TMCI,0);
    putvalue(env_NaviSD_FctSync_Bit26_MFZ, 0);
    putvalue(env_NaviSD_FctSync_Bit27_Cal,0); 
    putvalue(env_NaviSD_FctSync_Bit29_LDList,0);
    putvalue(env_NaviSD_FctSync_Bit30_FaList,0);
    putvalue(env_NaviSD_FctSync_Bit31_PrList,0);
    putvalue(env_NaviSD_FctSync_Bit32_NavB,0);
    putvalue(env_NaviSD_FctSync_Bit33_AL,0);
    putvalue(env_NaviSD_FctSync_Bit34_RGL,0);
    putvalue(env_NaviSD_FctSync_Bit36_VG,0);
    putvalue(env_NaviSD_FctSync_Bit38_IS,0);
    putvalue(env_NaviSD_FctSync_Bit39_AGRT,0);
    putvalue(env_NaviSD_FctSync_Bit40_TBI,0);

    //InfoStates
    putvalue(env_NaviSD_InfoStates_states,NAV_INFOSATES_NOERROR);

    //ActiveRgType
    putvalue(env_NaviSD_ActRGTy_RGType_s,empty_string);
    putvalue(env_NaviSD_ActRGTy_RGType,NAV_ACTIVERGTYPE_RGI);

    //TrafficBlock_Indication
    putvalue(env_NaviSD_TBInd_TMCSym,NAV_TRAFFICBLOCK_NO_TMC_SYMBOL);

    //RG_ActDeact
    putvalue(env_NaviSD_RGActDeact_Res, NAV_RGACTDEACT_SUCCESSFUL);
    putvalue(env_NaviSD_RGActDeact_CoTy_s, empty_string);
    putvalue(env_NaviSD_RGActDeact_CITy_s, empty_string);
    putvalue(env_NaviSD_RGActDeact_CIInfo, 0);
    putvalue(env_NaviSD_RGActDeact_AbortRes, NAV_RGACTDEACT_ABORT_SUCCESSFUL);
    putvalue(env_NaviSD_RGActDeact_Error_on, FALSE);
    putvalue(env_NaviSD_RGActDeact_ErrorCode, 0); 

    //RepeatLastAnnouncement
    putvalue(env_NaviSD_RepeatLastNavAnn_Res,NAV_REPEATLASTNAVANN_SUCCESSFUL);
    putvalue(env_NaviSD_RepeatLastNavAnn_Abo,NAV_REPEATLASTNAVANN_ABORT_SUCCESSFUL);
    putvalue(env_NaviSD_RepeatLastNavAnn_Err, FALSE);
    putvalue(env_NaviSD_RepeatLastNavAnn_ErrC, 0); 

    //GetNextListPos
    putvalue(env_NaviSD_GetNextLiPos_CuPos,0);
    putvalue(env_NaviSD_GetNextLiPos_NePos,0);
    putvalue(env_NaviSD_GetNextLiPos_AbsPos,0);
    putvalue(env_NaviSD_GetNextLiPos_Offset,0);
    putvalue(env_NaviSD_GetNextLiPos_LiTy_s,empty_string);
    putvalue(env_NaviSD_GetNextLiPos_Result,NAV_GETNEXTLISTPOS_SUCCESSFUL);
    putvalue(env_NaviSD_GetNextLiPos_Abort,NAV_GETNEXTLISTPOS_ABORT_SUCCESSFUL);
    putvalue(env_NaviSD_GetNextLiPos_Error_on, FALSE);
    putvalue(env_NaviSD_GetNextLiPos_ErrorCo, 0); 

    //NbSpeller
    putvalue(env_NaviSD_NbSpeller_Mode_s,empty_string);
    putvalue(env_NaviSD_NbSpeller_SearchStr_s,empty_string);
    putvalue(env_NaviSD_NbSpeller_MatchEntr,0);
    putvalue(env_NaviSD_NbSpeller_Pos,0);
    putvalue(env_NaviSD_NbSpeller_Result,NAV_NBSPELLER_SUCCESSFUL);
    putvalue(env_NaviSD_NbSpeller_Abort,NAV_NBSPELLER_ABORT_SUCCESSFUL);
    putvalue(env_NaviSD_NbSpeller_Error_on, FALSE);
    putvalue(env_NaviSD_NbSpeller_ErrorCode, 0); 

    //LaneGuidance
    putvalue(env_NaviSD_LG_ASGID, 0);
    putvalue(env_NaviSD_LG_TAID, 0);
    putvalue(env_NaviSD_LG_LGOnOff, NAV_LANEGUIDANCE_NOTDISPLAYED);
    putvalue(env_NaviSD_LG_AH_shift, FALSE);
    putvalue(env_NaviSD_LG_AH_dir, FORWARD);
    putvalue(env_NaviSD_LG_AH_POS, TRUE);
    putvalue(env_NaviSD_LG_AH_IS, 0);
    putvalue(env_NaviSD_LG_AH_RA, 0);
    putvalue(env_NaviSD_LG_AH_start, 0);
    putvalue(env_NaviSD_LG_AH_elements, 0);
    putvalue(env_NaviSD_LG_DataSource, NAV_DEFAULT_LIST);
    putvalue(env_NaviSD_LG_CSVPath, empty_string);
    putvalue(env_NaviSD_LG_DataSource_result, empty_string);
    putvalue(env_NaviSD_LG_DataSource_file, empty_string);
    //MR 76047
    putvalue(env_NaviSD_LG_StatusOFF, 0);
    
    //LastDest_List
    putvalue(env_NaviSD_LDL_ASGID, 0);
    putvalue(env_NaviSD_LDL_TAID, 0);
    putvalue(env_NaviSD_LDL_TotalNumLE, 0);
    putvalue(env_NaviSD_LDL_AH_shift, FALSE);
    putvalue(env_NaviSD_LDL_AH_dir, FORWARD);
    putvalue(env_NaviSD_LDL_AH_POS, TRUE);
    putvalue(env_NaviSD_LDL_AH_IS, 0);
    putvalue(env_NaviSD_LDL_AH_RA, 0);
    putvalue(env_NaviSD_LDL_AH_start, 0);
    putvalue(env_NaviSD_LDL_AH_elements, 0);
    putvalue(env_NaviSD_LDL_DataSource, NAV_DEFAULT_LIST);
    putvalue(env_NaviSD_LDL_CSVPath, empty_string);
    putvalue(env_NaviSD_LDL_DataSource_result, empty_string);
    putvalue(env_NaviSD_LDL_DataSource_file, empty_string);
    //MR 76047
    putvalue(env_NaviSD_LDL_StatusOFF, 0);
    
    //FavoriteDest_List
    putvalue(env_NaviSD_FDL_ASGID, 0);
    putvalue(env_NaviSD_FDL_TAID, 0);
    putvalue(env_NaviSD_FDL_TotalNumLE, 0);
    putvalue(env_NaviSD_FDL_AH_shift, FALSE);
    putvalue(env_NaviSD_FDL_AH_dir, FORWARD);
    putvalue(env_NaviSD_FDL_AH_POS, TRUE);
    putvalue(env_NaviSD_FDL_AH_IS, 0);
    putvalue(env_NaviSD_FDL_AH_RA, 0);
    putvalue(env_NaviSD_FDL_AH_start, 0);
    putvalue(env_NaviSD_FDL_AH_elements, 0);
    putvalue(env_NaviSD_FDL_DataSource, NAV_DEFAULT_LIST);
    putvalue(env_NaviSD_FDL_CSVPath, empty_string);
    putvalue(env_NaviSD_FDL_DataSource_result, empty_string);
    putvalue(env_NaviSD_FDL_DataSource_file, empty_string);
    //MR 76047
    putvalue(env_NaviSD_FDL_StatusOFF, 0);
    
    //NavBook
    putvalue(env_NaviSD_NB_ASGID, 0);
    putvalue(env_NaviSD_NB_TAID, 0);
    putvalue(env_NaviSD_NB_TotalNumLE, 0);
    putvalue(env_NaviSD_NB_AH_shift, FALSE);
    putvalue(env_NaviSD_NB_AH_dir, FORWARD);
    putvalue(env_NaviSD_NB_AH_POS, TRUE);
    putvalue(env_NaviSD_NB_AH_IS, 0);
    putvalue(env_NaviSD_NB_AH_RA, 0);
    putvalue(env_NaviSD_NB_AH_start, 0);
    putvalue(env_NaviSD_NB_AH_elements, 0);
    putvalue(env_NaviSD_NB_DataSource, NAV_DEFAULT_LIST);
    putvalue(env_NaviSD_NB_CSVPath, empty_string);
    putvalue(env_NaviSD_NB_DataSource_result, empty_string);
    putvalue(env_NaviSD_NB_DataSource_file, empty_string);  
    //MR 76047
    putvalue(env_NaviSD_NB_StatusOFF, 0);
    
    //Address_List
    putvalue(env_NaviSD_AL_ASGID, 0);
    putvalue(env_NaviSD_AL_TAID, 0);
    putvalue(env_NaviSD_AL_OtherList_Ref, 0);
    putvalue(env_NaviSD_AL_OtherListType, 0);
    putvalue(env_NaviSD_AL_TotalNumLE, 0);
    putvalue(env_NaviSD_AL_AH_shift, FALSE);
    putvalue(env_NaviSD_AL_AH_dir, FORWARD);
    putvalue(env_NaviSD_AL_AH_POS, TRUE);
    putvalue(env_NaviSD_AL_AH_IS, TRUE);
    putvalue(env_NaviSD_AL_AH_RA, 0);
    putvalue(env_NaviSD_AL_AH_start, 0);
    putvalue(env_NaviSD_AL_AH_elements, 3);
    putvalue(env_NaviSD_AL_DataSource, NAV_DEFAULT_LIST);
    putvalue(env_NaviSD_AL_CSVPath, empty_string);
    putvalue(env_NaviSD_AL_DataSource_result, empty_string);
    putvalue(env_NaviSD_AL_DataSource_file, empty_string);
    //MR 76047 
    putvalue(env_NaviSD_AL_StatusOFF, 0);
    
    //IssueList #62
    putValue(env_NaviSD_FctList_0x0F_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x10_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x11_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x12_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x13_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x14_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x15_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x16_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x17_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x18_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x19_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x1A_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x1B_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x1C_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x1D_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x1E_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x1F_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x20_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x21_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x22_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x23_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x24_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x25_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x26_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x27_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x28_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x29_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x2A_TimeOut, 0);
    //Updates from J.Karl 07.11.2013
    putValue(env_NaviSD_FctList_0x2B_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x2C_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x2D_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x2E_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x2F_TimeOut, 0);
    putValue(env_NaviSD_FctList_0x32_TimeOut, 0);

    //IssueList #74
    gNaviFctList_0x22_TimeOut=0;
    gNaviFctList_0x29_TimeOut=0;
    gNaviFctList_0x2A_TimeOut=0;
    gNaviFctList_0x23_TimeOut=0;

    //IssueList #68
    putValue(env_NaviSD_FctList_0x22_3min_TO, 0);
    putValue(env_NaviSD_FctList_0x29_3min_TO, 0);
    putValue(env_NaviSD_FctList_0x2A_3min_TO, 0);
    putValue(env_NaviSD_FctList_0x23_3min_TO, 0);
    
    //IssueList #216 15S1 update 17.01.2014
 //------------------------------------------------
    //---------------------0x33 POI_Search
    putValue(env_NaviSD_POISearch_AOFE,0);
    putValue(env_NaviSD_POISearch_POI_Type,0);
    putValue(env_NaviSD_POISearch_POI_TypeHex,0);
    putValue(env_NaviSD_POISearch_POISR,0);
    putValue(env_NaviSD_POISearch_POISRHex,0);
    putValue(env_NaviSD_POISearch_ProgressIndicator,0);
    putValue(env_NaviSD_POISearch_SearchTypeH,0);
    putValue(env_NaviSD_POISearch_SearchType,0);
    gPOIS_STact                                     = 0x00;
    gPOIS_POISRact                                  = 0x00;
    gPOIS_POITyact                                  = 0x00;
    tempPOIS_1                                      = 0;
    tempPOIS_2                                      = 0;
    tempPOIS_3                                      = 0;
    //MR 76047 
    putvalue(env_NaviSD_POIList_StatusOFF, 0);


    //-----------------------------------------------------------------
    //--------------------0x34 POI_List
    putValue(env_NaviSD_POI_List_AH,0);
    putValue(env_NaviSD_POI_List_AHD,0);
    putValue(env_NaviSD_POI_List_ASG_ID,0);
    putValue(env_NaviSD_POI_List_ASG_IDhex,0);
    putValue(env_NaviSD_POI_List_direction,0);
    putValue(env_NaviSD_POI_List_elements,0);
    putValue(env_NaviSD_POI_List_FRU,0);
    putValue(env_NaviSD_POI_List_index,0);
    putValue(env_NaviSD_POI_List_RecordAdd,0);
    putValue(env_NaviSD_POI_List_shift,0);
    putValue(env_NaviSD_POI_List_start,0);
    putValue(env_NaviSD_POI_List_TAID,0);
    putValue(env_NaviSD_POI_List_TNLE,0);
    putValue(env_NaviSD_POI_List_transmitPos,0);

    //-----------------------------------------------------------------
    //--------------------0x35 FSG_Setup
    putValue(env_NaviSD_FSGS_SPOIT0,0);
    putValue(env_NaviSD_FSGS_VG0,0);
    putValue(env_NaviSD_FSGS_VG1,0);
    putValue(env_NaviSD_FSGS_VG2,0);

    //-----------------------------------------------------------------
    //--------------------0x36 Map_Presentation
    putValue(env_NaviSD_MapPres_0,0);
    putValue(env_NaviSD_MapPres_1,0);
    putValue(env_NaviSD_MapPres_2,0);

    //MR 76047 
    //-----------------------------------------------------------------
    //--------------------0x37 ManeuverState
    putValue(env_NaviSD_ManeuverState_State,0);
    putValue(env_NaviSD_ManeuverState_StateHex,0);
    //@sysvar::naviSD_FSG::ManeuverState_State              =0;
    //@sysvar::naviSD_FSG::ManeuverState_StateHex           =0;    
    
    
    //-----------------------------------------------------------------
    //--------------------0x38 ETC_Status
    putValue(env_NaviSD_ETC_Status_CardStatus,0);
    putValue(env_NaviSD_ETC_Status_Extension1,0);
    putValue(env_NaviSD_ETC_Status_Extension1_hex,0);
    //@sysvar::naviSD_FSG::ETC_Status_CardStatus          =0;
    //@sysvar::naviSD_FSG::ETC_Status_Extension1          =0;
    //@sysvar::naviSD_FSG::ETC_Status_Extension1_hex      =0;    
          
}

FSG_OperationState_Indication(dword Indication_array [], int datalength)
{    
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                FSG_OperationState_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD FSG_OperationState_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

FSG_OperationState_Request(byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;                    //LSG-ID
    requestarray[1]=FctID_FSG_OperationState;    //Fct.-ID
    requestarray[2]=request;                    //request type

    switch(request)
    {
        case Data_REQ:
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x0F_TimeOut)!=TRUE)
            {                    
            requestarray[3] =gFSG_OperationState;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD FSG_OperationState_Request: invalid request %d", request);
        break;
    }
}

RG_Status_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
               RG_Status_Request(Data_REQ, 0);                            //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD RouteGuidanceStatus_Indication: invalid indication %d", gBAP_Indication[5]);
        break;
    }
}

RG_Status_Request(byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;            //LSG-ID
    requestarray[1] =FctID_RG_Status;        //Fct.-ID
    requestarray[2] =request;               //request type
    
    switch(request)
    {
        case Data_REQ:
        //IssueList #62
            if (getValue(env_NaviSD_FctList_0x11_TimeOut)!=TRUE)
            {
            requestarray[3] =gRG_Status;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            }
        break;
        case Error_REQ:                
            requestarray[3] =errorcode;

            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD RouteGuidanceStatus_Request: invalid request %d", request);
        break;
    }
   
 }

on envVar env_NaviSD_FSG_OP_State_update
{
    if(gNaviSD_PowerOnOff ==POWER_ON && getvalue(this))
    {
        gFSG_OperationState =getvalue(env_NaviSD_FSG_OP_State);

        FSG_OperationState_Request(Data_REQ, 0); //send status
    }
}

init_variables ()
{
    dword i, j;

    //BAP communication
    for (i=0;i<BAP_BUFFER_SIZE;i++)
        gBAP_Indication[i]=0;
    
    //RGB-Values for background colors
    gRGB_red    =MakeRGB(255,0,0);
    gRGB_yellow =MakeRGB(255,255,0);
    gRGB_green  =MakeRGB(0,255,0);
    gRGB_grey   =MakeRGB(192,192,192);
    gRGB_white  =MakeRGB(255,255,255);

    for (j=0;j<REQUESTBUFFER_LINES;j++)
    {
        gBAP_Requestbuffer_status[j]        =0;
        gBAP_Requestbuffer_BAPDataTyp[j]    =0;
    
        for (i=0;i<BAP_BUFFER_SIZE;i++)
            gBAP_Request[j][i] =0;
    }

    gwrite_requestbuffer_line   =0; 
    gstatus_requestbuffer       =0;

    putvalue(env_NaviSD_Config_SWConfig,xml_path);
    putvalue(env_NaviSD_Config_DBC,dbc_path);

    
    //FunctionList
    for(i=0; i<8;i++)
        gFunctionList[i] =0;

    //Byte0
    gFunctionList[0] +=(getvalue(env_NaviSD_FctList_0x01) *0x40);   //Bit1 - GetAll
    gFunctionList[0] +=(getvalue(env_NaviSD_FctList_0x02) *0x20);   //Bit2 - BAPConfig
    gFunctionList[0] +=(getvalue(env_NaviSD_FctList_0x03) *0x10);   //Bit3 - FunctionList
    gFunctionList[0] +=(getvalue(env_NaviSD_FctList_0x04) *0x08);   //Bit4 - Heartbeat

    //Byte1
    gFunctionList[1] +=(getvalue(env_NaviSD_FctList_0x0F) *0x01);   //Bit15 - FSG_OperationState

    //Byte2
    gFunctionList[2] +=(getvalue(env_NaviSD_FctList_0x10) *0x80);   //Bit16 - CompassInfo
    gFunctionList[2] +=(getvalue(env_NaviSD_FctList_0x11) *0x40);   //Bit17 - RG_Status
    gFunctionList[2] +=(getvalue(env_NaviSD_FctList_0x12) *0x20);   //Bit18 - DistanceToNextManeuver
    gFunctionList[2] +=(getvalue(env_NaviSD_FctList_0x13) *0x10);   //Bit19 - CurrentPositionInfo
    gFunctionList[2] +=(getvalue(env_NaviSD_FctList_0x14) *0x08);   //Bit20 - TurnToInfo
    gFunctionList[2] +=(getvalue(env_NaviSD_FctList_0x15) *0x04);   //Bit21 - DistanceToDestination
    gFunctionList[2] +=(getvalue(env_NaviSD_FctList_0x16) *0x02);   //Bit22 - TimeToDestination
    gFunctionList[2] +=(getvalue(env_NaviSD_FctList_0x17) *0x01);   //Bit23 - ManeuverDescriptor

    //Byte3
    gFunctionList[3] +=(getvalue(env_NaviSD_FctList_0x18) *0x80);   //Bit24 - LaneGuidance
    gFunctionList[3] +=(getvalue(env_NaviSD_FctList_0x19) *0x40);   //Bit25 - TMCinfo
    gFunctionList[3] +=(getvalue(env_NaviSD_FctList_0x1A) *0x20);   //Bit26 - MagnetFieldZone
    gFunctionList[3] +=(getvalue(env_NaviSD_FctList_0x1B) *0x10);   //Bit27 - Calibration
    gFunctionList[3] +=(getvalue(env_NaviSD_FctList_0x1C) *0x08);   //Bit28 - ASGcapabilities
    gFunctionList[3] +=(getvalue(env_NaviSD_FctList_0x1D) *0x04);   //Bit29 - LasDest_List
    gFunctionList[3] +=(getvalue(env_NaviSD_FctList_0x1E) *0x02);   //Bit30 - FavoriteDest_List
    gFunctionList[3] +=(getvalue(env_NaviSD_FctList_0x1F) *0x01);   //Bit31 - PreferredDest_List

    //Byte4
    gFunctionList[4] +=(getvalue(env_NaviSD_FctList_0x20) *0x80);   //Bit32 - NavBook
    gFunctionList[4] +=(getvalue(env_NaviSD_FctList_0x21) *0x40);   //Bit33 - Address_List
    gFunctionList[4] +=(getvalue(env_NaviSD_FctList_0x22) *0x20);   //Bit34 - RG_ActDeact
    gFunctionList[4] +=(getvalue(env_NaviSD_FctList_0x23) *0x10);   //Bit35 - RepeatLastNavAnnouncement
    gFunctionList[4] +=(getvalue(env_NaviSD_FctList_0x24) *0x08);   //Bit36 - VoiceGuidance
    gFunctionList[4] +=(getvalue(env_NaviSD_FctList_0x25) *0x04);   //Bit37 - FunctionSynchronisation
    gFunctionList[4] +=(getvalue(env_NaviSD_FctList_0x26) *0x02);   //Bit38 - InfoStates
    gFunctionList[4] +=(getvalue(env_NaviSD_FctList_0x27) *0x01);   //Bit39 - ActiveRgType

    //Byte5
    gFunctionList[5] +=(getvalue(env_NaviSD_FctList_0x28) *0x80);   //Bit40 - TrafficBlockIndication
    gFunctionList[5] +=(getvalue(env_NaviSD_FctList_0x29) *0x40);   //Bit41 - GetNextListPos
    gFunctionList[5] +=(getvalue(env_NaviSD_FctList_0x2A) *0x20);   //Bit42 - NbSpeller
    //Updates from J.Karl 07.11.2013
    gFunctionList[5] +=(getvalue(env_NaviSD_FctList_0x2B) *0x10);   //Bit43 - MapColorAndType
    gFunctionList[5] +=(getvalue(env_NaviSD_FctList_0x2C) *0x08);   //Bit44 - MapViewAndOrientation
    gFunctionList[5] +=(getvalue(env_NaviSD_FctList_0x2D) *0x04);   //Bit45 - MapScale
    gFunctionList[5] +=(getvalue(env_NaviSD_FctList_0x2E) *0x02);   //Bit46 - DestinationInfo
    gFunctionList[5] +=(getvalue(env_NaviSD_FctList_0x2F) *0x01);   //Bit47 - Altitude
    
    //Updates from J.Karl 07.11.2013
    //Byte6
    //IssueList #216 15S1 update 17.01.2014
    gFunctionList[6] +=(getvalue(env_NaviSD_FctList_0x30) *0x80);   //Bit48 - OnlineNavigationState
    gFunctionList[6] +=(getvalue(env_NaviSD_FctList_0x31) *0x40);   //Bit49 - ExitView
    gFunctionList[6] +=(getvalue(env_NaviSD_FctList_0x32) *0x20);   //Bit50 - SemidynamicRouteGuidance
    gFunctionList[6] +=(getvalue(env_NaviSD_FctList_0x33) *0x10);   //Bit51 - POI_Search
    gFunctionList[6] +=(getvalue(env_NaviSD_FctList_0x34) *0x08);   //Bit52 - POI_List
    gFunctionList[6] +=(getvalue(env_NaviSD_FctList_0x35) *0x04);   //Bit53 - FSG_Setup
    gFunctionList[6] +=(getvalue(env_NaviSD_FctList_0x36) *0x02);   //Bit54 - Map_Presentation
    //MR 76047 
    gFunctionList[6] +=(getvalue(env_NaviSD_FctList_0x37) *0x01);   //Bit55 - ManeuverState
    
    //MR 76047 
    //Byte7
    gFunctionList[7] +=(getvalue(env_NaviSD_FctList_0x38) *0x80);   //Bit56 - ETC_Status
    
    //Panel   
    //IssueList #87 - EnableControl even FunctionList=OFF
    /*if(getvalue(env_NaviSD_FctList_0x0F))
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x0F_FSG-OperationState", gRGB_white);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x0F_FSG-OperationState_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x0F_FSG-OperationState", gRGB_red);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x0F_FSG-OperationState_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x10))
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x10_CompassInfo", gRGB_white);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x10_CompassInfo_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x10_CompassInfo", gRGB_red);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x10_CompassInfo_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x11))
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x11_RG_Status", gRGB_white);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x11_RG_Status_PanelElement", TRUE);
       //IssueList #14
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x11_RG_Status_PanelElement_update", TRUE);
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x11_RG_Status", gRGB_red);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x11_RG_Status_PanelElement", FALSE);
        //IssueList #14
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x11_RG_Status_PanelElement_update", FALSE);
    }

    
    if(getvalue(env_NaviSD_FctList_0x12))
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x12_DistanceToNextManeuver", gRGB_white);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x12_DistanceToNextManeuver_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x12_DistanceToNextManeuver", gRGB_red);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x12_DistanceToNextManeuver_PanelElement", FALSE);
    }

    
    if(getvalue(env_NaviSD_FctList_0x13))
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x13_CurrentPositionInfo", gRGB_white);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x13_CurrentPositionInfo_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x13_CurrentPositionInfo", gRGB_red);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x13_CurrentPositionInfo_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x14))
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x14_TurnToInfo", gRGB_white);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x14_TurnToInfo_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x14_TurnToInfo", gRGB_red);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x14_TurnToInfo_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x15))
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x15_DistanceToDestination", gRGB_white);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x15_DistanceToDestination_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x15_DistanceToDestination", gRGB_red);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x15_DistanceToDestination_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x16))
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x16_TimeToDestination", gRGB_white);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x16_TimeToDestination_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x16_TimeToDestination", gRGB_red);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x16_TimeToDestination_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x17))
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x17_ManeuverDescriptor", gRGB_white);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x17_ManeuverDescriptor_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x17_ManeuverDescriptor", gRGB_red);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x17_ManeuverDescriptor_PanelElement", FALSE);
    }

    
    if(getvalue(env_NaviSD_FctList_0x18))
    {
        SetControlBackColor("FSG_NaviSD_0x18 - LaneGuidance_(array)", "FSG_0x18_LaneGuidance", gRGB_white);
        enableControl("FSG_NaviSD_0x18 - LaneGuidance_(array)", "FSG_0x18_LaneGuidance_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_0x18 - LaneGuidance_(array)", "FSG_0x18_LaneGuidance", gRGB_red);
        enableControl("FSG_NaviSD_0x18 - LaneGuidance_(array)", "FSG_0x18_LaneGuidance_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x19))
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x19_TMCinfo", gRGB_white);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x19_TMCinfo_PanelElement", TRUE);      
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x19_TMCinfo", gRGB_red);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x19_TMCinfo_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x1A))
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x1A_MagnetFieldZone", gRGB_white);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x1A_MagnetFieldZone_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x1A_MagnetFieldZone", gRGB_red);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x1A_MagnetFieldZone_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x1B))
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x1B_Calibration", gRGB_white);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x1B_Calibration_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x1B_Calibration", gRGB_red);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x1B_Calibration_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x1C))
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x1C_ASGcapabilities", gRGB_white);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x1C_ASGcapabilities_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x1C_ASGcapabilities", gRGB_red);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x1C_ASGcapabilities_PanelElement", FALSE);
    }

    
    if(getvalue(env_NaviSD_FctList_0x1D))
    {
        SetControlBackColor("FSG_NaviSD_0x1D - LastDest_List_(array)", "FSG_0x1D_LastDest_List", gRGB_white);
        enableControl("FSG_NaviSD_0x1D - LastDest_List_(array)", "FSG_0x1D_LastDest_List_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_0x1D - LastDest_List_(array)", "FSG_0x1D_LastDest_List", gRGB_red);
        enableControl("FSG_NaviSD_0x1D - LastDest_List_(array)", "FSG_0x1D_LastDest_List_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x1E))
    {
        SetControlBackColor("FSG_NaviSD_0x1E - FavoriteDest_List_(array)", "FSG_0x1E_FavoriteDest_List", gRGB_white);
        enableControl("FSG_NaviSD_0x1E - FavoriteDest_List_(array)", "FSG_0x1E_FavoriteDest_List_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_0x1E - FavoriteDest_List_(array)", "FSG_0x1E_FavoriteDest_List", gRGB_red);
        enableControl("FSG_NaviSD_0x1E - FavoriteDest_List_(array)", "FSG_0x1E_FavoriteDest_List_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x1F))
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x1F_PreferredDestList", gRGB_white);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x1F_PreferredDestList_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x1F_PreferredDestList", gRGB_red);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x1F_PreferredDestList_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x20))
    {
        SetControlBackColor("FSG_NaviSD_0x20 - NavBook_(array)", "FSG_0x20_NavBook", gRGB_white);
        enableControl("FSG_NaviSD_0x20 - NavBook_(array)", "FSG_0x20_NavBook_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_0x20 - NavBook_(array)", "FSG_0x20_NavBook", gRGB_red);
        enableControl("FSG_NaviSD_0x20 - NavBook_(array)", "FSG_0x20_NavBook_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x21))
    {
        SetControlBackColor("FSG_NaviSD_0x21 - AddressList_(array)", "FSG_0x21_Address_List", gRGB_white);
        enableControl("FSG_NaviSD_0x21 - AddressList_(array)", "FSG_0x21_Address_List_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_0x21 - AddressList_(array)", "FSG_0x21_Address_List", gRGB_red);
        enableControl("FSG_NaviSD_0x21 - AddressList_(array)", "FSG_0x21_Address_List_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x22))
    {
        SetControlBackColor("FSG_NaviSD_Methods", "FSG_0x22_RG_ActDeact", gRGB_white);
        enableControl("FSG_NaviSD_Methods", "FSG_0x22_RG_ActDeact_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Methods", "FSG_0x22_RG_ActDeact", gRGB_red);
        enableControl("FSG_NaviSD_Methods", "FSG_0x22_RG_ActDeact_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x23))
    {
        SetControlBackColor("FSG_NaviSD_Methods", "FSG_0x23_RepeatLastNavAnnouncement", gRGB_white);
        enableControl("FSG_NaviSD_Methods", "FSG_0x23_RepeatLastNavAnnouncement_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Methods", "FSG_0x23_RepeatLastNavAnnouncement", gRGB_red);
        enableControl("FSG_NaviSD_Methods", "FSG_0x23_RepeatLastNavAnnouncement_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x24))
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x24_VoiceGuidance", gRGB_white);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x24_VoiceGuidance_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x24_VoiceGuidance", gRGB_red);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x24_VoiceGuidance_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x25))
    {
        SetControlBackColor("FSG_NaviSD_Properties_3", "FSG_0x25_FunctionSynchronisation", gRGB_white);
        enableControl("FSG_NaviSD_Properties_3", "FSG_0x25_FunctionSynchronisation_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_3", "FSG_0x25_FunctionSynchronisation", gRGB_red);
        enableControl("FSG_NaviSD_Properties_3", "FSG_0x25_FunctionSynchronisation_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x26))
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x26_InfoStates", gRGB_white);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x26_InfoStates_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x26_InfoStates", gRGB_red);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x26_InfoStates_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x27))
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x27_ActiveRgType", gRGB_white);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x27_ActiveRgType_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_2", "FSG_0x27_ActiveRgType", gRGB_red);
        enableControl("FSG_NaviSD_Properties_2", "FSG_0x27_ActiveRgType_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x28))
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x28_TrafficBlock_Indication", gRGB_white);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x28_TrafficBlock_Indication_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Properties_1", "FSG_0x28_TrafficBlock_Indication", gRGB_red);
        enableControl("FSG_NaviSD_Properties_1", "FSG_0x28_TrafficBlock_Indication_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x29))
    {
        SetControlBackColor("FSG_NaviSD_Methods", "FSG_0x29_GetNextListPos", gRGB_white);
        enableControl("FSG_NaviSD_Methods", "FSG_0x29_GetNextListPos_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Methods", "FSG_0x29_GetNextListPos", gRGB_red);
        enableControl("FSG_NaviSD_Methods", "FSG_0x29_GetNextListPos_PanelElement", FALSE);
    }


    if(getvalue(env_NaviSD_FctList_0x2A))
    {
        SetControlBackColor("FSG_NaviSD_Methods", "FSG_0x2A_NbSpeller", gRGB_white);
        enableControl("FSG_NaviSD_Methods", "FSG_0x2A_NbSpeller_PanelElement", TRUE);
        
    }
    else
    {
        SetControlBackColor("FSG_NaviSD_Methods", "FSG_0x2A_NbSpeller", gRGB_red);
        enableControl("FSG_NaviSD_Methods", "FSG_0x2A_NbSpeller_PanelElement", FALSE);
    }
    */   //IssueList #87

    //FSG-OperationState
    gFSG_OperationState =NAV_OPSTATE_INITIALIZING;
    putValue(env_NaviSD_FSG_OP_State, gFSG_OperationState);

    //CompassInfo
    gCI_Direction_Symbolic  =0;
    gCI_Direction_Angle     =0;
    putValue(env_NaviSD_Direction_Symbolik,gCI_Direction_Symbolic);
    putValue(env_NaviSD_Direction_Angle, gCI_Direction_Angle);

    //RouteGuidance_Status
    gRG_Status =0;
    gNav_RG_ActDeact_MethodHandling =0;
    putValue(env_NaviSD_RG_Status, gRG_Status);

    //DistanceToNextManeuver
    gDTNM_Distance              =0;
    gDTNM_Unit                  =0;
    gDTNM_BargraphOnOff         =0;
    gDTNM_Bargraph              =0;
    gDTNM_ValidityInformation   =1;
    putValue(env_NaviSD_DTNM_Distance, gDTNM_Distance);
    putValue(env_NaviSD_DTNM_Unit, gDTNM_Unit);
    putValue(env_NaviSD_DTNM_BG_ON_OFF, gDTNM_BargraphOnOff);
    putValue(env_NaviSD_DTNM_BG, gDTNM_Bargraph);
    putValue(env_NaviSD_DTNM_ValidityInfo, gDTNM_ValidityInformation);

    //CurrentPositionInfo
    for (i=0;i<NAV_POSITIONINFO_LENGTH;i++)
        gCurrentPositionInfo_PositionInfo[i] =0;
    
    strncpy(gCurrentPositionInfo_PositionInfo, "'PositionInfo'", elcount("'PositionInfo'"));
    
    putValue(env_NaviSD_PositionInfo, gCurrentPositionInfo_PositionInfo);

    //TurnToInfo
    for (i=0;i<NAV_TURNTOINFO_TURNTOINFO_LENGTH;i++)
        gTurnToInfo_TurnToInfo[i] =0;
    
    strncpy(gTurnToInfo_TurnToInfo, "'TurnToInfo'", elcount("'TurnToInfo'"));
    
    putValue(env_NaviSD_TTI_TurnToInfo, gTurnToInfo_TurnToInfo);

    for (i=0;i<NAV_TURNTOINFO_SIGNPOST_LENGTH;i++)
        gTurnToInfo_SignPost[i] =0;
    
    strncpy(gTurnToInfo_SignPost, "'SignPost'", elcount("'SignPost'"));

    putValue(env_NaviSD_TTI_SignPost, gTurnToInfo_SignPost);

    //DistanceToDestination
    gDTD_Distance              =0;
    gDTD_Unit                  =0;
    gDTD_ValidityInformation   =1;
    //MR 76047 
    gDTD_DTDType               =1;
    
    putValue(env_NaviSD_DTD_Distance, gDTD_Distance);
    putValue(env_NaviSD_DTD_Unit, gDTD_Unit);
    putValue(env_NaviSD_DTD_ValidityInfo, gDTD_ValidityInformation);
    //MR 76047 
    putValue(env_NaviSD_DTD_DTDType, gDTD_DTDType);

    //TimeToDestination
    gTTD_TimeInfoType           =0;
    gTTD_NavigationTimeFormat   =0;
    gTTD_Minute                 =0;
    gTTD_Hour                   =0;
    gTTD_Day                    =0;
    gTTD_Month                  =0;
    gTTD_Year                   =0;
    gTTD_ValidityInformation    =62; //all 'valid'  

    putValue(env_NaviSD_TTD_TimeInfoType, gTTD_TimeInfoType);
    putValue(env_NaviSD_TTD_NavigationTF, gTTD_NavigationTimeFormat);
    putValue(env_NaviSD_TTD_Minute, gTTD_Minute);
    putValue(env_NaviSD_TTD_Hour, gTTD_Hour);
    putValue(env_NaviSD_TTD_Day, gTTD_Day);
    putValue(env_NaviSD_TTD_Month, gTTD_Month);
    putValue(env_NaviSD_TTD_Year, gTTD_Year);
    putValue(env_NaviSD_TTD_Minute_VI, 1);
    putValue(env_NaviSD_TTD_Hour_VI, 1);
    putValue(env_NaviSD_TTD_Day_VI, 1);
    putValue(env_NaviSD_TTD_Month_VI, 1);
    putValue(env_NaviSD_TTD_Year_VI, 1);

    //ManeuverDescriptor
    gMD_MainElement_1 =0;
    gMD_MainElement_2 =0;
    gMD_MainElement_3 =0;
    
    gMD_Direction_1 =0;
    gMD_Direction_2 =0;
    gMD_Direction_3 =0;
    
    gMD_ZLevelGuidance_1 =0;
    gMD_ZLevelGuidance_2 =0;
    gMD_ZLevelGuidance_3 =0;

    for(i=0;i<255;i++)
    {
        gMD_Sidestreet_1 [i] =0;
        gMD_Sidestreet_2 [i] =0;
        gMD_Sidestreet_3 [i] =0;
    }
    
    putvalue(env_NaviSD_MD_MainElement1, 0);
    putvalue(env_NaviSD_MD_MainElement2, 0);
    putvalue(env_NaviSD_MD_MainElement3, 0);

    putvalue(env_NaviSD_MD_Direction1, 0);
    putvalue(env_NaviSD_MD_Direction2, 0);
    putvalue(env_NaviSD_MD_Direction3, 0);

    putvalue(env_NaviSD_MD_Z_Level1, 0);
    putvalue(env_NaviSD_MD_Z_Level2, 0);
    putvalue(env_NaviSD_MD_Z_Level3, 0);

    putvalue(env_NaviSD_MD_Sidestreet1, gMD_Sidestreet_1);
    putvalue(env_NaviSD_MD_Sidestreet2, gMD_Sidestreet_2);
    putvalue(env_NaviSD_MD_Sidestreet3, gMD_Sidestreet_3);

    //TMCinfo
    gTMCinfo_MessageID                  =0;
    gTMCinfo_MessageStatus              =0;
    gTMCinfo_MessageWaitingIndication   =0;
    gTMCinfo_Priority                   =0;

    for(i=0;i<NAV_STREETNAME_LENGTH;i++)
        gTMCinfo_StreetName[i]  =0;        
    
    strncpy(gTMCinfo_StreetName, "'StreetName'", elcount("'StreetName'"));

    for(i=0;i<NAV_LOCATION_LENGTH;i++)
        gTMCinfo_Location[i]    =0;
    
    strncpy(gTMCinfo_Location, "'Location'", elcount("'Location'"));
    
    for(i=0;i<NAV_INFOTEXT_LENGTH;i++)
        gTMCinfo_Infotext[i]=0;
    
    strncpy(gTMCinfo_Infotext, "'Infotext'", elcount("'Infotext'"));

    gTMCinfo_Length_Validity =TRUE;    
    gTMCinfo_Length_Value    =0;
    gTMCinfo_Length_Unit     =0;

    putvalue(env_NaviSD_TMCI_MessageID, gTMCinfo_MessageID);
    putvalue(env_NaviSD_TMCI_MS, gTMCinfo_MessageStatus);
    putvalue(env_NaviSD_TMCI_MS_s, empty_string);
    putvalue(env_NaviSD_TMCI_MessageWaitInd, gTMCinfo_MessageWaitingIndication);
    putvalue(env_NaviSD_TMCI_Priority, gTMCinfo_Priority);
    putvalue(env_NaviSD_TMCI_StreetName, gTMCinfo_StreetName);
    putvalue(env_NaviSD_TMCI_Location, gTMCinfo_Location);
    putvalue(env_NaviSD_TMCI_Infotext, gTMCinfo_Infotext);
    putvalue(env_NaviSD_TMCI_Length_Validity, gTMCinfo_Length_Validity);
    putvalue(env_NaviSD_TMCI_Length_Value, gTMCinfo_Length_Value);
    putvalue(env_NaviSD_TMCI_Length_Unit, gTMCinfo_Length_Unit);
    putvalue(env_NaviSD_TMCI_Error_on, FALSE);
    putvalue(env_NaviSD_TMCI_ErrorCode, 0);

    //MagnetFieldZone
    gNaviSD_MFZone =1;
    
    putValue(env_NaviSD_MFZone_Zone_set, gNaviSD_MFZone);
    putValue(env_NaviSD_MFZone_Zone_s, gNaviSD_MFZone_s[gNaviSD_MFZone]);
    putvalue(env_NaviSD_MFZone_Error_on, FALSE);
    putvalue(env_NaviSD_MFZone_ErrorCode, 0); 

    //Calibration
    gNaviSD_CalibrationState =NAV_CALIBRATION_CALIBRATED;
    
    putValue(env_NaviSD_CaliState_set, gNaviSD_CalibrationState);
    putValue(env_NaviSD_CaliState_s, gNaviSD_CalibrationState_s[gNaviSD_CalibrationState]);
    putvalue(env_NaviSD_CaliState_Error_on, FALSE);
    putvalue(env_NaviSD_CaliState_ErrorCode, 0);
        
    //ASGcapabilities
    gNaviSD_ASGcap_PresentationCapabilities =0;
    gNaviSD_ASGcap_FurtherCapabilities      =0;
    gNaviSD_ASGcap_PresentationCapabilities_bit0 =0;

    putvalue(env_NaviSD_ASGcap_Pres_s, gNaviSD_ASGcap_PresentationCapabilities_bit0_s[gNaviSD_ASGcap_PresentationCapabilities_bit0]);
    putvalue(env_NaviSD_ASGcap_Pres,gNaviSD_ASGcap_PresentationCapabilities_bit0);
    putvalue(env_NaviSD_ASGcap_Error_on, FALSE);
    putvalue(env_NaviSD_ASGcap_ErrorCode, 0); 

    //PrefererredDestList
    gNaviSD_PrefDestList_ListType =0;

    putvalue(env_NaviSD_PrefDeLis_Type, gNaviSD_PrefDestList_ListType);

    //VoiceGuidance
    gNaviSD_VoiceGuidance_State =NAV_VOICEGUIDANCE_ON_FULL;

    putvalue(env_NaviSD_VG_State_s, gNaviSD_VoiceGuidance_State_s[gNaviSD_VoiceGuidance_State]);
    putvalue(env_NaviSD_VG_State,gNaviSD_VoiceGuidance_State);
    putvalue(env_NaviSD_VG_Error_on, FALSE);
    putvalue(env_NaviSD_VG_ErrorCode, 0);

    //FunctionSynchronisation
    for (i=0; i<8; i++)
        gNaviSD_FunctionSynchronisation_FctList[i] =0xFF;
    
    gNaviSD_FunctionSynchronisation_FctList_Bit16  =FALSE;    
    gNaviSD_FunctionSynchronisation_FctList_Bit17  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit18  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit19  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit20  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit21  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit22  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit23  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit24  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit25  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit26  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit27  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit29  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit30  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit31  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit32  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit33  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit34  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit36  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit38  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit39  =FALSE;
    gNaviSD_FunctionSynchronisation_FctList_Bit40  =FALSE;
    
    //Byte 2
    gNaviSD_FunctionSynchronisation_FctList[2] =gNaviSD_FunctionSynchronisation_FctList_Bit23;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit22 *0x02;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit21 *0x04;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit20 *0x08;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit19 *0x10;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit18 *0x20;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit17 *0x40;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit16 *0x80;

    //Byte 3
    gNaviSD_FunctionSynchronisation_FctList[3] =gNaviSD_FunctionSynchronisation_FctList_Bit31;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit30 *0x02;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit29 *0x04;
    gNaviSD_FunctionSynchronisation_FctList[3] +=0                                             *0x08;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit27 *0x10;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit26 *0x20;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit25 *0x40;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit24 *0x80;

    //Byte 4
    gNaviSD_FunctionSynchronisation_FctList[4] =gNaviSD_FunctionSynchronisation_FctList_Bit39;
    gNaviSD_FunctionSynchronisation_FctList[4] +=gNaviSD_FunctionSynchronisation_FctList_Bit38 *0x02;
    gNaviSD_FunctionSynchronisation_FctList[4] +=0                                             *0x04;
    gNaviSD_FunctionSynchronisation_FctList[4] +=gNaviSD_FunctionSynchronisation_FctList_Bit36 *0x08;
    gNaviSD_FunctionSynchronisation_FctList[4] +=0                                             *0x10;
    gNaviSD_FunctionSynchronisation_FctList[4] +=gNaviSD_FunctionSynchronisation_FctList_Bit34 *0x20;
    gNaviSD_FunctionSynchronisation_FctList[4] +=gNaviSD_FunctionSynchronisation_FctList_Bit33 *0x40;
    gNaviSD_FunctionSynchronisation_FctList[4] +=gNaviSD_FunctionSynchronisation_FctList_Bit32 *0x80;

    //Byte 5
    gNaviSD_FunctionSynchronisation_FctList[5] =0;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x02;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x04;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x08;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x10;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x20;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x40;
    gNaviSD_FunctionSynchronisation_FctList[5] =gNaviSD_FunctionSynchronisation_FctList_Bit40 *0x80;

    putvalue(env_NaviSD_FctSync_Bit16_CI, gNaviSD_FunctionSynchronisation_FctList_Bit16);
    putvalue(env_NaviSD_FctSync_Bit17_RGS,gNaviSD_FunctionSynchronisation_FctList_Bit17);
    putvalue(env_NaviSD_FctSync_Bit18_DTNM,gNaviSD_FunctionSynchronisation_FctList_Bit18);
    putvalue(env_NaviSD_FctSync_Bit19_CPI,gNaviSD_FunctionSynchronisation_FctList_Bit19);
    putvalue(env_NaviSD_FctSync_Bit20_TTI,gNaviSD_FunctionSynchronisation_FctList_Bit20);
    putvalue(env_NaviSD_FctSync_Bit21_DTD,gNaviSD_FunctionSynchronisation_FctList_Bit21);
    putvalue(env_NaviSD_FctSync_Bit22_TTD,gNaviSD_FunctionSynchronisation_FctList_Bit22);
    putvalue(env_NaviSD_FctSync_Bit23_MD,gNaviSD_FunctionSynchronisation_FctList_Bit23);
    putvalue(env_NaviSD_FctSync_Bit24_LG,gNaviSD_FunctionSynchronisation_FctList_Bit24);
    putvalue(env_NaviSD_FctSync_Bit25_TMCI,gNaviSD_FunctionSynchronisation_FctList_Bit25);
    putvalue(env_NaviSD_FctSync_Bit26_MFZ, gNaviSD_FunctionSynchronisation_FctList_Bit26);
    putvalue(env_NaviSD_FctSync_Bit27_Cal,gNaviSD_FunctionSynchronisation_FctList_Bit27); 
    putvalue(env_NaviSD_FctSync_Bit29_LDList,gNaviSD_FunctionSynchronisation_FctList_Bit29);
    putvalue(env_NaviSD_FctSync_Bit30_FaList,gNaviSD_FunctionSynchronisation_FctList_Bit30);
    putvalue(env_NaviSD_FctSync_Bit31_PrList,gNaviSD_FunctionSynchronisation_FctList_Bit31);
    putvalue(env_NaviSD_FctSync_Bit32_NavB,gNaviSD_FunctionSynchronisation_FctList_Bit32);
    putvalue(env_NaviSD_FctSync_Bit33_AL,gNaviSD_FunctionSynchronisation_FctList_Bit33);
    putvalue(env_NaviSD_FctSync_Bit34_RGL,gNaviSD_FunctionSynchronisation_FctList_Bit34);
    putvalue(env_NaviSD_FctSync_Bit36_VG,gNaviSD_FunctionSynchronisation_FctList_Bit36);
    putvalue(env_NaviSD_FctSync_Bit38_IS,gNaviSD_FunctionSynchronisation_FctList_Bit38);
    putvalue(env_NaviSD_FctSync_Bit39_AGRT,gNaviSD_FunctionSynchronisation_FctList_Bit39);
    putvalue(env_NaviSD_FctSync_Bit40_TBI,gNaviSD_FunctionSynchronisation_FctList_Bit40);

    //InfoStates
    gNAV_InfoStates =NAV_INFOSATES_NOERROR;      

    putvalue(env_NaviSD_InfoStates_states,gNAV_InfoStates);

    //ActiveRgType
    gNAV_ActiveRgType_RGType =0;

    putvalue(env_NaviSD_ActRGTy_RGType_s,gNAV_ActiveRgType_RGType_s[gNAV_ActiveRgType_RGType]);
    putvalue(env_NaviSD_ActRGTy_RGType,gNAV_ActiveRgType_RGType);
    putvalue(env_NaviSD_ActRGTy_Error_on, FALSE);
    putvalue(env_NaviSD_ActRGTy_ErrorCode, 0); 

    //TrafficBlock_Indication
    gNAV_TrafficBlock_Ind_TMCSymbol =NAV_TRAFFICBLOCK_NO_TMC_SYMBOL;
    putvalue(env_NaviSD_TBInd_TMCSym,gNAV_TrafficBlock_Ind_TMCSymbol);

    //RG_ActDeact
    gNav_RGActDeact_Status  =0;
    gNav_RG_ActDeact_Result =NAV_RGACTDEACT_SUCCESSFUL;
    gNav_RGActDeact_ControlType        =NAV_STARTROUTEGUIDANCE;
    gNav_RGActDeact_CI_Type            =NAV_RGACTDEACT_INVALID;
    gNav_RGActDeact_ControlInformation =0;

    putvalue(env_NaviSD_RGActDeact_Res, gNav_RG_ActDeact_Result);
    putvalue(env_NaviSD_RGActDeact_CoTy_s, empty_string);
    putvalue(env_NaviSD_RGActDeact_CITy_s, empty_string);
    putvalue(env_NaviSD_RGActDeact_CIInfo, gNav_RGActDeact_ControlInformation);
    putvalue(env_NaviSD_RGActDeact_AbortRes, NAV_RGACTDEACT_ABORT_SUCCESSFUL);
    putvalue(env_NaviSD_RGActDeact_Error_on, FALSE);
    putvalue(env_NaviSD_RGActDeact_ErrorCode, 0);

    //RepeatLastAnnouncement
    gNav_RepeatLastNavAnn_Status =0;
    gNav_RepeatLastNavAnn_Result =NAV_REPEATLASTNAVANN_SUCCESSFUL;

    putvalue(env_NaviSD_RepeatLastNavAnn_Res,NAV_REPEATLASTNAVANN_SUCCESSFUL);
    putvalue(env_NaviSD_RepeatLastNavAnn_Abo,NAV_REPEATLASTNAVANN_ABORT_SUCCESSFUL);
    putvalue(env_NaviSD_RepeatLastNavAnn_Err, FALSE);
    putvalue(env_NaviSD_RepeatLastNavAnn_ErrC, 0); 

    //GetNextListPos
    gNav_GetNextListPos_Status     =0;
    gNav_GetNextListPos_Result     =0;
    gNav_GetNextListPos_ListType   =0; 
    gNav_GetNextListPos_currentPos =0;
    gNav_GetNextListPos_Offset     =0;
    gNav_GetNextListPos_nextPos    =0;
    gNav_GetNextListPos_absListPos =0;

    putvalue(env_NaviSD_GetNextLiPos_CuPos,gNav_GetNextListPos_currentPos);
    putvalue(env_NaviSD_GetNextLiPos_NePos,gNav_GetNextListPos_nextPos);
    putvalue(env_NaviSD_GetNextLiPos_AbsPos,gNav_GetNextListPos_absListPos);
    putvalue(env_NaviSD_GetNextLiPos_Offset,gNav_GetNextListPos_Offset);
    putvalue(env_NaviSD_GetNextLiPos_LiTy_s,empty_string);
    putvalue(env_NaviSD_GetNextLiPos_Result,NAV_GETNEXTLISTPOS_SUCCESSFUL);
    putvalue(env_NaviSD_GetNextLiPos_Abort,NAV_GETNEXTLISTPOS_ABORT_SUCCESSFUL);
    putvalue(env_NaviSD_GetNextLiPos_Error_on, FALSE);
    putvalue(env_NaviSD_GetNextLiPos_ErrorCo, 0); 

    //NbSpeller
    gNav_NbSpeller_Status           =0;
    gNav_NbSpeller_Result           =NAV_NBSPELLER_SUCCESSFUL;
    gNav_NbSpeller_Mode             =NAV_NBSPELLER_MATCHSPELLER;
    gNav_NbSpeller_MatchingEntries  =0;
    gNav_NbSpeller_Pos              =0;

    for(i=0;i<NAV_SEARCHSTRING_LENGTH;i++)
        gNav_NbSpeller_SearchString[i]  =0;

    putvalue(env_NaviSD_NbSpeller_Mode_s,empty_string);
    putvalue(env_NaviSD_NbSpeller_SearchStr_s,empty_string);
    putvalue(env_NaviSD_NbSpeller_MatchEntr,gNav_NbSpeller_MatchingEntries);
    putvalue(env_NaviSD_NbSpeller_Pos,gNav_NbSpeller_Pos);
    putvalue(env_NaviSD_NbSpeller_Result,NAV_NBSPELLER_SUCCESSFUL);
    putvalue(env_NaviSD_NbSpeller_Abort,NAV_NBSPELLER_ABORT_SUCCESSFUL);
    putvalue(env_NaviSD_NbSpeller_Error_on, FALSE);
    putvalue(env_NaviSD_NbSpeller_ErrorCode, 0); 
    
    //LaneGuidance
    gLaneGuidance_ASGID    =0;
    gLaneGuidance_TAID     =0;
    gLaneGuidance_LaneGuidanceOnOff =NAV_LANEGUIDANCE_NOTDISPLAYED;
    gLaneGuidanceLine_sum =0;

    for(j=0; j<NAV_LANEGUIDANCE_ENTRIES; j++)
    {     
        gLaneGuidance_Pos[j]                =NAV_LANEGUIDANCE_STRAIGHT;
        gLaneGuidance_LaneType[j]           =NAV_LANETYPE_UNSPECIFIC;
        gLaneGuidance_LaneMarking_left[j]   =NAV_LANEMARKINGLEFT_NOLANE;
        gLaneGuidance_LaneMarking_right[j]  =NAV_LANEMARKINGRIGHT_NOLANE;
        gLaneGuidance_LaneDescription[j]    =NAV_LANEDESCRIPTION_AVAILABLE;
        gLaneGuidance_GuidanceInfo[j]       =NAV_GUIDANCEINFO_NOTRECOMMENDEDLANE;

        for(i=0;i<NAV_LANESIDESTREETS_LENGTH;i++)
            gLaneGuidance_LaneSidestreets[j][i] =0;
    }
    
    putvalue(env_NaviSD_LG_ASGID, gLaneGuidance_ASGID);
    putvalue(env_NaviSD_LG_TAID, gLaneGuidance_TAID);
    putvalue(env_NaviSD_LG_LGOnOff,gLaneGuidance_LaneGuidanceOnOff);
    putvalue(env_NaviSD_LG_AH_shift, FALSE);
    putvalue(env_NaviSD_LG_AH_dir, FORWARD);
    putvalue(env_NaviSD_LG_AH_POS, FALSE);
    putvalue(env_NaviSD_LG_AH_IS, FALSE);
    putvalue(env_NaviSD_LG_AH_RA, 0);
    putvalue(env_NaviSD_LG_AH_start, 0);
    //IssueList #54
    //putvalue(env_NaviSD_LG_AH_elements, 3);
    putvalue(env_NaviSD_LG_AH_elements, 0);
    putvalue(env_NaviSD_LG_DataSource, NAV_DEFAULT_LIST);
    putvalue(env_NaviSD_LG_CSVPath, empty_string);
    putvalue(env_NaviSD_LG_DataSource_result, empty_string);
    putvalue(env_NaviSD_LG_DataSource_file, empty_string);
    putvalue(env_NaviSD_LG_CA_switch, FALSE);
    putvalue(env_NaviSD_LG_Error_on, FALSE);
    putvalue(env_NaviSD_LG_ErrorCode, 0);
    //MR 76047 
    putvalue(env_NaviSD_LG_StatusOFF, 0);

    //LastDest_List
    gLastDestList_ASGID =0;
    gLastDestList_TAID  =0;

    gLastDestList_TotalNumListElements  =0;
    gLastDestListLine_sum               =0;

    for(j=0; j<NAV_LASTDESTLIST_ENTRIES; j++)
    {   
        gLastDestList_Pos[j]                        =0;
        gLastDestList_POIType[j]                     =NAV_LASTDESTLIST_POITYPE_NOPOI;
        gLastDestList_ListEntryValidInformation[j]  =0;

        for(i=0;i<NAV_LASTDESTLIST_DESCRIPTION_LENGTH;i++)
            gLastDestList_Description[j][i] =0;
    }

    for(i=0; i<NAV_FILENAME_SIZE; i++)
        gLastDestList_CSV_filename[i] =0;

    putvalue(env_NaviSD_LDL_ASGID, gLastDestList_ASGID);
    putvalue(env_NaviSD_LDL_TAID, gLastDestList_TAID);
    putvalue(env_NaviSD_LDL_TotalNumLE, gLastDestList_TotalNumListElements);
    putvalue(env_NaviSD_LDL_AH_shift, FALSE);
    putvalue(env_NaviSD_LDL_AH_dir, FORWARD);
    putvalue(env_NaviSD_LDL_AH_POS, TRUE);
    putvalue(env_NaviSD_LDL_AH_IS, FALSE);
    putvalue(env_NaviSD_LDL_AH_RA, 0);
    putvalue(env_NaviSD_LDL_AH_start, 0);
    putvalue(env_NaviSD_LDL_AH_elements, 3);
    putvalue(env_NaviSD_LDL_DataSource, NAV_DEFAULT_LIST);
    putvalue(env_NaviSD_LDL_CSVPath, empty_string);
    putvalue(env_NaviSD_LDL_DataSource_result, empty_string);
    putvalue(env_NaviSD_LDL_DataSource_file, empty_string);
    putvalue(env_NaviSD_LDL_CA_switch, FALSE);
    putvalue(env_NaviSD_LDL_Error_on, FALSE);
    putvalue(env_NaviSD_LDL_ErrorCode, 0);
    //MR 76047 
    putvalue(env_NaviSD_LDL_StatusOFF, 0);
    
    //FavoriteDest_List
    gFavoriteDestList_ASGID =0;
    gFavoriteDestList_TAID  =0;

    gFavoriteDestList_TotalNumListElements  =0;
    gFavoriteDestListLine_sum               =0;

    for(j=0; j<NAV_FAVORITEDESTLIST_ENTRIES; j++)
    {   
        gFavoriteDestList_Pos[j]                        =0;
        gFavoriteDestList_POIType[j]                    =NAV_FAVORITEDESTLIST_POITYPE_NOPOI;
        gFavoriteDestList_ListEntryValidInformation[j]  =0;

        for(i=0;i<NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH;i++)
            gFavoriteDestList_Description[j][i] =0;
    }

    for(i=0; i<NAV_FILENAME_SIZE; i++)
        gFavoriteDestList_CSV_filename[i] =0;

    putvalue(env_NaviSD_FDL_ASGID, gFavoriteDestList_ASGID);
    putvalue(env_NaviSD_FDL_TAID, gFavoriteDestList_TAID);
    putvalue(env_NaviSD_FDL_TotalNumLE, gFavoriteDestList_TotalNumListElements);
    putvalue(env_NaviSD_FDL_AH_shift, FALSE);
    putvalue(env_NaviSD_FDL_AH_dir, FORWARD);
    putvalue(env_NaviSD_FDL_AH_POS, TRUE);
    putvalue(env_NaviSD_FDL_AH_IS, FALSE);
    putvalue(env_NaviSD_FDL_AH_RA, 0);
    putvalue(env_NaviSD_FDL_AH_start, 0);
    putvalue(env_NaviSD_FDL_AH_elements, 3);
    putvalue(env_NaviSD_FDL_DataSource, NAV_DEFAULT_LIST);
    putvalue(env_NaviSD_FDL_CSVPath, empty_string);
    putvalue(env_NaviSD_FDL_DataSource_result, empty_string);
    putvalue(env_NaviSD_FDL_DataSource_file, empty_string);
    putvalue(env_NaviSD_FDL_CA_switch, FALSE);
    putvalue(env_NaviSD_FDL_Error_on, FALSE);
    putvalue(env_NaviSD_FDL_ErrorCode, 0);
    //MR 76047 
    putvalue(env_NaviSD_FDL_StatusOFF, 0);
    
    //NavBook
    gNavBook_ASGID =0;
    gNavBook_TAID  =0;

    gNavBook_TotalNumListElements  =0;
    gNavBookLine_sum               =0;

    for(j=0; j<NAV_NAVBOOK_ENTRIES; j++)
    {   
        gNavBook_Pos[j]                        =0;
        gNavBook_ListEntryValidInformation[j]  =0;

        for(i=0;i<NAV_NAVBOOK_LASTNAME_LENGTH;i++)
            gNavBook_LastName[j][i] =0;

        for(i=0;i<NAV_NAVBOOK_FIRSTNAME_LENGTH;i++)
            gNavBook_FirstName[j][i] =0;
    }

    for(i=0; i<NAV_FILENAME_SIZE; i++)
        gNavBook_CSV_filename[i] =0;

    putvalue(env_NaviSD_NB_ASGID, gNavBook_ASGID);
    putvalue(env_NaviSD_NB_TAID, gNavBook_TAID);
    putvalue(env_NaviSD_NB_TotalNumLE, gNavBook_TotalNumListElements);
    putvalue(env_NaviSD_NB_AH_shift, FALSE);
    putvalue(env_NaviSD_NB_AH_dir, FORWARD);
    putvalue(env_NaviSD_NB_AH_POS, TRUE);
    putvalue(env_NaviSD_NB_AH_IS, 1);
    putvalue(env_NaviSD_NB_AH_RA, 0);
    putvalue(env_NaviSD_NB_AH_start, 0);
    putvalue(env_NaviSD_NB_AH_elements, 3);
    putvalue(env_NaviSD_NB_DataSource, NAV_DEFAULT_LIST);
    putvalue(env_NaviSD_NB_CSVPath, empty_string);
    putvalue(env_NaviSD_NB_DataSource_result, empty_string);
    putvalue(env_NaviSD_NB_DataSource_file, empty_string);
    putvalue(env_NaviSD_NB_CA_switch, FALSE);
    putvalue(env_NaviSD_NB_Error_on, FALSE);
    putvalue(env_NaviSD_NB_ErrorCode, 0);
    //MR 76047 
    putvalue(env_NaviSD_NB_StatusOFF, 0);

    //Address_List
    gAddressList_ASGID =0;
    gAddressList_TAID  =0;

    gAddressList_TotalNumListElements   =0;
    gAddressList_OtherListType          =0;
    gAddressList_OtherListReference     =0;
    gAddressListLine_sum                =0;

    for(j=0; j<NAV_ADDRESSLIST_ENTRIES; j++)
    {   
        gAddressList_Pos[j]                         =0;
        gAddressList_ListEntryValidInformation[j]   =0;
        gAddressList_POIType[j]                     =0;
        gAddressList_AddressType[j]                 =0; 

        for(i=0;i<NAV_ADDRESSLIST_LASTNAME_LENGTH;i++)
            gAddressList_LastName[j][i]=0;
            
        for(i=0;i<NAV_ADDRESSLIST_FIRSTNAME_LENGTH;i++)
            gAddressList_FirstName[j][i]=0;
                
        for(i=0;i<NAV_ADDRESSLIST_STREET_LENGTH;i++)
            gAddressList_Street[j][i]=0;
            
        for(i=0;i<NAV_ADDRESSLIST_CITY_LENGTH;i++)
            gAddressList_City[j][i]=0;
                
        for(i=0;i<NAV_ADDRESSLIST_REGION_LENGTH;i++)
            gAddressList_Region[j][i]=0;
                
        for(i=0;i<NAV_ADDRESSLIST_POSTALCODE_LENGTH;i++)
            gAddressList_PostalCode[j][i]=0;
                
        for(i=0;i<NAV_ADDRESSLIST_COUNTRY_LENGTH;i++)
            gAddressList_Country[j][i]=0;
                
        for(i=0;i<NAV_ADDRESSLIST_COORDINATES_LENGTH;i++)
            gAddressList_Coordinates[j][i]=0;
    // MR78172        
        for(i=0;i<NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH;i++)
            gAddressList_POIDescription[j][i]=0;            
    }

    for(i=0; i<NAV_FILENAME_SIZE; i++)
        gAddressList_CSV_filename[i] =0;

    putvalue(env_NaviSD_AL_ASGID, gNavBook_ASGID);
    putvalue(env_NaviSD_AL_TAID, gNavBook_TAID);
    putvalue(env_NaviSD_AL_OtherList_Ref, gAddressList_OtherListReference);
    putvalue(env_NaviSD_AL_OtherListType, gAddressList_OtherListType);
    putvalue(env_NaviSD_AL_TotalNumLE, gNavBook_TotalNumListElements);
    putvalue(env_NaviSD_AL_AH_shift, FALSE);
    putvalue(env_NaviSD_AL_AH_dir, FORWARD);
    putvalue(env_NaviSD_AL_AH_POS, TRUE);
    putvalue(env_NaviSD_AL_AH_IS, 1);
    putvalue(env_NaviSD_AL_AH_RA, 0);
    putvalue(env_NaviSD_AL_AH_start, 0);
    putvalue(env_NaviSD_AL_AH_elements, 3);
    putvalue(env_NaviSD_AL_DataSource, NAV_DEFAULT_LIST);
    putvalue(env_NaviSD_AL_CSVPath, empty_string);
    putvalue(env_NaviSD_AL_DataSource_result, empty_string);
    putvalue(env_NaviSD_AL_DataSource_file, empty_string);
    putvalue(env_NaviSD_AL_CA_switch, FALSE);
    putvalue(env_NaviSD_AL_Error_on, FALSE);
    putvalue(env_NaviSD_AL_ErrorCode, 0);
    //MR 76047 
    putvalue(env_NaviSD_AL_StatusOFF, 0);
    
   //IssueList #9
   
   putValue(env_NaviSD_FctList_0x0F_HB , 1);
   putValue(env_NaviSD_FctList_0x10_HB , 1);
   putValue(env_NaviSD_FctList_0x11_HB , 1);
   putValue(env_NaviSD_FctList_0x12_HB , 1);
   putValue(env_NaviSD_FctList_0x13_HB , 1);
   putValue(env_NaviSD_FctList_0x14_HB , 1);
   putValue(env_NaviSD_FctList_0x15_HB , 1);
   putValue(env_NaviSD_FctList_0x16_HB , 1);
   putValue(env_NaviSD_FctList_0x17_HB , 1);
   putValue(env_NaviSD_FctList_0x19_HB , 1);
   putValue(env_NaviSD_FctList_0x1A_HB , 1);
   putValue(env_NaviSD_FctList_0x1B_HB , 1);
   putValue(env_NaviSD_FctList_0x1C_HB , 1);
   putValue(env_NaviSD_FctList_0x1F_HB , 1);
   putValue(env_NaviSD_FctList_0x24_HB , 1);
   putValue(env_NaviSD_FctList_0x25_HB , 1);
   putValue(env_NaviSD_FctList_0x26_HB , 1);
   putValue(env_NaviSD_FctList_0x27_HB , 1);
   putValue(env_NaviSD_FctList_0x28_HB , 1);
   //Updates from J.Karl 07.11.2013
   putValue(env_NaviSD_FctList_0x2B_HB , 1);

   //IssueList #68
    putValue(env_NaviSD_FctList_0x22_3min_TO, 0);
    putValue(env_NaviSD_FctList_0x29_3min_TO, 0);
    putValue(env_NaviSD_FctList_0x2A_3min_TO, 0);
    putValue(env_NaviSD_FctList_0x23_3min_TO, 0);
    
    //IssueList #128 - LaneGuidance EnvVar
    putValue(env_NaviLG_Pos_0,0); 
    putValue(env_NaviLG_LaneDir_0,0);
    //putValue(env_NaviLG_LaneSide_0,empty_string );
    putValue(env_NaviLG_LaneType_0,0);
    putValue(env_NaviLG_LaneMark_L_0,0);
    putValue(env_NaviLG_LaneMark_R_0,0);
    putValue(env_NaviLG_LaneDesc_0,0);
    putValue(env_NaviLG_GuidInfo_0,0);

    putValue(env_NaviLG_Pos_1,0); 
    putValue(env_NaviLG_LaneDir_1,0);
    //putValue(env_NaviLG_LaneSide_1,empty_string );
    putValue(env_NaviLG_LaneType_1,0);
    putValue(env_NaviLG_LaneMark_L_1,0);
    putValue(env_NaviLG_LaneMark_R_1,0);
    putValue(env_NaviLG_LaneDesc_1,0);
    putValue(env_NaviLG_GuidInfo_1,0);

    putValue(env_NaviLG_Pos_2,0); 
    putValue(env_NaviLG_LaneDir_2,0);
    //putValue(env_NaviLG_LaneSide_2,empty_string );
    putValue(env_NaviLG_LaneType_2,0);
    putValue(env_NaviLG_LaneMark_L_2,0);
    putValue(env_NaviLG_LaneMark_R_2,0);
    putValue(env_NaviLG_LaneDesc_2,0);
    putValue(env_NaviLG_GuidInfo_2,0);

    putValue(env_NaviLG_Pos_3,0); 
    putValue(env_NaviLG_LaneDir_3,0);
    //putValue(env_NaviLG_LaneSide_3,empty_string );
    putValue(env_NaviLG_LaneType_3,0);
    putValue(env_NaviLG_LaneMark_L_3,0);
    putValue(env_NaviLG_LaneMark_R_3,0);
    putValue(env_NaviLG_LaneDesc_3,0);
    putValue(env_NaviLG_GuidInfo_3,0);

    putValue(env_NaviLG_Pos_4,0); 
    putValue(env_NaviLG_LaneDir_4,0);
    //putValue(env_NaviLG_LaneSide_4,empty_string );
    putValue(env_NaviLG_LaneType_4,0);
    putValue(env_NaviLG_LaneMark_L_4,0);
    putValue(env_NaviLG_LaneMark_R_4,0);
    putValue(env_NaviLG_LaneDesc_4,0);
    putValue(env_NaviLG_GuidInfo_4,0);

    putValue(env_NaviLG_Pos_5,0); 
    putValue(env_NaviLG_LaneDir_5,0);
    //putValue(env_NaviLG_LaneSide_5,empty_string );
    putValue(env_NaviLG_LaneType_5,0);
    putValue(env_NaviLG_LaneMark_L_5,0);
    putValue(env_NaviLG_LaneMark_R_5,0);
    putValue(env_NaviLG_LaneDesc_5,0);
    putValue(env_NaviLG_GuidInfo_5,0);

    putValue(env_NaviLG_Pos_6,0); 
    putValue(env_NaviLG_LaneDir_6,0);
    //putValue(env_NaviLG_LaneSide_6,empty_string );
    putValue(env_NaviLG_LaneType_6,0);
    putValue(env_NaviLG_LaneMark_L_6,0);
    putValue(env_NaviLG_LaneMark_R_6,0);
    putValue(env_NaviLG_LaneDesc_6,0);
    putValue(env_NaviLG_GuidInfo_6,0);

    putValue(env_NaviLG_Pos_7,0); 
    putValue(env_NaviLG_LaneDir_7,0);
    //putValue(env_NaviLG_LaneSide_7,empty_string );
    putValue(env_NaviLG_LaneType_7,0);
    putValue(env_NaviLG_LaneMark_L_7,0);
    putValue(env_NaviLG_LaneMark_R_7,0);
    putValue(env_NaviLG_LaneDesc_7,0);
    putValue(env_NaviLG_GuidInfo_7,0);

    putValue(env_NaviLG_Enable_0, 0);
    putValue(env_NaviLG_Enable_1, 0);
    putValue(env_NaviLG_Enable_2, 0);
    putValue(env_NaviLG_Enable_3, 0);
    putValue(env_NaviLG_Enable_4, 0);
    putValue(env_NaviLG_Enable_5, 0);
    putValue(env_NaviLG_Enable_6, 0);
    putValue(env_NaviLG_Enable_7, 0);
    
    putValue(env_NaviSD_LG_DataS_result_EV,empty_string);

     //IssueList #76 - MR49870 
    //LDL
    //insert
   putValue(env_NaviSD_LDL_insert_Err,1);
   putValue(env_NaviSD_LDL_insert_successor, 0);
   putValue(env_NaviSD_LDL_insert_UPD_button,0);
   putValue(env_NaviSD_LDL_insert_size, 0);

    //delete
    putValue(env_NaviSD_LDL_delete_ErrHand,1);
    putValue(env_NaviSD_LDL_delete_size, 0);
   
    //Disable BIT16 controls
    enableControl("FSG_NAVISD_LASTDEST_INSERT_DELETE", "Envar:env_NaviSD_LDL_insert_size", 0); 
    enableControl("FSG_NAVISD_LASTDEST_INSERT_DELETE", "Envar:env_NaviSD_LDL_delete_size", 0); 
    enableControl("FSG_NAVISD_LASTDEST_INSERT_DELETE", "Envar:env_NaviSD_LDL_insert_POS_16", 0); 
    enableControl("FSG_NAVISD_LASTDEST_INSERT_DELETE", "Envar:env_NaviSD_LDL_delete_POS_16", 0); 

    //setting LDL as default List
    putValue(env_NaviSD_PrefDeLis_Type,0x01);
    putValue(env_NaviSD_PrefDeLis_Type_update, 0x1); 

    //IssueList #185 - setting List as default
    putValue(env_NaviSD_LDL_DataSource, 1);

    //IssueList #202 - setting List as default dataSource
    putValue(env_NaviSD_LG_DataSource,1);

//IssueList #216 15S1 update 17.01.2014
//------------------------------------------------
    //---------------------0x33 POI_Search
    putValue(env_NaviSD_POISearch_AOFE,0);
    putValue(env_NaviSD_POISearch_POI_Type,0);
    putValue(env_NaviSD_POISearch_POI_TypeHex,0);
    putValue(env_NaviSD_POISearch_POISR,0);
    putValue(env_NaviSD_POISearch_POISRHex,0);
    putValue(env_NaviSD_POISearch_ProgressIndicator,0);
    putValue(env_NaviSD_POISearch_SearchTypeH,0);
    putValue(env_NaviSD_POISearch_SearchType,0);
    putValue(env_NaviSD_POISearch_error_state,0);
    putValue(env_NaviSD_POISearch_error_code,0);
    gPOIS_STact                                     = 0x00;
    gPOIS_POISRact                                  = 0x00;
    gPOIS_POITyact                                  = 0x00;
    tempPOIS_1                                      = 0;
    tempPOIS_2                                      = 0;
    tempPOIS_3                                      = 0;
    //MR 76047
    putvalue(env_NaviSD_POIList_StatusOFF, 0);

    //-----------------------------------------------------------------
    //--------------------0x34 POI_List
    putValue(env_NaviSD_POI_List_AH,1);
    putValue(env_NaviSD_POI_List_AHD,0);
    putValue(env_NaviSD_POI_List_ASG_ID,0);
    putValue(env_NaviSD_POI_List_ASG_IDhex,0);
    putValue(env_NaviSD_POI_List_direction,0);
    putValue(env_NaviSD_POI_List_elements,0);
    putValue(env_NaviSD_POI_List_FRU,0);
    putValue(env_NaviSD_POI_List_index,0);
    putValue(env_NaviSD_POI_List_RecordAdd,0);
    putValue(env_NaviSD_POI_List_shift,0);
    putValue(env_NaviSD_POI_List_start,0);
    putValue(env_NaviSD_POI_List_TAID,0);
    putValue(env_NaviSD_POI_List_TNLE,0);
    putValue(env_NaviSD_POI_List_transmitPos,0);
    putValue(env_NaviSD_POI_List_DataSource,0);
    putValue(env_NaviSD_POI_List_CSVcurrent," ");
    putValue(env_NaviSD_POI_List_CSVPath," ");

    for(i=0; i<NAV_FILENAME_SIZE; i++)
        gPOIList_CSV_filename[i] =0;

    //-----------------------------------------------------------------
    //--------------------0x35 FSG_Setup
    putValue(env_NaviSD_FSGS_SPOIT0,0);
    putValue(env_NaviSD_FSGS_VG0,0);
    putValue(env_NaviSD_FSGS_VG1,0);
    putValue(env_NaviSD_FSGS_VG2,0);

    //-----------------------------------------------------------------
    //--------------------0x36 Map_Presentation
    putValue(env_NaviSD_MapPres_0,0);
    putValue(env_NaviSD_MapPres_1,0);
    putValue(env_NaviSD_MapPres_2,0);

    //MR 76047 
    //-----------------------------------------------------------------
    //--------------------0x37 ManeuverState
    putValue(env_NaviSD_ManeuverState_State,0);
    putValue(env_NaviSD_ManeuverState_StateHex,0);  

    //-----------------------------------------------------------------
    //--------------------0x38 ETC_Status
    putValue(env_NaviSD_ETC_Status_CardStatus,0);
    putValue(env_NaviSD_ETC_Status_Extension1,0);
    putValue(env_NaviSD_ETC_Status_Extension1_hex,0);       
}

CompassInfo_Request(byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;            //LSG-ID
    requestarray[1] =FctID_CompassInfo;        //Fct.-ID
    requestarray[2] =request;               //request type

    switch(request)
    {
        case Data_REQ:    
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x10_TimeOut)!=TRUE)
            {        
            requestarray[3] =gCI_Direction_Symbolic;
            requestarray[4] =gCI_Direction_Angle & 0x00ff;
            requestarray[5] =(gCI_Direction_Angle & 0xff00)/0x100;
            
            set_status_requestbuffer (requestarray, 6, Bap_ByteSequence);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    //error
            writelineEx(gError_Trace, 0, "NaviSD CompassInfo_Request: invalid request %d", request);
        break;
    }
}

on envVar env_NaviSD_RG_Status_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getValue(this))
    {
        gRG_Status =getValue(env_NaviSD_RG_Status);

        RG_Status_Request(Data_REQ,0); //send status    
    }    
}

DistanceToNextManeuver_Request(byte request, byte errorcode)
{   
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;                        //LSG-ID
    requestarray[1]=FctID_DistanceToNextManeuver;    //Fct.-ID
    requestarray[2]=request;                        //request type

    switch(request)
    {
        case Data_REQ:
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x12_TimeOut)!=TRUE)
            {        
            requestarray[3] =gDTNM_Distance & 0xff;
            requestarray[4] =(gDTNM_Distance & 0xff00)/0x100;
            requestarray[5] =(gDTNM_Distance & 0xff0000)/0x10000;
            requestarray[6] =(gDTNM_Distance & 0xff000000)/0x1000000;
            requestarray[7] =gDTNM_Unit;
            requestarray[8] =gDTNM_BargraphOnOff;
            requestarray[9] =gDTNM_Bargraph;
            requestarray[10]=gDTNM_ValidityInformation;

            set_status_requestbuffer (requestarray, 11, Bap_ByteSequence);
            }
        break;

        case Error_REQ:
            requestarray[3] =errorcode;

            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;

        default:    
            writelineEx(gError_Trace, 0, "NaviSD DistanceToNextManeuver: invalid request %d", request);
        break;
    }
}

on envVar env_NaviSD_DTNM_update
{
    if (POWER_ON==gNaviSD_PowerOnOff && getValue(this))
    {
        gDTNM_Distance =getValue(env_NaviSD_DTNM_Distance);
        gDTNM_Unit =getValue(env_NaviSD_DTNM_Unit);
        
        gDTNM_BargraphOnOff =getValue(env_NaviSD_DTNM_BG_ON_OFF);
        gDTNM_Bargraph =getValue(env_NaviSD_DTNM_BG);
        gDTNM_ValidityInformation =getValue(env_NaviSD_DTNM_ValidityInfo);
        
        DistanceToNextManeuver_Request(Data_REQ,0);     
    }    
}

DistanceToNextManeuver_Indication(dword Indication_array [], int datalength)
{    
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                DistanceToNextManeuver_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "ASG-NaviSD DistanceToNextManeuver_Indication: invalid indication %d", Indication_array[2]);
        break;
    }
}

on envVar env_NaviSD_PositionInfo_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getValue(this))
    {
        getValue(env_NaviSD_PositionInfo,gCurrentPositionInfo_PositionInfo);
        CurrentPositionInfo_Request(Data_REQ, 0);
    }
}

CurrentPositionInfo_Request(byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE], Offset;

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                 //LSG-ID
    requestarray[1] =FctID_CurrentPositionInfo;     //Fct.-ID
    requestarray[2] =request;                    //request type

    switch(request)
    {
        case Data_REQ:
        //IssueList #62
            if (getValue(env_NaviSD_FctList_0x13_TimeOut)!=TRUE)
            {                
                requestarray[3] =strlen(gCurrentPositionInfo_PositionInfo);
                Offset =4;
            
                for(i=0;i<strlen(gCurrentPositionInfo_PositionInfo);i++)
                {
                 requestarray[Offset] =gCurrentPositionInfo_PositionInfo[i];    
                 Offset++;
                }

                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
        break;
        case Error_REQ:                
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    //error
            writelineEx(gError_Trace, 0, "NaviSD CurrentPositionInfo: invalid request %d", request);
        break;
    }
}

CurrentPositionInfo_Indication(dword Indication_array [], int datalength)
{
    switch (Indication_array[2])    // indication
    {
        case DataGet_IND:
            CurrentPositionInfo_Request(Data_REQ, 0);
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD CurrentPositionInfo_Indication: invalid indication %d", Indication_array[2]);
        break;
    }
}

on envVar env_NaviSD_TTI_update
{
    if (POWER_ON==gNaviSD_PowerOnOff && getValue(this))
    {
        getValue(env_NaviSD_TTI_TurnToInfo,gTurnToInfo_TurnToInfo);
        getValue(env_NaviSD_TTI_SignPost,gTurnToInfo_SignPost);

        TurnToInfo_Request(Data_REQ, 0);
    }
}

TurnToInfo_Request(byte request, byte errorcode)
{
    int i =0, Offset =0;
    byte count =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;        //LSG-ID
    requestarray[1] =FctID_TurnToInfo;    //Fct.-ID
    requestarray[2] =request;           //request type


    switch(request)
    {
        case Data_REQ:
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x14_TimeOut)!=TRUE)
            {
                //TurnToInfo    
                requestarray[3] =strlen(gTurnToInfo_TurnToInfo);
                Offset=4;

                for(i=0;i<strlen(gTurnToInfo_TurnToInfo);i++)
                {
                 requestarray[Offset]=gTurnToInfo_TurnToInfo[i];    
                 Offset++;
                }
            
                //SignPost
                requestarray[Offset] =strlen(gTurnToInfo_SignPost);
                Offset++;
                for(i=0;i<strlen(gTurnToInfo_SignPost);i++)
                {
                 requestarray[Offset]=gTurnToInfo_SignPost[i];    
                 Offset++;
                }

                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
        break;
        case Error_REQ:    
            requestarray[3] =errorcode;

            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD TurnToInfo: invalid request %d", request);
        break;
    }
}

TurnToInfo_Indication(dword Indication_array [], int datalength)
{
    switch (Indication_array[2])
    {
        case DataGet_IND:
                TurnToInfo_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD CurrentPositionInfo_Indication: invalid indication %d", Indication_array[2]);
        break;
    }
}

on envVar env_NaviSD_DTD_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getValue(this))
    {    
        gDTD_Distance =getValue(env_NaviSD_DTD_Distance);
        gDTD_Unit =getValue(env_NaviSD_DTD_Unit);
        gDTD_ValidityInformation =getValue(env_NaviSD_DTD_ValidityInfo);
        //MR 76047 
        gDTD_DTDType = getValue(env_NaviSD_DTD_DTDType);

        DistanceToDestination_Request(Data_REQ,0);     
    }    
}

CompassInfo_Indication(dword Indication_array [], int datalength)
{
    switch (Indication_array[2])    // indication
    {
        case DataGet_IND:
                CompassInfo_Request(Data_REQ, 0);   //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD CompassInfo_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

ManeuverDescriptor_Request(byte request, byte errorcode)
{
    int  i, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                //LSG-ID
    requestarray[1] =FctID_ManeuverDescriptor;    //Fct.-ID
    requestarray[2] =request;                   //request type

    switch(request)
    {
        case Data_REQ:
             //IssueList #62
            if (getValue(env_NaviSD_FctList_0x17_TimeOut)!=TRUE)
            {
                //Maneuver_1                
                requestarray[3] =gMD_MainElement_1;
                requestarray[4] =gMD_Direction_1;
                requestarray[5] =gMD_ZLevelGuidance_1;
            
                requestarray[6] =gMD_Sidestreet_1[0];
                Offset =7;
            
                for(i=0;i<=gMD_Sidestreet_1[0];i++)
                {
                    if(i>0)        
                    {
                        requestarray[Offset] =gMD_Sidestreet_1[i];    
                        Offset++;
                    }
                }
            
                //Maneuver_2                
                requestarray[Offset] =gMD_MainElement_2;
                Offset++;
                requestarray[Offset] =gMD_Direction_2;
                Offset++;
                requestarray[Offset] =gMD_ZLevelGuidance_2;
                Offset++;

                requestarray[Offset] =gMD_Sidestreet_2[0];
                Offset++;
            
                for(i=0;i<=gMD_Sidestreet_2[0];i++)
                {
                    if(i>0)        
                    {
                        requestarray[Offset] =gMD_Sidestreet_2[i];    
                        Offset++;
                    }
                }

                //Maneuver_3                
                requestarray[Offset] =gMD_MainElement_3;
                Offset++;
                requestarray[Offset] =gMD_Direction_3;
                Offset++;
                requestarray[Offset] =gMD_ZLevelGuidance_3;
                Offset++;

                requestarray[Offset] =gMD_Sidestreet_3[0];
                Offset++;
            
                for(i=0;i<=gMD_Sidestreet_3[0];i++)
                {
                    if(i>0)        
                    {
                        requestarray[Offset] =gMD_Sidestreet_3[i];    
                        Offset++;
                    }
                }
            
                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "ManeuverDescriptor_Request: invalid request %d", request);
        break;
    }    
}

on envVar env_NaviSD_MD_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getValue(this)==1)
    {   
        //MainElement
        gMD_MainElement_1 =getvalue(env_NaviSD_MD_MainElement1);
        gMD_MainElement_2 =getvalue(env_NaviSD_MD_MainElement2);
        gMD_MainElement_3 =getvalue(env_NaviSD_MD_MainElement3);
        
        //Direction
        gMD_Direction_1 =getvalue(env_NaviSD_MD_Direction1);
        gMD_Direction_2 =getvalue(env_NaviSD_MD_Direction2);
        gMD_Direction_3 =getvalue(env_NaviSD_MD_Direction3);

        //Z-Level
        gMD_ZLevelGuidance_1 =getvalue(env_NaviSD_MD_Z_Level1);
        gMD_ZLevelGuidance_2 =getvalue(env_NaviSD_MD_Z_Level2);
        gMD_ZLevelGuidance_3 =getvalue(env_NaviSD_MD_Z_Level3);
        
        //Sidestreets
        getvalue(env_NaviSD_MD_Sidestreet1, gMD_Sidestreet_1);
        getvalue(env_NaviSD_MD_Sidestreet2, gMD_Sidestreet_2);
        getvalue(env_NaviSD_MD_Sidestreet3, gMD_Sidestreet_3);

        ManeuverDescriptor_Request(Data_REQ,0);
    }
}

ManeuverDescriptor_Indication(dword Indication_array [], int datalength)
{    
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                ManeuverDescriptor_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD ManeuverDescriptor_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

LaneGuidance_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize; 
    word LaneGuidanceEntry, current_element, Offset;

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;
    
    shift               =0;
    direction           =0;
    transmitpos         =0;
    indexsize           =0;
    LaneGuidanceEntry   =0;
    current_element     =0;
    Offset              =0;

    // decode "mode-byte"
    shift       =mode &0x01;
    direction   =(mode &0x02)/0x02;
    transmitpos =(mode &0x04)/0x04;
    indexsize   =(mode &0x08)/0x08;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                //LSG-ID
    requestarray[1] =FctID_LaneGuidance;        //Fct.-ID
    requestarray[2] =request;                   //request type
    Offset =3;

    switch(request)
    {
        case Changed_REQ:            
            
            requestarray[Offset] =gLaneGuidance_LaneGuidanceOnOff;    
            Offset++;

            /***ArrayHeader***/
            requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
            Offset++;
            
            if (indexsize)
            {   
                requestarray[Offset] =(requested_startelement &0x00FF);
                Offset++;
                requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
                Offset++;

                requestarray[Offset] =(elements &0x00FF);
                Offset++;
                requestarray[Offset] =((elements &0xFF00) /0x100);
                Offset++;
            }
            else
            {   
                requestarray[Offset] =requested_startelement;
                Offset++;

                requestarray[Offset] =elements;
                Offset++;
            }
            
            LaneGuidanceEntry =startelement;
            
            if (getvalue(env_NaviSD_LG_CA_switch)) //ArrayData
            {
                //copy data
                switch(recordaddress)
                {
                    case 0: //complete record
                        while(current_element <elements)
                        {
                            if(LaneGuidanceEntry ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LaneGuidance_Request: invalid LaneGuidanceEntry");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gLaneGuidance_Pos[LaneGuidanceEntry] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gLaneGuidance_Pos[LaneGuidanceEntry]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gLaneGuidance_Pos[LaneGuidanceEntry];
                                        Offset++;
                                    }
                                }
                                                                                                                             
                                //LaneDirection
                                requestarray[Offset] =gLaneGuidance_LaneDirection[LaneGuidanceEntry];
                                Offset++;

                                //LaneSidestreets
                                //IssueList #202 - ifElse condition
                                if (getValue(env_NaviSD_LG_DataSource)!=0x02)
                                {
                                    requestarray[Offset] =strlen(gLaneGuidance_LaneSidestreets[LaneGuidanceEntry]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gLaneGuidance_LaneSidestreets[LaneGuidanceEntry]);i++)
                                    {
                                        requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i];    
                                        Offset++;
                                    }
                                }
                                else
                                {
                                    requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][0];
                                    Offset++;
                                    
                                    for(i=0;i<gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][0];i++)
                                        {
                                            requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i+1];    
                                            Offset++;
                                        }
                                }

                                //LaneType
                                requestarray[Offset] =gLaneGuidance_LaneType[LaneGuidanceEntry];
                                Offset++;

                                //LaneMarking_left & LaneMarking_right
                                requestarray[Offset] =((gLaneGuidance_LaneMarking_left[LaneGuidanceEntry] *0x10) &0xF0) +(gLaneGuidance_LaneMarking_right[LaneGuidanceEntry] &0x0F);
                                Offset++;

                                //LaneDescription & GuidanceInfo
                                requestarray[Offset] =((gLaneGuidance_LaneDescription[LaneGuidanceEntry] *0x10) &0xF0) +(gLaneGuidance_GuidanceInfo[LaneGuidanceEntry] &0x0F);
                                Offset++;
                            }
                            current_element++;
                            LaneGuidanceEntry =LaneGuidance_nextvalidLine(LaneGuidanceEntry, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 1: //LaneDirection, LaneSidestreets, LaneType, Lane Description, GuidanceInfo
                        while(current_element <elements)
                        {
                            if(LaneGuidanceEntry ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LaneGuidance_Request: invalid LaneGuidanceEntry");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gLaneGuidance_Pos[LaneGuidanceEntry] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gLaneGuidance_Pos[LaneGuidanceEntry]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gLaneGuidance_Pos[LaneGuidanceEntry];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //LaneDirection
                                requestarray[Offset] =gLaneGuidance_LaneDirection[LaneGuidanceEntry];
                                Offset++;

                                
                                //LaneSidestreets
                                //IssueList #202 - ifElse condition
                                if (getValue(env_NaviSD_LG_DataSource)!=0x02)
                                {
                                    requestarray[Offset] =strlen(gLaneGuidance_LaneSidestreets[LaneGuidanceEntry]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gLaneGuidance_LaneSidestreets[LaneGuidanceEntry]);i++)
                                    {
                                        requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i];    
                                        Offset++;
                                    }
                                }
                                else
                                {
                                    requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][0];
                                    Offset++;
                                    
                                    for(i=0;i<gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][0];i++)
                                        {
                                            requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i+1];    
                                            Offset++;
                                        }
                                }

                                //LaneType
                                requestarray[Offset] =gLaneGuidance_LaneType[LaneGuidanceEntry];
                                Offset++;

                                //LaneDescription & GuidanceInfo
                                requestarray[Offset] =((gLaneGuidance_LaneDescription[LaneGuidanceEntry] *0x10) &0xF0) +(gLaneGuidance_GuidanceInfo[LaneGuidanceEntry] &0x0F);
                                Offset++;
                            }
                            current_element++;
                            LaneGuidanceEntry =LaneGuidance_nextvalidLine(LaneGuidanceEntry, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 2: //LaneDirection, LaneDescription, GuidanceInfo
                        while(current_element <elements)
                        {
                            if(LaneGuidanceEntry ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LaneGuidance_Request: invalid LaneGuidanceEntry");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gLaneGuidance_Pos[LaneGuidanceEntry] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gLaneGuidance_Pos[LaneGuidanceEntry]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gLaneGuidance_Pos[LaneGuidanceEntry];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //LaneDirection
                                requestarray[Offset] =gLaneGuidance_LaneDirection[LaneGuidanceEntry];
                                Offset++;

                                //LaneDescription & GuidanceInfo
                                requestarray[Offset] =((gLaneGuidance_LaneDescription[LaneGuidanceEntry] *0x10) &0xF0) +(gLaneGuidance_GuidanceInfo[LaneGuidanceEntry] &0x0F);
                                Offset++;
                            }
                            current_element++;
                            LaneGuidanceEntry =LaneGuidance_nextvalidLine(LaneGuidanceEntry, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 3: //LaneDescription, GuidanceInfo
                        while(current_element <elements)
                        {
                            if(LaneGuidanceEntry ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LaneGuidance_Request: invalid LaneGuidanceEntry");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gLaneGuidance_Pos[LaneGuidanceEntry] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gLaneGuidance_Pos[LaneGuidanceEntry]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gLaneGuidance_Pos[LaneGuidanceEntry];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //LaneDescription & GuidanceInfo
                                requestarray[Offset] =((gLaneGuidance_LaneDescription[LaneGuidanceEntry] *0x10) &0xF0) +(gLaneGuidance_GuidanceInfo[LaneGuidanceEntry] &0x0F);
                                Offset++;
                            }
                            current_element++;
                            LaneGuidanceEntry =LaneGuidance_nextvalidLine(LaneGuidanceEntry, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 15:
                        while(current_element <elements)
                        {
                            if(LaneGuidanceEntry ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LaneGuidance_Request: invalid LaneGuidanceEntry");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gLaneGuidance_Pos[LaneGuidanceEntry] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gLaneGuidance_Pos[LaneGuidanceEntry]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gLaneGuidance_Pos[LaneGuidanceEntry];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            LaneGuidanceEntry =LaneGuidance_nextvalidLine(LaneGuidanceEntry, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    default:
                        write("NaviSD LaneGuidance_Request: invalid recordaddress %d", recordaddress);
                    break;
                } //end switch "recordaddress"
            }//end ArrayData  
            
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);    //new
        
        break; //end Changed_REQ
        
        case Data_REQ:
            //changes from Jran Karl (28.03.2012)
            //MR 63336    02.07.2014
            //if(getvalue(env_NaviSD_LG_Timeout) != TRUE)
            if( /*getvalue(env_NaviSD_LG_Timeout) != */ TRUE)
            {
            //VAGH-10511
            ASGID = gLaneGuidance_ASGID;
            TAID = gLaneGuidance_TAID;
                if(getvalue(env_NaviSD_LG_ASGID_error) != FALSE)
                {
                    ASGID += 0x2;
                }
                if(getvalue(env_NaviSD_LG_TAID_error) != FALSE)
                {
                    TAID += 0x02;
                }

                requestarray[Offset] =((ASGID *0x10) &0xF0) +(TAID &0x0F);    
                Offset++;
                requestarray[Offset] =gLaneGuidance_LaneGuidanceOnOff;    
                Offset++;
    //end of changes from Jran Karl (28.03.2012)
            /***ArrayHeader***/
            requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
            Offset++;
                        
            if (indexsize)
            {   
                requestarray[Offset] =(requested_startelement &0x00FF);
                Offset++;
                requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
                Offset++;

                requestarray[Offset] =(elements &0x00FF);
                Offset++;
                requestarray[Offset] =((elements &0xFF00) /0x100);
                Offset++;
            }
            else
            {   
                requestarray[Offset] =requested_startelement;
                Offset++;

                requestarray[Offset] =elements;
                Offset++;
            }
            
            LaneGuidanceEntry =startelement;

            switch(recordaddress)
            {
                case 0: //complete record
                        while(current_element <elements)
                        {
                            if(LaneGuidanceEntry ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LaneGuidance_Request: invalid LaneGuidanceEntry");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gLaneGuidance_Pos[LaneGuidanceEntry] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gLaneGuidance_Pos[LaneGuidanceEntry]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gLaneGuidance_Pos[LaneGuidanceEntry];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //LaneDirection
                                requestarray[Offset] =gLaneGuidance_LaneDirection[LaneGuidanceEntry];
                                Offset++;

                                //LaneSidestreets
                                //IssueList #202 - ifElse condition
                                if (getValue(env_NaviSD_LG_DataSource)!=0x02)
                                {
                                    requestarray[Offset] =strlen(gLaneGuidance_LaneSidestreets[LaneGuidanceEntry]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gLaneGuidance_LaneSidestreets[LaneGuidanceEntry]);i++)
                                    {
                                        requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i];    
                                        Offset++;
                                    }
                                }
                                else
                                {
                                    requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][0];
                                    Offset++;

                                    for(i=0;i<gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][0];i++)
                                        {
                                            requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i+1];    
                                            Offset++;
                                        }
                                }

                                //LaneType
                                requestarray[Offset] =gLaneGuidance_LaneType[LaneGuidanceEntry];
                                Offset++;

                                //LaneMarking_left & LaneMarking_right
                                requestarray[Offset] =((gLaneGuidance_LaneMarking_left[LaneGuidanceEntry] *0x10) &0xF0) +(gLaneGuidance_LaneMarking_right[LaneGuidanceEntry] &0x0F);
                                Offset++;

                                //LaneDescription & GuidanceInfo
                                requestarray[Offset] =((gLaneGuidance_LaneDescription[LaneGuidanceEntry] *0x10) &0xF0) +(gLaneGuidance_GuidanceInfo[LaneGuidanceEntry] &0x0F);
                                Offset++;
                            }
                            current_element++;
                            LaneGuidanceEntry =LaneGuidance_nextvalidLine(LaneGuidanceEntry, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 1: //LaneDirection, LaneSidestreets, LaneType, Lane Description, GuidanceInfo
                        while(current_element <elements)
                        {
                            if(LaneGuidanceEntry ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LaneGuidance_Request: invalid LaneGuidanceEntry");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gLaneGuidance_Pos[LaneGuidanceEntry] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gLaneGuidance_Pos[LaneGuidanceEntry]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gLaneGuidance_Pos[LaneGuidanceEntry];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //LaneDirection
                                requestarray[Offset] =gLaneGuidance_LaneDirection[LaneGuidanceEntry];
                                Offset++;

                                
                                //LaneSidestreets
                                //IssueList #202 - ifElse condition
                                if (getValue(env_NaviSD_LG_DataSource)!=0x02)
                                {
                                    requestarray[Offset] =strlen(gLaneGuidance_LaneSidestreets[LaneGuidanceEntry]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gLaneGuidance_LaneSidestreets[LaneGuidanceEntry]);i++)
                                    {
                                        requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i];    
                                        Offset++;
                                    }
                                }
                                else
                                {
                                    requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][0];
                                    Offset++;

                                    for(i=0;i<gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][0];i++)
                                        {
                                            requestarray[Offset] =gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i+1];    
                                            Offset++;
                                        }
                                }

                                //LaneType
                                requestarray[Offset] =gLaneGuidance_LaneType[LaneGuidanceEntry];
                                Offset++;

                                //LaneDescription & GuidanceInfo
                                requestarray[Offset] =((gLaneGuidance_LaneDescription[LaneGuidanceEntry] *0x10) &0xF0) +(gLaneGuidance_GuidanceInfo[LaneGuidanceEntry] &0x0F);
                                Offset++;
                            }
                            current_element++;
                            LaneGuidanceEntry =LaneGuidance_nextvalidLine(LaneGuidanceEntry, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 2: //LaneDirection, LaneDescription, GuidanceInfo
                        while(current_element <elements)
                        {
                            if(LaneGuidanceEntry ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LaneGuidance_Request: invalid LaneGuidanceEntry");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gLaneGuidance_Pos[LaneGuidanceEntry] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gLaneGuidance_Pos[LaneGuidanceEntry]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gLaneGuidance_Pos[LaneGuidanceEntry];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //LaneDirection
                                requestarray[Offset] =gLaneGuidance_LaneDirection[LaneGuidanceEntry];
                                Offset++;

                                //LaneDescription & GuidanceInfo
                                requestarray[Offset] =((gLaneGuidance_LaneDescription[LaneGuidanceEntry] *0x10) &0xF0) +(gLaneGuidance_GuidanceInfo[LaneGuidanceEntry] &0x0F);
                                Offset++;
                            }
                            current_element++;
                            LaneGuidanceEntry =LaneGuidance_nextvalidLine(LaneGuidanceEntry, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 3: //LaneDescription, GuidanceInfo
                        while(current_element <elements)
                        {
                            if(LaneGuidanceEntry ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LaneGuidance_Request: invalid LaneGuidanceEntry");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gLaneGuidance_Pos[LaneGuidanceEntry] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gLaneGuidance_Pos[LaneGuidanceEntry]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gLaneGuidance_Pos[LaneGuidanceEntry];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //LaneDescription & GuidanceInfo
                                requestarray[Offset] =((gLaneGuidance_LaneDescription[LaneGuidanceEntry] *0x10) &0xF0) +(gLaneGuidance_GuidanceInfo[LaneGuidanceEntry] &0x0F);
                                Offset++;
                            }
                            current_element++;
                            LaneGuidanceEntry =LaneGuidance_nextvalidLine(LaneGuidanceEntry, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 15:
                        while(current_element <elements)
                        {
                            if(LaneGuidanceEntry ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LaneGuidance_Request: invalid LaneGuidanceEntry");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gLaneGuidance_Pos[LaneGuidanceEntry] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gLaneGuidance_Pos[LaneGuidanceEntry]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gLaneGuidance_Pos[LaneGuidanceEntry];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            LaneGuidanceEntry =LaneGuidance_nextvalidLine(LaneGuidanceEntry, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                    default:
                        write("NaviSD LaneGuidance_Request: invalid recordaddress %d", recordaddress);
                     break;
                } //end switch "recordaddress"
           //changes from Jran Karl (28.03.2012)
       }
            else
            {
                write("NaviSD LaneGuidance_Request: Simulate timeout of Status-Array!");
            }
        //end of changes from Jran Karl (28.03.2012)
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
         break; //end Error_REQ
    
    } //end switch "request"   
}

LaneGuidance_Indication(dword Indication_array [], int datalength)
{
    byte mode, shift, direction, recordaddress, indexsize, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements, valid_elements, Offset;
    int i=0, transSuppression;

    // Init local variables. 
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0xff;
    valid_elements          =0;
    transmitpos             =0;
    Offset                  =0;
    //MR 76047 
    transSuppression        = getvalue(env_NaviSD_LG_StatusOFF);

        switch (Indication_array[2]) // indication
        {
            case DataGet_IND:
                if(getvalue(env_NaviSD_LG_Error_on))
                {
                    LaneGuidance_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue(env_NaviSD_LG_ErrorCode));
                }
                //MR 63336    02.07.2014
                else if(getvalue(env_NaviSD_LG_Timeout) == TRUE)
                {
                /* NOP */
                }
                else
                {
                    //getData
                    gLaneGuidance_ASGID =(gBAP_Indication[3] &0xF0) /0x10;
                    gLaneGuidance_TAID  =gBAP_Indication[3] &0x0F;
            
                    
                    /***ArrayHeader***/
                    mode            =(Indication_array[4] &0xF0) /0x10;
                    recordaddress   =Indication_array[4] &0x0F;
                    Offset =5;
                
                    // decode "mode-byte"
                    shift       =mode &0x01;
                    direction   =(mode &0x02)/0x02;
                    transmitpos =(mode &0x04)/0x04;
                    indexsize   =(mode &0x08)/0x08;              
            
                    if (indexsize)
                    {   
                        startelement =Indication_array[Offset];
                        Offset++;
                        startelement +=(Indication_array[Offset] *0x100);
                        Offset++;

                        elements =Indication_array[Offset];
                        Offset++;
                        elements +=(Indication_array[Offset] *0x100);
                        Offset++;
                    }
                    else
                    {   
                        startelement =Indication_array[Offset];
                        Offset++;

                        elements =Indication_array[Offset];
                        Offset++;
                    }   

                    requested_startelement =startelement;

                    /***Startelement=0***/
                    if(0==startelement) //Startelement-ID =0 -> start at first array-entry
                    {
                        if(FORWARD==direction)  //forward-start
                        {
                            valid_startelement =0;                                                           

                            if(NAV_LANEGUIDANCE_ENTRIES <=elements) //1. more elements requested, than in array
                            {
                                if (shift ==FALSE)  
                                {
                                    for(i=0;i<NAV_LANEGUIDANCE_ENTRIES;i++)
                                    {
                                        if(0 !=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i =NAV_LANEGUIDANCE_ENTRIES;
                                    }
                                }
                                else
                                {   
                                    valid_startelement  =startelement;
                                    valid_elements      =0;
                                }
                            }
                            else    //2. number of requested elements < elements in array
                            {
                                if (shift ==FALSE)
                                {
                                    for(i=0;i<elements;i++)
                                    {
                                        if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i =NAV_LANEGUIDANCE_ENTRIES;
                                    }
                                }
                                else
                                {
                                    valid_startelement  =startelement;
                                    valid_elements      =0;  
                                }

                            }
                        }                                                               //forward ends

                        else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
                        {   
                            //searching for valid startelement
                            for(i=(NAV_LANEGUIDANCE_ENTRIES-1);i>=0;i--)
                            {
                                if(0!=gLaneGuidance_ListEntryValidInformation[i])        //found valid startelement
                                {
                                    valid_startelement =i;                                
                                    i =0;                                                
                                }
                            }
                        
                            //searching for valid elements
                            if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                            {
                                valid_startelement  =startelement;
                                valid_elements      =0;
                            }
                            else if(0==valid_startelement)                                
                                valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                            else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                            {
                                for(i=valid_startelement;i>=0;i--)
                                {
                                    if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                        valid_elements++;                                //increment elements
                                    else                                                //no valid element, loop finished
                                        i=0;
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for(i=valid_startelement;i>(valid_startelement-elements);i--)
                                {
                                    if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                        valid_elements++;                                //increment elements
                                    else                                                //no valid element, loop finished
                                        i=0;
                                }            
                            }                                                            
                        }                                                               //backward-end
                    }                                                                   //startelement ==0 -end

                    /***Startelement!=0***/
                    else                                                                //searching for Startelement-ID                
                    {
                        //searching for valid startelement
                        for(i=0;i<NAV_LANEGUIDANCE_ENTRIES;i++)
                        {
                            if(gLaneGuidance_Pos[i] ==startelement)                        //found a valid element
                            {                                         
                                if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                                {
                                    if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                                        valid_startelement =i+1-2*direction;
                            
                                    else if(i==0 && BACKWARD==direction) 
                                        valid_startelement =gLaneGuidanceLine_sum;     //valid element is last element in Array                                                
                            
                                    else if(i==0 && FORWARD==direction) 
                                        valid_startelement =0;                          //valid element is first element in Array
                                }
                    
                                else
                                    valid_startelement =i;                              //found element is valid_startelement

                                i=NAV_LANEGUIDANCE_ENTRIES;
                            }
                        }

                        if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
                        {
                            valid_startelement  =startelement;
                            valid_elements      =0;
                        }
                        else                                                                //found valid entry for startelement in array
                        {
                            //verify number of valid elements
                            if(BACKWARD==direction)                                            //backward-start
                            {
                                if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                                    valid_elements=1;
                            
                                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                                {
                                    for(i=valid_startelement;i>=0;i--)
                                    {
                                        if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                                else                                                        //enougth array-elements available
                                {
                                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                                    {
                                        if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                            }                                                                //backward-end
                            else                                                            //forward-start
                            {
                                if((valid_startelement+elements)>=NAV_LANEGUIDANCE_ENTRIES)
                                {
                                    for(i=valid_startelement;i<NAV_LANEGUIDANCE_ENTRIES;i++)
                                    {
                                        if(0!=gLaneGuidance_Pos[i])                            //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=NAV_LANEGUIDANCE_ENTRIES;
                                    }
                                }
                                else
                                {
                                    for(i=valid_startelement;i<(valid_startelement+elements);i++)
                                    {
                                        if(0!=gLaneGuidance_Pos[i])                            //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=NAV_LANEGUIDANCE_ENTRIES;
                                    }
                                }
                            }
                        }
                    }

                    //send StatusArray
                    //MR 76047 
                    if(!transSuppression)
                        LaneGuidance_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                   
                    
                   //Panel
                   putvalue(env_NaviSD_LG_ASGID,gLaneGuidance_ASGID);
                   putvalue(env_NaviSD_LG_TAID,gLaneGuidance_TAID);
                }
             break;
            
            case Error_IND:
                writelineEx(gError_Trace, 0, "FSG_NaviSD LaneGuidance_Indication: received error, errorcode:0x%x", Indication_array[3]);
            break;

            default:
                writelineEx(gError_Trace, 0, "FSG_NaviSD LaneGuidance_Indication: invalid indication %d", Indication_array[2]);
             break;
    }
}

on envVar env_NaviSD_CompassInfo_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getValue(this))
    {
        gCI_Direction_Symbolic =getValue(env_NaviSD_Direction_Symbolik);
        gCI_Direction_Angle =getValue(env_NaviSD_Direction_Angle);
        
        CompassInfo_Request(Data_REQ,0); //send status
        putValue(this, 0);
    }
}

MagnetFieldZone_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataSetGet_IND:
                //get data
                gNaviSD_MFZone    =Indication_array[3];
                
                //Panel
                if(getvalue(env_NaviSD_MFZone_Error_on))
                    MagnetFieldZone_Request(Error_REQ, getvalue(env_NaviSD_MFZone_ErrorCode));
                    
                else
                {
                    if(gNaviSD_MFZone <0x10)
                    {
                        putvalue(env_NaviSD_MFZone_Zone_s,gNaviSD_MFZone_s[gNaviSD_MFZone]);
                        putvalue(env_NaviSD_MFZone_Zone_set,gNaviSD_MFZone);
                    
                        MagnetFieldZone_Request(Data_REQ, 0);
                    }
                    else
                    {
                        putvalue(env_NaviSD_MFZone_Zone_s,gstring_reserved);
                        MagnetFieldZone_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE);    //send error-message
                    }
                }
         break;

        case DataGet_IND:
                MagnetFieldZone_Request(Data_REQ, 0);                       //send status
         break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD MagnetFieldZone_Indication: invalid indication %d", Indication_array[2]);
         break;
    }
}

MagnetFieldZone_Request(byte request, byte errorcode)
{
    int  i, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;                //LSG-ID
    requestarray[1]=FctID_MagnetFieldZone;    //Fct.-ID
    requestarray[2]=request;                //request type

    switch(request)
    {
        case Data_REQ:
             //IssueList #62
            if (getValue(env_NaviSD_FctList_0x1A_TimeOut)!=TRUE)
            {                    
            requestarray[3] =gNaviSD_MFZone;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD MagnetFieldZone_Request: invalid request %d", request);
        break;
    }
}

on envVar env_NaviSD_MFZone_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getvalue(this))
    {
        gNaviSD_MFZone =getvalue(env_NaviSD_MFZone_Zone_set);

        putvalue(env_NaviSD_MFZone_Zone_s, gNaviSD_MFZone_s[gNaviSD_MFZone]);
        
        MagnetFieldZone_Request(Data_REQ, 0);
    }
}

Calibration_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataSetGet_IND:
                //get data
                gNaviSD_CalibrationState    =Indication_array[3];
                
                //Panel
                if(getvalue(env_NaviSD_CaliState_Error_on))
                    Calibration_Request(Error_REQ, getvalue(env_NaviSD_CaliState_ErrorCode));
                    
                else
                {    
                    if(gNaviSD_CalibrationState <0x03)
                    {
                        putvalue(env_NaviSD_CaliState_s,gNaviSD_CalibrationState_s[gNaviSD_CalibrationState]);
                        putvalue(env_NaviSD_CaliState_set,gNaviSD_CalibrationState);

                        Calibration_Request(Data_REQ, 0);
                    }
                    else if(gNaviSD_CalibrationState ==0xFF)
                    {
                        putvalue(env_NaviSD_CaliState_s,gstring_not_supported);
                        putvalue(env_NaviSD_CaliState_set,gNaviSD_CalibrationState);

                        Calibration_Request(Data_REQ, 0);
                    }
                    else
                    {
                        putvalue(env_NaviSD_CaliState_s,gstring_reserved);
                        Calibration_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE);    //send error-message
                    }
                }
         break;

        case DataGet_IND:
                Calibration_Request(Data_REQ, 0);                       //send status
         break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD Calibration_Indication: invalid indication %d", Indication_array[2]);
         break;
    }
}

Calibration_Request(byte request, byte errorcode)
{
    int  i, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;            //LSG-ID
    requestarray[1]=FctID_Calibration;    //Fct.-ID
    requestarray[2]=request;            //request type

    switch(request)
    {
        case Data_REQ:    
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x1B_TimeOut)!=TRUE)
            {                
            requestarray[3] =gNaviSD_CalibrationState;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD Calibration_Request: invalid request %d", request);
        break;
    }
}

on envVar env_NaviSD_TMCI_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getvalue(this))
    {
        gTMCinfo_MessageID                  =getvalue(env_NaviSD_TMCI_MessageID) &0x0f;
        gTMCinfo_MessageStatus              =getvalue(env_NaviSD_TMCI_MS);
        gTMCinfo_MessageWaitingIndication   =getvalue(env_NaviSD_TMCI_MessageWaitInd);
        gTMCinfo_Priority                   =getvalue(env_NaviSD_TMCI_Priority);
        getvalue(env_NaviSD_TMCI_StreetName, gTMCinfo_StreetName);
        getvalue(env_NaviSD_TMCI_Location, gTMCinfo_Location);
        getvalue(env_NaviSD_TMCI_Infotext, gTMCinfo_Infotext);
        gTMCinfo_Length_Validity            =getvalue(env_NaviSD_TMCI_Length_Validity);
        gTMCinfo_Length_Value               =getvalue(env_NaviSD_TMCI_Length_Value);
        gTMCinfo_Length_Unit                =getvalue(env_NaviSD_TMCI_Length_Unit);

        if(gTMCinfo_MessageStatus<0x04)
            putvalue(env_NaviSD_TMCI_MS_s, gTMCinfo_MessageStatus_s[gTMCinfo_MessageStatus]);
        else
            putvalue(env_NaviSD_TMCI_MS_s, gstring_reserved);
        
        putvalue(env_NaviSD_TMCI_MessageID, gTMCinfo_MessageID);
        
        TMCinfo_Request(Data_REQ,0);
    }

}

TMCinfo_Request(byte request, byte errorcode)
{
    int  i, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;        //LSG-ID
    requestarray[1]=FctID_TMCinfo;    //Fct.-ID
    requestarray[2]=request;        //request type

    switch(request)
    {
        case Data_REQ:    
        //IssueList #62
            if (getValue(env_NaviSD_FctList_0x19_TimeOut)!=TRUE)
            {                
                requestarray[3] =(gTMCinfo_MessageID &0x0f)*0x10 +(gTMCinfo_MessageStatus &0x0f);
                requestarray[4] =gTMCinfo_MessageWaitingIndication;
                requestarray[5] =gTMCinfo_Priority;
                Offset =6;
            
                //Streetname
                requestarray[Offset] =strlen(gTMCinfo_StreetName);
                Offset++;

                for(i=0;i<strlen(gTMCinfo_StreetName);i++)
                {
                    requestarray[Offset] =gTMCinfo_StreetName[i];
                    Offset++;
                }
            
                //Location
                requestarray[Offset] =strlen(gTMCinfo_Location);
                Offset++;

                for(i=0;i<strlen(gTMCinfo_Location);i++)
                {
                    requestarray[Offset] =gTMCinfo_Location[i];
                    Offset++;
                }

                //Infotext
                requestarray[Offset] =strlen(gTMCinfo_Infotext);
                Offset++;

                for(i=0;i<strlen(gTMCinfo_Infotext);i++)
                {
                    requestarray[Offset] =gTMCinfo_Infotext[i];
                    Offset++;
                }

                //Length_Validity
                requestarray[Offset] =gTMCinfo_Length_Validity;
                Offset++;

                //Length_Value
                requestarray[Offset] =gTMCinfo_Length_Value &0xff;
                Offset++;
                requestarray[Offset] =(gTMCinfo_Length_Value &0xff00) /0x100;
                Offset++;
                requestarray[Offset] =(gTMCinfo_Length_Value &0xff0000) /0x10000;
                Offset++;
                requestarray[Offset] =(gTMCinfo_Length_Value &0xff000000) /0x1000000;
                Offset++;

                //Length_Unit
                requestarray[Offset] =gTMCinfo_Length_Unit;
                Offset++;

                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD TMCinfo_Request: invalid request %d", request);
        break;
    }
}

TMCinfo_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataSetGet_IND:
                //get data
                gTMCinfo_MessageID      =(Indication_array[3] &0xf0) /0x10;
                gTMCinfo_MessageStatus  =Indication_array[3] &0x0f;
                gTMCinfo_Reserve1       =Indication_array[4];
                gTMCinfo_Reserve2       =Indication_array[5];
                
                //Panel
                putvalue(env_NaviSD_TMCI_MessageID,gTMCinfo_MessageID);

                if(getvalue(env_NaviSD_TMCI_Error_on))
                    TMCinfo_Request(Error_REQ, getvalue(env_NaviSD_TMCI_ErrorCode));
                    
                else
                {
                    if((gTMCinfo_MessageStatus <0x4) && (gTMCinfo_MessageStatus !=0x2))
                    {
                        putvalue(env_NaviSD_TMCI_MS_s,gTMCinfo_MessageStatus_s[gTMCinfo_MessageStatus]);
                        putvalue(env_NaviSD_TMCI_MS,gTMCinfo_MessageStatus);
                    
                        TMCinfo_Request(Data_REQ, 0);
                    }
                    else
                    {   
                        putvalue(env_NaviSD_TMCI_MS_s,gstring_reserved);
                        TMCinfo_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE);    //send error-message
                    }
                }
         break;

        case DataGet_IND:
                TMCinfo_Request(Data_REQ, 0);                       //send status
         break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD TMCinfo_Indication: invalid indication %d", Indication_array[2]);
         break;
    }
}

on envVar env_NaviSD_CaliState_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getvalue(this))
    {
        gNaviSD_CalibrationState    =getvalue(env_NaviSD_CaliState_set);
        
        if(gNaviSD_CalibrationState <0x03)
            putvalue(env_NaviSD_CaliState_s,gNaviSD_CalibrationState_s[gNaviSD_CalibrationState]);
               
        else if(gNaviSD_CalibrationState ==0xFF)
            putvalue(env_NaviSD_CaliState_s,gstring_not_supported);

        Calibration_Request(Data_REQ, 0);
    }
}

ASGcapabilities_Request(byte request, byte errorcode)
{
    int  i, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;                //LSG-ID
    requestarray[1]=FctID_ASGcapabilities;    //Fct.-ID
    requestarray[2]=request;                //request type

    switch(request)
    {
        case Data_REQ:
        //IssueList #62
            if (getValue(env_NaviSD_FctList_0x1C_TimeOut)!=TRUE)
            {                
            requestarray[3] =(gNaviSD_ASGcap_PresentationCapabilities *0x10) +gNaviSD_ASGcap_FurtherCapabilities;
            
            set_status_requestbuffer (requestarray, 4, Bap_ByteSequence);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "ASGcapabilities_Request Calibration_Request: invalid request %d", request);
        break;
    }
}

ASGcapabilities_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataSetGet_IND:
                //get data
                gNaviSD_ASGcap_PresentationCapabilities =(Indication_array[3] &0x10) /0x10; //Bit 1 evaluated
                gNaviSD_ASGcap_FurtherCapabilities      =Indication_array[3] &0x0f; 
                
                gNaviSD_ASGcap_PresentationCapabilities_bit0 =gNaviSD_ASGcap_PresentationCapabilities &0x1;
                                
                //Panel
                putvalue(env_NaviSD_ASGcap_Pres_s,gNaviSD_ASGcap_PresentationCapabilities_bit0_s[gNaviSD_ASGcap_PresentationCapabilities_bit0]);
                putvalue(env_NaviSD_ASGcap_Pres, gNaviSD_ASGcap_PresentationCapabilities_bit0);

                if(getvalue(env_NaviSD_ASGcap_Error_on))
                    ASGcapabilities_Request(Error_REQ, getvalue(env_NaviSD_ASGcap_ErrorCode));
                    
                else
                    ASGcapabilities_Request(Data_REQ, 0);
                    
         break;

        case DataGet_IND:
                ASGcapabilities_Request(Data_REQ, 0);                       //send status
         break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD ASGcapabilities_Indication: invalid indication %d", Indication_array[2]);
         break;
    }
}

on envVar env_NaviSD_ASGcap_Pres_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getvalue(this))
    {
        gNaviSD_ASGcap_PresentationCapabilities_bit0    =getvalue(env_NaviSD_ASGcap_Pres);

        gNaviSD_ASGcap_PresentationCapabilities         =gNaviSD_ASGcap_PresentationCapabilities_bit0;

        putvalue(env_NaviSD_ASGcap_Pres_s, gNaviSD_ASGcap_PresentationCapabilities_bit0_s[gNaviSD_ASGcap_PresentationCapabilities_bit0]);

        ASGcapabilities_Request(Data_REQ, 0);
    }
}

on timer StartFSG_Timer
{
    switch (gStartFSGTimer_handling)
    {
        case 1:
            CompassInfo_Request(Data_REQ, 0);           //send status
            CurrentPositionInfo_Request(Data_REQ, 0);   //send status 
            
            gStartFSGTimer_handling =2;
            settimer (StartFSG_Timer,3500);
        break;

        case 2:
            gFSG_OperationState =NAV_OPSTATE_NORMAL;            
            putvalue(env_NaviSD_FSG_OP_State,gFSG_OperationState);
            
            FSG_OperationState_Request(Data_REQ, 0);    //send status

            gStartFSGTimer_handling =0;
        break;

        default:
        break;
    }   
}

//IssueList #216 15S1 update 17.01.2014
on message BAP_Navigation_ASG_03
{
    int i, error;
    byte RX_Data[8];        //received CAN-DATA
    dword RX_Header[3];        //received CAN-Header

    RX_Header[0]=this.CAN; 
    RX_Header[1]=this.ID; 
    RX_Header[2]=this.DLC; // received length
    
    // extract CAN data                                                                        
    for (i=0; i<this.DLC; i++)                                                         
        RX_Data[i]=this.byte(i);          
            
    //send received CAN-data with CAN-header to BAP-DLL
    error =Bap170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    
    if(error !=0)
        write("FSG-NaviSD: BAP_CAN_SetRxData: %d", error);
}

//IssueList #216 15S1 update 17.01.2014
/*on message BAP_Navigation2_ASG_01
{
    int i, error;
    byte RX_Data[8];        //received CAN-DATA
    dword RX_Header[3];        //received CAN-Header

    RX_Header[0]=this.CAN; 
    RX_Header[1]=this.ID; 
    RX_Header[2]=this.DLC; // received length
    
    // extract CAN data                                                                        
    for (i=0; i<this.DLC; i++)                                                         
        RX_Data[i]=this.byte(i);          
            
    //send received CAN-data with CAN-header to BAP-DLL
    error =Bap170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    
    if(error !=0)
        write("FSG-NaviSD: BAP_CAN_SetRxData: %d", error);
}*/

//IssueList #216 15S1 update 17.01.2014
on message BAP_Navigation_ASG_04
{
    int i, error;
    byte RX_Data[8];        //received CAN-DATA
    dword RX_Header[3];        //received CAN-Header

    RX_Header[0]=this.CAN; 
    RX_Header[1]=this.ID; 
    RX_Header[2]=this.DLC; // received length
    
    // extract CAN data                                                                        
    for (i=0; i<this.DLC; i++)                                                         
        RX_Data[i]=this.byte(i);          
            
    //send received CAN-data with CAN-header to BAP-DLL
    error =Bap170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    
    if(error !=0)
        write("FSG-NaviSD: BAP_CAN_SetRxData: %d", error);
}

on message BAP_Navigation_ASG_01 // ASG BAP-message
{
    int i, error;
    byte RX_Data[8];        //received CAN-DATA
    dword RX_Header[3];        //received CAN-Header

    RX_Header[0]=this.CAN; 
    RX_Header[1]=this.ID; 
    RX_Header[2]=this.DLC; // received length
    
   
    // extract CAN data                                                                        
    for (i=0; i<this.DLC; i++)                                                         
    {    RX_Data[i]=this.byte(i);
    }      
            
    //send received CAN-data with CAN-header to BAP-DLL
    //IssueList #159 - start
        //temp=BAP170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    
        switch ((RX_Data[1] & 0x0F))
        {
        //getAll
        case 1: //error
                if (getValue(env_FSG_NaviSD_GetAll_ErrEn)==0x01)
                Request_error(FctID_GetAll,getValue(env_FSG_NaviSD_GetAll_ErrCode)); 
                
                else if (getValue(env_FSG_NaviSD_GetAll_FctEn) == 0x01)
                error=BAP170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 2: //error
                if (getValue(env_BAPCFG_FSG_NaviSD_ErrEn)==0x01)
                Request_error(FctID_BAP_Config,getValue(env_BAPCFG_FSG_NaviSD_ErrCode)); 

                 else if (getValue(env_BAPCFG_FSG_NaviSD_FctEn) == 0x01)
                error=BAP170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 3: //error
                if (getValue(env_FSG_NaviSD_FctList_ErrEn)==0x01)
                Request_error(FctID_FunctionList,getValue(env_FSG_NaviSD_FctList_ErrCode)); 
                
                else if (getValue(env_FSG_NaviSD_FctList_FctEn) == 0x01)
                error=BAP170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);
                break;
             
        
        default: error=BAP170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    //send recieved CAN-data with CAN-header to BAP-DLL
                break;
        }
        //IssueList #159 - end
    
    if(error !=0)
        write("FSG_NaviSD-NaviSD: BAP_CAN_SetRxData: %d", error);   
}

on message BAP_Navigation_ASG_02    // ASG BAP-message
{
    int i, error;
    byte RX_Data[8];        //received CAN-DATA
    dword RX_Header[3];        //received CAN-Header

    RX_Header[0]=this.CAN; 
    RX_Header[1]=this.ID; 
    RX_Header[2]=this.DLC; // received length
    
    // extract CAN data                                                                        
    for (i=0; i<this.DLC; i++)                                                         
        RX_Data[i]=this.byte(i);          
            
    //send received CAN-data with CAN-header to BAP-DLL
    error =BAP170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    
    if(error !=0)
        write("FSG-NaviSD: BAP_CAN_SetRxData: %d", error);   
}

DistanceToDestination_Indication (dword Indication_array [], int datalength)
{    
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                DistanceToDestination_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD DistanceToDestination_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

TimeToDestination_Indication (dword Indication_array [], int datalength)
{    
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                TimeToDestination_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD TimeToDestination_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

DistanceToDestination_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                        //LSG-ID
    requestarray[1] =FctID_DistanceToDestination;    //Fct.-ID
    requestarray[2] =request;                        //request type

    switch(request)
    {
        case Data_REQ:
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x15_TimeOut)!=TRUE)
            {                
            requestarray[3] =gDTD_Distance & 0xff;
            requestarray[4] =(gDTD_Distance & 0xff00)/0x100;
            requestarray[5] =(gDTD_Distance & 0xff0000)/0x10000;
            requestarray[6] =(gDTD_Distance & 0xff000000)/0x1000000;
            requestarray[7] =gDTD_Unit;
            //MR 76047 
            requestarray[8] =gDTD_ValidityInformation | (gDTD_DTDType << 4);
                        
            set_status_requestbuffer (requestarray, 9, Bap_ByteSequence);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "NaviSD DistanceToDestination_Request: invalid request %d", request);
        break;
    }    
}

TimeToDestination_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                //LSG-ID
    requestarray[1] =FctID_TimeToDestination;   //Fct.-ID
    requestarray[2] =request;                   //request type

    switch(request)
    {
        case Data_REQ:
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x16_TimeOut)!=TRUE)
            {                                
            requestarray[3] =(gTTD_TimeInfoType *0x10) +gTTD_NavigationTimeFormat;
            requestarray[4] =gTTD_Minute;
            requestarray[5] =gTTD_Hour;
            requestarray[6] =gTTD_Day;
            requestarray[7] =gTTD_Month;
            requestarray[8] =gTTD_Year;
            requestarray[9] =gTTD_ValidityInformation;
            
            
            set_status_requestbuffer (requestarray, 10, Bap_ByteSequence);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "NaviSD TimeToDestination_Request: invalid request %d", request);
        break;
    }    
}

Fct_initSendBuf (char description[], dword Cache_Request_Header[], byte Cache_Request_Data[])
{
    byte error = BAP_ERR_OK;
    
    error = BAP170_InitSendBuf(NODE_INDEX, Cache_Request_Header, Cache_Request_Data);
    
    if(error != BAP_ERR_OK)
        write("Fct_initSendBuf %s errorcode: 0x%x", description, error);
}

on timer Powerontimer
{   
    gNaviSD_PowerOnOff =TRUE;

    settimer(TaskTimer, 10);    //start BAP-DLL-Timer
}

on envVar env_NaviSD_PowerOnOff
{
    int length, error;


    if(getvalue(this) ==1)
    {
        //BAP-Init, FSG NaviSD
        if(gBAP_Init ==FALSE)
        {
            gBAP_Init =TRUE;
                                        
            error =BAP170_Init(NODE_INDEX,LSG_NaviSD);
             
            // Check for initialisation error.
            if(error ==BAP_ERR_OK)
                write("FSG-NaviSD BAP_Init successful");
            
            else
                writelineEx(gError_Trace, 0,"FSG-NaviSD error BAP_Init: 0x%x", error);
        }

        //initialize variables
        init_variables();                            
        
        // init data for bapconfig message.
        initBapConfig();    

        //initialize arrays
        LaneGuidance_init_static();
        //LastDestList_init_static();
        putValue(env_NaviSD_BAP_Shortlist,1);
        //putValue(env_Navi_LaneGuidanceList_Short,1);
        FavoriteDestList_init_static();
        NavBook_init_static();
        AddressList_init_static();

        //initialize Cache
        BAP_Set_Cache();                            
                
        //BAP-Start
        error =BAP170_Start(NODE_INDEX,LSG_NaviSD);
        
        if(error ==BAP_ERR_OK)
            write("FSG-NaviSD BAP_Start successful");
        
        else
            writelineEx(gError_Trace, 0,"FSG-NaviSD error BAP_Start: 0x%x", error);
    
        // set global variable
        gNaviSD_PowerOnOff = getvalue(env_NaviSD_PowerOnOff);
    
        settimer(Powerontimer, 20);

        gStartFSGTimer_handling =1;
        settimer(StartFSG_Timer,1000);
    }
    else // Must be a shutdown.
    {
        // Set global variable.
        gNaviSD_PowerOnOff =getvalue(this);
        
        BAP170_Shutdown(NODE_INDEX,LSG_NaviSD);
        
        Shutdown_NaviSD();
    }
}/* end of method */

on envVar env_NaviSD_TTD_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getValue(this))
    {    
        gTTD_TimeInfoType =getValue(env_NaviSD_TTD_TimeInfoType);
        gTTD_NavigationTimeFormat =getValue(env_NaviSD_TTD_NavigationTF);
        gTTD_Minute =getValue(env_NaviSD_TTD_Minute);
        gTTD_Hour =getValue(env_NaviSD_TTD_Hour);
        gTTD_Day =getValue(env_NaviSD_TTD_Day);
        gTTD_Month =getValue(env_NaviSD_TTD_Month);
        gTTD_Year =getValue(env_NaviSD_TTD_Year);

        //IssueList #119
        //gTTD_ValidityInformation =getValue(env_NaviSD_TTD_Minute_VI)*0x02 +getValue(env_NaviSD_TTD_Hour_VI)*0x04 +getValue(env_NaviSD_TTD_Day_VI)*0x08 +getValue(env_NaviSD_TTD_Month_VI)*0x10 +getValue(env_NaviSD_TTD_Year_VI)*0x20;
        gTTD_ValidityInformation = getValue(env_NaviSD_TTD_VI_Disp);    
        TimeToDestination_Request(Data_REQ,0);     
    }    
}

on envVar env_NaviSD_PrefDeLis_Type_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getvalue(this))
    {
        gNaviSD_PrefDestList_ListType =getvalue(env_NaviSD_PrefDeLis_Type);
        
        PreferredDestList_Request(Data_REQ,0);
    }
    putValue(this,0);
}

PreferredDestList_Indication (dword Indication_array [], int datalength)
{    
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                PreferredDestList_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD PreferredDestList_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

PreferredDestList_Request(byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;                    //LSG-ID
    requestarray[1]=FctID_PreferredDestList;    //Fct.-ID
    requestarray[2]=request;                    //request type

    switch(request)
    {
        case Data_REQ:
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x1F_TimeOut)!=TRUE)
            {                    
            requestarray[3] =gNaviSD_PrefDestList_ListType;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD FSG_OperationState_Request: invalid request %d", request);
        break;
    }
}

VoiceGuidance_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataSetGet_IND:
                //get data
                gNaviSD_VoiceGuidance_State    =Indication_array[3];
                
                //Panel
                if(getvalue(env_NaviSD_VG_Error_on))
                    VoiceGuidance_Request(Error_REQ, getvalue(env_NaviSD_VG_ErrorCode));
                    
                else
                {
                    if(gNaviSD_VoiceGuidance_State <0x03)
                    {
                        putvalue(env_NaviSD_VG_State_s,gNaviSD_VoiceGuidance_State_s[gNaviSD_VoiceGuidance_State]);
                        putvalue(env_NaviSD_VG_State,gNaviSD_VoiceGuidance_State);
                
                        VoiceGuidance_Request(Data_REQ, 0);
                    }
                    else
                    {
                        putvalue(env_NaviSD_VG_State_s,gstring_reserved);
                        VoiceGuidance_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE);    //send error-message
                    }
                }
         break;

        case DataGet_IND:
                VoiceGuidance_Request(Data_REQ, 0);                       //send status
         break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD VoiceGuidance_Indication: invalid indication %d", Indication_array[2]);
         break;
    }
}

VoiceGuidance_Request(byte request, byte errorcode)
{
    int  i, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;                //LSG-ID
    requestarray[1]=FctID_VoiceGiudance;    //Fct.-ID
    requestarray[2]=request;                //request type

    switch(request)
    {
        case Data_REQ:
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x24_TimeOut)!=TRUE)
            {                    
            requestarray[3] =gNaviSD_VoiceGuidance_State;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD VoiceGuidance_Request: invalid request %d", request);
        break;
    }
}

on envVar env_NaviSD_VG_State_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getvalue(this))
    {
        gNaviSD_VoiceGuidance_State =getvalue(env_NaviSD_VG_State);

        //IssueList #216 15S1 update 17.01.2014
    //if(gNaviSD_VoiceGuidance_State <0x03)
    if(gNaviSD_VoiceGuidance_State <0x04)
            putvalue(env_NaviSD_VG_State_s, gNaviSD_VoiceGuidance_State_s[gNaviSD_VoiceGuidance_State]);
        else
            putvalue(env_NaviSD_VG_State_s, gstring_reserved);
        
        VoiceGuidance_Request(Data_REQ, 0);
    }
}

FunctionSynchronisation_Request (byte request, byte errorcode)
{
    int  i, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                    //LSG-ID
    requestarray[1] =FctID_FunctionSynchronisation;    //Fct.-ID
    requestarray[2] =request;                       //request type

    switch(request)
    {
        case Data_REQ:
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x25_TimeOut)!=TRUE)
            {
                Offset =3;

                for(i=0 ;i<8; i++)                
                {
                    requestarray[Offset] =gNaviSD_FunctionSynchronisation_FctList[i];
                    Offset++;
                }            

                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD FunctionSynchronisation_Request: invalid request %d", request);
        break;
    }
}

on envVar env_NaviSD_FctSync_update
{
    int i=0;
    
    //get data
    gNaviSD_FunctionSynchronisation_FctList_Bit16  =getvalue(env_NaviSD_FctSync_Bit16_CI);
    gNaviSD_FunctionSynchronisation_FctList_Bit17  =getvalue(env_NaviSD_FctSync_Bit17_RGS);
    gNaviSD_FunctionSynchronisation_FctList_Bit18  =getvalue(env_NaviSD_FctSync_Bit18_DTNM);
    gNaviSD_FunctionSynchronisation_FctList_Bit19  =getvalue(env_NaviSD_FctSync_Bit19_CPI);
    gNaviSD_FunctionSynchronisation_FctList_Bit20  =getvalue(env_NaviSD_FctSync_Bit20_TTI);
    gNaviSD_FunctionSynchronisation_FctList_Bit21  =getvalue(env_NaviSD_FctSync_Bit21_DTD);
    gNaviSD_FunctionSynchronisation_FctList_Bit22  =getvalue(env_NaviSD_FctSync_Bit22_TTD);
    gNaviSD_FunctionSynchronisation_FctList_Bit23  =getvalue(env_NaviSD_FctSync_Bit23_MD);
    gNaviSD_FunctionSynchronisation_FctList_Bit24  =getvalue(env_NaviSD_FctSync_Bit24_LG);
    gNaviSD_FunctionSynchronisation_FctList_Bit25  =getvalue(env_NaviSD_FctSync_Bit25_TMCI);
    gNaviSD_FunctionSynchronisation_FctList_Bit26  =getvalue(env_NaviSD_FctSync_Bit26_MFZ);
    gNaviSD_FunctionSynchronisation_FctList_Bit27  =getvalue(env_NaviSD_FctSync_Bit27_Cal);
    gNaviSD_FunctionSynchronisation_FctList_Bit29  =getvalue(env_NaviSD_FctSync_Bit29_LDList);
    gNaviSD_FunctionSynchronisation_FctList_Bit30  =getvalue(env_NaviSD_FctSync_Bit30_FaList);
    gNaviSD_FunctionSynchronisation_FctList_Bit31  =getvalue(env_NaviSD_FctSync_Bit31_PrList);
    gNaviSD_FunctionSynchronisation_FctList_Bit32  =getvalue(env_NaviSD_FctSync_Bit32_NavB);
    gNaviSD_FunctionSynchronisation_FctList_Bit33  =getvalue(env_NaviSD_FctSync_Bit33_AL);
    gNaviSD_FunctionSynchronisation_FctList_Bit34  =getvalue(env_NaviSD_FctSync_Bit34_RGL);
    gNaviSD_FunctionSynchronisation_FctList_Bit36  =getvalue(env_NaviSD_FctSync_Bit36_VG);
    gNaviSD_FunctionSynchronisation_FctList_Bit38  =getvalue(env_NaviSD_FctSync_Bit38_IS);
    gNaviSD_FunctionSynchronisation_FctList_Bit39  =getvalue(env_NaviSD_FctSync_Bit39_AGRT);
    gNaviSD_FunctionSynchronisation_FctList_Bit40  =getvalue(env_NaviSD_FctSync_Bit40_TBI);

    //clear
    for(i=0;i<8;i++) 
        gNaviSD_FunctionSynchronisation_FctList[i] =0;
    
    //Byte 2
    gNaviSD_FunctionSynchronisation_FctList[2] =gNaviSD_FunctionSynchronisation_FctList_Bit23;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit22 *0x02;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit21 *0x04;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit20 *0x08;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit19 *0x10;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit18 *0x20;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit17 *0x40;
    gNaviSD_FunctionSynchronisation_FctList[2] +=gNaviSD_FunctionSynchronisation_FctList_Bit16 *0x80;

    //Byte 3
    gNaviSD_FunctionSynchronisation_FctList[3] =gNaviSD_FunctionSynchronisation_FctList_Bit31;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit30 *0x02;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit29 *0x04;
    gNaviSD_FunctionSynchronisation_FctList[3] +=0                                             *0x08;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit27 *0x10;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit26 *0x20;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit25 *0x40;
    gNaviSD_FunctionSynchronisation_FctList[3] +=gNaviSD_FunctionSynchronisation_FctList_Bit24 *0x80;

    //Byte 4
    gNaviSD_FunctionSynchronisation_FctList[4] =gNaviSD_FunctionSynchronisation_FctList_Bit39;
    gNaviSD_FunctionSynchronisation_FctList[4] +=gNaviSD_FunctionSynchronisation_FctList_Bit38 *0x02;
    gNaviSD_FunctionSynchronisation_FctList[4] +=0                                             *0x04;
    gNaviSD_FunctionSynchronisation_FctList[4] +=gNaviSD_FunctionSynchronisation_FctList_Bit36 *0x08;
    gNaviSD_FunctionSynchronisation_FctList[4] +=0                                             *0x10;
    gNaviSD_FunctionSynchronisation_FctList[4] +=gNaviSD_FunctionSynchronisation_FctList_Bit34 *0x20;
    gNaviSD_FunctionSynchronisation_FctList[4] +=gNaviSD_FunctionSynchronisation_FctList_Bit33 *0x40;
    gNaviSD_FunctionSynchronisation_FctList[4] +=gNaviSD_FunctionSynchronisation_FctList_Bit32 *0x80;

    //Byte 5
    gNaviSD_FunctionSynchronisation_FctList[5] =0;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x02;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x04;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x08;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x10;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x20;
    gNaviSD_FunctionSynchronisation_FctList[5] =0                                             *0x40;
    gNaviSD_FunctionSynchronisation_FctList[5] =gNaviSD_FunctionSynchronisation_FctList_Bit40 *0x80;
    
    FunctionSynchronisation_Request(Data_REQ, 0);
}

FunctionSynchronisation_Indication (dword Indication_array [], int datalength)
{    
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                FunctionSynchronisation_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD FunctionSynchronisation_Indication: invalid indication %d", Indication_array[2]);
        break;
    }
}

on envVar env_NaviSD_InfoStates_update
{
    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        gNAV_InfoStates =getvalue(env_NaviSD_InfoStates_states);
        
        InfoStates_Request(Data_REQ, 0);
    }
}

InfoStates_Indication(dword Indication_array [], int datalength)
{    
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                InfoStates_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD InfoStates_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

InfoStates_Request(byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;        //LSG-ID
    requestarray[1] =FctID_InfoStates;    //Fct.-ID
    requestarray[2] =request;           //request type

    switch(request)
    {
        case Data_REQ:    
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x26_TimeOut)!=TRUE)
            {            
            requestarray[3] =gNAV_InfoStates;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD InfoStates_Request: invalid request %d", request);
        break;
    }
}

on envVar env_NaviSD_ActRGTy_RGType_update
{
    if(POWER_ON==gNaviSD_PowerOnOff && getvalue(this))
    {
        gNAV_ActiveRgType_RGType =getvalue(env_NaviSD_ActRGTy_RGType);
    
    //IssueList #216 15S1 update 17.01.2014
        //if(gNAV_ActiveRgType_RGType <0x3)
    if(gNAV_ActiveRgType_RGType <0x4)
            putvalue(env_NaviSD_ActRGTy_RGType_s, gNAV_ActiveRgType_RGType_s[gNAV_ActiveRgType_RGType]);
        else if(gNAV_ActiveRgType_RGType ==0xFF)
            putvalue(env_NaviSD_ActRGTy_RGType_s, gNAV_ActiveRgType_RGType_0xFF_s);
        
        ActiveRgType_Request(Data_REQ, 0);
    }
}

ActiveRgType_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataSetGet_IND:
                //get data
                gNAV_ActiveRgType_RGType    =Indication_array[3];
                
                //Panel
                if(getvalue(env_NaviSD_ActRGTy_Error_on))
                    ActiveRgType_Request(Error_REQ, getvalue(env_NaviSD_ActRGTy_ErrorCode));
                    
                else
                {
                    //IssueList #216 15S1 update 17.01.2014
                    //if(gNAV_ActiveRgType_RGType <0x03)
                    //MR 76047
                    if(gNAV_ActiveRgType_RGType <0x06)
                    {
                        putvalue(env_NaviSD_ActRGTy_RGType_s,gNAV_ActiveRgType_RGType_s[gNAV_ActiveRgType_RGType]);
                        putvalue(env_NaviSD_ActRGTy_RGType,gNAV_ActiveRgType_RGType);
                        ActiveRgType_Request(Data_REQ, 0);
                    }
                    else if(gNAV_ActiveRgType_RGType ==0xFF)
                    {
                        putvalue(env_NaviSD_ActRGTy_RGType_s,gNAV_ActiveRgType_RGType_0xFF_s);
                        putvalue(env_NaviSD_ActRGTy_RGType,gNAV_ActiveRgType_RGType);
                        ActiveRgType_Request(Data_REQ, 0);
                    }
                    else 
                    {
                        putvalue(env_NaviSD_ActRGTy_RGType_s,gstring_reserved);
                        ActiveRgType_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE);    //send error-message
                    }
                }
         break;

        case DataGet_IND:
                ActiveRgType_Request(Data_REQ, 0);                      //send status
         break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD ActiveRgType_Indication: invalid indication %d", Indication_array[2]);
         break;
    }
}

ActiveRgType_Request(byte request, byte errorcode)
{
    int  i, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;            //LSG-ID
    requestarray[1]=FctID_ActiveRgType;    //Fct.-ID
    requestarray[2]=request;            //request type

    switch(request)
    {
        case Data_REQ:
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x27_TimeOut)!=TRUE)
            {                
            requestarray[3] =gNAV_ActiveRgType_RGType;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD ActiveRgType_Request: invalid request %d", request);
        break;
    }
}

TrafficBlock_Ind_Indication(dword Indication_array [], int datalength)
{    
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                TrafficBlock_Ind_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD TrafficBlock_Ind_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

TrafficBlock_Ind_Request(byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                    //LSG-ID
    requestarray[1] =FctID_TrafficBlock_Indication;    //Fct.-ID
    requestarray[2] =request;                       //request type

    switch(request)
    {
        case Data_REQ:
            //IssueList #62
            if (getValue(env_NaviSD_FctList_0x28_TimeOut)!=TRUE)
            {                
            requestarray[3] =gNAV_TrafficBlock_Ind_TMCSymbol;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD TrafficBlock_Ind_Request: invalid request %d", request);
        break;
    }
}

on envVar env_NaviSD_TBInd_TMCSym_update
{
    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        gNAV_TrafficBlock_Ind_TMCSymbol =getvalue(env_NaviSD_TBInd_TMCSym);
        
        TrafficBlock_Ind_Request(Data_REQ, 0);
    }
}

on envVar env_NaviSD_RGActDeact_Result
{
    if (POWER_ON==gNaviSD_PowerOnOff && getValue(this))
    {
        gNav_RG_ActDeact_Result =getValue(env_NaviSD_RGActDeact_Res);
    
        //putvalue(env_NaviSD_RGActDeact_CoTy_s, gNav_RGActDeact_ControlType_s [gNav_RGActDeact_ControlType]);
        //putvalue(env_NaviSD_RGActDeact_CITy_s, gNav_RGActDeact_CI_Type_s [gNav_RGActDeact_CI_Type]);
        //gNav_RGActDeact_ControlInformation =getValue(env_NaviSD_RGActDeact_CIInfo);
        //gDTNM_ValidityInformation =getValue(env_NaviSD_DTNM_ValidityInfo);
        
        RGActDeact_Request(Result_REQ, 0);                                        //send result-message 
    }    
}

RGActDeact_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                    //LSG-ID
    requestarray[1] =FctID_RG_ActDeact;                //Fct.-ID
    requestarray[2] =request;
    
    switch(request)
    {
        case Processing_REQ:        
            requestarray[3] =0;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
        break;
        case Result_REQ:
            //IssueList #68
            if (gNaviFctList_0x22_Processing_flg == 0x00)
            {
            requestarray[3] =gNav_RG_ActDeact_Result;
            
            //IssueList #38
            //if (gNav_RG_ActDeact_Result == NAV_RGACTDEACT_SUCCESSFUL)
            //{
                set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            //}
            }

        break;
        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
            
            //IssueList #68
            cancelTimer(gNaviFctList_0x22_ProcessingTimer);
        break;
        default:    //error
            writelineEx(gError_Trace, 0, "NaviSD RGActDeact_Request: unknown request %d", request);
        break;
    }
}

RGActDeact_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2])
    {
        case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_NaviSD_RGActDeact_ErrorCode) ==0x00)||(getValue(env_NaviSD_RGActDeact_ErrorCode) > 0x3F)) && (gNaviFctList_0x22_TimeOut == 0x00))
             {
             RGActDeact_Request(Processing_REQ, 0);                                    //send Processing
                
               //IssueList #68
                if (gNaviFctList_0x22_Processing_flg==0x01)
                {
                  if (isTimerActive(gNaviFctList_0x22_ProcessingTimer) == 0x00)
                  setTimer(gNaviFctList_0x22_ProcessingTimer,NAVIMAXPROCESSINGTIME);

                RGActDeact_Request(Processing_REQ, 0);
                }
             }
        break;
        
        case StartResult_IND:
            //IssueList #74
            if (getValue(env_NaviSD_FctList_0x22_TimeOut)!=TRUE)
            {
            gNaviFctList_0x22_TimeOut = 0x00;
                 //IssueList #57
                if (getValue(env_NaviSD_RGActDeact_Error_on)==0x00)
                putValue(env_NaviSD_RGActDeact_ErrorCode,0);
                
                
                if(getvalue(env_NaviSD_RGActDeact_Error_on))
                    RGActDeact_Request(Error_REQ, getvalue(env_NaviSD_RGActDeact_ErrorCode));

                else
                {
                    //IssueList #216 15S1 update 17.01.2014
                    //if((Indication_array[3] &0xF0) >0x10 || (Indication_array[3] &0x0F) >0x05)
                    //VAGH-12498 - Navi AU: RGActDeact always changes to 01 when Business Address is selected
                    if((Indication_array[3] &0xF0) >0x50 || (Indication_array[3] &0x0F) >0x08)                                        //invalid BAP-data
                    {
                        gNav_RG_ActDeact_Result =NAV_RGACTDEACT_NOTSUCCESSFUL;
                        putvalue(env_NaviSD_RGActDeact_Res, gNav_RG_ActDeact_Result);
                
                        RGActDeact_Request(Result_REQ, 0);                                        //send result-message 
                    }            
                    else                                                                        //start method                                        
                    {    
                        if(TRUE ==gNav_RGActDeact_Status)                                            //if method already active
                            settimer(RGActDeact_Timer, gNav_RG_ActDeact_TimerTime);                    //retrigger method
                
                        else
                        {                       
                            gNav_RGActDeact_Status =TRUE;                                            //method active
                   
                            gNav_RGActDeact_ControlType            =(Indication_array[3] &0xF0) /0x10;
                            gNav_RGActDeact_CI_Type                =Indication_array[3] &0x0F;
                            gNav_RGActDeact_ControlInformation     =Indication_array[4];
                            gNav_RGActDeact_ControlInformation     +=Indication_array[5] *0x100;
        
                            gNav_RG_ActDeact_MethodHandling =1;
                            settimer(RGActDeact_MethodHandling_Timer, gNav_RG_ActDeact_MethodHandling_Time);
                            settimer(RGActDeact_Timer, gNav_RG_ActDeact_TimerTime);
                        }
                    }
                }
              } //IssueList #74
            else
            gNaviFctList_0x22_TimeOut = 0x01;
            break;
        
            case Abort_IND:
                if(getvalue(env_NaviSD_RGActDeact_Error_on))
                {
                    RGActDeact_Request(Error_REQ, getvalue(env_NaviSD_RGActDeact_ErrorCode));
                }
                else
                {                           
                    if(TRUE !=gNav_RGActDeact_Status)                                    //method not active
                    {                    
                        RGActDeact_Request(Error_REQ, 0x50);            //send error-message
                        gNav_RG_ActDeact_Result =NAV_RGACTDEACT_ABORT_NOT_SUCCESSFUL;
                        putvalue(env_NaviSD_RGActDeact_AbortRes, NAV_RGACTDEACT_ABORT_NOT_SUCCESSFUL);
                                                
                        RGActDeact_Request(Result_REQ, 0);                                    //send result-message
                    }
                    else if(TRUE ==gNav_RGActDeact_Status)                                        //method still active
                    {                
                        gNav_RG_ActDeact_Result =getvalue(env_NaviSD_RGActDeact_AbortRes);

                        if(NAV_RGACTDEACT_ABORT_SUCCESSFUL ==gNav_RG_ActDeact_Result)        //only, if abort is successfull
                        {
                            canceltimer(RGActDeact_Timer);                                //abort method
                            gNav_RGActDeact_Status =0;                                        //method finished
                        }

                        RGActDeact_Request(Result_REQ, 0);                                //send result-message                
                    }
                }

        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD RGActDeact_Indication: unknown indication %d", Indication_array[2]);
        break;
        }
}

on timer RGActDeact_Timer
{
    gNav_RG_ActDeact_Result =getvalue(env_NaviSD_RGActDeact_Res);

        //IssueList #216 15S1 update 17.01.2014
    /*if (gNav_RG_ActDeact_Result !=NAV_RGACTDEACT_NOTSUCCESSFUL 
        && gNav_RG_ActDeact_Result !=NAV_RGACTDEACT_NOTSUCCESSFUL_CI_NOT_MATCH 
            && gNav_RG_ActDeact_Result !=NAV_RGACTDEACT_NOTSUCCESSFUL_DEST_ADDR_REFINED 
            && gNav_RGActDeact_Status ==TRUE)  */  
    if ( gNav_RG_ActDeact_Result !=NAV_RGACTDEACT_NOTSUCCESSFUL_HOME_ADDR_NOT_SPEC 
        && gNav_RG_ActDeact_Result !=NAV_RGACTDEACT_NOTSUCCESSFUL_SEL_ROUTE_FSG 
        && gNav_RG_ActDeact_Result !=NAV_RGACTDEACT_NOTSUCCESSFUL_SEL_HOME_ADDR_FSG 
        && gNav_RG_ActDeact_Result !=NAV_RGACTDEACT_NOTSUCCESSFUL_NO_NAV_DATA 
        && gNav_RG_ActDeact_Result !=NAV_RGACTDEACT_NOTSUCCESSFUL 
        && gNav_RG_ActDeact_Result !=NAV_RGACTDEACT_NOTSUCCESSFUL_CI_NOT_MATCH 
        && gNav_RG_ActDeact_Result !=NAV_RGACTDEACT_NOTSUCCESSFUL_DEST_ADDR_REFINED 
        && gNav_RGActDeact_Status ==TRUE)    
        {
            putvalue(env_NaviSD_RGActDeact_CoTy_s, gNav_RGActDeact_ControlType_s [gNav_RGActDeact_ControlType]);
            putvalue(env_NaviSD_RGActDeact_CITy_s, gNav_RGActDeact_CI_Type_s [gNav_RGActDeact_CI_Type]);
            putvalue(env_NaviSD_RGActDeact_CIInfo, gNav_RGActDeact_ControlInformation);                  
        }
     
    RGActDeact_Request(Result_REQ, 0); //send Result

    gNav_RGActDeact_Status =FALSE; //method not active    
}

RepeatLastNavAnnouncement_Indication (dword Indication_array [], int datalength)
{
switch (Indication_array[2])
    {
        case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_NaviSD_RepeatLastNavAnn_ErrC) ==0x00)||(getValue(env_NaviSD_RepeatLastNavAnn_ErrC) > 0x3F)) &&  (gNaviFctList_0x23_TimeOut == 0x00))
             {
             RepeatLastNavAnnouncement_Request(Processing_REQ, 0);                    //send Processing
               
                //IssueList #68
                if (gNaviFctList_0x23_Processing_flg==0x01)
                {
                  if (isTimerActive(gNaviFctList_0x23_ProcessingTimer) == 0x00)
                  setTimer(gNaviFctList_0x23_ProcessingTimer,NAVIMAXPROCESSINGTIME);

                RepeatLastNavAnnouncement_Request(Processing_REQ, 0);
                }
             }
        break;
        
        case StartResult_IND:
        //IssueList #74
            if (getValue(env_NaviSD_FctList_0x23_TimeOut)!=TRUE)
            { 
            gNaviFctList_0x23_TimeOut = 0x00;
                //IssueList #57
                if (getValue(env_NaviSD_RepeatLastNavAnn_Err)==0x00)
                putValue(env_NaviSD_RepeatLastNavAnn_ErrC,0);
                
                if(getvalue(env_NaviSD_RepeatLastNavAnn_Err))
                    RepeatLastNavAnnouncement_Request(Error_REQ, getvalue(env_NaviSD_RepeatLastNavAnn_ErrC));

                else
                {
                    if(TRUE ==gNav_RepeatLastNavAnn_Status)                                    //if method already active
                        settimer(RepeatLastNavAnn_Timer, gNav_RepeatLastNavAnn_TimerTime);    //retrigger method
                
                    else
                    {   
                        gNav_RepeatLastNavAnn_Status =TRUE;                                //method active
                   
                        settimer(RepeatLastNavAnn_Timer, gNav_RepeatLastNavAnn_TimerTime);
                    }
                }
            } //IssueList #74
            else
            gNaviFctList_0x23_TimeOut = 0x01;
        break;
        
        case Abort_IND:
            if(getvalue(env_NaviSD_RepeatLastNavAnn_Err))
                RepeatLastNavAnnouncement_Request(Error_REQ, getvalue(env_NaviSD_RepeatLastNavAnn_ErrC));

            else
            {
                if(TRUE !=gNav_RepeatLastNavAnn_Status)                                //method not active                    
                    RepeatLastNavAnnouncement_Request(Error_REQ, 0x50);            //send error-message
            
                else if(TRUE !=gNav_RepeatLastNavAnn_Status)                            //method not active
                {    
                    gNav_RepeatLastNavAnn_Result =NAV_REPEATLASTNAVANN_SUCCESSFUL;
                    putvalue(env_NaviSD_RepeatLastNavAnn_Abo, NAV_REPEATLASTNAVANN_ABORT_NOT_SUCCESSFUL);
                                                
                    RepeatLastNavAnnouncement_Request(Result_REQ, 0);                    //send result-message
                }
                else if(TRUE ==gNav_RepeatLastNavAnn_Status)                                        //method still active
                {            
                    gNav_RepeatLastNavAnn_Result =getvalue(env_NaviSD_RepeatLastNavAnn_Abo);

                    if(NAV_REPEATLASTNAVANN_ABORT_SUCCESSFUL ==gNav_RepeatLastNavAnn_Result)        //only, if abort is successfull
                    {
                        canceltimer(RepeatLastNavAnn_Timer);                            //abort method
                        gNav_RepeatLastNavAnn_Status =0;                                //method finished
                    }

                    RepeatLastNavAnnouncement_Request(Result_REQ, 0);                    //send result-message                
                }
            }
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD RepeatLastNavAnnouncement_Indication: unknown indication %d", Indication_array[2]);
        break;
        }
}

RepeatLastNavAnnouncement_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                        //LSG-ID
    requestarray[1] =FctID_RepeatLastNavAnnouncement;   //Fct.-ID
    requestarray[2] =request;
    
    switch(request)
    {
        case Processing_REQ:        
            requestarray[3] =0;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
        break;
        case Result_REQ:
         //IssueList #68
            if (gNaviFctList_0x23_Processing_flg == 0x00)
            {
            requestarray[3] =gNav_RepeatLastNavAnn_Result;
            
            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            }
        break;
        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
            
            //IssueList #68
            cancelTimer(gNaviFctList_0x23_ProcessingTimer);
        break;
        default:    //error
            writelineEx(gError_Trace, 0, "NaviSD RepeatLastNavAnnouncement_Request: unknown request %d", request);
        break;
    }
}

on timer RepeatLastNavAnn_Timer
{
    gNav_RepeatLastNavAnn_Result =getvalue(env_NaviSD_RepeatLastNavAnn_Res);
     
    RepeatLastNavAnnouncement_Request(Result_REQ, 0); //send Result

    gNav_RepeatLastNavAnn_Status =FALSE; //method not active    
}

GetNextListPos_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2])
    {
        case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_NaviSD_GetNextLiPos_ErrorCo) ==0x00)||(getValue(env_NaviSD_GetNextLiPos_ErrorCo) > 0x3F)) && gNaviFctList_0x29_TimeOut == 0x00)
             {
             GetNextListPos_Request(Processing_REQ, 0);                                    //send Processing
                
                //IssueList #68
                if (gNaviFctList_0x29_Processing_flg==0x01)
                {
                  if (isTimerActive(gNaviFctList_0x29_ProcessingTimer) == 0x00)
                  setTimer(gNaviFctList_0x29_ProcessingTimer,NAVIMAXPROCESSINGTIME);

                GetNextListPos_Request(Processing_REQ, 0);
                }
             }
        break;
        
        case StartResult_IND: 
            //IssueList #74
            if (getValue(env_NaviSD_FctList_0x29_TimeOut)!=TRUE)
            {
            gNaviFctList_0x29_TimeOut = 0x00;
                //IssueList #57
                if (getValue(env_NaviSD_GetNextLiPos_Error_on)==0x00)
                putValue(env_NaviSD_GetNextLiPos_ErrorCo,0);
                
                if(getvalue(env_NaviSD_GetNextLiPos_Error_on))
                    GetNextListPos_Request(Error_REQ, getvalue(env_NaviSD_GetNextLiPos_ErrorCo));

                else
                {
                    if(Indication_array[7] >0x3)                                            //invalid BAP-data
                    {
                        gNav_GetNextListPos_Result =NAV_RGACTDEACT_NOTSUCCESSFUL;
                        putvalue(env_NaviSD_GetNextLiPos_Result, gNav_GetNextListPos_Result);
                
                        GetNextListPos_Request(Result_REQ, 0);                                    //send result-message 
                    }            
                    else                                                                        //start method                                        
                    {    
                        if(TRUE ==gNav_GetNextListPos_Status)                                        //if method already active
                            settimer(GetNextListPos_Timer, gNav_GetNextListPos_TimerTime);            //retrigger method
                
                        else
                        {   
                            gNav_GetNextListPos_Status =TRUE;                                        //method active
                   
                            gNav_GetNextListPos_currentPos  =Indication_array[3] &0xFF;
                            gNav_GetNextListPos_currentPos  +=Indication_array[4] *0x100;
                            gNav_GetNextListPos_Offset      =Indication_array[5] &0xFF;
                            gNav_GetNextListPos_Offset      +=Indication_array[6] *0x100;
                            gNav_GetNextListPos_ListType    =Indication_array[7];

                            settimer(GetNextListPos_Timer, gNav_GetNextListPos_TimerTime);
                        }   
                    }
                }
            } //IssueList #74
            else
            gNaviFctList_0x29_TimeOut = 0x01;

        break;
        
        case Abort_IND: 
            if(getvalue(env_NaviSD_GetNextLiPos_Error_on))
                GetNextListPos_Request(Error_REQ, getvalue(env_NaviSD_GetNextLiPos_ErrorCo));

            else
            {
                if(TRUE !=gNav_GetNextListPos_Status)                                //method not active                    
                    GetNextListPos_Request(Error_REQ, 0x50);            //send error-message
            
                else if(TRUE !=gNav_GetNextListPos_Status)                            //method not active
                {    
                    gNav_GetNextListPos_Result =NAV_GETNEXTLISTPOS_ABORT_NOT_SUCCESSFUL;
                    putvalue(env_NaviSD_GetNextLiPos_Abort, NAV_GETNEXTLISTPOS_ABORT_NOT_SUCCESSFUL);
                                                
                    GetNextListPos_Request(Result_REQ, 0);                                    //send result-message
                }
                else if(TRUE ==gNav_GetNextListPos_Status)                                    //method still active
                {                
                    gNav_GetNextListPos_Result =getvalue(env_NaviSD_GetNextLiPos_Abort);

                    if(NAV_GETNEXTLISTPOS_ABORT_SUCCESSFUL ==gNav_GetNextListPos_Result)        //only, if abort is successfull
                    {
                        canceltimer(GetNextListPos_Timer);                                    //abort method
                        gNav_GetNextListPos_Status =0;                                        //method finished
                    }

                    GetNextListPos_Request(Result_REQ, 0);                                //send result-message                
                }
            }
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD GetNextListPos_Indication: unknown indication %d", Indication_array[2]);
        break;
        }
}

GetNextListPos_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                    //LSG-ID
    requestarray[1] =FctID_GetNextListPos;            //Fct.-ID
    requestarray[2] =request;
    
    switch(request)
    {
        case Processing_REQ:        
            requestarray[3] =0;
            
            set_status_requestbuffer (requestarray, 4, Bap_ByteSequence);
        break;
        case Result_REQ:
             //IssueList #68
            if (gNaviFctList_0x29_Processing_flg == 0x00)
            {
            requestarray[3] =gNav_GetNextListPos_Result;
            requestarray[4] =gNav_GetNextListPos_currentPos &0xFF;
            requestarray[5] =(gNav_GetNextListPos_currentPos &0xFF00) /0x100;
            requestarray[6] =gNav_GetNextListPos_nextPos &0xFF;
            requestarray[7] =(gNav_GetNextListPos_nextPos &0xFF00) /0x100;
            requestarray[8] =gNav_GetNextListPos_absListPos &0xFF;
            requestarray[9] =(gNav_GetNextListPos_absListPos &0xFF00) /0x100;
            
            set_status_requestbuffer (requestarray, 10, Bap_ByteSequence);
            }
        break;
        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);

            //IssueList #68
            cancelTimer(gNaviFctList_0x29_ProcessingTimer);
        break;
        default:    //error
            writelineEx(gError_Trace, 0, "NaviSD GetNextListPos_Request: unknown request %d", request);
        break;
    }
}

on timer GetNextListPos_Timer
{
    gNav_GetNextListPos_Result =getvalue(env_NaviSD_GetNextLiPos_Result);

        if (gNav_GetNextListPos_Result !=NAV_GETNEXTLISTPOS_NOT_SUCCESSFUL && gNav_GetNextListPos_Status ==TRUE)    
        {
            putvalue(env_NaviSD_GetNextLiPos_CuPos, gNav_GetNextListPos_currentPos);
            putvalue(env_NaviSD_GetNextLiPos_Offset, gNav_GetNextListPos_Offset);
            putvalue(env_NaviSD_GetNextLiPos_LiTy_s, gNav_GetNextListPos_ListType_s[gNav_GetNextListPos_ListType]);                  
            gNav_GetNextListPos_nextPos     =getvalue(env_NaviSD_GetNextLiPos_NePos);
            gNav_GetNextListPos_absListPos  =getvalue(env_NaviSD_GetNextLiPos_AbsPos);
        }
     
    GetNextListPos_Request(Result_REQ, 0); //send Result

    gNav_GetNextListPos_Status =FALSE; //method not active    
}

NbSpeller_Indication (dword Indication_array [], int datalength)
{
    int i=0, Offset =0;

    switch (Indication_array[2])
    {
        case Processing_CNF:
            //IssueList #57  and #74
           if (((getValue(env_NaviSD_NbSpeller_ErrorCode) ==0x00)||(getValue(env_NaviSD_NbSpeller_ErrorCode) > 0x3F)) &&  (gNaviFctList_0x2A_TimeOut == 0x00))
             {
             NbSpeller_Request(Processing_REQ, 0);                                        //send Processing
                
                //IssueList #68
                if (gNaviFctList_0x2A_Processing_flg==0x01)
                {
                  if (isTimerActive(gNaviFctList_0x2A_ProcessingTimer) == 0x00)
                  setTimer(gNaviFctList_0x2A_ProcessingTimer,NAVIMAXPROCESSINGTIME);

                NbSpeller_Request(Processing_REQ, 0);
                }
             }
        break;
        
        case StartResult_IND: 
            //IssueList #74
            if (getValue(env_NaviSD_FctList_0x2A_TimeOut)!=TRUE)
            {
            gNaviFctList_0x2A_TimeOut = 0x00;
                //IssueList #57
                if (getValue(env_NaviSD_NbSpeller_Error_on)==0x00)
                putValue(env_NaviSD_NbSpeller_ErrorCode,0);
                
                if(getvalue(env_NaviSD_NbSpeller_Error_on))
                    NbSpeller_Request(Error_REQ, getvalue(env_NaviSD_NbSpeller_ErrorCode));

                else
                {
                    if(Indication_array[3] >0x2)                                            //invalid BAP-data
                    {
                        gNav_NbSpeller_Result =NAV_NBSPELLER_NOT_SUCCESSFUL;
                        putvalue(env_NaviSD_NbSpeller_Result, gNav_NbSpeller_Result);
                
                        NbSpeller_Request(Result_REQ, 0);                                        //send result-message 
                    }            
                    else                                                                        //start method                                        
                    {    
                        if(TRUE ==gNav_NbSpeller_Status)                                        //if method already active
                            settimer(NbSpeller_Timer, gNav_NbSpeller_TimerTime);                //retrigger method
                
                        else
                        {   
                            gNav_NbSpeller_Status =TRUE;                                        //method active
                   
                            gNav_NbSpeller_Mode         =Indication_array[3];
                    
                            for(i=0;i<NAV_SEARCHSTRING_LENGTH;i++) //clear
                                gNav_NbSpeller_SearchString[i]  =0;
                    
                            Offset =5;
                            for (i=0; i<Indication_array[4]; i++)
                            {
                                gNav_NbSpeller_SearchString[i] =Indication_array[Offset];
                                Offset++;
                            }

                            settimer(NbSpeller_Timer, gNav_NbSpeller_TimerTime);
                        }
                    }
                }
            } //IssueList #74
            else
            gNaviFctList_0x2A_TimeOut = 0x01;
        break;
        
        case Abort_IND:
            if(getvalue(env_NaviSD_NbSpeller_Error_on))
                NbSpeller_Request(Error_REQ, getvalue(env_NaviSD_NbSpeller_ErrorCode));

            else
            {
                if(TRUE !=gNav_NbSpeller_Status)                                //method not active                    
                    NbSpeller_Request(Error_REQ, 0x50);            //send error-message
            
                else if(TRUE !=gNav_NbSpeller_Status)                                    //method not active
                {    
                    gNav_NbSpeller_Result =NAV_NBSPELLER_ABORT_NOT_SUCCESSFUL;
                    putvalue(env_NaviSD_NbSpeller_Abort, NAV_NBSPELLER_ABORT_NOT_SUCCESSFUL);
                                                
                    NbSpeller_Request(Result_REQ, 0);                                    //send result-message
                }
                else if(TRUE ==gNav_NbSpeller_Status)                                    //method still active
                {                
                    gNav_NbSpeller_Result =getvalue(env_NaviSD_NbSpeller_Abort);

                    if(NAV_NBSPELLER_ABORT_SUCCESSFUL ==gNav_NbSpeller_Result)            //only, if abort is successfull
                    {
                        canceltimer(NbSpeller_Timer);                                    //abort method
                        gNav_NbSpeller_Status =0;                                        //method finished
                    }

                    NbSpeller_Request(Result_REQ, 0);                                    //send result-message                
                }
            }
        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD NbSpeller_Indication: unknown indication %d", Indication_array[2]);
        break;
        }
}

NbSpeller_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;        //LSG-ID
    requestarray[1] =FctID_NbSpeller;   //Fct.-ID
    requestarray[2] =request;
    
    switch(request)
    {
        case Processing_REQ:        
            requestarray[3] =0;
            
            set_status_requestbuffer (requestarray, 4, Bap_ByteSequence);
        break;
        case Result_REQ:
         //IssueList #68
            if (gNaviFctList_0x2A_Processing_flg == 0x00)
            {
            requestarray[3] =gNav_NbSpeller_Result;
            requestarray[4] =gNav_NbSpeller_MatchingEntries &0xFF;
            requestarray[5] =(gNav_NbSpeller_MatchingEntries &0xFF00) /0x100;
            requestarray[6] =gNav_NbSpeller_Pos &0xFF;
            requestarray[7] =(gNav_NbSpeller_Pos &0xFF00) /0x100;

            set_status_requestbuffer (requestarray, 8, Bap_ByteSequence);
            }
        break;
        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
            
            //IssueList #68
            cancelTimer(gNaviFctList_0x2A_ProcessingTimer);
        break;
        default:    //error
            writelineEx(gError_Trace, 0, "NaviSD NbSpeller_Request: unknown request %d", request);
        break;
    }
}

on timer NbSpeller_Timer
{
    gNav_NbSpeller_Result =getvalue(env_NaviSD_NbSpeller_Result);

        if (gNav_NbSpeller_Result !=NAV_NBSPELLER_NOT_SUCCESSFUL && gNav_NbSpeller_Status ==TRUE)    
        {
            putvalue(env_NaviSD_NbSpeller_Mode_s, gNav_NbSpeller_Mode_s[gNav_NbSpeller_Mode]);
            putvalue(env_NaviSD_NbSpeller_SearchStr_s, gNav_NbSpeller_SearchString);
                              
            gNav_NbSpeller_MatchingEntries  =getvalue(env_NaviSD_NbSpeller_MatchEntr);
            gNav_NbSpeller_Pos              =getvalue(env_NaviSD_NbSpeller_Pos);
        }
     
    NbSpeller_Request(Result_REQ, 0); //send Result

    gNav_NbSpeller_Status =FALSE; //method not active  
}

//Updates from J.Karl 07.11.2013
MapColorAndType_Indication(dword Indication_array [], int datalength)
{    
  write("-> MapColorAndType_Indication");
    switch (Indication_array[2]) // indication
    {
        //IssueList #216 15S1 update 17.01.2014 - start
        case DataSetGet_IND:
                //get data
                gMCAT_Cact         =Indication_array[3];
                gMCAT_AMTact       =Indication_array[4];
                gMCAT_MMSact       =Indication_array[5];
                gMCAT_SMT          =Indication_array[6];

                putValue(env_NaviSD_MapCAT_AMTHex, gMCAT_AMTact);
                putValue(env_NaviSD_MapCAT_ColorHex, gMCAT_Cact);
                putValue(env_NaviSD_MapCAT_MMSHex, gMCAT_MMSact);
                putValue(env_NaviSD_MapCAT_AMT, gMCAT_AMTact);
                putValue(env_NaviSD_MapCAT_Color,gMCAT_Cact);
                putValue(env_NaviSD_MapCAT_MMS,gMCAT_MMSact);

                 MapColorAndType_Request(Data_REQ, 0);                       //send status
        break;
        //IssueList #216 15S1 update 17.01.2014 - end
        
        case DataGet_IND:
                MapColorAndType_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD MapColorAndType_Indication: invalid indication %d", Indication_array[2]);
        break;
    }
}

//Updates from J.Karl 07.11.2013
MapColorAndType_Request(byte request, byte errorcode)
{
    int  i;
  dword requestarray [BAP_BUFFER_SIZE];
  
  write("-> MapColorAndType_Request");

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                    //LSG-ID
    requestarray[1] =FctID_MapColorAndType_Indication;    //Fct.-ID
    requestarray[2] =request;                       //request type

    switch(request)
    {
        case Data_REQ:
            if (getValue(env_NaviSD_FctList_0x2B_TimeOut)!=TRUE)
            {                
            //IssueList #216 15S1 update 17.01.2014
            //requestarray[3] =gNAV_TrafficBlock_Ind_TMCSymbol;
            //set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            gMCAT_SMT = getValue(env_NaviSD_MapCAT_SMT0);
            gMCAT_SMT += getValue(env_NaviSD_MapCAT_SMT1) <<1;
            gMCAT_SMT += getValue(env_NaviSD_MapCAT_SMT2) <<2;
            gMCAT_SMT += getValue(env_NaviSD_MapCAT_SMT3) <<3;
            gMCAT_SMT += getValue(env_NaviSD_MapCAT_SMT4) <<4;
            gMCAT_SMT += getValue(env_NaviSD_MapCAT_SMT5) <<5;

            requestarray[3] = gMCAT_Cact;
            requestarray[4] = gMCAT_AMTact;
            requestarray[5] = gMCAT_MMSact;
            requestarray[6] = gMCAT_SMT;
            set_status_requestbuffer (requestarray, 7, Bap_ByteSequence);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD MapColorAndType_Request: invalid request %d", request);
        break;
    }
}

//Updates from J.Karl 07.11.2013
MapViewAndOrientation_Indication(dword Indication_array [], int datalength)
{    
   //IssueList #216 15S1 update 17.01.2014
   int tempReserved1,tempReserved2,tempReserved3;
   write("-> MapViewAndOrientation_Indication");
    switch (Indication_array[2]) // indication
    {
        //IssueList #216 15S1 update 17.01.2014 -start
        case DataSetGet_IND:
                //get data
                putValue(env_NaviSD_MapVAO_MapVHex , Indication_array[3]);
                putValue(env_NaviSD_MapVAO_MapV, Indication_array[3]);
                putValue(env_NaviSD_MapVAO_SMVHex,Indication_array[4]);
                putValue(env_NaviSD_MapVAO_SMV , Indication_array[4]);
                tempReserved1                       = Indication_array[5];
                tempReserved2                       = Indication_array[6];
                putValue(env_NaviSD_MapVAO_MV0,Indication_array[7]& 00000001);
                putValue(env_NaviSD_MapVAO_MV1 , (Indication_array[7]& 00000010) >>1);
                putValue(env_NaviSD_MapVAO_MOHex,Indication_array[8]);
                putValue(env_NaviSD_MapVAO_MO,Indication_array[8]);
                tempReserved3                       = Indication_array[9];
                gMVAO_MVact = Indication_array[3];
                gMVAO_SMVact = Indication_array[4];
                gMVAO_SMVsact = Indication_array[5];
                gMVAO_SSMVact = Indication_array[6];
                gMVAO_MVisact = Indication_array[7];
                gMVAO_MOact = Indication_array[8];
                gMVAO_Modact = Indication_array[9];
                
                MapViewAndOrientation_Request(Data_REQ, 0);    //send status
            break;
                //IssueList #216 15S1 update 17.01.2014 -end

        case DataGet_IND:
                MapViewAndOrientation_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD MapViewAndOrientation_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

//Updates from J.Karl 07.11.2013
MapViewAndOrientation_Request(byte request, byte errorcode)
{
    int  i;
  dword requestarray [BAP_BUFFER_SIZE];
  
  write("-> MapViewAndOrientation_Request");

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                    //LSG-ID
    requestarray[1] =FctID_MapViewAndOrientation_Indication;    //Fct.-ID
    requestarray[2] =request;                       //request type

    switch(request)
    {
        case Data_REQ:
            if (getValue(env_NaviSD_FctList_0x2C_TimeOut)!=TRUE)
            {    
            //IssueList #216 15S1 update 17.01.2014 -start
            //?    requestarray[3] =gNAV_TrafficBlock_Ind_TMCSymbol;
            //set_status_requestbuffer (requestarray, 4, Bap_UInt8);
                gMVAO_SMVsact  = getValue(env_NaviSD_MapVAO_SuppoMVs0);
                gMVAO_SMVsact += getValue(env_NaviSD_MapVAO_SuppoMVs1) <<1;
                gMVAO_SMVsact += getValue(env_NaviSD_MapVAO_SuppoMVs2) <<2;
                gMVAO_MVisact  = getValue(env_NaviSD_MapVAO_MV0); 
                gMVAO_MVisact += getValue(env_NaviSD_MapVAO_MV1) <<1;
                gMVAO_SSMVact  = getValue(env_NaviSD_MapVAO_SSMV0);
                gMVAO_SSMVact += getValue(env_NaviSD_MapVAO_SSMV1) <<1;
                gMVAO_SSMVact += getValue(env_NaviSD_MapVAO_SSMV2) <<2;
                gMVAO_Modact   = getValue(env_NaviSD_MapVAO_M0);


                requestarray[3] = gMVAO_MVact;
                requestarray[4] = gMVAO_SMVact; 
                requestarray[5] = gMVAO_SMVsact;
                requestarray[6] = gMVAO_SSMVact;
                requestarray[7] = gMVAO_MVisact;
                requestarray[8] = gMVAO_MOact;
                requestarray[9] = gMVAO_Modact;

                set_status_requestbuffer (requestarray, 10, Bap_ByteSequence);
            //IssueList #216 15S1 update 17.01.2014 -end
            
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD MapViewAndOrientation_Request: invalid request %d", request);
        break;
    }
}

//Updates from J.Karl 07.11.2013
MapScale_Indication(dword Indication_array [], int datalength)
{    
    //IssueList #216 15S1 update 17.01.2014
    int tempReserved2,tempReserved3,tempReserved4;
    
    write("-> MapScale_Indication");
    switch (Indication_array[2]) // indication
    {
        //IssueList #216 15S1 update 17.01.2014    -start
         case DataSetGet_IND:
                //get data
                putValue(env_NaviSD_MapS_Steps, Indication_array[3]);
                putValue(env_NaviSD_MapS_AutoZoomHex, Indication_array[4] /0x10);
                putValue(env_NaviSD_MapS_AZSBit0,Indication_array[4] &00000001);
                tempReserved2                           = Indication_array[5];
                tempReserved2                          += Indication_array[6];
                tempReserved3                           = Indication_array[7];
                tempReserved4                           = Indication_array[8];

                 MapScale_Request(Data_REQ, 0);                       //send status

         break;
        //IssueList #216 15S1 update 17.01.2014    -end
        case DataGet_IND:
                MapScale_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD MapScale_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

//Updates from J.Karl 07.11.2013
MapScale_Request(byte request, byte errorcode)
{
    int  i, tempReserved1, Offset =0;;
  dword requestarray [BAP_BUFFER_SIZE];
  
  write("-> MapScale_Request");

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                    //LSG-ID
    requestarray[1] =FctID_MapScale_Indication;    //Fct.-ID
    requestarray[2] =request;                       //request type

    switch(request)
    {
        case Data_REQ:
            if (getValue(env_NaviSD_FctList_0x2D_TimeOut)!=TRUE)
            {                
            //?    requestarray[3] =gNAV_TrafficBlock_Ind_TMCSymbol;
            //set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            //IssueList #216 15S1 update 17.01.2014 - start
                requestarray[3] = tempReserved1;
                requestarray[4] = getValue(env_NaviSD_MapS_AutoZoomHex) <<4;
                requestarray[4]+= getValue(env_NaviSD_MapS_AZSBit0);
                requestarray[5] = getValue(env_NaviSD_MapS_Scale) & 0xFF;
                requestarray[6] = (getValue(env_NaviSD_MapS_Scale) >> 8) & 0xFF;
                requestarray[7] = getValue(env_NaviSD_MapS_UnitHex);
                requestarray[8] = getValue(env_NaviSD_MapS_SAZBit0);

            set_status_requestbuffer (requestarray, 9, Bap_ByteSequence);
            //IssueList #216 15S1 update 17.01.2014 - end
        break;
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD MapScale_Request: invalid request %d", request);
        break;
    }
}

//Updates from J.Karl 07.11.2013
DestinationInfo_Indication(dword Indication_array [], int datalength)
{    
  write("-> DestinationInfo_Indication");
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                DestinationInfo_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD DestinationInfo_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

//Updates from J.Karl 07.11.2013
DestinationInfo_Request(byte request, byte errorcode)
{
    int  i,tempReserved1, Offset =0;;
  dword requestarray [BAP_BUFFER_SIZE];
  
  write("-> DestinationInfo_Request");

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                    //LSG-ID
    requestarray[1] =FctID_DestinationInfo_Indication;    //Fct.-ID
    requestarray[2] =request;                       //request type

    switch(request)
    {
        case Data_REQ:
            if (getValue(env_NaviSD_FctList_0x2E_TimeOut)!=TRUE)
            {
                //IssueList #216 15S1 update 17.01.2014    -start            
                //?requestarray[3] =gNAV_TrafficBlock_Ind_TMCSymbol;
                //set_status_requestbuffer (requestarray, 4, Bap_UInt8);
                getValue(env_NaviSD_DI_POIDes, gDI_POIDes); 
                getValue(env_NaviSD_DI_Street, gDI_Street); 
                getValue(env_NaviSD_DI_Town,   gDI_Town); 
                getValue(env_NaviSD_DI_State,  gDI_State); 
                getValue(env_NaviSD_DI_PostCod,gDI_PostalC); 
                getValue(env_NaviSD_DI_Country,gDI_Country);
                
                putValue(env_NaviSD_DestInfo_POI_DescH ,0);
                for(i=0;i<strlen(gDI_POIDes);i++)
                    {
                        putValue(env_NaviSD_DestInfo_POI_DescH, getvalue(env_NaviSD_DestInfo_POI_DescH)+ gDI_POIDes[i]);
                        putValue(env_NaviSD_DestInfo_POI_DescH, getValue(env_NaviSD_DestInfo_POI_DescH) <<8);
                    }
                /* putValue(env_NaviSD_DestInfo_StreetHex = gDI_Street;
                putValue(env_NaviSD_DestInfo_TownHex = gDI_Town;
                putValue(env_NaviSD_DestInfo_StateHex = gDI_State;
                putValue(env_NaviSD_DestInfo_PostalCodeHex = gDI_PostalC;
                putValue(env_NaviSD_DestInfo_CountryHex = gDI_Country;*/
                
                requestarray[3] = (getValue(env_NaviSD_DestInfo_Latitude) >> 0)  & 255; 
                requestarray[4] = (getValue(env_NaviSD_DestInfo_Latitude) >> 8)  & 255; 
                requestarray[5] = (getValue(env_NaviSD_DestInfo_Latitude) >> 16) & 255; 
                requestarray[6] = (getValue(env_NaviSD_DestInfo_Latitude) >> 24) & 255; 

                requestarray[7] = (getValue(env_NaviSD_DestInfo_Longitude) >>0)  & 255;
                requestarray[8] = (getValue(env_NaviSD_DestInfo_Longitude) >>8)  & 255;
                requestarray[9] = (getValue(env_NaviSD_DestInfo_Longitude) >>16) & 255;
                requestarray[10] = (getValue(env_NaviSD_DestInfo_Longitude) >>24) & 255;
                requestarray[11] = getValue(env_NaviSD_DestInfo_TotalNumOS);
                requestarray[12] = getValue(env_NaviSD_DestInfo_StopO_SN); 
                requestarray[13] = getValue(env_NaviSD_DestInfo_POI_TypeHex);
                //POIDestination
                requestarray[14] =strlen(gDI_POIDes);
                Offset=15;

                for(i=0;i<strlen(gDI_POIDes);i++)
                {
                     requestarray[Offset]=gDI_POIDes[i];    
                     Offset++;
                }            
                //Street
                requestarray[Offset] =strlen(gDI_Street);
                Offset++;
                for(i=0;i<strlen(gDI_Street);i++)
                {
                     requestarray[Offset]=gDI_Street[i];    
                     Offset++;
                }
                //Town
                requestarray[Offset] =strlen(gDI_Town);
                Offset++;
                for(i=0;i<strlen(gDI_Town);i++)
                {
                     requestarray[Offset]=gDI_Town[i];    
                     Offset++;
                }
                //State
                requestarray[Offset] =strlen(gDI_State);
                Offset++;
                for(i=0;i<strlen(gDI_State);i++)
                {
                     requestarray[Offset]=gDI_State[i];    
                     Offset++;
                }
                //PostalCode
                requestarray[Offset] =strlen(gDI_PostalC);
                Offset++;
                for(i=0;i<strlen(gDI_PostalC);i++)
                {
                     requestarray[Offset]=gDI_PostalC[i];    
                     Offset++;
                }
                //Country
                requestarray[Offset] =strlen(gDI_Country);
                Offset++;
                for(i=0;i<strlen(gDI_Country);i++)
                {
                     requestarray[Offset]=gDI_Country[i];    
                     Offset++;
                }

            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            //IssueList #216 15S1 update 17.01.2014    -end
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD DestinationInfo_Request: invalid request %d", request);
        break;
    }
}

//Updates from J.Karl 07.11.2013
Altitude_Indication(dword Indication_array [], int datalength)
{    
  write("-> Altitude_Indication");
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                Altitude_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD Altitude_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

//Updates from J.Karl 07.11.2013
Altitude_Request(byte request, byte errorcode)
{
    int  i,tempReserved1, Offset =0;;
  dword requestarray [BAP_BUFFER_SIZE];
  
  write("-> Altitude_Request");

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                    //LSG-ID
    requestarray[1] =FctID_Altitude_Indication;    //Fct.-ID
    requestarray[2] =request;                       //request type

    switch(request)
    {
        case Data_REQ:
            if (getValue(env_NaviSD_FctList_0x2F_TimeOut)!=TRUE)
            {        
                //IssueList #216 15S1 update 17.01.2014            
                //?requestarray[3] =gNAV_TrafficBlock_Ind_TMCSymbol;
                //set_status_requestbuffer (requestarray, 4, Bap_UInt8);
                
                //Correction from J.Karl 18.04.2014
                //requestarray[3] = (getValue(env_NaviSD_Altitude_Altitude) >>8) & 255;
                //requestarray[4] = (getValue(env_NaviSD_Altitude_Altitude) >>0) & 255;
                requestarray[3] = (getValue(env_NaviSD_Altitude_Altitude) >>0) & 255;
                requestarray[4] = (getValue(env_NaviSD_Altitude_Altitude) >>8) & 255;
                requestarray[5] = getValue(env_NaviSD_Altitude_Unit); 
            set_status_requestbuffer (requestarray, 6, Bap_ByteSequence);
            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD Altitude_Request: invalid request %d", request);
        break;
    }
}

//Updates from J.Karl 07.11.2013
SemidynamicRouteGuidance_Indication(dword Indication_array [], int datalength)
{    
  write("-> SemidynamicRouteGuidance_Indication");
    switch (Indication_array[2]) // indication
    {
        case DataGet_IND:
                SemidynamicRouteGuidance_Request(Data_REQ, 0);    //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD SemidynamicRouteGuidance_Indication: invalid indication %d", Indication_array[2]);
        break;
    }

}

//Updates from J.Karl 07.11.2013
SemidynamicRouteGuidance_Request(byte request, byte errorcode)
{
    int  i,tempReserved1, Offset =0;;
  dword requestarray [BAP_BUFFER_SIZE];
  
  write("-> SemidynamicRouteGuidance_Request");

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                    //LSG-ID
    requestarray[1] =FctID_SemidynamicRouteGuidance_Indication;    //Fct.-ID
    requestarray[2] =request;                       //request type

    switch(request)
    {
        case Data_REQ:
            if (getValue(env_NaviSD_FctList_0x32_TimeOut)!=TRUE)
            {                
            //?requestarray[3] =gNAV_TrafficBlock_Ind_TMCSymbol;
            //set_status_requestbuffer (requestarray, 4, Bap_UInt8);
            requestarray[3] = getValue(env_NaviSD_SemidRG_TI0) + (getValue(env_NaviSD_SemidRG_TI1) <<1);
            requestarray[4] = getValue(env_NaviSD_SemidRG_Delay_minute);
            requestarray[5] = getValue(env_NaviSD_SemidRG_Delay_hour);
            requestarray[6] = getValue(env_NaviSD_SemidRG_NewDTD_distance) >>24;
            requestarray[7] = getValue(env_NaviSD_SemidRG_NewDTD_distance) >>16;
            requestarray[8] = getValue(env_NaviSD_SemidRG_NewDTD_distance) >>8;
            requestarray[9] = getValue(env_NaviSD_SemidRG_NewDTD_distance) ;
            requestarray[10] = getValue(env_NaviSD_SemidRG_NewDTD_unitH);
            requestarray[11] = getValue(env_NaviSD_SemidRG_NewDTD_typeH);
            requestarray[12] = getValue(env_NaviSD_SemidRG_NewTTD_TITHex)<<4;
            requestarray[12]+= getValue(env_NaviSD_SemidRG_NewTTD_NTFHex);// & 11111111;
            requestarray[13] = getValue(env_NaviSD_SemidRG_NewTTD_Min);
            requestarray[14] = getValue(env_NaviSD_SemidRG_NewTTD_Hour);
            requestarray[15] = getValue(env_NaviSD_SemidRG_NewTTD_Day);
            requestarray[16] = getValue(env_NaviSD_SemidRG_NewTTD_Month);
            requestarray[17] = getValue(env_NaviSD_SemidRG_NewTTD_Year);
            requestarray[18] = getValue(env_NaviSD_SemidRG_VI5) <<5;
            requestarray[18]+= getValue(env_NaviSD_SemidRG_VI4) <<4;
            requestarray[18]+= getValue(env_NaviSD_SemidRG_VI3) <<3;
            requestarray[18]+= getValue(env_NaviSD_SemidRG_VI2) <<2;
            requestarray[18]+= getValue(env_NaviSD_SemidRG_VI1) <<1;
            requestarray[18]+= getValue(env_NaviSD_SemidRG_VI0);



            set_status_requestbuffer (requestarray, 19, Bap_ByteSequence);

            }
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD SemidynamicRouteGuidance_Request: invalid request %d", request);
        break;
    }
}

LaneGuidance_init_static()
{
    byte j, i, LaneGuidanceEntry;
    
    //clear
    LaneGuidanceEntry       =0;
    gLaneGuidanceLine_sum  =0;
    
    for(j=0;j<NAV_LANEGUIDANCE_ENTRIES;j++) 
    {
        gLaneGuidance_Pos[j]                        =0;
        gLaneGuidance_LaneDirection[j]              =0;
        gLaneGuidance_LaneType[j]                   =0;
        gLaneGuidance_LaneMarking_right[j]          =0;
        gLaneGuidance_LaneMarking_left[j]           =0;
        gLaneGuidance_LaneDescription[j]            =0;
        gLaneGuidance_GuidanceInfo[j]               =0;
        gLaneGuidance_ListEntryValidInformation[j]  =0;

        for(i=0;i<NAV_LANESIDESTREETS_LENGTH;i++)
            gLaneGuidance_LaneSidestreets[j][i] =0;
    }
          
    //entry 0
    gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
    gLaneGuidance_Pos [LaneGuidanceEntry]               =1;    
    gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =NAV_LANEGUIDANCE_STRAIGHT;
    strncpy(gLaneGuidance_LaneSidestreets [LaneGuidanceEntry], "Sidestreet_0",NAV_LANESIDESTREETS_LENGTH);
    gLaneGuidance_LaneType [LaneGuidanceEntry]          =NAV_LANETYPE_NORMAL;
    gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =NAV_LANEMARKINGLEFT_NOLANE;
    gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =NAV_LANEMARKINGRIGHT_SOLIDDIVIDERLINE;
    gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =NAV_LANEDESCRIPTION_AVAILABLE;
    gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =NAV_GUIDANCEINFO_NOTRECOMMENDEDLANE;
    LaneGuidanceEntry++;
    
    //entry 1
    gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
    gLaneGuidance_Pos [LaneGuidanceEntry]               =2;    
    gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =NAV_LANEGUIDANCE_RIGHT;
    strncpy(gLaneGuidance_LaneSidestreets [LaneGuidanceEntry], "Sidestreet_1",NAV_LANESIDESTREETS_LENGTH);
    gLaneGuidance_LaneType [LaneGuidanceEntry]          =NAV_LANETYPE_FORBIDDEN;
    gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =NAV_LANEMARKINGLEFT_SOLIDDIVIDERLINE;
    gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =NAV_LANEMARKINGRIGHT_DASHEDDIVIDERLINE;
    gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =NAV_LANEDESCRIPTION_FORBIDDEN;
    gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =NAV_GUIDANCEINFO_RECOMMENDEDLANE;
    LaneGuidanceEntry++;        

    //entry 2
    gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
    gLaneGuidance_Pos [LaneGuidanceEntry]               =3;    
    gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =NAV_LANEGUIDANCE_BACK;
    strncpy(gLaneGuidance_LaneSidestreets [LaneGuidanceEntry], "Sidestreet_2",NAV_LANESIDESTREETS_LENGTH);
    gLaneGuidance_LaneType [LaneGuidanceEntry]          =NAV_LANETYPE_DYNAMICCONTROLLED;
    gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =NAV_LANEMARKINGLEFT_DASHEDDIVIDERLINE;
    gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =NAV_LANEMARKINGRIGHT_NOLANE;
    gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =NAV_LANEDESCRIPTION_ENDINGLATER;
    gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =NAV_GUIDANCEINFO_NOTRECOMMENDEDLANE;
    LaneGuidanceEntry++;

    //entry 3
    gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
    gLaneGuidance_Pos [LaneGuidanceEntry]               =4;    
    gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =NAV_LANEGUIDANCE_RIGHT;
    strncpy(gLaneGuidance_LaneSidestreets [LaneGuidanceEntry], "Sidestreet_3",NAV_LANESIDESTREETS_LENGTH);
    gLaneGuidance_LaneType [LaneGuidanceEntry]          =NAV_LANETYPE_TAXILANE;
    gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =NAV_LANEMARKINGLEFT_DASHEDDIVIDERLINE;
    gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =NAV_LANEMARKINGRIGHT_NOLANE;
    gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =NAV_LANEDESCRIPTION_ENDINGLATER;
    gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =NAV_GUIDANCEINFO_BESTRECOMMENDATION;
    LaneGuidanceEntry++;

    //entry 4
    gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
    gLaneGuidance_Pos [LaneGuidanceEntry]               =5;    
    gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =NAV_LANEGUIDANCE_STRAIGHT;
    strncpy(gLaneGuidance_LaneSidestreets [LaneGuidanceEntry], "Sidestreet_4",NAV_LANESIDESTREETS_LENGTH);
    gLaneGuidance_LaneType [LaneGuidanceEntry]          =NAV_LANETYPE_BUSTAXIBICYCLELANE;
    gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =NAV_LANEMARKINGLEFT_NOLANE;
    gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =NAV_LANEMARKINGRIGHT_DASHEDDIVIDERLINE;
    gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =NAV_LANEDESCRIPTION_BEGINSINMIDDLE;
    gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =NAV_GUIDANCEINFO_NOTRECOMMENDEDLANE;
    LaneGuidanceEntry++;

    //entry 5
    gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
    gLaneGuidance_Pos [LaneGuidanceEntry]               =6;    
    gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =NAV_LANEGUIDANCE_STRAIGHT;
    strncpy(gLaneGuidance_LaneSidestreets [LaneGuidanceEntry], "Sidestreet_5",NAV_LANESIDESTREETS_LENGTH);
    gLaneGuidance_LaneType [LaneGuidanceEntry]          =NAV_LANETYPE_TRAMWAYNORMAL;
    gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =NAV_LANEMARKINGLEFT_SOLIDDIVIDERLINE;
    gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =NAV_LANEMARKINGRIGHT_NOLANE;
    gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =NAV_LANEDESCRIPTION_MERGINGTOLEFT;
    gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =NAV_GUIDANCEINFO_BESTRECOMMENDATION;
    LaneGuidanceEntry++;

    //entry 6
    gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
    gLaneGuidance_Pos [LaneGuidanceEntry]               =7;    
    gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =NAV_LANEGUIDANCE_LEFT;
    strncpy(gLaneGuidance_LaneSidestreets [LaneGuidanceEntry], "Sidestreet_6",NAV_LANESIDESTREETS_LENGTH);
    gLaneGuidance_LaneType [LaneGuidanceEntry]          =NAV_LANETYPE_HIDELANE;
    gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =NAV_LANEMARKINGLEFT_NOLANE;
    gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =NAV_LANEMARKINGRIGHT_SOLIDDIVIDERLINE;
    gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =NAV_LANEDESCRIPTION_AVAILABLE;
    gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =NAV_GUIDANCEINFO_NOTRECOMMENDEDLANE;
    LaneGuidanceEntry++;

    //entry 7
    gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
    gLaneGuidance_Pos [LaneGuidanceEntry]               =8;    
    gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =NAV_LANEGUIDANCE_BACK;
    strncpy(gLaneGuidance_LaneSidestreets [LaneGuidanceEntry], "Sidestreet_7",NAV_LANESIDESTREETS_LENGTH);
    gLaneGuidance_LaneType [LaneGuidanceEntry]          =NAV_LANETYPE_BUSBICYCLELANE;
    gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =NAV_LANEMARKINGLEFT_DASHEDDIVIDERLINE;
    gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =NAV_LANEMARKINGRIGHT_NOLANE;
    gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =NAV_LANEDESCRIPTION_NOTSUPPORTED;
    gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =NAV_GUIDANCEINFO_RECOMMENDEDLANE;
    LaneGuidanceEntry++;
    
    /*/entry 8
    gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
    gLaneGuidance_Pos [LaneGuidanceEntry]               =8;
    gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =NAV_LANEGUIDANCE_LEFT;
    strncpy(gLaneGuidance_LaneSidestreets [LaneGuidanceEntry], "Sidestreet_8",NAV_LANESIDESTREETS_LENGTH);
    gLaneGuidance_LaneType [LaneGuidanceEntry]          =NAV_LANETYPE_TOLLLANE;
    gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =NAV_LANEMARKINGLEFT_SOLIDDIVIDERLINE;
    gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =NAV_LANEMARKINGRIGHT_NOLANE;
    gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =NAV_LANEDESCRIPTION_EXPANDINGTORIGHT;
    gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =NAV_GUIDANCEINFO_BESTRECOMMENDATION;*/

    gLaneGuidanceLine_sum  =LaneGuidanceEntry;

    //write Array in "write-window"
    /*writeClear(gLaneGuidance_writeWindow);
    writelineEx(gLaneGuidance_writeWindow, 0, "");
    writelineEx(gLaneGuidance_writeWindow, 0,"*******Default LaneGuidance_Array*******");
    writelineEx(gLaneGuidance_writeWindow, 0, "");

    for (i=0;i<=gLaneGuidanceLine_sum;i++)
    {
        writelineEx(gLaneGuidance_writeWindow, 0,"*******Element %d*******",i);
        
        writelineEx(gLaneGuidance_writeWindow, 0,"Pos[%d]: 0x%x", i, gLaneGuidance_Pos [i]);
        
        writelineEx(gLaneGuidance_writeWindow, 0,"LaneDirection[%d]: 0x%x",i, gLaneGuidance_LaneDirection[i]);
        switch (gLaneGuidance_LaneDirection[i])
        {
            case NAV_LANEGUIDANCE_STRAIGHT:
                    writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_STRAIGHT);
            break;

            case NAV_LANEGUIDANCE_LEFT:
                    writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_LEFT);
            break;

            case NAV_LANEGUIDANCE_BACK:
                    writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_BACK);
            break;

            case NAV_LANEGUIDANCE_RIGHT:
                    writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_RIGHT);
            break;

            default:             
            break;
        }

        writelineEx(gLaneGuidance_writeWindow, 0,"LaneSidestreets[%d]: %s",i, gLaneGuidance_LaneSidestreets[i]);        
        
        writelineEx(gLaneGuidance_writeWindow, 0,"LaneType[%d]: 0x%x",i, gLaneGuidance_LaneType[i]);
        if(gLaneGuidance_LaneType[i] <0x1A)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneType_s[gLaneGuidance_LaneType[i]]);

        writelineEx(gLaneGuidance_writeWindow, 0,"LaneMarking_left[%d]: 0x%x",i, gLaneGuidance_LaneMarking_left[i]);
        if(gLaneGuidance_LaneMarking_left[i] <0x03)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneMarking_left_s[gLaneGuidance_LaneMarking_left[i]]);

        writelineEx(gLaneGuidance_writeWindow, 0,"LaneMarking_right[%d]: 0x%x",i, gLaneGuidance_LaneMarking_right[i]);
        if(gLaneGuidance_LaneMarking_right[i] <0x03)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneMarking_right_s[gLaneGuidance_LaneMarking_right[i]]);

        writelineEx(gLaneGuidance_writeWindow, 0,"LaneDescription[%d]: 0x%x",i, gLaneGuidance_LaneDescription[i]);
        if(gLaneGuidance_LaneDescription[i] <0x0B)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDescription_s[gLaneGuidance_LaneDescription[i]]);
        else if(gLaneGuidance_LaneDescription[i] ==0xF)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gstring_not_supported);

        writelineEx(gLaneGuidance_writeWindow, 0,"GuidanceInfo[%d]: 0x%x",i, gLaneGuidance_GuidanceInfo[i]); 
        if(gLaneGuidance_GuidanceInfo[i] <0x03)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_GuidanceInfo_s[gLaneGuidance_GuidanceInfo[i]]);

        writelineEx(gLaneGuidance_writeWindow, 0, "");*/
        //IssueList #54
        putValue(env_NaviSD_LG_AH_elements, gLaneGuidanceLine_sum);
   // }
}

byte LaneGuidance_nextvalidLine (byte current_LaneGuidanceEntry, byte direction)
{
    byte next_LaneGuidanceEntry;
    int i;
         
    //init lokal variables
    next_LaneGuidanceEntry  =0;
    i                       =0;

    //search next "list entry"
    if(((NAV_LANEGUIDANCE_ENTRIES-1)==current_LaneGuidanceEntry && FORWARD ==direction) || (0 ==current_LaneGuidanceEntry && BACKWARD ==direction))    //last-/fist-element of array reached
        next_LaneGuidanceEntry =0xFF;
    else
    {
            next_LaneGuidanceEntry =current_LaneGuidanceEntry +1-2*direction;       //increment or decrement array-line (depends on direction);
                 
            //IssueList #71
            if (next_LaneGuidanceEntry < NAV_LANEGUIDANCE_ENTRIES)
            {
                if(0 ==gLaneGuidance_ListEntryValidInformation[next_LaneGuidanceEntry])    // check if next element is "valid"
                    next_LaneGuidanceEntry =0xff;
            }                        
    }

    return(next_LaneGuidanceEntry);
}

LastDestList_Indication(dword Indication_array [], int datalength)
{
    //changes for IssueList #152 - MR 53938
    //NAV_LASTDESTLIST_ENTRIES --> gLDL_CSVtotalElem
    
    byte mode, shift, direction, recordaddress, transmitpos, indexsize;
    word startelement, elements, valid_startelement, requested_startelement, valid_elements, Offset; 
    int i=0, transSuppression;
    //IssueList #190
    byte ldl_InValidStartElemFlg;

    //IssueList #76 - MR49870 : LDL
    int j =0;
    byte LDL_DelFlg;
    word validStartElem_plusElem;

    // Init local variables. 
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    transmitpos             =0;
    requested_startelement  =0;
    startelement            =0;
    indexsize               =0;
    elements                =0;
    valid_startelement      =0xff;
    valid_elements          =0;
    Offset                  =0;
    //MR 76047 
    transSuppression        = getvalue(env_NaviSD_LDL_StatusOFF);
    //IssueList #76 - MR49870 : LDL
    validStartElem_plusElem = 0;

        switch (Indication_array[2]) // indication
        {
            case DataGet_IND:
                if(getvalue(env_NaviSD_LDL_Error_on))
                {
                    //MR 63667 11.07.2014 -TNLE with SA-button
                    //LastDestList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue(env_NaviSD_LDL_ErrorCode));
                    LastDestList_Request(Error_REQ, 0, 0, 0, 0, 0, 0, getvalue(env_NaviSD_LDL_ErrorCode));
                }
                //MR 63336    02.07.2014
                else if(getvalue(env_NaviSD_LDL_Timeout) == TRUE)
                {
                /* NOP */
                }
                else
                {
                    //getData
                    gLastDestList_ASGID =(gBAP_Indication[3] &0xF0) /0x10;
                    gLastDestList_TAID  =gBAP_Indication[3] &0x0F;
            
                    /***ArrayHeader***/
                    mode            =(Indication_array[4] &0xF0) /0x10;
                    recordaddress   =Indication_array[4] &0x0F;
                    Offset =5;
                
                    // decode "mode-byte"
                    shift       =mode &0x01;
                    direction   =(mode &0x02)/0x02;
                    transmitpos =(mode &0x04)/0x04;
                    indexsize   =(mode &0x08)/0x08;              
            
                    if (indexsize)
                    {   
                        startelement =Indication_array[Offset];
                        Offset++;
                        startelement +=(Indication_array[Offset] *0x100);
                        Offset++;

                        elements =Indication_array[Offset];
                        Offset++;
                        elements +=(Indication_array[Offset] *0x100);
                        Offset++;
                    }
                    else
                    {   
                        startelement =Indication_array[Offset];
                        Offset++;

                        elements =Indication_array[Offset];
                        Offset++;
                    }   

                    requested_startelement =startelement;
                

                /***Startelement=0***/
                if(0==startelement) //Startelement-ID =0 -> start at first array-entry
                {
                    if(FORWARD==direction)  //forward-start
                    {
                        valid_startelement =0;                                                           

                        //IssueList #76 - MR49870 : LDL
                        //if(gLDL_CSVtotalElem <=elements) //1. more elements requested, than in array
                        if(gLastDestList_TotalNumListElements <=elements) //1. more elements requested, than in array
                        {
                            if (shift ==FALSE)  
                            {
                                //IssueList #76 - MR49870 : LDL
                                //for(i=0;i<gLDL_CSVtotalElem;i++)
                                for(i=0;i<gLastDestList_TotalNumListElements;i++)
                                {
                                    if(0 !=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                        valid_elements++;
                                        //write("write 1");                                //increment elements
                                    else                                                //no valid element, loop finished
                                        i =gLDL_CSVtotalElem;
                                }
                            }
                            else
                            {   
                                valid_startelement  =startelement;
                                valid_elements      =0;
                            }
                        }
                        else    //2. number of requested elements < elements in array
                        {
                            if (shift ==FALSE)
                            {
                                for(i=0;i<elements;i++)
                                {
                                    if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                        valid_elements++;
                                        //write("write 2");                                //increment elements
                                    else                                                //no valid element, loop finished
                                        i =gLDL_CSVtotalElem;
                                }
                            }
                            else
                            {
                                valid_startelement  =startelement;
                                valid_elements      =0;
                            }

                        }
                    }                                                               //forward ends

                    else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
                    {   
                        //searching for valid startelement
                        for(i=(gLDL_CSVtotalElem-1);i>=0;i--)
                        {
                            if(0!=gLastDestList_ListEntryValidInformation[i])        //found valid startelement
                            {
                                valid_startelement =i;                                
                                i =0;                                                
                            }
                        }
                        
                        //searching for valid elements
                        if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                        {
                            valid_startelement  =startelement;
                            valid_elements      =0;
                        }
                        else if(0==valid_startelement)                                
                            valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                        else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                        {
                            for(i=valid_startelement;i>=0;i--)
                            {
                                if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                    valid_elements++;
                                    //write("write 3");                                //increment elements
                                else                                                //no valid element, loop finished
                                    i=0;
                            }
                        }
                        else                                                        //enougth array-elements available
                        {
                            for(i=valid_startelement;i>(valid_startelement-elements);i--)
                            {
                                if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                    valid_elements++;
                                    //write("write 4");                                //increment elements
                                else                                                //no valid element, loop finished
                                    i=0;
                            }
                                      
                        }                                                            
                    }                                                               //backward-end
                }                                                                   //startelement ==0 -end

                /***Startelement!=0***/
                else                                                                //searching for Startelement-ID                
                {
                    //IssueList #190 - start
                    ldl_InValidStartElemFlg = 0;
                    for(i=0;i<gLDL_CSVtotalElem;i++)
                    {
                        if (startelement==gLDL_Pos_insDel[i][0])
                        {
                            //check if Start is deleted then reply with 0 elements
                            if( gLDL_Pos_insDel[i][1]==0x01)
                            {
                            valid_startelement  =startelement;
                            valid_elements      =0;
                            ldl_InValidStartElemFlg = 1;
                            }
                        }
                    }
                    //IssueList #190 - end

                    //IssueList #190 - if condition
                    if (ldl_InValidStartElemFlg == 0x00)
                    {    
                        //searching for valid startelement
                        for(i=0;i<gLDL_CSVtotalElem;i++)
                        {
                            if(gLastDestList_Pos[i] ==startelement)                        //found a valid element
                            {                                          
                                if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                                {
                                    if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                                        valid_startelement =i+1-2*direction;
                                                                
                                    else if(i==0 && BACKWARD==direction) 
                                        valid_startelement =gLastDestListLine_sum;     //valid element is last element in Array                                                
                                
                                    else if(i==0 && FORWARD==direction) 
                                        valid_startelement =0;                          //valid element is first element in Array
                                }
                        
                                else
                                    valid_startelement =i;                              //found element is valid_startelement

                                i=gLDL_CSVtotalElem;
                            }
                        }

                        if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
                        {
                            valid_startelement  =startelement;
                            valid_elements      =0;
                        }
                        else                                                                //found valid entry for startelement in array
                        {
                            //verify number of valid elements
                            if(BACKWARD==direction)                                            //backward-start
                            {
                                if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                                {
                                   //IssueList #76 - MR49870 : LDL
                                   LDL_DelFlg = 0x00;
                                   //IssueList #190
                                   //LDL_DelFlg = ldl_deleteCheck(gLastDestList_Pos[0],gLDL_Pos_insDel,gLDL_CSVtotalElem );
                                   LDL_DelFlg = ldl_deleteCheck(gLastDestList_Pos[0]);

                                    if (LDL_DelFlg == 0x00)
                                    valid_elements=1;
                                }
                                
                                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                                {
                                    for(i=valid_startelement;i>=0;i--)
                                    {
                                        if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;
                                            //write("write 6");                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                                else                                                        //enougth array-elements available
                                {
                                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                                    {
                                        if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;
                                            //write("write 7");                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                            }                                                                //backward-end
                            else                                                            //forward-start
                            {
                                //IssueList #76 - MR49870 : LDL
                                //if((valid_startelement+elements)>=gLDL_CSVtotalElem)
                                if((valid_startelement+elements)>=gLastDestList_TotalNumListElements)
                                {
                                    for(i=valid_startelement;i<gLDL_CSVtotalElem;i++)
                                    {
                                        if(0!=gLastDestList_Pos[i])                            //if there is an valid element
                                            {
                                            //IssueList #76 - MR49870 : LDL
                                            LDL_DelFlg = 0x00;
                                            //IssueList #190
                                            //LDL_DelFlg = ldl_deleteCheck(gLastDestList_Pos[i],gLDL_Pos_insDel,gLDL_CSVtotalElem );
                                            LDL_DelFlg = ldl_deleteCheck(gLastDestList_Pos[i]);

                                            if (LDL_DelFlg == 0x00 && valid_elements < elements)
                                            valid_elements++;
                                            //write("write 8");
                                            }                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=gLDL_CSVtotalElem;
                                    }
                                }
                                else
                                {
                                    //IssueList #76 - MR49870 : LDL
                                    //for(i=valid_startelement;i<(valid_startelement+elements);i++)
                                    validStartElem_plusElem =valid_startelement+elements;
                                    for(i=valid_startelement;i<validStartElem_plusElem;i++)
                                    {
                                        if(0!=gLastDestList_Pos[i])                            //if there is an valid element
                                        {    
                                        //IssueList #76 - MR49870 : LDL
                                            LDL_DelFlg = 0x00;
                                            //IssueList #190
                                            //LDL_DelFlg = ldl_deleteCheck(gLastDestList_Pos[i],gLDL_Pos_insDel,gLDL_CSVtotalElem );
                                            LDL_DelFlg = ldl_deleteCheck(gLastDestList_Pos[i]);

                                            if (LDL_DelFlg == 0x00) 
                                            {                               
                                                if (valid_elements < elements)
                                                valid_elements++;
                                                //write("write 9");
                                            }
                                            else
                                            {
                                                 if (valid_elements < elements)
                                                 validStartElem_plusElem++;      //adjust the loop boundary based on number of deleted elements
                                             }                                                                    
                                        
                                        }
                                        else                                                //no valid element, loop finished
                                            i=gLDL_CSVtotalElem;
                                    }
                                }
                            }
                        } //else
                    }//gValidStartElemFlg
                } //else Startelement!=0

                transmitpos =TRUE;
                mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                //send StatusArray
                //MR 63667 11.07.2014 -TNLE with SA-button
                //LastDestList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0); 
        //MR 76047 
        if(!transSuppression)
                LastDestList_Request(Data_REQ, gLastDestList_TotalNumListElements, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                     
                
                //Panel
                putvalue(env_NaviSD_LDL_ASGID,gLastDestList_ASGID);
                putvalue(env_NaviSD_LDL_TAID,gLastDestList_TAID);
                }
             break;
            
            case Error_IND:
                writelineEx(gError_Trace, 0, "FSG_NaviSD LastDestList_Indication: received error, errorcode:0x%x", Indication_array[3]);
            break;

            default:
                writelineEx(gError_Trace, 0, "FSG_NaviSD LastDestList_Indication: invalid indication %d", Indication_array[2]);
             break;
    }
}

LastDestList_Request(byte request, word tnle, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, LastDestListLine, indexsize; 
    word current_element, Offset;

    //IssueList #76 - MR49870 : LDL
    byte LDL_DelFlg;

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;
    
    shift               =0;
    direction           =0;
    transmitpos         =0;
    indexsize           =0;
    LastDestListLine    =0;
    current_element     =0;
    Offset              =0;

    // decode "mode-byte"
    shift       =mode &0x01;
    direction   =(mode &0x02)/0x02;
    transmitpos =(mode &0x04)/0x04;
    indexsize   =(mode &0x08)/0x08;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                //LSG-ID
    requestarray[1] =FctID_LastDest_List;        //Fct.-ID
    requestarray[2] =request;                   //request type
    Offset =3;

    switch(request)
    {
        case Changed_REQ:

            /***ArrayHeader***/
            requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
            Offset++;
            
            if (indexsize)
            {   
                requestarray[Offset] =(requested_startelement &0x00FF);
                Offset++;
                requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
                Offset++;

                requestarray[Offset] =(elements &0x00FF);
                Offset++;
                requestarray[Offset] =((elements &0xFF00) /0x100);
                Offset++;
            }
            else
            {   
                requestarray[Offset] =requested_startelement;
                Offset++;

                requestarray[Offset] =elements;
                Offset++;
            }
            
            LastDestListLine =startelement;
            
            if (getvalue(env_NaviSD_LDL_CA_switch)) //ArrayData
            {
                //copy data
                switch(recordaddress)
                {
                    case 0: //complete record
                        while(current_element <elements)
                        {
                            if(LastDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LastDestList_Request: invalid LastDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    requestarray[Offset] =gLastDestList_Pos[LastDestListLine];
                                    Offset++;
                                }
                                                                                              
                                //POI_Type
                                requestarray[Offset] =gLastDestList_POIType[LastDestListLine];
                                Offset++;

                                //Description
                                requestarray[Offset] =strlen(gLastDestList_Description[LastDestListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gLastDestList_Description[LastDestListLine]);i++)
                                {
                                    requestarray[Offset] =gLastDestList_Description[LastDestListLine][i];    
                                    Offset++;
                                }
                            }
                            current_element++;
                            LastDestListLine =LastDestList_nextvalidLine(LastDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 1: //Description
                        while(current_element <elements)
                        {
                            if(LastDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LastDestList_Request: invalid LastDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    requestarray[Offset] =gLastDestList_Pos[LastDestListLine];
                                    Offset++;
                                }
                                                                                              
                                //Description
                                requestarray[Offset] =strlen(gLastDestList_Description[LastDestListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gLastDestList_Description[LastDestListLine]);i++)
                                {
                                    requestarray[Offset] =gLastDestList_Description[LastDestListLine][i];    
                                    Offset++;
                                }
                            }
                            current_element++;
                            LastDestListLine =LastDestList_nextvalidLine(LastDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 2: //POI_Type
                        while(current_element <elements)
                        {
                            if(LastDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LastDestList_Request: invalid LastDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    requestarray[Offset] =gLastDestList_Pos[LastDestListLine];
                                    Offset++;
                                }
                                                                                              
                                //POI_Type
                                requestarray[Offset] =gLastDestList_POIType[LastDestListLine];
                                Offset++;
                            }
                            current_element++;
                            LastDestListLine =LastDestList_nextvalidLine(LastDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 15:
                        while(current_element <elements)
                        {
                            if(LastDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LastDestList_Request: invalid LastDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    requestarray[Offset] =gLastDestList_Pos[LastDestListLine];
                                    Offset++;
                                }
                            }
                            current_element++;
                            
                            LastDestListLine =LastDestList_nextvalidLine(LastDestListLine, direction);
                    
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    default:
                        write("NaviSD LastDestList_Request: invalid recordaddress %d", recordaddress);
                    break;
                } //end switch "recordaddress" 
            }
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); //new

        break; //end Changed_REQ
        
        case Data_REQ:
            //changes from Jran Karl (28.03.2012)
            //MR 63336    02.07.2014
            //if(getvalue(env_NaviSD_LDL_Timeout) != TRUE)
            if(/* getvalue(env_NaviSD_LDL_Timeout) != */ TRUE)
            {
            //VAGH-10511
            ASGID = gLastDestList_ASGID;
            TAID = gLastDestList_TAID;
                if(getvalue(env_NaviSD_LDL_ASGID_error) != FALSE)
                {
                    ASGID += 0x2;
                }
                if(getvalue(env_NaviSD_LDL_TAID_error) != FALSE)
                {
                    TAID += 0x02;
                }
        //end of changes from Jran Karl (28.03.2012)
                requestarray[Offset] =((ASGID *0x10) &0xF0) +(TAID &0x0F);    
                Offset++;
                
                //MR 63667 11.07.2014 -TNLE with SA-button
                //requestarray[Offset] =gLastDestList_TotalNumListElements;
                requestarray[Offset] = tnle;    
                Offset++;

            /***ArrayHeader***/
            requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
            Offset++;
            requestarray[Offset] =requested_startelement;
            Offset++;
            requestarray[Offset] =elements;
            Offset++;
            
            LastDestListLine =startelement;
            
            //copy data
            switch(recordaddress)
            {
                case 0: //complete record
                        while(current_element <elements)
                        {
                            if(LastDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LastDestList_Request: invalid LastDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    //IssueList #76 - MR49870 : LDL
                                     //Updating the status array excluding the deleted elements
                                     LDL_DelFlg = 0x00;
                                     //IssueList #190
                                     //LDL_DelFlg = ldl_deleteCheck(gLastDestList_Pos[LastDestListLine],gLDL_Pos_insDel,gLDL_CSVtotalElem);
                                     LDL_DelFlg = ldl_deleteCheck(gLastDestList_Pos[LastDestListLine]);
                                            
                                     if (LDL_DelFlg == 0x00)
                                     {
                                        requestarray[Offset] =gLastDestList_Pos[LastDestListLine];
                                        Offset++;
                                     }
                                }
                                //IssueList #76 - MR49870 : LDL
                                if (LDL_DelFlg == 0x00)
                                {
                                    //POI_Type
                                    requestarray[Offset] =gLastDestList_POIType[LastDestListLine];
                                    Offset++;

                                    //Description
                                    requestarray[Offset] =strlen(gLastDestList_Description[LastDestListLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gLastDestList_Description[LastDestListLine]);i++)
                                    {
                                        requestarray[Offset] =gLastDestList_Description[LastDestListLine][i];    
                                        Offset++;
                                    }
                                }//LDL_DelFlg
                            }
                            //IssueList #76 - MR49870 : LDL
                            if (LDL_DelFlg == 0x00)
                            current_element++;

                            LastDestListLine =LastDestList_nextvalidLine(LastDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 1: //Description
                        while(current_element <elements)
                        {
                            if(LastDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LastDestList_Request: invalid LastDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    requestarray[Offset] =gLastDestList_Pos[LastDestListLine];
                                    Offset++;
                                }
                                                                                              
                                //Description
                                requestarray[Offset] =strlen(gLastDestList_Description[LastDestListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gLastDestList_Description[LastDestListLine]);i++)
                                {
                                    requestarray[Offset] =gLastDestList_Description[LastDestListLine][i];    
                                    Offset++;
                                }
                            }
                            current_element++;
                            LastDestListLine =LastDestList_nextvalidLine(LastDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 2: //POI_Type
                        while(current_element <elements)
                        {
                            if(LastDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LastDestList_Request: invalid LastDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    requestarray[Offset] =gLastDestList_Pos[LastDestListLine];
                                    Offset++;
                                }
                                                                                              
                                //POI_Type
                                requestarray[Offset] =gLastDestList_POIType[LastDestListLine];
                                Offset++;
                            }
                            current_element++;
                            LastDestListLine =LastDestList_nextvalidLine(LastDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 15:
                        while(current_element <elements)
                        {
                            if(LastDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD LastDestList_Request: invalid LastDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    //IssueList #76 - MR49870 : LDL
                                     //Updating the status array excluding the deleted elements
                                     LDL_DelFlg = 0x00;
                                     //IssueList #190
                                     //LDL_DelFlg = ldl_deleteCheck(gLastDestList_Pos[LastDestListLine],gLDL_Pos_insDel,gLDL_CSVtotalElem);
                                     LDL_DelFlg = ldl_deleteCheck(gLastDestList_Pos[LastDestListLine]);
                                            
                                     if (LDL_DelFlg == 0x00)
                                     {
                                        requestarray[Offset] =gLastDestList_Pos[LastDestListLine];
                                        Offset++;
                                     }//LDL_DelFlg
                                }
                            }
                            //IssueList #76 - MR49870 : LDL
                            if (LDL_DelFlg == 0x00)
                            current_element++;

                            LastDestListLine =LastDestList_nextvalidLine(LastDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                    default:
                        write("NaviSD LastDestList_Request: invalid recordaddress %d", recordaddress);
                     break;
                } //end switch "recordaddress"
            //changes from Jran Karl (28.03.2012)
        }
            else
            {
                write("NaviSD LastDestList_Request: Simulate timeout of Status-Array!");
            }
        //end of changes from Jran Karl (28.03.2012)
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
         break; //end Error_REQ
    
    } //end switch "request"   
}

LastDestList_init_static()
{
    byte j, i, LastDestListLine;
    
    //clear
    LastDestListLine       =0;
    gLastDestListLine_sum  =0;

    for(j=0;j<NAV_LASTDESTLIST_ENTRIES;j++) 
    {
        gLastDestList_Pos[j]                        =0;
        gLastDestList_POIType[j]                    =0;
        gLastDestList_ListEntryValidInformation[j]  =0;

        for(i=0;i<NAV_LASTDESTLIST_DESCRIPTION_LENGTH;i++)
            gLastDestList_Description[j][i] =0;
    }
          
    //entry 0
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0x02;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_NOPOI;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_0",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 1
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0x0E;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_AIRPORT;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_1",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 2
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0xF4;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_BUSSTATION;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_2",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;
    
    //entry 3
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0x32;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_CLOTHINGSTORE;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_3",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;
    
    //entry 4
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0x26;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_EMERGENCY;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_4",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 5
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0xD4;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_HARBOR;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_5",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 6
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0x9B;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_HOSPITAL;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_6",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 7
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0x04;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_PARKING;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_7",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 8
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0xA3;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_CARREPAIRSHOPVW;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_8",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 9
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0x89;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_UNKOWN;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_9",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 10
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0x72;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_CAMPING;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_10",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 11
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0xd7;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_COURT;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_11",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 12
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0x19;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_GASSTATION;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_12",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 13
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0x45;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_HEALTHCARE;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_13",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;
    
    //entry 14
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0xE8;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_SHOESTORES;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_14",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 15
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0xB4;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_PARKS;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_15",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;

    //entry 16
    gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
    gLastDestList_Pos [LastDestListLine]                       =0xC8;
    gLastDestList_POIType [LastDestListLine]                   =NAV_LASTDESTLIST_POITYPE_LIBRARY;
    strncpy(gLastDestList_Description [LastDestListLine], "Description_16",NAV_LASTDESTLIST_DESCRIPTION_LENGTH);
    LastDestListLine++;
    
    gLastDestListLine_sum               =LastDestListLine;
    gLastDestList_TotalNumListElements  =gLastDestListLine_sum;

    //write Array in "write-window"
    /*
    writeClear(gLastDestList_writeWindow);
    writelineEx(gLastDestList_writeWindow, 0, "");
    writelineEx(gLastDestList_writeWindow, 0,"*******Default LastDestList_Array*******");
    writelineEx(gLastDestList_writeWindow, 0, "");
    
    for (i=0;i<gLastDestListLine_sum;i++)
    {
        writelineEx(gLastDestList_writeWindow, 0,"*******Element %d*******",i);
        
        writelineEx(gLastDestList_writeWindow, 0,"Pos[%d]: 0x%x", i, gLastDestList_Pos [i]);
                     
        writelineEx(gLastDestList_writeWindow, 0,"POI_Type[%d]: 0x%x",i, gLastDestList_POIType[i]);
        if(gLastDestList_POIType[i] <0xA0)
            writeEx(gLastDestList_writeWindow, 0," -> '%s'", gLastDestList_POIType_s[gLastDestList_POIType[i]]);
        
        else if (gLastDestList_POIType[i] ==0xFF)
            writeEx(gLastDestList_writeWindow, 0," -> '%s'", gstring_unknown);
        else
            writeEx(gLastDestList_writeWindow, 0," -> '%s'", gstring_reserved);
        
        writelineEx(gLastDestList_writeWindow, 0,"Description[%d]: %s",i, gLastDestList_Description[i]);

        writelineEx(gLastDestList_writeWindow, 0, "");
    }

    writelineEx(gLastDestList_writeWindow, 0,"Anzahl der Listenelemente: %d", gLastDestListLine_sum);
    */
    putvalue(env_NaviSD_LDL_TotalNumLE, gLastDestList_TotalNumListElements);
}

byte LastDestList_nextvalidLine (byte current_LastDestListLine, byte direction)
{
    byte next_LastDestListLine;
    int i;
         
    //init lokal variables
    next_LastDestListLine  =0;
    i                      =0;

    //search next "list entry"
    if(((gLastDestListLine_sum-1)==current_LastDestListLine && FORWARD ==direction) || (0 ==current_LastDestListLine && BACKWARD ==direction))    //last-/fist-element of array reached
        next_LastDestListLine =0xFF;
    else
    {
            next_LastDestListLine =current_LastDestListLine +1-2*direction;       //increment or decrement array-line (depends on direction);
  
            //IssueList #71
            if (next_LastDestListLine < NAV_LASTDESTLIST_ENTRIES)
            {
            if(0 ==gLastDestList_ListEntryValidInformation[next_LastDestListLine])    // check if next element is "valid"
                next_LastDestListLine =0xff; 
            }                    
    }

    return(next_LastDestListLine);
          
}

LastDestList_init_CSV () //Byte & file selection
{
    int i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
    dword CSVfileHandle =0, ConfigFileHandle =0;
    char buffer_string[NAV_BUFFERSIZE], Path_CSV[NAV_BUFFERSIZE], Path_Config[NAV_BUFFERSIZE];
    byte LastDestListLine =0, buffer_byte[NAV_BUFFERSIZE];
    char LastDestList_Pos_string [NAV_LASTDESTLIST_ENTRIES][NAV_TEXTLENGTH];           //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
    char LastDestList_POIType_string [NAV_LASTDESTLIST_ENTRIES][NAV_TEXTLENGTH];       //help value ->"POI_Type" is stored in the ASCII(UTF-8) code in the *.csv 

    if(getvalue(env_NaviSD_LDL_DataSource) == NAV_EXTERNAL_LIST) //output data in write window "FSGLastDestList"  
    {
        writeClear(gLastDestList_writeWindow);
        writelineEx(gLastDestList_writeWindow, 0,"*******External LastDest_List*******");
        writelineEx(gLastDestList_writeWindow, 0, "");
        writelineEx(gLastDestList_writeWindow, 0, "**********************Start load new LastDest_List**********************");   
    
        for(j=0;j<NAV_LASTDESTLIST_ENTRIES;j++) //clear "LastDestList Array"
        {
            gLastDestList_Pos[j]                        =0;
            gLastDestList_POIType[j]                    =0;
            gLastDestList_ListEntryValidInformation[j]  =FALSE;

            for(i=0;i<NAV_LASTDESTLIST_DESCRIPTION_LENGTH;i++)
                gLastDestList_Description[j][i]=0;           
        }

        for(i=0;i<NAV_FILENAME_SIZE; i++) //clear "filename"
            gLastDestList_CSV_filename[i] =0;       
        
        for(j=0;j<NAV_LASTDESTLIST_ENTRIES; j++) //clear "buffer"
        {
            buffer_string[j]    =0;
            buffer_byte[j]      =0;

            for(i=0;i<NAV_TEXTLENGTH;i++) //clear help value
            {
                LastDestList_Pos_string[j][i]       =0;
                LastDestList_POIType_string[j][i]   =0;
            }
        }        

        i =0; j =0; LastDestListLine =0; current_CSV_line =0; //reset values 
                      
        getvalue(env_NaviSD_LDL_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
        
        //write("complete path *.csv: %s", Path_CSV); //debug
        
        i =0;

        while (Path_CSV[i] !=0) //scan "path"
        {
            if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
                count1++;                
            
            //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
            i++;
        }  
         
        i =0; j =0; //reset values

        while (Path_CSV[i] !=0) //seperate "path" and "filename"
        {
            if(count2==count1) //get filename after last "\"
            {              
                gLastDestList_CSV_filename[j] =Path_CSV[i];
                j++;

                Path_CSV[i] =0;              
            }

            if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
                count2++;
                               
            i++;
        }

        writelineEx(gLastDestList_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 

        writelineEx(gLastDestList_writeWindow, 0,"filename of *.csv: '%s'", gLastDestList_CSV_filename);  //output filename 

        putvalue(env_NaviSD_LDL_DataSource_file, gLastDestList_CSV_filename); //output current loaded *.csv-file on panel

        setFilePath(Path_CSV, 0); //set path for *.csv file

        CSVfileHandle =openFileRead(gLastDestList_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        

        if (CSVfileHandle!=0) //*.csv file access successful
        {
            writelineEx(gLastDestList_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gLastDestList_CSV_filename);    //output result  
            
            putvalue(env_NaviSD_LDL_DataSource_result, "successful");   //output result on panel                      
            
            Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
                           
            for (i=0; i<Num_of_csv_byte; i++) //copy data into "LastDestList"
            {      
                if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
                {
                    if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in LastDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                    {
                        if(current_CSV_line>0 && LastDestListLine<NAV_LASTDESTLIST_ENTRIES) //ignore first line in *.csv file
                        {   
                            writelineEx(gLastDestList_writeWindow, 0, "");
                            writelineEx(gLastDestList_writeWindow, 0,"*******Element %d*******",LastDestListLine);

                            //transform 'string' to 'long' for "POS", "Type" and "Attributes"
                            gLastDestList_Pos[LastDestListLine]     =atol(LastDestList_Pos_string[LastDestListLine]);
                            gLastDestList_POIType[LastDestListLine] =atol(LastDestList_POIType_string[LastDestListLine]);                        
                            
                            writelineEx(gLastDestList_writeWindow, 0,"Pos[%d]: 0x%x",LastDestListLine, gLastDestList_Pos[LastDestListLine]);
                            
                            writelineEx(gLastDestList_writeWindow, 0,"POI_Type[%d]: 0x%x",LastDestListLine, gLastDestList_POIType[LastDestListLine]);
                            if(gLastDestList_POIType[LastDestListLine] <0xA0)
                                writeEx(gLastDestList_writeWindow, 0," -> '%s'", gLastDestList_POIType_s[gLastDestList_POIType[LastDestListLine]]);
        
                            else if (gLastDestList_POIType[LastDestListLine] ==0xFF)
                                writeEx(gLastDestList_writeWindow, 0," -> '%s'", gstring_unknown);
                            else
                                writeEx(gLastDestList_writeWindow, 0," -> '%s'", gstring_reserved);

                            writelineEx(gLastDestList_writeWindow, 0,"Description[%d]: %s",LastDestListLine, gLastDestList_Description[LastDestListLine]);                            
                            
                            gLastDestList_ListEntryValidInformation[LastDestListLine]  =TRUE;
                                                
                            LastDestListLine++; // -> next line in *.csv (next record element)
                        }

                        current_CSV_line++; //next line in *.csv file
                        element =0; //start at 'POS' (first record element of "array data")
                        j=0; //reset value
                    }
                      
                    else if(current_CSV_line>0 && LastDestListLine<NAV_LASTDESTLIST_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                    {
                        switch (element)
                        {
                            case 0: //POS
                                    LastDestList_Pos_string[LastDestListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //POIType
                                    LastDestList_POIType_string[LastDestListLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 2: //Description
                                    gLastDestList_Description[LastDestListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            default:
                             break;
                        }
                    }                               
                }
                               
                else  // ";" is detected ->next record element of "array data"
                {                                          
                    element++;
                    j=0; //reset value  
                }                                              
        
            }         
            
            //IssueList #76 - MR49870 : LDL
            // - if condition           
            if (getValue(env_NaviSD_LDL_insert_UPD_button) == 0x00)
            gLastDestList_TotalNumListElements =gLastDestListLine_sum =LastDestListLine; //get "total number of list elements"
            
            putvalue(env_NaviSD_LDL_TotalNumLE, gLastDestList_TotalNumListElements);

            writelineEx(gLastDestList_writeWindow, 0, "");

            writelineEx(gLastDestList_writeWindow, 0,"Anzahl der Listenelemente: %d", gLastDestListLine_sum); //output total number of list elements

            writelineEx(gLastDestList_writeWindow, 0, "");

            if(fileClose (CSVfileHandle) !=0) //close *.csv file
                writelineEx(gLastDestList_writeWindow, 0,"Datei '%s' geschlossen", gLastDestList_CSV_filename); //output result
             
            else
                writelineEx(gLastDestList_writeWindow, 0,"Fehler beim Schlieen der Datei '%s'", gLastDestList_CSV_filename);//output result
        }

        else //*.csv file access not successful
        {
            writelineEx(gLastDestList_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gLastDestList_CSV_filename); //output result
            
            putvalue(env_NaviSD_LDL_DataSource_result,"not successful"); //output result
        }
    
     //IssueList #76 - MR49870 : LDL
         for(i =0; i<gLastDestList_TotalNumListElements; i++)
        gLDL_Pos_insDel[i] [0] =gLastDestList_Pos[i];

        if (getValue(env_NaviSD_LDL_insert_UPD_button) == 0x00)
        gLDL_totalDELctr = 0;

    }

       
}

on envVar env_NaviSD_LDL_CA
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        if(getvalue(env_NaviSD_LDL_AH_start) >255 && getvalue(env_NaviSD_LDL_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_NaviSD_LDL_AH_IS,1);

        //get data from Panel
        recordaddress   =getvalue(env_NaviSD_LDL_AH_RA);
        shift           =getvalue(env_NaviSD_LDL_AH_shift);
        direction       =getvalue(env_NaviSD_LDL_AH_dir);
        transmitpos     =getvalue(env_NaviSD_LDL_AH_POS);
        indexsize       =getvalue(env_NaviSD_LDL_AH_IS);
        startelement    =getvalue(env_NaviSD_LDL_AH_start);
        elements        =getvalue(env_NaviSD_LDL_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        if (getvalue(env_NaviSD_LDL_CA_switch))
        {
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
        {
            if(FORWARD==direction)  //forward-start
            {
                valid_startelement =0;                                                           

                if(NAV_LASTDESTLIST_ENTRIES <=elements) //1. more elements requested, than in array
                {
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<NAV_LASTDESTLIST_ENTRIES;i++)
                        {
                            if(0 !=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i =NAV_LASTDESTLIST_ENTRIES;
                        }
                    }
                    else
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if (shift ==FALSE)
                    {
                        for(i=0;i<elements;i++)
                        {
                            if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i =NAV_LASTDESTLIST_ENTRIES;
                        }
                    }
                    else 
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
            {   
                //searching for valid startelement
                for(i=(NAV_LASTDESTLIST_ENTRIES-1);i>=0;i--)
                {
                    if(0!=gLastDestList_ListEntryValidInformation[i])        //found valid startelement
                    {
                        valid_startelement =i;                                
                        i =0;                                                
                    }
                }
                        
                //searching for valid elements
                if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  =startelement;
                    valid_elements      =0;
                }
                else if(0==valid_startelement)                                
                    valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for(i=valid_startelement;i>=0;i--)
                    {
                        if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                    {
                        if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }                   
                }                                                            
            }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID                
        {
            //searching for valid startelement
            for(i=0;i<NAV_LASTDESTLIST_ENTRIES;i++)
            {
                if(gLastDestList_Pos[i] ==startelement)                        //found a valid element
                {                                       
                    if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                    {
                        if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement =i+1-2*direction;
                                                            
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gLastDestListLine_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
                    
                    else
                        valid_startelement =i;                              //found element is valid_startelement

                    i =NAV_LASTDESTLIST_ENTRIES;
                }
                else
                    valid_startelement =0xff;
            }

            if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
            {   
                valid_startelement  =startelement;
                valid_elements      =0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if(BACKWARD==direction)                                            //backward-start
                {
                    if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                        valid_elements=1;
                            
                    else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for(i=valid_startelement;i>=0;i--)
                        {
                            if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for(i=valid_startelement;i>(valid_startelement-elements);i--)
                        {
                            if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements)>=NAV_LASTDESTLIST_ENTRIES)
                    {
                        for(i=valid_startelement;i<NAV_LASTDESTLIST_ENTRIES;i++)
                        {
                            if(0!=gLastDestList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_LASTDESTLIST_ENTRIES;
                        }
                    }
                    else
                    {
                        for(i=valid_startelement;i<(valid_startelement+elements);i++)
                        {
                            if(0!=gLastDestList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_LASTDESTLIST_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue(env_NaviSD_LDL_AH_elements, valid_elements);
        }

        else
        {
            valid_startelement      =startelement;
            valid_elements          =elements;
        }

        requested_startelement =startelement;
        
        //MR 63667 11.07.2014 -TNLE with SA-button
        //LastDestList_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
        LastDestList_Request(Changed_REQ, 0, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

on envVar env_NaviSD_LDL_reload //load external LastDestList from *.csv
{
word i;


    if(getvalue(this) && getvalue(env_NaviSD_LDL_DataSource) ==NAV_EXTERNAL_LIST)
    {
            //IssueList #76 - MR49870 : LDL
           if (getValue(env_NaviSD_LDL_insert_UPD_button)==0x00)
             {
                 for(i =0; i<NAV_LASTDESTLIST_ENTRIES; i++)
                 {
                  gLDL_Pos_insDel[i] [0] =0x00;   //POS value
                  gLDL_Pos_insDel[i] [1] =0x00;   //tagging of deleted elements
                  }
            }
       
            LastDestList_init_CSV();

            //IssueList #76 - MR49870 : LDL
            if (getValue(env_NaviSD_LDL_insert_UPD_button)==0x00)
            {
              //MR 63332 #3   02.07.2014
              //gLastDestList_TotalNumListElements = getValue(env_NaviSD_LDL_TotalNumLE);
              gLDL_CSVtotalElem = gLastDestList_TotalNumListElements;

              //Clear insert/delete panel
               putValue(env_NaviSD_LDL_delete_start, 0);
               putValue(env_NaviSD_LDL_insert_start, 0);
               putValue(env_NaviSD_LDL_insert_start, 0);
               putValue(env_NaviSD_LDL_insert_successor, 0);
               putValue(env_NaviSD_LDL_delete_ErrHand, 1);
               putValue(env_NaviSD_LDL_delete_Message, empty_string);

               putValue(env_NaviSD_LDL_insert_Err, 1);
               putValue(env_NaviSD_LDL_Insert_Message, empty_string);
            }
                //Clearing send buffer       
                for(i =0; i<NAV_LASTDESTLIST_ENTRIES; i++)
                gLDL_Send[i][0] =0;   //POS value

      }

    else if(getvalue(env_NaviSD_LDL_DataSource) != NAV_EXTERNAL_LIST)
        putvalue(env_NaviSD_LDL_DataSource_result,"not successful, select 'external *.csv'");
}

on envVar env_NaviSD_LDL_DataSource
{
    if (getvalue(this) ==NAV_DEFAULT_LIST)
    {
        LastDestList_init_static();
        putvalue(env_NaviSD_LDL_DataSource_file, empty_string);
        putvalue(env_NaviSD_LDL_DataSource_result, empty_string);
    }
}

on envVar env_NaviSD_LDL_StatusArray
{
    //MR 63667 11.07.2014 -TNLE with SA-button
    //word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    word tnle, requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    //MR 76047 
    int i, transSuppression;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;
    //MR 76047 
    transSuppression        = getvalue(env_NaviSD_LDL_StatusOFF);

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        if(getvalue(env_NaviSD_LDL_AH_start) >255 && getvalue(env_NaviSD_LDL_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_NaviSD_LDL_AH_IS,1);

        //get data from Panel
        gLastDestList_ASGID                 =getvalue(env_NaviSD_LDL_ASGID);
        gLastDestList_TAID                  =getvalue(env_NaviSD_LDL_TAID);
        
        //MR 63332 #3   02.07.2014
        //gLastDestList_TotalNumListElements  =getvalue(env_NaviSD_LDL_TotalNumLE);

        tnle =getvalue(env_NaviSD_LDL_TotalNumLE);

        recordaddress   =getvalue(env_NaviSD_LDL_AH_RA);
        shift           =getvalue(env_NaviSD_LDL_AH_shift);
        direction       =getvalue(env_NaviSD_LDL_AH_dir);
        transmitpos     =getvalue(env_NaviSD_LDL_AH_POS);
        indexsize       =getvalue(env_NaviSD_LDL_AH_IS);
        startelement    =getvalue(env_NaviSD_LDL_AH_start);
        elements        =getvalue(env_NaviSD_LDL_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
        {
            if(FORWARD==direction)  //forward-start
            {
                valid_startelement =0;                                                           

                if(NAV_LASTDESTLIST_ENTRIES <=elements) //1. more elements requested, than in array
                {
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<NAV_LASTDESTLIST_ENTRIES;i++)
                        {
                            if(0 !=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i =NAV_LASTDESTLIST_ENTRIES;
                        }
                    }
                    else
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if (shift ==FALSE)
                    {
                        for(i=0;i<elements;i++)
                        {
                            if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i =NAV_LASTDESTLIST_ENTRIES;
                        }
                    }
                    else 
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
            {   
                //searching for valid startelement
                for(i=(NAV_LASTDESTLIST_ENTRIES-1);i>=0;i--)
                {
                    if(0!=gLastDestList_ListEntryValidInformation[i])        //found valid startelement
                    {
                        valid_startelement =i;                                
                        i =0;                                                
                    }
                }
                        
                //searching for valid elements
                if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  =startelement;
                    valid_elements      =0;
                }
                else if(0==valid_startelement)                                
                    valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for(i=valid_startelement;i>=0;i--)
                    {
                        if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                    {
                        if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }                   
                }                                                            
            }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID                
        {
            //searching for valid startelement
            for(i=0;i<NAV_LASTDESTLIST_ENTRIES;i++)
            {
                if(gLastDestList_Pos[i] ==startelement)                        //found a valid element
                {                                       
                    if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                    {
                        if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement =i+1-2*direction;
                                                            
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gLastDestListLine_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
                    
                    else
                        valid_startelement =i;                              //found element is valid_startelement

                    i =NAV_LASTDESTLIST_ENTRIES;
                }
                else
                    valid_startelement =0xff;
            }

            if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
            {   
                valid_startelement  =startelement;
                valid_elements      =0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if(BACKWARD==direction)                                            //backward-start
                {
                    if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                        valid_elements=1;
                            
                    else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for(i=valid_startelement;i>=0;i--)
                        {
                            if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for(i=valid_startelement;i>(valid_startelement-elements);i--)
                        {
                            if(0!=gLastDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements)>=NAV_LASTDESTLIST_ENTRIES)
                    {
                        for(i=valid_startelement;i<NAV_LASTDESTLIST_ENTRIES;i++)
                        {
                            if(0!=gLastDestList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_LASTDESTLIST_ENTRIES;
                        }
                    }
                    else
                    {
                        for(i=valid_startelement;i<(valid_startelement+elements);i++)
                        {
                            if(0!=gLastDestList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_LASTDESTLIST_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue(env_NaviSD_LDL_AH_elements, valid_elements);

        //send StatusArray
        //MR 63667 11.07.2014 -TNLE with SA-button
        //LastDestList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    //MR 76047 
    if(!transSuppression)
        LastDestList_Request(Data_REQ, tnle, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

FavoriteDestList_Indication(dword Indication_array [], int datalength)
{
    byte mode, shift, direction, recordaddress, indexsize, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements, valid_elements, Offset;
    //MR 76047 
    int i=0, transSuppression;

    // Init local variables. 
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0xff;
    valid_elements          =0;
    transmitpos             =0;
    Offset                  =0;
    //MR 76047 
    transSuppression        = getvalue(env_NaviSD_FDL_StatusOFF);

        switch (Indication_array[2]) // indication
        {
            case DataGet_IND:
                if(getvalue(env_NaviSD_FDL_Error_on))
                {
                    FavoriteDestList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue(env_NaviSD_FDL_ErrorCode));
                }
                //MR 63336    02.07.2014
                else if( getvalue(env_NaviSD_FDL_Timeout) == TRUE)
                {
                /* NOP */
                }
                else
                {
                    //getData
                    gFavoriteDestList_ASGID =(gBAP_Indication[3] &0xF0) /0x10;
                    gFavoriteDestList_TAID  =gBAP_Indication[3] &0x0F;
            
                    /***ArrayHeader***/
                    mode            =(Indication_array[4] &0xF0) /0x10;
                    recordaddress   =Indication_array[4] &0x0F;
                    Offset =5;
                
                    // decode "mode-byte"
                    shift       =mode &0x01;
                    direction   =(mode &0x02)/0x02;
                    transmitpos =(mode &0x04)/0x04;
                    indexsize   =(mode &0x08)/0x08;              
            
                    if (indexsize)
                    {   
                        startelement =Indication_array[Offset];
                        Offset++;
                        startelement +=(Indication_array[Offset] *0x100);
                        Offset++;

                        elements =Indication_array[Offset];
                        Offset++;
                        elements +=(Indication_array[Offset] *0x100);
                        Offset++;
                    }
                    else
                    {   
                        startelement =Indication_array[Offset];
                        Offset++;

                        elements =Indication_array[Offset];
                        Offset++;
                    }   

                    requested_startelement =startelement;

                    /***Startelement=0***/
                    if(0==startelement) //Startelement-ID =0 -> start at first array-entry
                    {
                        if(FORWARD==direction)  //forward-start
                        {
                            valid_startelement =0;                                                           

                            if(NAV_FAVORITEDESTLIST_ENTRIES <=elements) //1. more elements requested, than in array
                            {
                                if (shift ==FALSE)  
                                {
                                    for(i=0;i<NAV_FAVORITEDESTLIST_ENTRIES;i++)
                                    {
                                        if(0 !=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i =NAV_FAVORITEDESTLIST_ENTRIES;
                                    }
                                }
                                else
                                {   
                                    valid_startelement  =startelement;
                                    valid_elements      =0;
                                }
                            }
                            else    //2. number of requested elements < elements in array
                            {
                                if (shift ==FALSE)
                                {
                                    for(i=0;i<elements;i++)
                                    {
                                        if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i =NAV_FAVORITEDESTLIST_ENTRIES;
                                    }
                                }
                                else
                                {
                                    valid_startelement  =startelement;
                                    valid_elements      =0;
                                }

                            }
                        }                                                               //forward ends

                        else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
                        {   
                            //searching for valid startelement
                            for(i=(NAV_FAVORITEDESTLIST_ENTRIES-1);i>=0;i--)
                            {
                                if(0!=gFavoriteDestList_ListEntryValidInformation[i])        //found valid startelement
                                {
                                    valid_startelement =i;                                
                                    i =0;                                                
                                }
                            }
                        
                            //searching for valid elements
                            if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                            {
                                valid_startelement  =startelement;
                                valid_elements      =0;
                            }
                            else if(0==valid_startelement)                                
                                valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                            else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                            {
                                for(i=valid_startelement;i>=0;i--)
                                {
                                    if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                        valid_elements++;                                //increment elements
                                    else                                                //no valid element, loop finished
                                        i=0;
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for(i=valid_startelement;i>(valid_startelement-elements);i--)
                                {
                                    if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                        valid_elements++;                                //increment elements
                                    else                                                //no valid element, loop finished
                                        i=0;
                                }
                                      
                            }                                                            
                        }                                                               //backward-end
                    }                                                                   //startelement ==0 -end

                    /***Startelement!=0***/
                    else                                                                //searching for Startelement-ID                
                    {
                        //searching for valid startelement
                        for(i=0;i<NAV_FAVORITEDESTLIST_ENTRIES;i++)
                        {
                            if(gFavoriteDestList_Pos[i] ==startelement)                        //found a valid element
                            {                                          
                                if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                                {
                                    if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                                        valid_startelement =i+1-2*direction;
                                                            
                                    else if(i==0 && BACKWARD==direction) 
                                        valid_startelement =gFavoriteDestListLine_sum;     //valid element is last element in Array                                                
                            
                                    else if(i==0 && FORWARD==direction) 
                                        valid_startelement =0;                          //valid element is first element in Array
                                }
                    
                                else
                                    valid_startelement =i;                              //found element is valid_startelement

                                i=NAV_FAVORITEDESTLIST_ENTRIES;
                            }
                        }

                        if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
                        {
                            valid_startelement  =startelement;
                            valid_elements      =0;
                        }
                        else                                                                //found valid entry for startelement in array
                        {
                            //verify number of valid elements
                            if(BACKWARD==direction)                                            //backward-start
                            {
                                if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                                    valid_elements=1;
                            
                                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                                {
                                    for(i=valid_startelement;i>=0;i--)
                                    {
                                        if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                                else                                                        //enougth array-elements available
                                {
                                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                                    {
                                        if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                            }                                                                //backward-end
                            else                                                            //forward-start
                            {
                                if((valid_startelement+elements)>=NAV_FAVORITEDESTLIST_ENTRIES)
                                {
                                    for(i=valid_startelement;i<NAV_FAVORITEDESTLIST_ENTRIES;i++)
                                    {
                                        if(0!=gFavoriteDestList_Pos[i])                            //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=NAV_FAVORITEDESTLIST_ENTRIES;
                                    }
                                }
                                else
                                {
                                    for(i=valid_startelement;i<(valid_startelement+elements);i++)
                                    {
                                        if(0!=gFavoriteDestList_Pos[i])                            //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=NAV_FAVORITEDESTLIST_ENTRIES;
                                    }
                                }
                            }
                        }
                    }

                    transmitpos =TRUE;
                    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                    //send StatusArray
            //MR 76047 
                    if(!transSuppression)
                    FavoriteDestList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                   
                   
                   //Panel
                   putvalue(env_NaviSD_FDL_ASGID,gFavoriteDestList_ASGID);
                   putvalue(env_NaviSD_FDL_TAID,gFavoriteDestList_TAID); 
                }
             break;
            
            case Error_IND:
                writelineEx(gError_Trace, 0, "FSG_NaviSD FavoriteDestList_Indication: received error, errorcode:0x%x", Indication_array[3]);
            break;

            default:
                writelineEx(gError_Trace, 0, "FSG_NaviSD FavoriteDestList_Indication: invalid indication %d", Indication_array[2]);
             break;
    }
}

FavoriteDestList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word FavoriteDestListLine;

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;
    
    shift               =0;
    direction           =0;
    transmitpos         =0;
    indexsize           =0;
    FavoriteDestListLine=0;
    current_element     =0;
    Offset              =0;

    // decode "mode-byte"
    shift       =mode &0x01;
    direction   =(mode &0x02)/0x02;
    transmitpos =(mode &0x04)/0x04;
    indexsize   =(mode &0x08)/0x08;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                //LSG-ID
    requestarray[1] =FctID_FavoriteDest_List;    //Fct.-ID
    requestarray[2] =request;                   //request type
    Offset =3;

    switch(request)
    {
        case Changed_REQ:

            /***ArrayHeader***/
            requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
            Offset++;
            
            if (indexsize)
            {   
                requestarray[Offset] =(requested_startelement &0x00FF);
                Offset++;
                requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
                Offset++;

                requestarray[Offset] =(elements &0x00FF);
                Offset++;
                requestarray[Offset] =((elements &0xFF00) /0x100);
                Offset++;
            }
            else
            {   
                requestarray[Offset] =requested_startelement;
                Offset++;

                requestarray[Offset] =elements;
                Offset++;
            }
            
            FavoriteDestListLine =startelement;
            
            if (getvalue(env_NaviSD_FDL_CA_switch)) //ArrayData
            {
                //copy data
                switch(recordaddress)
                {
                    case 0: //complete record
                        while(current_element <elements)
                        {
                            if(FavoriteDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD FavoriteDestList_Request: invalid FavoriteDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gFavoriteDestList_Pos[FavoriteDestListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gFavoriteDestList_Pos[FavoriteDestListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gFavoriteDestList_Pos[FavoriteDestListLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //POI_Type
                                requestarray[Offset] =gFavoriteDestList_POIType[FavoriteDestListLine];
                                Offset++;

                                //Description
                                requestarray[Offset] =strlen(gFavoriteDestList_Description[FavoriteDestListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gFavoriteDestList_Description[FavoriteDestListLine]);i++)
                                {
                                    requestarray[Offset] =gFavoriteDestList_Description[FavoriteDestListLine][i];    
                                    Offset++;
                                }
                            }
                            current_element++;
                            FavoriteDestListLine =FavoriteDestList_nextvalidLine(FavoriteDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 1: //Description
                        while(current_element <elements)
                        {
                            if(FavoriteDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD FavoriteDestList_Request: invalid FavoriteDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gFavoriteDestList_Pos[FavoriteDestListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gFavoriteDestList_Pos[FavoriteDestListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gFavoriteDestList_Pos[FavoriteDestListLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //Description
                                requestarray[Offset] =strlen(gFavoriteDestList_Description[FavoriteDestListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gFavoriteDestList_Description[FavoriteDestListLine]);i++)
                                {
                                    requestarray[Offset] =gFavoriteDestList_Description[FavoriteDestListLine][i];    
                                    Offset++;
                                }
                            }
                            current_element++;
                            FavoriteDestListLine =FavoriteDestList_nextvalidLine(FavoriteDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 2: //POI_Type
                        while(current_element <elements)
                        {
                            if(FavoriteDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD FavoriteDestList_Request: invalid FavoriteDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gFavoriteDestList_Pos[FavoriteDestListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gFavoriteDestList_Pos[FavoriteDestListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gFavoriteDestList_Pos[FavoriteDestListLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //POI_Type
                                requestarray[Offset] =gFavoriteDestList_POIType[FavoriteDestListLine];
                                Offset++;
                            }
                            current_element++;
                            FavoriteDestListLine =FavoriteDestList_nextvalidLine(FavoriteDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 15:
                        while(current_element <elements)
                        {
                            if(FavoriteDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD FavoriteDestList_Request: invalid FavoriteDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gFavoriteDestList_Pos[FavoriteDestListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gFavoriteDestList_Pos[FavoriteDestListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gFavoriteDestList_Pos[FavoriteDestListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            FavoriteDestListLine =FavoriteDestList_nextvalidLine(FavoriteDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    default:
                    write("NaviSD FavoriteDestList_Request: invalid recordaddress %d", recordaddress);
                    break;
                } //end switch "recordaddress"*/
            }
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); //new

        break; //end Changed_REQ
        
        case Data_REQ:
            //changes from Jran Karl (28.03.2012)
            //MR 63336    02.07.2014
            //if(getvalue(env_NaviSD_FDL_Timeout) != TRUE)
            if( /*getvalue(env_NaviSD_FDL_Timeout) != */ TRUE)
            {
            //VAGH-10511
            ASGID = gFavoriteDestList_ASGID;
            TAID = gFavoriteDestList_TAID;
                if(getvalue(env_NaviSD_FDL_ASGID_error) != FALSE)
                {
                    ASGID += 0x2;
                }
                if(getvalue(env_NaviSD_FDL_TAID_error) != FALSE)
                {
                    TAID += 0x02;
                }
    //end of changes from Jran Karl (28.03.2012)
                requestarray[Offset] =((ASGID *0x10) &0xF0) +(TAID &0x0F);    
                Offset++;
                requestarray[Offset] =gFavoriteDestList_TotalNumListElements;    
                Offset++;

            /***ArrayHeader***/
            requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
            Offset++;
            requestarray[Offset] =requested_startelement;
            Offset++;
            requestarray[Offset] =elements;
            Offset++;
            
            FavoriteDestListLine =startelement;
            
            //copy data
            switch(recordaddress)
            {
                case 0: //complete record
                        while(current_element <elements)
                        {
                            if(FavoriteDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD FavoriteDestList_Request: invalid FavoriteDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gFavoriteDestList_Pos[FavoriteDestListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gFavoriteDestList_Pos[FavoriteDestListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gFavoriteDestList_Pos[FavoriteDestListLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //POI_Type
                                requestarray[Offset] =gFavoriteDestList_POIType[FavoriteDestListLine];
                                Offset++;

                                //Description
                                requestarray[Offset] =strlen(gFavoriteDestList_Description[FavoriteDestListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gFavoriteDestList_Description[FavoriteDestListLine]);i++)
                                {
                                    requestarray[Offset] =gFavoriteDestList_Description[FavoriteDestListLine][i];    
                                    Offset++;
                                }
                            }
                            current_element++;
                            FavoriteDestListLine =FavoriteDestList_nextvalidLine(FavoriteDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 1: //Description
                        while(current_element <elements)
                        {
                            if(FavoriteDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD FavoriteDestList_Request: invalid FavoriteDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gFavoriteDestList_Pos[FavoriteDestListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gFavoriteDestList_Pos[FavoriteDestListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gFavoriteDestList_Pos[FavoriteDestListLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //Description
                                requestarray[Offset] =strlen(gFavoriteDestList_Description[FavoriteDestListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gFavoriteDestList_Description[FavoriteDestListLine]);i++)
                                {
                                    requestarray[Offset] =gFavoriteDestList_Description[FavoriteDestListLine][i];    
                                    Offset++;
                                }
                            }
                            current_element++;
                            FavoriteDestListLine =FavoriteDestList_nextvalidLine(FavoriteDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 2: //POI_Type
                        while(current_element <elements)
                        {
                            if(FavoriteDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD FavoriteDestList_Request: invalid FavoriteDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gFavoriteDestList_Pos[FavoriteDestListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gFavoriteDestList_Pos[FavoriteDestListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gFavoriteDestList_Pos[FavoriteDestListLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //POI_Type
                                requestarray[Offset] =gFavoriteDestList_POIType[FavoriteDestListLine];
                                Offset++;
                            }
                            current_element++;
                            FavoriteDestListLine =FavoriteDestList_nextvalidLine(FavoriteDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                case 15:
                        while(current_element <elements)
                        {
                            if(FavoriteDestListLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD FavoriteDestList_Request: invalid FavoriteDestListLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gFavoriteDestList_Pos[FavoriteDestListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gFavoriteDestList_Pos[FavoriteDestListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gFavoriteDestList_Pos[FavoriteDestListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            FavoriteDestListLine =FavoriteDestList_nextvalidLine(FavoriteDestListLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                 break;

                    default:
                        write("NaviSD FavoriteDestList_Request: invalid recordaddress %d", recordaddress);
                     break;
                } //end switch "recordaddress"
            //changes from Jran Karl (28.03.2012)
        }
            else
            {
                write("NaviSD FavoriteDestList_Request: Simulate timeout of Status-Array!");
            }
        //end of changes from Jran Karl (28.03.2012)
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
         break; //end Error_REQ
    
    } //end switch "request"   
}

byte FavoriteDestList_nextvalidLine (byte current_FavoriteDestListLine, byte direction)
{
    byte next_FavoriteDestListLine;
    int i;
         
    //init lokal variables
    next_FavoriteDestListLine  =0;
    i                          =0;

    //search next "list entry"
    if(((gFavoriteDestListLine_sum-1)==current_FavoriteDestListLine && FORWARD ==direction) || (0 ==current_FavoriteDestListLine && BACKWARD ==direction))    //Favorite-/fist-element of array reached
        next_FavoriteDestListLine =0xFF;
    else
    {
            next_FavoriteDestListLine =current_FavoriteDestListLine +1-2*direction;       //increment or decrement array-line (depends on direction);
                 
            //IssueList #71
            if (next_FavoriteDestListLine < NAV_FAVORITEDESTLIST_ENTRIES)
            {
            if(0 ==gFavoriteDestList_ListEntryValidInformation[next_FavoriteDestListLine])    // check if next element is "valid"
                next_FavoriteDestListLine =0xff;
             }                     
    }

    return(next_FavoriteDestListLine);
}

FavoriteDestList_init_CSV () //Byte & file selection
{
    int i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
    dword CSVfileHandle =0, ConfigFileHandle =0;
    char buffer_string[NAV_BUFFERSIZE], Path_CSV[NAV_BUFFERSIZE], Path_Config[NAV_BUFFERSIZE];
    byte FavoriteDestListLine =0, buffer_byte[NAV_BUFFERSIZE];
    char FavoriteDestList_Pos_string [NAV_FAVORITEDESTLIST_ENTRIES][NAV_TEXTLENGTH];           //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
    char FavoriteDestList_POIType_string [NAV_FAVORITEDESTLIST_ENTRIES][NAV_TEXTLENGTH];       //help value ->"POI_Type" is stored in the ASCII(UTF-8) code in the *.csv 

    if(getvalue(env_NaviSD_FDL_DataSource) == NAV_EXTERNAL_LIST) //output data in write window "FSGFavoriteDestList"  
    {
        writeClear(gFavoriteDestList_writeWindow);
        writelineEx(gFavoriteDestList_writeWindow, 0,"*******External FavoriteDest_List*******");
        writelineEx(gFavoriteDestList_writeWindow, 0, "");
        writelineEx(gFavoriteDestList_writeWindow, 0, "**********************Start load new FavoriteDest_List**********************");   
    
        for(j=0;j<NAV_FAVORITEDESTLIST_ENTRIES;j++) //clear "FavoriteDestList Array"
        {
            gFavoriteDestList_Pos[j]                        =0;
            gFavoriteDestList_POIType[j]                    =0;
            gFavoriteDestList_ListEntryValidInformation[j]  =FALSE;

            for(i=0;i<NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH;i++)
                gFavoriteDestList_Description[j][i]=0;           
        }

        for(i=0;i<NAV_FILENAME_SIZE; i++) //clear "filename"
            gFavoriteDestList_CSV_filename[i] =0;       
        
        for(j=0;j<NAV_FAVORITEDESTLIST_ENTRIES; j++) //clear "buffer"
        {
            buffer_string[j]    =0;
            buffer_byte[j]      =0;

            for(i=0;i<NAV_TEXTLENGTH;i++) //clear help value
            {
                FavoriteDestList_Pos_string[j][i]       =0;
                FavoriteDestList_POIType_string[j][i]   =0;
            }
        }        

        i =0; j =0; FavoriteDestListLine =0; current_CSV_line =0; //reset values 
                      
        getvalue(env_NaviSD_FDL_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
        
        //write("complete path *.csv: %s", Path_CSV); //debug
        
        i =0;

        while (Path_CSV[i] !=0) //scan "path"
        {
            if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
                count1++;                
            
            //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
            i++;
        }  
         
        i =0; j =0; //reset values

        while (Path_CSV[i] !=0) //seperate "path" and "filename"
        {
            if(count2==count1) //get filename after Favorite "\"
            {              
                gFavoriteDestList_CSV_filename[j] =Path_CSV[i];
                j++;

                Path_CSV[i] =0;              
            }

            if(Path_CSV[i]==0x5C) //count "\" to get filename after Favorite "\"            
                count2++;
                               
            i++;
        }

        writelineEx(gFavoriteDestList_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 

        writelineEx(gFavoriteDestList_writeWindow, 0,"filename of *.csv: '%s'", gFavoriteDestList_CSV_filename);  //output filename 

        putvalue(env_NaviSD_FDL_DataSource_file, gFavoriteDestList_CSV_filename); //output current loaded *.csv-file on panel

        setFilePath(Path_CSV, 0); //set path for *.csv file

        CSVfileHandle =openFileRead(gFavoriteDestList_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        

        if (CSVfileHandle!=0) //*.csv file access successful
        {
            writelineEx(gFavoriteDestList_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gFavoriteDestList_CSV_filename);    //output result  
            
            putvalue(env_NaviSD_FDL_DataSource_result, "successful");   //output result on panel                      
            
            Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
                           
            for (i=0; i<Num_of_csv_byte; i++) //copy data into "FavoriteDestList"
            {      
                if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
                {
                    if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in FavoriteDestList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                    {
                        if(current_CSV_line>0 && FavoriteDestListLine<NAV_FAVORITEDESTLIST_ENTRIES) //ignore first line in *.csv file
                        {   
                            writelineEx(gFavoriteDestList_writeWindow, 0, "");
                            writelineEx(gFavoriteDestList_writeWindow, 0,"*******Element %d*******",FavoriteDestListLine);

                            //transform 'string' to 'long' for "POS", "Type" and "Attributes"
                            gFavoriteDestList_Pos[FavoriteDestListLine]     =atol(FavoriteDestList_Pos_string[FavoriteDestListLine]);
                            gFavoriteDestList_POIType[FavoriteDestListLine] =atol(FavoriteDestList_POIType_string[FavoriteDestListLine]);                        
                            
                            writelineEx(gFavoriteDestList_writeWindow, 0,"Pos[%d]: 0x%x",FavoriteDestListLine, gFavoriteDestList_Pos[FavoriteDestListLine]);
                            
                            writelineEx(gFavoriteDestList_writeWindow, 0,"POI_Type[%d]: 0x%x",FavoriteDestListLine, gFavoriteDestList_POIType[FavoriteDestListLine]);
                            if(gFavoriteDestList_POIType[FavoriteDestListLine] <0xA0)
                                writeEx(gFavoriteDestList_writeWindow, 0," -> '%s'", gFavoriteDestList_POIType_s[gFavoriteDestList_POIType[FavoriteDestListLine]]);
        
                            else if (gFavoriteDestList_POIType[FavoriteDestListLine] ==0xFF)
                                writeEx(gFavoriteDestList_writeWindow, 0," -> '%s'", gstring_unknown);
                            else
                                writeEx(gFavoriteDestList_writeWindow, 0," -> '%s'", gstring_reserved);

                            writelineEx(gFavoriteDestList_writeWindow, 0,"Description[%d]: %s",FavoriteDestListLine, gFavoriteDestList_Description[FavoriteDestListLine]);                            
                            
                            gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
                                                
                            FavoriteDestListLine++; // -> next line in *.csv (next record element)
                        }

                        current_CSV_line++; //next line in *.csv file
                        element =0; //start at 'POS' (first record element of "array data")
                        j=0; //reset value
                    }
                      
                    else if(current_CSV_line>0 && FavoriteDestListLine<NAV_FAVORITEDESTLIST_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                    {
                        switch (element)
                        {
                            case 0: //POS
                                    FavoriteDestList_Pos_string[FavoriteDestListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //POIType
                                    FavoriteDestList_POIType_string[FavoriteDestListLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 2: //Description
                                    gFavoriteDestList_Description[FavoriteDestListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            default:
                             break;
                        }
                    }                               
                }
                               
                else  // ";" is detected ->next record element of "array data"
                {                                          
                    element++;
                    j=0; //reset value  
                }                                              
        
            }         
            
            gFavoriteDestList_TotalNumListElements =gFavoriteDestListLine_sum =FavoriteDestListLine; //get "total number of list elements"
            
            putvalue(env_NaviSD_FDL_TotalNumLE, gFavoriteDestList_TotalNumListElements);

            writelineEx(gFavoriteDestList_writeWindow, 0, "");

            writelineEx(gFavoriteDestList_writeWindow, 0,"Anzahl der Listenelemente: %d", gFavoriteDestListLine_sum); //output total number of list elements

            writelineEx(gFavoriteDestList_writeWindow, 0, "");

            if(fileClose (CSVfileHandle) !=0) //close *.csv file
                writelineEx(gFavoriteDestList_writeWindow, 0,"Datei '%s' geschlossen", gFavoriteDestList_CSV_filename); //output result
             
            else
                writelineEx(gFavoriteDestList_writeWindow, 0,"Fehler beim Schlieen der Datei '%s'", gFavoriteDestList_CSV_filename);//output result
        }

        else //*.csv file access not successful
        {
            writelineEx(gFavoriteDestList_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gFavoriteDestList_CSV_filename); //output result
            
            putvalue(env_NaviSD_FDL_DataSource_result,"not successful"); //output result
        }
    }
}

FavoriteDestList_init_static()
{
    byte j, i, FavoriteDestListLine;
    
    //clear
    FavoriteDestListLine   =0;
    gFavoriteDestListLine_sum  =0;

    for(j=0;j<NAV_FAVORITEDESTLIST_ENTRIES;j++) 
    {
        gFavoriteDestList_Pos[j]                        =0;
        gFavoriteDestList_POIType[j]                    =0;
        gFavoriteDestList_ListEntryValidInformation[j]  =0;

        for(i=0;i<NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH;i++)
            gFavoriteDestList_Description[j][i] =0;
    }
          
    //entry 0
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0x87;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_CARWASH;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_0",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;

    //entry 1
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0x14;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_NOPOI;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_1",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;

    //entry 2
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0x9D;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_COMMUNITYCENTER;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_2",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;
    
    //entry 3
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0x62;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_CEMETRY;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_3",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;
    
    //entry 4
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0x95;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_BORDERCROSS;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_4",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;

    //entry 5
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0x39;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_AUTOMOBILECLUB;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_5",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;

    //entry 6
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0xB4;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_ELECTRONICS;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_6",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;

    //entry 7
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0x47;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_GUESTHOUSE;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_7",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;

    //entry 8
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0xF6;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_INSURANCE;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_8",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;

    //entry 9
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0xC4;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_OPTICAL;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_9",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;

    //entry 10
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0x08;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_PHOTOGRAPHER;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_10",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;

    //entry 11
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0xE5;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_RESTAREA;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_11",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;

    //entry 12
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0xA2;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_TOOLBOOTH;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_12",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;

    //entry 13
    gFavoriteDestList_ListEntryValidInformation[FavoriteDestListLine]  =TRUE;
    gFavoriteDestList_Pos [FavoriteDestListLine]                       =0x61;
    gFavoriteDestList_POIType [FavoriteDestListLine]                   =NAV_FAVORITEDESTLIST_POITYPE_UTILITIES;
    strncpy(gFavoriteDestList_Description [FavoriteDestListLine], "Description_13",NAV_FAVORITEDESTLIST_DESCRIPTION_LENGTH);
    FavoriteDestListLine++;
    
    gFavoriteDestListLine_sum                   =FavoriteDestListLine;
    gFavoriteDestList_TotalNumListElements  =gFavoriteDestListLine_sum;

    //write Array in "write-window"
    /*
    writeClear(gFavoriteDestList_writeWindow);
    writelineEx(gFavoriteDestList_writeWindow, 0, "");
    writelineEx(gFavoriteDestList_writeWindow, 0,"*******Default FavoriteDestList_Array*******");
    writelineEx(gFavoriteDestList_writeWindow, 0, "");
    
    for (i=0;i<gFavoriteDestListLine_sum;i++)
    {
        writelineEx(gFavoriteDestList_writeWindow, 0,"*******Element %d*******",i);
        
        writelineEx(gFavoriteDestList_writeWindow, 0,"Pos[%d]: 0x%x", i, gFavoriteDestList_Pos [i]);
                     
        writelineEx(gFavoriteDestList_writeWindow, 0,"POI_Type[%d]: 0x%x",i, gFavoriteDestList_POIType[i]);
        if(gFavoriteDestList_POIType[i] <0xA0)
            writeEx(gFavoriteDestList_writeWindow, 0," -> '%s'", gFavoriteDestList_POIType_s[gFavoriteDestList_POIType[i]]);
        
        else if (gFavoriteDestList_POIType[i] ==0xFF)
            writeEx(gFavoriteDestList_writeWindow, 0," -> '%s'", gstring_unknown);
        else
            writeEx(gFavoriteDestList_writeWindow, 0," -> '%s'", gstring_reserved);
        
        writelineEx(gFavoriteDestList_writeWindow, 0,"Description[%d]: %s",i, gFavoriteDestList_Description[i]);

        writelineEx(gFavoriteDestList_writeWindow, 0, "");
    }

    writelineEx(gFavoriteDestList_writeWindow, 0,"Anzahl der Listenelemente: %d", gFavoriteDestListLine_sum);
    */
    putvalue(env_NaviSD_FDL_TotalNumLE, gFavoriteDestList_TotalNumListElements);
}

on envVar env_NaviSD_FDL_CA
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        if(getvalue(env_NaviSD_FDL_AH_start) >255 && getvalue(env_NaviSD_FDL_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_NaviSD_FDL_AH_IS,1);

        //get data from Panel
        recordaddress   =getvalue(env_NaviSD_FDL_AH_RA);
        shift           =getvalue(env_NaviSD_FDL_AH_shift);
        direction       =getvalue(env_NaviSD_FDL_AH_dir);
        transmitpos     =getvalue(env_NaviSD_FDL_AH_POS);
        indexsize       =getvalue(env_NaviSD_FDL_AH_IS);
        startelement    =getvalue(env_NaviSD_FDL_AH_start);
        elements        =getvalue(env_NaviSD_FDL_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        if (getvalue(env_NaviSD_FDL_CA_switch))
        {
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
        {
            if(FORWARD==direction)  //forward-start
            {
                valid_startelement =0;                                                           

                if(NAV_FAVORITEDESTLIST_ENTRIES <=elements) //1. more elements requested, than in array
                {
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<NAV_FAVORITEDESTLIST_ENTRIES;i++)
                        {
                            if(0 !=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i =NAV_FAVORITEDESTLIST_ENTRIES;
                        }
                    }
                    else
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if (shift ==FALSE)
                    {
                        for(i=0;i<elements;i++)
                        {
                            if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i =NAV_FAVORITEDESTLIST_ENTRIES;
                        }
                    }
                    else 
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }

                }
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the Favorite element of the array)
            {   
                //searching for valid startelement
                for(i=(NAV_FAVORITEDESTLIST_ENTRIES-1);i>=0;i--)
                {
                    if(0!=gFavoriteDestList_ListEntryValidInformation[i])        //found valid startelement
                    {
                        valid_startelement =i;                                
                        i =0;                                                
                    }
                }
                        
                //searching for valid elements
                if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  =startelement;
                    valid_elements      =0;
                }
                else if(0==valid_startelement)                                
                    valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for(i=valid_startelement;i>=0;i--)
                    {
                        if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                    {
                        if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }                   
                }                                                            
            }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID                
        {
            //searching for valid startelement
            for(i=0;i<NAV_FAVORITEDESTLIST_ENTRIES;i++)
            {
                if(gFavoriteDestList_Pos[i] ==startelement)                        //found a valid element
                {                                       
                    if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                    {
                        if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement =i+1-2*direction;
                                                            
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gFavoriteDestListLine_sum;     //valid element is Favorite element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
                    
                    else
                        valid_startelement =i;                              //found element is valid_startelement

                    i =NAV_FAVORITEDESTLIST_ENTRIES;
                }
                else
                    valid_startelement =0xff;
            }

            if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
            {   
                valid_startelement  =startelement;
                valid_elements      =0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if(BACKWARD==direction)                                            //backward-start
                {
                    if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                        valid_elements=1;
                            
                    else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for(i=valid_startelement;i>=0;i--)
                        {
                            if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for(i=valid_startelement;i>(valid_startelement-elements);i--)
                        {
                            if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements)>=NAV_FAVORITEDESTLIST_ENTRIES)
                    {
                        for(i=valid_startelement;i<NAV_FAVORITEDESTLIST_ENTRIES;i++)
                        {
                            if(0!=gFavoriteDestList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_FAVORITEDESTLIST_ENTRIES;
                        }
                    }
                    else
                    {
                        for(i=valid_startelement;i<(valid_startelement+elements);i++)
                        {
                            if(0!=gFavoriteDestList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_FAVORITEDESTLIST_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue(env_NaviSD_FDL_AH_elements, valid_elements);
        }
        else
        {
            valid_startelement      =startelement;
            valid_elements          =elements;
        }

        requested_startelement =startelement;

        FavoriteDestList_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

on envVar env_NaviSD_FDL_DataSource
{
    if (getvalue(this) ==NAV_DEFAULT_LIST)
    {
        FavoriteDestList_init_static();
        putvalue(env_NaviSD_FDL_DataSource_file, empty_string);
        putvalue(env_NaviSD_FDL_DataSource_result, empty_string);
    }
}

on envVar env_NaviSD_FDL_StatusArray
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    //MR 76047 
    int i, transSuppression;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;
    //MR 76047 
    transSuppression        = getvalue(env_NaviSD_FDL_StatusOFF);

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        if(getvalue(env_NaviSD_FDL_AH_start) >255 && getvalue(env_NaviSD_FDL_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_NaviSD_FDL_AH_IS,1);

        //get data from Panel
        gFavoriteDestList_ASGID                 =getvalue(env_NaviSD_FDL_ASGID);
        gFavoriteDestList_TAID                  =getvalue(env_NaviSD_FDL_TAID);
        
        //MR 63332 #3   02.07.2014
        //gFavoriteDestList_TotalNumListElements  =getvalue(env_NaviSD_FDL_TotalNumLE);

        recordaddress   =getvalue(env_NaviSD_FDL_AH_RA);
        shift           =getvalue(env_NaviSD_FDL_AH_shift);
        direction       =getvalue(env_NaviSD_FDL_AH_dir);
        transmitpos     =getvalue(env_NaviSD_FDL_AH_POS);
        indexsize       =getvalue(env_NaviSD_FDL_AH_IS);
        startelement    =getvalue(env_NaviSD_FDL_AH_start);
        elements        =getvalue(env_NaviSD_FDL_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
        {
            if(FORWARD==direction)  //forward-start
            {
                valid_startelement =0;                                                           

                if(NAV_FAVORITEDESTLIST_ENTRIES <=elements) //1. more elements requested, than in array
                {
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<NAV_FAVORITEDESTLIST_ENTRIES;i++)
                        {
                            if(0 !=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i =NAV_FAVORITEDESTLIST_ENTRIES;
                        }
                    }
                    else
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if (shift ==FALSE)
                    {
                        for(i=0;i<elements;i++)
                        {
                            if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i =NAV_FAVORITEDESTLIST_ENTRIES;
                        }
                    }
                    else 
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }

                }
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the Favorite element of the array)
            {   
                //searching for valid startelement
                for(i=(NAV_FAVORITEDESTLIST_ENTRIES-1);i>=0;i--)
                {
                    if(0!=gFavoriteDestList_ListEntryValidInformation[i])        //found valid startelement
                    {
                        valid_startelement =i;                                
                        i =0;                                                
                    }
                }
                        
                //searching for valid elements
                if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  =startelement;
                    valid_elements      =0;
                }
                else if(0==valid_startelement)                                
                    valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for(i=valid_startelement;i>=0;i--)
                    {
                        if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                    {
                        if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }                   
                }                                                            
            }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID                
        {
            //searching for valid startelement
            for(i=0;i<NAV_FAVORITEDESTLIST_ENTRIES;i++)
            {
                if(gFavoriteDestList_Pos[i] ==startelement)                        //found a valid element
                {                                       
                    if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                    {
                        if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement =i+1-2*direction;
                                                            
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gFavoriteDestListLine_sum;     //valid element is Favorite element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
                    
                    else
                        valid_startelement =i;                              //found element is valid_startelement

                    i =NAV_FAVORITEDESTLIST_ENTRIES;
                }
                else
                    valid_startelement =0xff;
            }

            if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
            {   
                valid_startelement  =startelement;
                valid_elements      =0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if(BACKWARD==direction)                                            //backward-start
                {
                    if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                        valid_elements=1;
                            
                    else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for(i=valid_startelement;i>=0;i--)
                        {
                            if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for(i=valid_startelement;i>(valid_startelement-elements);i--)
                        {
                            if(0!=gFavoriteDestList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements)>=NAV_FAVORITEDESTLIST_ENTRIES)
                    {
                        for(i=valid_startelement;i<NAV_FAVORITEDESTLIST_ENTRIES;i++)
                        {
                            if(0!=gFavoriteDestList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_FAVORITEDESTLIST_ENTRIES;
                        }
                    }
                    else
                    {
                        for(i=valid_startelement;i<(valid_startelement+elements);i++)
                        {
                            if(0!=gFavoriteDestList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_FAVORITEDESTLIST_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue(env_NaviSD_FDL_AH_elements, valid_elements);

        //send StatusArray
    //MR 76047 
        if(!transSuppression)
        FavoriteDestList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

on envVar env_NaviSD_FDL_reload //load external FavoriteDestList from *.csv
{
    if(getvalue(this) && getvalue(env_NaviSD_FDL_DataSource) ==NAV_EXTERNAL_LIST)
        FavoriteDestList_init_CSV();

    else if(getvalue(env_NaviSD_FDL_DataSource) != NAV_EXTERNAL_LIST)
        putvalue(env_NaviSD_FDL_DataSource_result,"not successful, select 'external *.csv'");
}

on envVar env_NaviSD_LG_reload //load external FavoriteDestList from *.csv
{
    if(getvalue(this) && getvalue(env_NaviSD_LG_DataSource) ==NAV_EXTERNAL_LIST)
        LaneGuidance_init_CSV();

    else if(getvalue(env_NaviSD_LG_DataSource) != NAV_EXTERNAL_LIST)
        putvalue(env_NaviSD_LG_DataSource_result,"not successful, select 'external *.csv'");
}

LaneGuidance_init_CSV () //Byte & file selection
{
    dword Num_of_csv_byte =0, element =0, LaneGuidanceLine =0, current_CSV_line =0, count1 =0, count2 =0, CSVfileHandle =0, ConfigFileHandle =0, i =0, j =0;
    char buffer_string[NAV_BUFFERSIZE], Path_CSV[NAV_BUFFERSIZE], Path_Config[NAV_BUFFERSIZE];
    byte buffer_byte[NAV_BUFFERSIZE];
    char LaneGuidance_Pos_string [NAV_LANEGUIDANCE_ENTRIES][NAV_TEXTLENGTH];                //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
    char LaneGuidance_LaneDirection_string [NAV_LANEGUIDANCE_ENTRIES][NAV_TEXTLENGTH];      //help value ->"LaneDirection" is stored in the ASCII(UTF-8) code in the *.csv 
    char LaneGuidance_LaneType_string [NAV_LANEGUIDANCE_ENTRIES][NAV_TEXTLENGTH];           //help value ->"LaneType" is stored in the ASCII(UTF-8) code in the *.csv   
    char LaneGuidance_LaneMarking_left_string [NAV_LANEGUIDANCE_ENTRIES][NAV_TEXTLENGTH];   //help value ->"LaneMarking_left" is stored in the ASCII(UTF-8) code in the *.csv 
    char LaneGuidance_LaneMarking_right_string [NAV_LANEGUIDANCE_ENTRIES][NAV_TEXTLENGTH];  //help value ->"LaneMarking_right" is stored in the ASCII(UTF-8) code in the *.csv 
    char LaneGuidance_LaneDescription_string [NAV_LANEGUIDANCE_ENTRIES][NAV_TEXTLENGTH];    //help value ->"LaneDescription" is stored in the ASCII(UTF-8) code in the *.csv   
    char LaneGuidance_GuidanceInfo_string [NAV_LANEGUIDANCE_ENTRIES][NAV_TEXTLENGTH];       //help value ->"GuidanceInfo" is stored in the ASCII(UTF-8) code in the *.csv 

    if(getvalue(env_NaviSD_LG_DataSource) == NAV_EXTERNAL_LIST) //output data in write window "FSGLaneGuidance"  
    {
        writeClear(gLaneGuidance_writeWindow);
        writelineEx(gLaneGuidance_writeWindow, 0,"*******External LaneGuidance*******");
        writelineEx(gLaneGuidance_writeWindow, 0, "");
        writelineEx(gLaneGuidance_writeWindow, 0, "**********************Start load new LaneGuidance**********************");   
    
        for(j=0;j<NAV_LANEGUIDANCE_ENTRIES;j++) //clear "LaneGuidance Array"
        {
            gLaneGuidance_Pos[j]                        =0;
            gLaneGuidance_LaneDirection[j]              =NAV_LANEGUIDANCE_STRAIGHT;
            gLaneGuidance_ListEntryValidInformation[j]  =FALSE;
            gLaneGuidance_LaneType[j]                   =NAV_LANETYPE_UNSPECIFIC;
            gLaneGuidance_LaneMarking_left[j]           =NAV_LANEMARKINGLEFT_NOLANE;
            gLaneGuidance_LaneMarking_right[j]          =NAV_LANEMARKINGRIGHT_NOLANE;
            gLaneGuidance_LaneDescription[j]            =NAV_LANEDESCRIPTION_AVAILABLE;
            gLaneGuidance_GuidanceInfo[j]               =NAV_GUIDANCEINFO_NOTRECOMMENDEDLANE;
            gLaneGuidance_ListEntryValidInformation[j]  =FALSE;
                
            for(i=0;i<NAV_LANESIDESTREETS_LENGTH;i++)
                gLaneGuidance_LaneSidestreets[j][i]=0;           
        }

        for(i=0;i<NAV_FILENAME_SIZE; i++) //clear "filename"
            gLaneGuidance_CSV_filename[i] =0;       
        
        for(j=0;j<NAV_LANEGUIDANCE_ENTRIES; j++) //clear "buffer"
        {
            buffer_string[j]    =0;
            buffer_byte[j]      =0;

            for(i=0;i<NAV_TEXTLENGTH;i++) //clear help value
            {
                LaneGuidance_Pos_string[j][i]                   =0;
                LaneGuidance_LaneDirection_string[j][i]         =0;  
                LaneGuidance_LaneType_string [j][i]             =0;
                LaneGuidance_LaneMarking_left_string [j][i]     =0;
                LaneGuidance_LaneMarking_right_string [j][i]    =0;
                LaneGuidance_LaneDescription_string [j][i]      =0;
                LaneGuidance_GuidanceInfo_string [j][i]         =0;
            }
        }        

        i =0; j =0; LaneGuidanceLine =0; current_CSV_line =0; //reset values 
                      
        getvalue(env_NaviSD_LG_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
        
        //write("complete path *.csv: %s", Path_CSV); //debug
        
        i =0;

        while (Path_CSV[i] !=0) //scan "path"
        {
            if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
                count1++;                
            
            //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
            i++;
        }  
         
        i =0; j =0; //reset values

        while (Path_CSV[i] !=0) //seperate "path" and "filename"
        {
            if(count2==count1) //get filename after last "\"
            {              
                gLaneGuidance_CSV_filename[j] =Path_CSV[i];
                j++;

                Path_CSV[i] =0;              
            }

            if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
                count2++;
                               
            i++;
        }

        writelineEx(gLaneGuidance_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 

        writelineEx(gLaneGuidance_writeWindow, 0,"filename of *.csv: '%s'", gLaneGuidance_CSV_filename);  //output filename 

        putvalue(env_NaviSD_LG_DataSource_file, gLaneGuidance_CSV_filename); //output current loaded *.csv-file on panel

        setFilePath(Path_CSV, 0); //set path for *.csv file

        CSVfileHandle =openFileRead(gLaneGuidance_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        

        if (CSVfileHandle!=0) //*.csv file access successful
        {
            writelineEx(gLaneGuidance_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gLaneGuidance_CSV_filename);    //output result  
            
            putvalue(env_NaviSD_LG_DataSource_result, "successful");   //output result on panel                      
            
            Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
            
            for (i=0; i<Num_of_csv_byte; i++) //copy data into "LaneGuidance"
            {                      
                if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
                {                    
                    if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in LaneGuidance) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                    {                                          
                        if(current_CSV_line>0 && LaneGuidanceLine<NAV_LANEGUIDANCE_ENTRIES) //ignore first line in *.csv file
                        {                                                          
                            writelineEx(gLaneGuidance_writeWindow, 0, "");
                            writelineEx(gLaneGuidance_writeWindow, 0,"*******Element %d*******",LaneGuidanceLine);

                            //transform 'string' to 'long' for "POS", "Type" and "Attributes"
                            gLaneGuidance_Pos[LaneGuidanceLine]                 =atol(LaneGuidance_Pos_string[LaneGuidanceLine]);
                            gLaneGuidance_LaneDirection[LaneGuidanceLine]       =atol(LaneGuidance_LaneDirection_string[LaneGuidanceLine]);                        
                            gLaneGuidance_LaneType[LaneGuidanceLine]            =atol(LaneGuidance_LaneType_string[LaneGuidanceLine]); 
                            gLaneGuidance_LaneMarking_left[LaneGuidanceLine]    =atol(LaneGuidance_LaneMarking_left_string[LaneGuidanceLine]);
                            gLaneGuidance_LaneMarking_right[LaneGuidanceLine]   =atol(LaneGuidance_LaneMarking_right_string[LaneGuidanceLine]);
                            gLaneGuidance_LaneDescription[LaneGuidanceLine]     =atol(LaneGuidance_LaneDescription_string[LaneGuidanceLine]);
                            gLaneGuidance_GuidanceInfo[LaneGuidanceLine]        =atol(LaneGuidance_GuidanceInfo_string[LaneGuidanceLine]);

                            writelineEx(gLaneGuidance_writeWindow, 0,"Pos[%d]: 0x%x",LaneGuidanceLine, gLaneGuidance_Pos[LaneGuidanceLine]);
                            
                            writelineEx(gLaneGuidance_writeWindow, 0,"LaneDirection[%d]: 0x%x",LaneGuidanceLine, gLaneGuidance_LaneDirection[LaneGuidanceLine]);
                            switch (gLaneGuidance_LaneDirection[LaneGuidanceLine])
                            {
                                case NAV_LANEGUIDANCE_STRAIGHT:
                                        writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_STRAIGHT);
                                break;

                                case NAV_LANEGUIDANCE_LEFT:
                                        writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_LEFT);
                                break;

                                case NAV_LANEGUIDANCE_BACK:
                                        writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_BACK);
                                break;

                                case NAV_LANEGUIDANCE_RIGHT:
                                        writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_RIGHT);
                                break;

                                default:             
                                break;
                            }
                            
                            writelineEx(gLaneGuidance_writeWindow, 0,"LaneSidestreets[%d]: %s",LaneGuidanceLine, gLaneGuidance_LaneSidestreets[LaneGuidanceLine]);
                            
                            writelineEx(gLaneGuidance_writeWindow, 0,"LaneType[%d]: 0x%x",LaneGuidanceLine, gLaneGuidance_LaneType[LaneGuidanceLine]);
                            if(gLaneGuidance_LaneType[LaneGuidanceLine] <0x19)
                                writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneType_s[gLaneGuidance_LaneType[LaneGuidanceLine]]);
                            else
                                writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gstring_reserved); 

                            writelineEx(gLaneGuidance_writeWindow, 0,"LaneMarking_left[%d]: 0x%x",LaneGuidanceLine, gLaneGuidance_LaneMarking_left[LaneGuidanceLine]);
                            if(gLaneGuidance_LaneMarking_left[LaneGuidanceLine] <0x3)
                                writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneMarking_left_s[gLaneGuidance_LaneMarking_left[LaneGuidanceLine]]);
                            else
                                writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gstring_reserved);

                            writelineEx(gLaneGuidance_writeWindow, 0,"LaneMarking_right[%d]: 0x%x",LaneGuidanceLine, gLaneGuidance_LaneMarking_right[LaneGuidanceLine]);
                            if(gLaneGuidance_LaneMarking_right[LaneGuidanceLine] <0x3)
                                writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneMarking_right_s[gLaneGuidance_LaneMarking_right[LaneGuidanceLine]]);
                            else
                                writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gstring_reserved);
   
                            writelineEx(gLaneGuidance_writeWindow, 0,"LaneDescription[%d]: 0x%x",LaneGuidanceLine, gLaneGuidance_LaneDescription[LaneGuidanceLine]);
                            if(gLaneGuidance_LaneDescription[LaneGuidanceLine] <0xA)
                                writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDescription_s[gLaneGuidance_LaneDescription[LaneGuidanceLine]]);
                            else if(gLaneGuidance_LaneDescription[LaneGuidanceLine] ==0xF)
                                writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gstring_not_supported);
                            else
                                writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gstring_reserved);

                            writelineEx(gLaneGuidance_writeWindow, 0,"GuidanceInfo[%d]: 0x%x",LaneGuidanceLine, gLaneGuidance_GuidanceInfo[LaneGuidanceLine]);
                            if(gLaneGuidance_GuidanceInfo[LaneGuidanceLine] <0x3)
                                writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_GuidanceInfo_s[gLaneGuidance_GuidanceInfo[LaneGuidanceLine]]);
                            else
                                writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gstring_reserved);                           
                            
                            gLaneGuidance_ListEntryValidInformation[LaneGuidanceLine]  =TRUE;
                                                
                            LaneGuidanceLine++; // -> next line in *.csv (next record element)
                        }

                        current_CSV_line++; //next line in *.csv file
                        element =0; //start at 'POS' (first record element of "array data")
                        j=0; //reset value
                    }
                      
                    else if(current_CSV_line>0 && LaneGuidanceLine<NAV_LANEGUIDANCE_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                    {                          
                        switch (element)
                        {
                            case 0: //POS
                                    LaneGuidance_Pos_string[LaneGuidanceLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //LaneDirection
                                    LaneGuidance_LaneDirection_string[LaneGuidanceLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 2: //Sidestreets
                                    gLaneGuidance_LaneSidestreets[LaneGuidanceLine][j] =buffer_byte[i];
                                    j++;                                
                             break;
                            
                            case 3: //LaneType
                                    LaneGuidance_LaneType_string[LaneGuidanceLine][j] =buffer_byte[i];
                                    j++;                                
                             break;
                            
                            case 4: //LaneMarking_left
                                    LaneGuidance_LaneMarking_left_string[LaneGuidanceLine][j] =buffer_byte[i];
                                    j++;                                
                             break;
                            
                            case 5: //LaneMarking_right
                                    LaneGuidance_LaneMarking_right_string[LaneGuidanceLine][j] =buffer_byte[i];
                                    j++;                                
                             break;
                            
                            case 6: //LaneDescription
                                    LaneGuidance_LaneDescription_string[LaneGuidanceLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 7: //GuidanceInfo
                                    LaneGuidance_GuidanceInfo_string[LaneGuidanceLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            default:
                             break;
                        }
                    }                      
                }
                               
                else  // ";" is detected ->next record element of "array data"
                {                          
                    element++;
                    j=0; //reset value  
                }                                              
            }         

            gLaneGuidanceLine_sum =LaneGuidanceLine;            

            writelineEx(gLaneGuidance_writeWindow, 0, "");

            writelineEx(gLaneGuidance_writeWindow, 0,"Anzahl der Listenelemente: %d", gLaneGuidanceLine_sum); //output total number of list elements

            writelineEx(gLaneGuidance_writeWindow, 0, "");

            if(fileClose (CSVfileHandle) !=0) //close *.csv file
                writelineEx(gLaneGuidance_writeWindow, 0,"Datei '%s' geschlossen", gLaneGuidance_CSV_filename); //output result
             
            else
                writelineEx(gLaneGuidance_writeWindow, 0,"Fehler beim Schlieen der Datei '%s'", gLaneGuidance_CSV_filename);//output result
        //IssueList #54
        putValue(env_NaviSD_LG_AH_elements, gLaneGuidanceLine_sum);
        }

        else //*.csv file access not successful
        {
            writelineEx(gLaneGuidance_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gLaneGuidance_CSV_filename); //output result
            
            putvalue(env_NaviSD_LG_DataSource_result,"not successful"); //output result
        }
    }
}

on envVar env_NaviSD_LG_DataSource
{
    if (getvalue(this) ==NAV_DEFAULT_LIST)
    {
        LaneGuidance_init_static();
        putvalue(env_NaviSD_LG_DataSource_file, empty_string);
        putvalue(env_NaviSD_LG_DataSource_result, empty_string);
    }
}

NavBook_Indication(dword Indication_array [], int datalength)
{
    byte mode, shift, direction, recordaddress, indexsize, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements, valid_elements, Offset;
    //MR 76047 
    int i=0, transSuppression;

    // Init local variables. 
    mode                    =0;
    direction               =0;
    shift                   =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    indexsize               =0;
    valid_startelement      =0xff;
    valid_elements          =0;
    transmitpos             =0;
    Offset                  =0;
    //MR 76047 
    transSuppression        = getvalue(env_NaviSD_NB_StatusOFF);
    
        switch (Indication_array[2]) // indication
        {
            case DataGet_IND:
                if(getvalue(env_NaviSD_NB_Error_on))
                {
                    NavBook_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue(env_NaviSD_NB_ErrorCode));
                }
                //MR 63336    02.07.2014
                else if ( getValue(env_NaviSD_FctList_0x20_TimeOut)== TRUE)
                {
                /* NOP */
                }
                else
                {
                    //getData
                    gNavBook_ASGID =(gBAP_Indication[3] &0xF0) /0x10;
                    gNavBook_TAID  =gBAP_Indication[3] &0x0F;
            
                    /***ArrayHeader***/
                    mode            =(Indication_array[4] &0xF0) /0x10;
                    recordaddress   =Indication_array[4] &0x0F;
                    Offset =5;
                
                    // decode "mode-byte"
                    shift       =mode &0x01;
                    direction   =(mode &0x02)/0x02;
                    transmitpos =(mode &0x04)/0x04;
                    indexsize   =(mode &0x08)/0x08;              
            
                    if (indexsize)
                    {   
                        startelement =Indication_array[Offset];
                        Offset++;
                        startelement +=(Indication_array[Offset] *0x100);
                        Offset++;

                        elements =Indication_array[Offset];
                        Offset++;
                        elements +=(Indication_array[Offset] *0x100);
                        Offset++;
                    }
                    else
                    {   
                        startelement =Indication_array[Offset];
                        Offset++;

                        elements =Indication_array[Offset];
                        Offset++;
                    }   

                    requested_startelement =startelement;

                    /***Startelement=0***/
                    if(0==startelement) //Startelement-ID =0 -> start at first array-entry
                    {
                        if(FORWARD==direction)  //forward-start
                        {
                            valid_startelement =0;                                                           

                            if(NAV_NAVBOOK_ENTRIES <=elements) //1. more elements requested, than in array
                            {
                                if (shift ==FALSE)  
                                {
                                    for(i=0;i<NAV_NAVBOOK_ENTRIES;i++)
                                    {
                                        if(0 !=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i =NAV_NAVBOOK_ENTRIES;
                                    }
                                }
                                else
                                {   
                                    valid_startelement  =startelement;
                                    valid_elements      =0;
                                }
                            }
                            else    //2. number of requested elements < elements in array
                            {
                                if (shift ==FALSE)
                                {
                                    for(i=0;i<elements;i++)
                                    {
                                        if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i =NAV_NAVBOOK_ENTRIES;
                                    }   
                                }
                                else
                                {
                                    valid_startelement  =startelement;
                                    valid_elements      =0;
                                }
                            }
                        }                                                               //forward ends

                        else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
                        {   
                            //searching for valid startelement
                            for(i=(NAV_NAVBOOK_ENTRIES-1);i>=0;i--)
                            {
                                if(0!=gNavBook_ListEntryValidInformation[i])        //found valid startelement
                                {
                                    valid_startelement =i;                                
                                    i =0;                                                
                                }
                            }
                        
                            //searching for valid elements
                            if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                            {
                                valid_startelement  =startelement;
                                valid_elements      =0;
                            }
                            else if(0==valid_startelement)                                
                                valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                            else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                            {
                                for(i=valid_startelement;i>=0;i--)
                                {
                                    if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                        valid_elements++;                                //increment elements
                                    else                                                //no valid element, loop finished
                                        i=0;
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for(i=valid_startelement;i>(valid_startelement-elements);i--)
                                {
                                    if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                        valid_elements++;                                //increment elements
                                    else                                                //no valid element, loop finished
                                        i=0;
                                }                
                            }                                                            
                        }                                                               //backward-end
                    }                                                                   //startelement ==0 -end

                    /***Startelement!=0***/
                    else                                                                //searching for Startelement-ID                
                    {
                        //searching for valid startelement
                        for(i=0;i<NAV_NAVBOOK_ENTRIES;i++)
                        {
                            if(gNavBook_Pos[i] ==startelement)                        //found a valid element
                            {                                          
                                if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                                {
                                    if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                                        valid_startelement =i+1-2*direction;
                                                            
                                    else if(i==0 && BACKWARD==direction) 
                                        valid_startelement =gNavBookLine_sum;     //valid element is last element in Array                                                
                            
                                    else if(i==0 && FORWARD==direction) 
                                        valid_startelement =0;                          //valid element is first element in Array
                                }
                    
                                else
                                    valid_startelement =i;                              //found element is valid_startelement

                                i=NAV_NAVBOOK_ENTRIES;
                            }
                        }

                        if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
                        {
                            valid_startelement  =startelement;
                            valid_elements      =0;
                        }
                        else                                                                //found valid entry for startelement in array
                        {
                            //verify number of valid elements
                            if(BACKWARD==direction)                                            //backward-start
                            {
                                if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                                    valid_elements=1;
                            
                                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                                {
                                    for(i=valid_startelement;i>=0;i--)
                                    {
                                        if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                                else                                                        //enougth array-elements available
                                {
                                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                                    {
                                        if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                            }                                                                //backward-end
                            else                                                            //forward-start
                            {
                                if((valid_startelement+elements)>=NAV_NAVBOOK_ENTRIES)
                                {
                                    for(i=valid_startelement;i<NAV_NAVBOOK_ENTRIES;i++)
                                    {
                                        if(0!=gNavBook_Pos[i])                            //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=NAV_NAVBOOK_ENTRIES;
                                    }
                                }
                                else
                                {
                                    for(i=valid_startelement;i<(valid_startelement+elements);i++)
                                    {
                                        if(0!=gNavBook_Pos[i])                            //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i=NAV_NAVBOOK_ENTRIES;
                                    }
                                }
                            }
                        }
                    }
                
                    transmitpos =TRUE;
                    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                    //send StatusArray
            //MR 76047 
                    if(!transSuppression)
                    NavBook_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                   
                    
                    //Panel
                   putvalue(env_NaviSD_NB_ASGID,gNavBook_ASGID);
                   putvalue(env_NaviSD_NB_TAID,gNavBook_TAID);
                   } 
             break;
            
            case Error_IND:
                writelineEx(gError_Trace, 0, "FSG_NaviSD NavBook_Indication: received error, errorcode:0x%x", Indication_array[3]);
            break;

            default:
                writelineEx(gError_Trace, 0, "FSG_NaviSD NavBook_Indication: invalid indication %d", Indication_array[2]);
             break;
    }
}

NavBook_init_static()
{
    byte j, i, NavBookLine;
    
    //clear
    NavBookLine       =0;
    gNavBookLine_sum  =0;

    for(j=0;j<NAV_NAVBOOK_ENTRIES;j++) 
    {
        gNavBook_Pos[j]                        =0;
        gNavBook_ListEntryValidInformation[j]  =0;

        for(i=0;i<NAV_NAVBOOK_LASTNAME_LENGTH;i++)
            gNavBook_LastName[j][i] =0;
        
        for(i=0;i<NAV_NAVBOOK_FIRSTNAME_LENGTH;i++)
            gNavBook_FirstName[j][i] =0;
    }
          
    //entry 0
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xFA;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_0",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_0",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 1
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x08;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_1",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_1",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 2
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x41;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_2",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_2",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 3
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x85;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_3",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_3",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 4
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x07;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_4",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_4",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 5
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x09;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_5",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_5",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 6
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xEB;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_6",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_6",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 7
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xE4;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_7",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_7",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 8
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xB8;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_8",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_8",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 9
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x97;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_9",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_9",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 10
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x57;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_10",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_10",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 11
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x71;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_11",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_11",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 12
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xF9;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_12",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_12",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 13
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xF2;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_13",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_13",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 14
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xA99;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_14",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_14",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 15
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xB78;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_15",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_15",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 16
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xFAA;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_16",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_16",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 17
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x5281;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_17",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_17",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 18
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xF286;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_18",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_18",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 19
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x7924;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_19",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_19",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 20
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xFA3E;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_20",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_20",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 21
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x712D;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_21",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_21",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 22
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xDEFA;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_22",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_22",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 23
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x748A;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_23",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_23",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 24
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xBA16;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_24",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_24",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 25
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x9009;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_25",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_25",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 26
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x5374;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_26",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_26",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 27
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xC36F;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_27",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_27",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 28
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0xCAB2;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_28",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_28",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;

    //entry 29
    gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
    gNavBook_Pos [NavBookLine]                       =0x8765;
    strncpy(gNavBook_LastName [NavBookLine], "LastName_29",NAV_NAVBOOK_LASTNAME_LENGTH);
    strncpy(gNavBook_FirstName [NavBookLine], "FirstName_29",NAV_NAVBOOK_FIRSTNAME_LENGTH);
    NavBookLine++;
    
    
    gNavBookLine_sum               =NavBookLine;
    gNavBook_TotalNumListElements  =gNavBookLine_sum;

    //write Array in "write-window"
    /*
    writeClear(gNavBook_writeWindow);
    writelineEx(gNavBook_writeWindow, 0, "");
    writelineEx(gNavBook_writeWindow, 0,"*******Default NavBook_Array*******");
    writelineEx(gNavBook_writeWindow, 0, "");
    
    for (i=0;i<gNavBookLine_sum;i++)
    {
        writelineEx(gNavBook_writeWindow, 0,"*******Element %d*******",i);
        
        writelineEx(gNavBook_writeWindow, 0,"Pos[%d]: 0x%x", i, gNavBook_Pos [i]);
                     
        writelineEx(gNavBook_writeWindow, 0,"LastName[%d]: %s",i, gNavBook_LastName[i]);

        writelineEx(gNavBook_writeWindow, 0,"FirstName[%d]: %s",i, gNavBook_FirstName[i]);

        writelineEx(gNavBook_writeWindow, 0, "");
    }

    writelineEx(gNavBook_writeWindow, 0,"Anzahl der Listenelemente: %d", gNavBookLine_sum);
    */
    putvalue(env_NaviSD_NB_TotalNumLE, gNavBook_TotalNumListElements);
}

NavBook_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize;
    word NavBookLine, current_element, Offset;
    
    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;
    
    shift               =0;
    direction           =0;
    transmitpos         =0;
    indexsize           =0;
    NavBookLine         =0;
    current_element     =0;
    Offset              =0;

    // decode "mode-byte"
    shift       =mode &0x01;
    direction   =(mode &0x02)/0x02;
    transmitpos =(mode &0x04)/0x04;
    indexsize   =(mode &0x08)/0x08;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                //LSG-ID
    requestarray[1] =FctID_NavBook      ;        //Fct.-ID
    requestarray[2] =request;                   //request type
    Offset =3;

    switch(request)
    {
        case Changed_REQ:

            /***ArrayHeader***/
            requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
            Offset++;
            
            if (indexsize)
            {   
                requestarray[Offset] =(requested_startelement &0x00FF);
                Offset++;
                requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
                Offset++;

                requestarray[Offset] =(elements &0x00FF);
                Offset++;
                requestarray[Offset] =((elements &0xFF00) /0x100);
                Offset++;
            }
            else
            {   
                requestarray[Offset] =requested_startelement;
                Offset++;

                requestarray[Offset] =elements;
                Offset++;
            }
            NavBookLine =startelement;

            
            if (getvalue(env_NaviSD_NB_CA_switch)) //ArrayData
            {
                //check, if startelement in array   
                if(requested_startelement !=0)
                {
                    for(i=0;i<NAV_NAVBOOK_ENTRIES;i++)
                    {
                        if(gNavBook_Pos[i] ==requested_startelement)
                        {
                            NavBookLine =i;    
                            i=NAV_NAVBOOK_ENTRIES; 
                        }
                        else
                            NavBookLine =0xff;
                    }
                }

                //copy data
                switch(recordaddress)
                {
                    case 0: //complete record
                        while(current_element <elements)
                        {
                            if(NavBookLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD NavBook_Request: invalid NavBookLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gNavBook_Pos[NavBookLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gNavBook_Pos[NavBookLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gNavBook_Pos[NavBookLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //LastName
                                requestarray[Offset] =strlen(gNavBook_LastName[NavBookLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gNavBook_LastName[NavBookLine]);i++)
                                {
                                    requestarray[Offset] =gNavBook_LastName[NavBookLine][i];    
                                    Offset++;
                                }

                                //FirstName
                                requestarray[Offset] =strlen(gNavBook_FirstName[NavBookLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gNavBook_FirstName[NavBookLine]);i++)
                                {
                                    requestarray[Offset] =gNavBook_FirstName[NavBookLine][i];    
                                    Offset++;
                                }
                            }
                            current_element++;
                            NavBookLine =NavBook_nextvalidLine(NavBookLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 1: //LastName
                        while(current_element <elements)
                        {
                            if(NavBookLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD NavBook_Request: invalid NavBookLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gNavBook_Pos[NavBookLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gNavBook_Pos[NavBookLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gNavBook_Pos[NavBookLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                                //LastName
                                requestarray[Offset] =strlen(gNavBook_LastName[NavBookLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gNavBook_LastName[NavBookLine]);i++)
                                {
                                    requestarray[Offset] =gNavBook_LastName[NavBookLine][i];    
                                    Offset++;
                                }
                            }
                            current_element++;
                            NavBookLine =NavBook_nextvalidLine(NavBookLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 2: //FirstName
                        while(current_element <elements)
                        {
                            if(NavBookLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD NavBook_Request: invalid NavBookLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gNavBook_Pos[NavBookLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gNavBook_Pos[NavBookLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gNavBook_Pos[NavBookLine];
                                        Offset++;
                                    }
                                }

                                //FirstName
                                requestarray[Offset] =strlen(gNavBook_FirstName[NavBookLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gNavBook_FirstName[NavBookLine]);i++)
                                {
                                    requestarray[Offset] =gNavBook_FirstName[NavBookLine][i];    
                                    Offset++;
                                }
                            }
                            current_element++;
                            NavBookLine =NavBook_nextvalidLine(NavBookLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;

                    case 15:
                        while(current_element <elements)
                        {
                            if(NavBookLine ==0xff) //Invalid "list entry"
                            {
                                write("NaviSD NavBook_Request: invalid NavBookLine");
                                current_element =elements;
                            }
                            else //"list entry" valid
                            {   
                                /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gNavBook_Pos[NavBookLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gNavBook_Pos[NavBookLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gNavBook_Pos[NavBookLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            NavBookLine =NavBook_nextvalidLine(NavBookLine, direction);
                            
                        }//end while

                        set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                    break;
                    }//end switch   */
                }
                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);  
                          
        break; //end Changed_REQ
        
        case Data_REQ:
            //IssueList #62
            //MR 63336    02.07.2014
            //if (getValue(env_NaviSD_FctList_0x20_TimeOut)!=TRUE)
        if ( /*getValue(env_NaviSD_FctList_0x20_TimeOut)!= */ TRUE)
            {
            //VAGH-10511
            ASGID = gNavBook_ASGID;
            TAID = gNavBook_TAID;
                if(getvalue(env_NaviSD_NB_ASGID_error) != FALSE)
                {
                    ASGID += 0x2;
                }
                if(getvalue(env_NaviSD_NB_TAID_error) != FALSE)
                {
                    TAID += 0x02;
                }
                
                requestarray[Offset] =((ASGID *0x10) &0xF0) +(TAID &0x0F);    
                Offset++;
                requestarray[Offset] =(gNavBook_TotalNumListElements &0x00FF);    
                Offset++;
                requestarray[Offset] =((gNavBook_TotalNumListElements &0xFF00) /0x100);    
                Offset++;

                /***ArrayHeader***/
                requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
                Offset++;
                        
                if (indexsize)
                {   
                    requestarray[Offset] =(requested_startelement &0x00FF);
                    Offset++;
                    requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
                    Offset++;

                    requestarray[Offset] =(elements &0x00FF);
                    Offset++;
                    requestarray[Offset] =((elements &0xFF00) /0x100);
                    Offset++;
                }
                else
                {   
                    requestarray[Offset] =requested_startelement;
                    Offset++;

                    requestarray[Offset] =elements;
                    Offset++;
                }

                NavBookLine =startelement;

                //copy data
                switch(recordaddress)
                {
                    case 0: //complete record
                            while(current_element <elements)
                            {
                                if(NavBookLine ==0xff) //Invalid "list entry"
                                {
                                    write("NaviSD NavBook_Request: invalid NavBookLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gNavBook_Pos[NavBookLine] &0x00FF);
                                            Offset++;
                                            requestarray[Offset] =((gNavBook_Pos[NavBookLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gNavBook_Pos[NavBookLine];
                                            Offset++;
                                        }
                                    }
                                                                                              
                                    //LastName
                                    requestarray[Offset] =strlen(gNavBook_LastName[NavBookLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gNavBook_LastName[NavBookLine]);i++)
                                    {
                                        requestarray[Offset] =gNavBook_LastName[NavBookLine][i];    
                                        Offset++;
                                    }

                                    //FirstName
                                    requestarray[Offset] =strlen(gNavBook_FirstName[NavBookLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gNavBook_FirstName[NavBookLine]);i++)
                                    {
                                        requestarray[Offset] =gNavBook_FirstName[NavBookLine][i];    
                                        Offset++;
                                    }
                                }
                                current_element++;
                                NavBookLine =NavBook_nextvalidLine(NavBookLine, direction);
                            
                            }//end while

                            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                     break;

                    case 1: //LastName
                            while(current_element <elements)
                            {
                                if(NavBookLine ==0xff) //Invalid "list entry"
                                {
                                    write("NaviSD NavBook_Request: invalid NavBookLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gNavBook_Pos[NavBookLine] &0x00FF);
                                            Offset++;
                                            requestarray[Offset] =((gNavBook_Pos[NavBookLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gNavBook_Pos[NavBookLine];
                                            Offset++;
                                        }
                                    }
                                                                                              
                                    //LastName
                                    requestarray[Offset] =strlen(gNavBook_LastName[NavBookLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gNavBook_LastName[NavBookLine]);i++)
                                    {
                                        requestarray[Offset] =gNavBook_LastName[NavBookLine][i];    
                                        Offset++;
                                    }
                                }
                                current_element++;
                                NavBookLine =NavBook_nextvalidLine(NavBookLine, direction);
                            
                            }//end while

                            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                     break;

                    case 2: //FirstName
                            while(current_element <elements)
                            {
                                if(NavBookLine ==0xff) //Invalid "list entry"
                                {
                                    write("NaviSD NavBook_Request: invalid NavBookLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gNavBook_Pos[NavBookLine] &0x00FF);
                                            Offset++;
                                            requestarray[Offset] =((gNavBook_Pos[NavBookLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gNavBook_Pos[NavBookLine];
                                            Offset++;
                                        }
                                    }

                                    //FirstName
                                    requestarray[Offset] =strlen(gNavBook_FirstName[NavBookLine]);
                                    Offset++;
                                
                                    for(i=0;i<strlen(gNavBook_FirstName[NavBookLine]);i++)
                                    {
                                        requestarray[Offset] =gNavBook_FirstName[NavBookLine][i];    
                                        Offset++;
                                    }
                                }
                                current_element++;
                                NavBookLine =NavBook_nextvalidLine(NavBookLine, direction);
                            
                            }//end while

                            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                     break;

                    case 15:
                            while(current_element <elements)
                            {
                                if(NavBookLine ==0xff) //Invalid "list entry"
                                {
                                    write("NaviSD NavBook_Request: invalid NavBookLine");
                                    current_element =elements;
                                }
                                else //"list entry" valid
                                {   
                                    /***Array Data***/
                                    if (transmitpos) // Pos  ->Array position transmitted
                                    {
                                        if (indexsize)
                                        {
                                            requestarray[Offset] =(gNavBook_Pos[NavBookLine] &0x00FF);
                                            Offset++;
                                            requestarray[Offset] =((gNavBook_Pos[NavBookLine]&0xFF00) /0x100);
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] =gNavBook_Pos[NavBookLine];
                                            Offset++;
                                        }
                                    }
                                }
                                current_element++;
                                NavBookLine =NavBook_nextvalidLine(NavBookLine, direction);
                            
                            }//end while

                            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
                     break;

                    default:
                        write("NaviSD NavBook_Request: invalid recordaddress %d", recordaddress);
                     break;
                } //end switch "recordaddress"
            }//end if for IssueList #62
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
         break; //end Error_REQ
    
    } //end switch "request"   
}

byte NavBook_nextvalidLine (byte current_NavBookLine, byte direction)
{
    byte next_NavBookLine;
    int i;
         
    //init lokal variables
    next_NavBookLine  =0;
    i                      =0;

    //search next "list entry"
    if(((gNavBookLine_sum-1)==current_NavBookLine && FORWARD ==direction) || (0 ==current_NavBookLine && BACKWARD ==direction))    //last-/fist-element of array reached
        next_NavBookLine =0xFF;
    else
    {
            next_NavBookLine =current_NavBookLine +1-2*direction;       //increment or decrement array-line (depends on direction);
                 
            //IssueList #71
            if (next_NavBookLine < NAV_NAVBOOK_ENTRIES)
            {
            if(0 ==gNavBook_ListEntryValidInformation[next_NavBookLine])    // check if next element is "valid"
                next_NavBookLine =0xff; 
            }                    
    }

    return(next_NavBookLine);
}

NavBook_init_CSV () //Byte & file selection
{
    dword CSVfileHandle =0, ConfigFileHandle =0, i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
    char buffer_string[NAV_BUFFERSIZE], Path_CSV[NAV_BUFFERSIZE], Path_Config[NAV_BUFFERSIZE];
    byte NavBookLine =0, buffer_byte[NAV_BUFFERSIZE];
    char NavBook_Pos_string [NAV_NAVBOOK_ENTRIES][NAV_TEXTLENGTH];           //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
    
    if(getvalue(env_NaviSD_NB_DataSource) == NAV_EXTERNAL_LIST) //output data in write window "FSGNavBook"  
    {
        writeClear(gNavBook_writeWindow);
        writelineEx(gNavBook_writeWindow, 0,"*******External NavBook_List*******");
        writelineEx(gNavBook_writeWindow, 0, "");
        writelineEx(gNavBook_writeWindow, 0, "**********************Start load new NavBook_List**********************");   
    
        for(j=0;j<NAV_NAVBOOK_ENTRIES;j++) //clear "NavBook Array"
        {
            gNavBook_ListEntryValidInformation[j]  =FALSE;

            gNavBook_Pos[j] =0;

            for(i=0;i<NAV_NAVBOOK_LASTNAME_LENGTH;i++)
                gNavBook_LastName[j][i]=0;
            
            for(i=0;i<NAV_NAVBOOK_FIRSTNAME_LENGTH;i++)
                gNavBook_FirstName[j][i]=0;            
        }

        for(i=0;i<NAV_FILENAME_SIZE; i++) //clear "filename"
            gNavBook_CSV_filename[i] =0;       
        
        for(j=0;j<NAV_NAVBOOK_ENTRIES; j++) //clear "buffer"
        {
            buffer_string[j]    =0;
            buffer_byte[j]      =0;

            for(i=0;i<NAV_TEXTLENGTH;i++) //clear help value
                NavBook_Pos_string[j][i]       =0;
        }        

        i =0; j =0; NavBookLine =0; current_CSV_line =0; //reset values 
                      
        getvalue(env_NaviSD_NB_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
        
        //write("complete path *.csv: %s", Path_CSV); //debug
        
        i =0;

        while (Path_CSV[i] !=0) //scan "path"
        {
            if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
                count1++;                
            
            //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
            i++;
        }  
         
        i =0; j =0; //reset values

        while (Path_CSV[i] !=0) //seperate "path" and "filename"
        {
            if(count2==count1) //get filename after last "\"
            {              
                gNavBook_CSV_filename[j] =Path_CSV[i];
                j++;

                Path_CSV[i] =0;              
            }

            if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
                count2++;
                               
            i++;
        }

        writelineEx(gNavBook_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 

        writelineEx(gNavBook_writeWindow, 0,"filename of *.csv: '%s'", gNavBook_CSV_filename);  //output filename 

        putvalue(env_NaviSD_NB_DataSource_file, gNavBook_CSV_filename); //output current loaded *.csv-file on panel

        setFilePath(Path_CSV, 0); //set path for *.csv file

        CSVfileHandle =openFileRead(gNavBook_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        

        if (CSVfileHandle!=0) //*.csv file access successful
        {
            writelineEx(gNavBook_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gNavBook_CSV_filename);    //output result  
            
            putvalue(env_NaviSD_NB_DataSource_result, "successful");   //output result on panel                      
            
            Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
            
            for (i=0; i<Num_of_csv_byte; i++) //copy data into "NavBook"
            {      
                if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
                {
                    if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in NavBook) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                    {
                        if(current_CSV_line>0 && NavBookLine<NAV_NAVBOOK_ENTRIES) //ignore first line in *.csv file
                        {   
                            writelineEx(gNavBook_writeWindow, 0, "");
                            writelineEx(gNavBook_writeWindow, 0,"*******Element %d*******",NavBookLine);

                            //transform 'string' to 'long' for "POS"
                            gNavBook_Pos[NavBookLine]     =atol(NavBook_Pos_string[NavBookLine]);                        
                            
                            writelineEx(gNavBook_writeWindow, 0,"Pos[%d]: 0x%x",NavBookLine, gNavBook_Pos[NavBookLine]);

                            writelineEx(gNavBook_writeWindow, 0,"LastName[%d]: %s",NavBookLine, gNavBook_LastName[NavBookLine]);                            
                            
                            writelineEx(gNavBook_writeWindow, 0,"FirstName[%d]: %s",NavBookLine, gNavBook_FirstName[NavBookLine]);

                            gNavBook_ListEntryValidInformation[NavBookLine]  =TRUE;
                                                
                            NavBookLine++; // -> next line in *.csv (next record element)
                        }

                        current_CSV_line++; //next line in *.csv file
                        element =0; //start at 'POS' (first record element of "array data")
                        j=0; //reset value
                    }
                      
                    else if(current_CSV_line>0 && NavBookLine<NAV_NAVBOOK_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                    {
                        switch (element)
                        {
                            case 0: //POS
                                    NavBook_Pos_string[NavBookLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //LastName
                                    gNavBook_LastName[NavBookLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 2: //FirstName
                                    gNavBook_FirstName[NavBookLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            default:
                             break;
                        }
                    }                               
                }
                               
                else  // ";" is detected ->next record element of "array data"
                {                                          
                    element++;
                    j=0; //reset value  
                }                                              
        
            }         
            
            gNavBook_TotalNumListElements =gNavBookLine_sum =NavBookLine; //get "total number of list elements"
            
            putvalue(env_NaviSD_NB_TotalNumLE, gNavBook_TotalNumListElements);

            writelineEx(gNavBook_writeWindow, 0, "");

            writelineEx(gNavBook_writeWindow, 0,"Anzahl der Listenelemente: %d", gNavBookLine_sum); //output total number of list elements

            writelineEx(gNavBook_writeWindow, 0, "");

            if(fileClose (CSVfileHandle) !=0) //close *.csv file
                writelineEx(gNavBook_writeWindow, 0,"Datei '%s' geschlossen", gNavBook_CSV_filename); //output result
             
            else
                writelineEx(gNavBook_writeWindow, 0,"Fehler beim Schlieen der Datei '%s'", gNavBook_CSV_filename);//output result
        }

        else //*.csv file access not successful
        {
            writelineEx(gNavBook_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gNavBook_CSV_filename); //output result
            
            putvalue(env_NaviSD_NB_DataSource_result,"not successful"); //output result
        }
    }
}

on envVar env_NaviSD_NB_DataSource
{
    if (getvalue(this) ==NAV_DEFAULT_LIST)
    {
        NavBook_init_static();
        putvalue(env_NaviSD_NB_DataSource_file, empty_string);
        putvalue(env_NaviSD_NB_DataSource_result, empty_string);
    }
}

on envVar env_NaviSD_LG_CA
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        if(getvalue(env_NaviSD_LG_AH_start) >255 && getvalue(env_NaviSD_LG_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_NaviSD_LG_AH_IS,1);

        //get data from Panel
        gLaneGuidance_LaneGuidanceOnOff =getvalue(env_NaviSD_LG_LGOnOff);

        recordaddress   =getvalue(env_NaviSD_LG_AH_RA);
        shift           =getvalue(env_NaviSD_LG_AH_shift);
        direction       =getvalue(env_NaviSD_LG_AH_dir);
        transmitpos     =getvalue(env_NaviSD_LG_AH_POS);
        indexsize       =getvalue(env_NaviSD_LG_AH_IS);
        startelement    =getvalue(env_NaviSD_LG_AH_start);
        elements        =getvalue(env_NaviSD_LG_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        if (getvalue(env_NaviSD_LG_CA_switch))
        {
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
        {
            if(FORWARD==direction)  //forward-start
            {
                valid_startelement =0;                                                           

                if(NAV_LANEGUIDANCE_ENTRIES <=elements) //1. more elements requested, than in array
                {
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<NAV_LANEGUIDANCE_ENTRIES;i++)
                        {
                            if(0 !=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i =NAV_LANEGUIDANCE_ENTRIES;
                        }
                    }
                    else
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if (shift ==FALSE)
                    {
                        for(i=0;i<elements;i++)
                        {
                            if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i =NAV_LANEGUIDANCE_ENTRIES;
                        }
                    }
                    else
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
            {   
                //searching for valid startelement
                for(i=(NAV_LANEGUIDANCE_ENTRIES-1);i>=0;i--)
                {
                    if(0!=gLaneGuidance_ListEntryValidInformation[i])        //found valid startelement
                    {
                        valid_startelement =i;                                
                        i =0;                                                
                    }
                }
                        
                //searching for valid elements
                if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  =startelement;
                    valid_elements      =0;
                }
                else if(0==valid_startelement)                                
                    valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for(i=valid_startelement;i>=0;i--)
                    {
                        if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                    {
                        if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }                   
                }                                                            
            }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID                
        {
            //searching for valid startelement
            for(i=0;i<NAV_LANEGUIDANCE_ENTRIES;i++)
            {
                if(gLaneGuidance_Pos[i] ==startelement)                        //found a valid element
                {                                       
                    if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                    {
                        if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement =i+1-2*direction;
                                                            
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gLaneGuidanceLine_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
                    
                    else
                        valid_startelement =i;                              //found element is valid_startelement

                    i =NAV_LANEGUIDANCE_ENTRIES;
                }
                else
                    valid_startelement =0xff;
            }

            if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
            {   
                valid_startelement  =startelement;
                valid_elements      =0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if(BACKWARD==direction)                                            //backward-start
                {
                    if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                        valid_elements=1;
                            
                    else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for(i=valid_startelement;i>=0;i--)
                        {
                            if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for(i=valid_startelement;i>(valid_startelement-elements);i--)
                        {
                            if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements)>=NAV_LANEGUIDANCE_ENTRIES)
                    {
                        for(i=valid_startelement;i<NAV_LANEGUIDANCE_ENTRIES;i++)
                        {
                            if(0!=gLaneGuidance_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_LANEGUIDANCE_ENTRIES;
                        }
                    }
                    else
                    {
                        for(i=valid_startelement;i<(valid_startelement+elements);i++)
                        {
                            if(0!=gLaneGuidance_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_LANEGUIDANCE_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue(env_NaviSD_LG_AH_elements, valid_elements);
        }
        
        else
        {
            valid_startelement      =startelement;
            valid_elements          =elements;
        }
        requested_startelement =startelement;

        LaneGuidance_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

on envVar env_NaviSD_LG_StatusArray
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    //MR 76047 
    int i, transSuppression;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;
    //MR 76047 
    transSuppression        = getvalue(env_NaviSD_LG_StatusOFF);

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        if(getvalue(env_NaviSD_LG_AH_start) >255 && getvalue(env_NaviSD_LG_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_NaviSD_LG_AH_IS,1);

        //get data from Panel
        gLaneGuidance_ASGID                 =getvalue(env_NaviSD_LG_ASGID);
        gLaneGuidance_TAID                  =getvalue(env_NaviSD_LG_TAID);
        gLaneGuidance_LaneGuidanceOnOff     =getvalue(env_NaviSD_LG_LGOnOff);

        recordaddress   =getvalue(env_NaviSD_LG_AH_RA);
        shift           =getvalue(env_NaviSD_LG_AH_shift);
        direction       =getvalue(env_NaviSD_LG_AH_dir);
        transmitpos     =getvalue(env_NaviSD_LG_AH_POS);
        indexsize       =getvalue(env_NaviSD_LG_AH_IS);
        startelement    =getvalue(env_NaviSD_LG_AH_start);
        elements        =getvalue(env_NaviSD_LG_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
        {
            if(FORWARD==direction)  //forward-start
            {
                valid_startelement =0;                                                           

                if(NAV_LANEGUIDANCE_ENTRIES <=elements) //1. more elements requested, than in array
                {
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<NAV_LANEGUIDANCE_ENTRIES;i++)
                        {
                            if(0 !=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i =NAV_LANEGUIDANCE_ENTRIES;
                        }
                    }
                    else
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if (shift ==FALSE)
                    {
                        for(i=0;i<elements;i++)
                        {
                            if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i =NAV_LANEGUIDANCE_ENTRIES;
                        }
                    }
                    else
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
            {   
                //searching for valid startelement
                for(i=(NAV_LANEGUIDANCE_ENTRIES-1);i>=0;i--)
                {
                    if(0!=gLaneGuidance_ListEntryValidInformation[i])        //found valid startelement
                    {
                        valid_startelement =i;                                
                        i =0;                                                
                    }
                }
                        
                //searching for valid elements
                if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  =startelement;
                    valid_elements      =0;
                }
                else if(0==valid_startelement)                                
                    valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for(i=valid_startelement;i>=0;i--)
                    {
                        if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                    {
                        if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }                   
                }                                                            
            }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID                
        {
            //searching for valid startelement
            for(i=0;i<NAV_LANEGUIDANCE_ENTRIES;i++)
            {
                if(gLaneGuidance_Pos[i] ==startelement)                        //found a valid element
                {                                       
                    if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                    {
                        if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement =i+1-2*direction;
                                                            
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gLaneGuidanceLine_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
                    
                    else
                        valid_startelement =i;                              //found element is valid_startelement

                    i =NAV_LANEGUIDANCE_ENTRIES;
                }
                else
                    valid_startelement =0xff;
            }

            if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
            {   
                valid_startelement  =startelement;
                valid_elements      =0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if(BACKWARD==direction)                                            //backward-start
                {
                    if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                        valid_elements=1;
                            
                    else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for(i=valid_startelement;i>=0;i--)
                        {
                            if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for(i=valid_startelement;i>(valid_startelement-elements);i--)
                        {
                            if(0!=gLaneGuidance_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements)>=NAV_LANEGUIDANCE_ENTRIES)
                    {
                        for(i=valid_startelement;i<NAV_LANEGUIDANCE_ENTRIES;i++)
                        {
                            if(0!=gLaneGuidance_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_LANEGUIDANCE_ENTRIES;
                        }
                    }
                    else
                    {
                        for(i=valid_startelement;i<(valid_startelement+elements);i++)
                        {
                            if(0!=gLaneGuidance_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_LANEGUIDANCE_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue(env_NaviSD_LG_AH_elements, valid_elements);

        //send StatusArray
    //MR 76047 
        if(!transSuppression)
        LaneGuidance_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

on envVar env_NaviSD_NB_reload //load external LastDestList from *.csv
{
    if(getvalue(this) && getvalue(env_NaviSD_NB_DataSource) ==NAV_EXTERNAL_LIST)
        NavBook_init_CSV(); 

    else if(getvalue(env_NaviSD_NB_DataSource) != NAV_EXTERNAL_LIST)
        putvalue(env_NaviSD_NB_DataSource_result,"not successful, select 'external *.csv'");
}

on envVar env_NaviSD_NB_CA
{
    word requested_startelement, startelement, elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        if(getvalue(env_NaviSD_NB_AH_start) >255 && getvalue(env_NaviSD_NB_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_NaviSD_NB_AH_IS,1);

        //get data from Panel
        recordaddress   =getvalue(env_NaviSD_NB_AH_RA);
        shift           =getvalue(env_NaviSD_NB_AH_shift);
        direction       =getvalue(env_NaviSD_NB_AH_dir);
        transmitpos     =getvalue(env_NaviSD_NB_AH_POS);
        indexsize       =getvalue(env_NaviSD_NB_AH_IS);
        startelement    =getvalue(env_NaviSD_NB_AH_start);
        elements        =getvalue(env_NaviSD_NB_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        if (getvalue(env_NaviSD_NB_CA_switch))
        {
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
        {
            if(FORWARD==direction)  //forward-start
            {
                valid_startelement =0;                                                           

                if(NAV_NAVBOOK_ENTRIES <=elements) //1. more elements requested, than in array
                {
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<NAV_NAVBOOK_ENTRIES;i++)
                        {
                            if(0 !=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i =NAV_NAVBOOK_ENTRIES;
                        }
                    }
                    else
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if (shift ==FALSE)
                    {
                        for(i=0;i<elements;i++)
                        {
                            if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i =NAV_NAVBOOK_ENTRIES;
                        }
                    }
                    else 
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
            {   
                //searching for valid startelement
                for(i=(NAV_NAVBOOK_ENTRIES-1);i>=0;i--)
                {
                    if(0!=gNavBook_ListEntryValidInformation[i])        //found valid startelement
                    {
                        valid_startelement =i;                                
                        i =0;                                                
                    }
                }
                        
                //searching for valid elements
                if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  =startelement;
                    valid_elements      =0;
                }
                else if(0==valid_startelement)                                
                    valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for(i=valid_startelement;i>=0;i--)
                    {
                        if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                    {
                        if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }                   
                }                                                            
            }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID                
        {
            //searching for valid startelement
            for(i=0;i<NAV_NAVBOOK_ENTRIES;i++)
            {
                if(gNavBook_Pos[i] ==startelement)                        //found a valid element
                {                                       
                    if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                    {
                        if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement =i+1-2*direction;
                                                            
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gNavBookLine_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
                    
                    else
                        valid_startelement =i;                              //found element is valid_startelement

                    i =NAV_NAVBOOK_ENTRIES;
                }
                else
                    valid_startelement =0xff;
            }
            write("Status Array: valid_startelement=0x%x", valid_startelement);
            if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
            {   
                valid_startelement  =startelement;
                valid_elements      =0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if(BACKWARD==direction)                                            //backward-start
                {
                    if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                        valid_elements=1;
                            
                    else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for(i=valid_startelement;i>=0;i--)
                        {
                            if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for(i=valid_startelement;i>(valid_startelement-elements);i--)
                        {
                            if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements)>=NAV_NAVBOOK_ENTRIES)
                    {
                        for(i=valid_startelement;i<NAV_NAVBOOK_ENTRIES;i++)
                        {
                            if(0!=gNavBook_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_NAVBOOK_ENTRIES;
                        }
                    }
                    else
                    {
                        for(i=valid_startelement;i<(valid_startelement+elements);i++)
                        {
                            if(0!=gNavBook_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_NAVBOOK_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue(env_NaviSD_NB_AH_elements, valid_elements);
        }
        else
        {
            valid_startelement      =startelement;
            valid_elements          =elements;
        }

        requested_startelement =startelement;

        NavBook_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

on envVar env_NaviSD_NB_StatusArray
{
    word requested_startelement, startelement, elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
    //MR 76047 
    int i, transSuppression;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;
    //MR 76047 
    transSuppression        = getvalue(env_NaviSD_NB_StatusOFF);

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        if(getvalue(env_NaviSD_NB_AH_start) >255 && getvalue(env_NaviSD_NB_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_NaviSD_NB_AH_IS,1);

        //get data from Panel
        gNavBook_ASGID                 =getvalue(env_NaviSD_NB_ASGID);
        gNavBook_TAID                  =getvalue(env_NaviSD_NB_TAID);
        
        //MR 63332 #3   02.07.2014
        //gNavBook_TotalNumListElements  =getvalue(env_NaviSD_NB_TotalNumLE);

        recordaddress   =getvalue(env_NaviSD_NB_AH_RA);
        shift           =getvalue(env_NaviSD_NB_AH_shift);
        direction       =getvalue(env_NaviSD_NB_AH_dir);
        transmitpos     =getvalue(env_NaviSD_NB_AH_POS);
        indexsize       =getvalue(env_NaviSD_NB_AH_IS);
        startelement    =getvalue(env_NaviSD_NB_AH_start);
        elements        =getvalue(env_NaviSD_NB_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;

        
        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
        {
            if(FORWARD==direction)  //forward-start
            {
                valid_startelement =0;                                                           

                if(NAV_NAVBOOK_ENTRIES <=elements) //1. more elements requested, than in array
                {
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<NAV_NAVBOOK_ENTRIES;i++)
                        {
                            if(0 !=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i =NAV_NAVBOOK_ENTRIES;
                        }
                    }
                    else
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if (shift ==FALSE)
                    {
                        for(i=0;i<elements;i++)
                        {
                            if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i =NAV_NAVBOOK_ENTRIES;
                        }
                    }
                    else 
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
            {   
                //searching for valid startelement
                for(i=(NAV_NAVBOOK_ENTRIES-1);i>=0;i--)
                {
                    if(0!=gNavBook_ListEntryValidInformation[i])        //found valid startelement
                    {
                        valid_startelement =i;                                
                        i =0;                                                
                    }
                }
                        
                //searching for valid elements
                if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  =startelement;
                    valid_elements      =0;
                }
                else if(0==valid_startelement)                                
                    valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for(i=valid_startelement;i>=0;i--)
                    {
                        if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                    {
                        if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }                   
                }                                                            
            }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID                
        {
            //searching for valid startelement
            for(i=0;i<NAV_NAVBOOK_ENTRIES;i++)
            {
                if(gNavBook_Pos[i] ==startelement)                        //found a valid element
                {                                       
                    if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                    {
                        if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement =i+1-2*direction;
                                                            
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gNavBookLine_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
                    
                    else
                        valid_startelement =i;                              //found element is valid_startelement

                    i =NAV_NAVBOOK_ENTRIES;
                }
                else
                    valid_startelement =0xff;
            }
            write("Status Array: valid_startelement=0x%x", valid_startelement);
            if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
            {   
                valid_startelement  =startelement;
                valid_elements      =0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if(BACKWARD==direction)                                            //backward-start
                {
                    if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                        valid_elements=1;
                            
                    else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for(i=valid_startelement;i>=0;i--)
                        {
                            if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for(i=valid_startelement;i>(valid_startelement-elements);i--)
                        {
                            if(0!=gNavBook_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements)>=NAV_NAVBOOK_ENTRIES)
                    {
                        for(i=valid_startelement;i<NAV_NAVBOOK_ENTRIES;i++)
                        {
                            if(0!=gNavBook_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_NAVBOOK_ENTRIES;
                        }
                    }
                    else
                    {
                        for(i=valid_startelement;i<(valid_startelement+elements);i++)
                        {
                            if(0!=gNavBook_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_NAVBOOK_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue(env_NaviSD_NB_AH_elements, valid_elements);

        //send StatusArray
    //MR 76047 
        if(!transSuppression)
        NavBook_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

AddressList_Indication(dword Indication_array [], int datalength)
{ /* Bewe(2013-10-17) - Clean-Up Indents */
  byte mode, shift, direction, recordaddress, indexsize, transmitpos;
  word valid_startelement, requested_startelement, startelement, elements, Offset, valid_elements;
  //MR 76047 
    int i=0, transSuppression;
  // Init local variables. 
  mode                    =0;
  direction               =0;
  shift                   =0;
  Offset                  =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  transmitpos             =0;        
  indexsize               =0;
  valid_startelement      =0xff;
  valid_elements          =0;
  //MR 76047 
    transSuppression        = getvalue(env_NaviSD_AL_StatusOFF);

  switch (Indication_array[2]) // indication
  {
    case DataGet_IND:
      if (getvalue(env_NaviSD_AL_Error_on))
      { AddressList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue(env_NaviSD_AL_ErrorCode)); }
      //MR 63336    02.07.2014
      else if (getvalue(env_NaviSD_AL_Timeout) == TRUE)
      {
       /* NOP */
      }
      else
      {
        //getData
        gAddressList_ASGID = (gBAP_Indication[3] &0xF0) /0x10;
        gAddressList_TAID  = gBAP_Indication[3] &0x0F;

        gAddressList_OtherListType      = gBAP_Indication[4];
        gAddressList_OtherListReference = gBAP_Indication[5];

        gAddressList_OtherListReference += gBAP_Indication[6] *0x100;
        
        /***ArrayHeader***/
        mode            = (Indication_array[7] &0xF0) /0x10;
        recordaddress   = Indication_array[7] &0x0F;
        Offset =8;
    
        // decode "mode-byte"
        shift       = mode &0x01;
        direction   = (mode &0x02)/0x02;
        transmitpos = (mode &0x04)/0x04;
        indexsize   = (mode &0x08)/0x08;              

        if (indexsize)
        {   
          startelement = Indication_array[Offset];
          Offset++;
          startelement += (Indication_array[Offset] *0x100);
          Offset++;

          elements = Indication_array[Offset];
          Offset++;
          elements += (Indication_array[Offset] *0x100);
          Offset++;
        }
        else
        {   
          startelement =Indication_array[Offset];
          Offset++;

          elements =Indication_array[Offset];
          Offset++;
        }   

        requested_startelement = startelement;
        // Bewe (2013-10-17) - Handling StartElement for OLT
        if (gAddressList_OtherListType!=0x0F)
        { /* OLT is NOT CompleteListe - use OL_Ref as startelement */
          startelement = gAddressList_OtherListReference;
        }
        /***Startelement=0***/
        if (0==startelement) //Startelement-ID =0 -> start at first array-entry
        {
          if (FORWARD==direction)  //forward-start
          {
            valid_startelement = 0;                                                           
            if (NAV_ADDRESSLIST_ENTRIES<=elements) //1. more elements requested, than in array
            {
              if (shift==FALSE)  
              {
                for (i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
                {
                  if (0 !=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                  {
                    if (gAddressList_Pos[i]>0xff)
                    { indexsize = TRUE; }
                    valid_elements++;         //increment elements
                  }    
                  else                                                //no valid element, loop finished
                  { i = NAV_ADDRESSLIST_ENTRIES; }
                }
              }
              else
              {
                valid_startelement = startelement;
                valid_elements     = 0;
              }
            }
            else    //2. number of requested elements < elements in array
            {
              if (shift ==FALSE)
              {
                for (i=0;i<elements;i++)
                {
                  if (0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                  {
                    if (gAddressList_Pos[i]>0xff)
                    { indexsize=TRUE; }
                    valid_elements++;                                //increment elements
                  }
                  else                                                //no valid element, loop finished
                  { i = NAV_ADDRESSLIST_ENTRIES; }
                }
              }
              else
              {
                valid_startelement  = startelement;
                valid_elements      = 0;
              }
            }
          } //forward-end
          else if (BACKWARD==direction && TRUE==shift)    //backward-start, only if the shift bit is set (this means starting with the last element of the array)
          {   
            //searching for valid startelement
            for (i=(NAV_ADDRESSLIST_ENTRIES-1);i>=0;i--)
            {
              if (0!=gAddressList_ListEntryValidInformation[i])        //found valid startelement
              {
                valid_startelement = i;                                
                i = 0;                                                
              }
            }
            //searching for valid elements
            if (0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
            {
              valid_startelement  =startelement;
              valid_elements      =0;
            }
            else if (0==valid_startelement)                                
            { valid_elements=1; }                       //only 1 element because valid startelement is on position 0    
            else if (elements>(valid_startelement+1))        //not enougth array-elements available, because array endet at array-position 0
            {
              for (i=valid_startelement;i>=0;i--)
              {
                if (0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                {
                  if (gAddressList_Pos[i] >0xff)
                  { indexsize =TRUE; }
                  valid_elements++;                                //increment elements
                }
                else                                                //no valid element, loop finished
                { i=0; }
              }
            }
            else                                                        //enougth array-elements available
            {
              for (i=valid_startelement;i>(valid_startelement-elements);i--)
              {
                if (0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                {
                  valid_elements++;                                //increment elements
                  if (gAddressList_Pos[i] >0xff)
                  { indexsize =TRUE; }
                }
                else                                                //no valid element, loop finished
                { i=0; }
              }                 
            }                                                            
          } //backward-end
        } //(startelement==0)-end
        /***Startelement!=0***/
        else  //searching for Startelement-ID                
        {
          //searching for valid startelement
          for (i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
          {
            if (gAddressList_Pos[i]==startelement)                        //found a valid element
            {                                          
              if (shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
              {
                if (i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                { valid_startelement =i+1-2*direction; }
                else if (i==0 && BACKWARD==direction) 
                { valid_startelement =gAddressListLine_sum; }    //valid element is last element in Array                                                
                else if (i==0 && FORWARD==direction) 
                { valid_startelement =0; }                         //valid element is first element in Array
              }
              else
              { valid_startelement =i; }                             //found element is valid_startelement
              i=NAV_ADDRESSLIST_ENTRIES;
            }
          }
          if (0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
          {
            valid_startelement  =startelement;
            valid_elements      =0;
          }
          else                                                                //found valid entry for startelement in array
          {
            //verify number of valid elements
            if (BACKWARD==direction)                                            //backward-start
            {
              if (valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
              { valid_elements=1; }
              else if (elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
              {
                for (i=valid_startelement;i>=0;i--)
                {
                  if (0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                  {
                    if (gAddressList_Pos[i] >0xff)
                    { indexsize =TRUE; }
                    valid_elements++;                                //increment elements
                  }
                  else                                                //no valid element, loop finished
                  { i=0; }
                }
              }
              else                                                        //enougth array-elements available
              {
                for (i=valid_startelement;i>(valid_startelement-elements);i--)
                {
                  if (0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                  {
                    if (gAddressList_Pos[i] >0xff)
                    { indexsize =TRUE; }
                    valid_elements++;                                //increment elements
                  }
                  else                                                //no valid element, loop finished
                  { i=0; }
                }
              }
            } //backward-end
            else                                                            //forward-start
            {
              if ((valid_startelement+elements)>=NAV_ADDRESSLIST_ENTRIES)
              {
                for (i=valid_startelement;i<NAV_ADDRESSLIST_ENTRIES;i++)
                {   
                  if (0!=gAddressList_Pos[i])                            //if there is an valid element
                  {
                    if (gAddressList_Pos[i] >0xff)
                    { indexsize =TRUE; }
                    valid_elements++;                                //increment elements
                  }
                  else                                                    //no valid element, loop finished
                  { i=NAV_ADDRESSLIST_ENTRIES; }
                }
              }
              else
              {
                for (i=valid_startelement;i<(valid_startelement+elements);i++)
                {
                  if (0!=gAddressList_Pos[i])                            //if there is an valid element
                  {
                    if (gAddressList_Pos[i] >0xff)
                    { indexsize =TRUE; }
                    valid_elements++;                                //increment elements
                  }
                  else                                                //no valid element, loop finished
                  { i=NAV_ADDRESSLIST_ENTRIES; }
                }
              }
            } // forward-end
          } // found_valid_start_in_array-end
        } //(startelement!=0)-end
        transmitpos = TRUE;
        if ((requested_startelement >0xFF) || (valid_startelement >0xFF))
        { indexsize = TRUE; }
        mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        //send StatusArray
    //MR 76047 
        if(!transSuppression)
        AddressList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                   
      }
      break;
            
    case Error_IND:
      writelineEx(gError_Trace, 0, "FSG_NaviSD AddressList_Indication: received error, errorcode:0x%x", Indication_array[3]);
      break;

    default:
      writelineEx(gError_Trace, 0, "FSG_NaviSD AddressList_Indication: invalid indication %d", Indication_array[2]);
      break;
  } //switch-end
}

AddressList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{ /* Bewe(2013-10-17) - Clean-Up Indents */
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];
  byte shift, direction, transmitpos, indexsize, current_element; 
  word AddressListLine, Offset;

  // Init local variables. 
  for (i=0;i<BAP_BUFFER_SIZE;i++)
  { requestarray [i]=0; }
  
  shift               =0;
  direction           =0;
  transmitpos         =0;
  indexsize           =0;
  AddressListLine     =0;
  current_element     =0;
  Offset              =0;

  // decode "mode-byte"
  shift       =mode &0x01;
  direction   =(mode &0x02)/0x02;
  transmitpos =(mode &0x04)/0x04;
  indexsize   =(mode &0x08)/0x08;
  // Handle request.
  requestarray[0] =LSG_NaviSD;                    //LSG-ID
  requestarray[1] =FctID_Address_List;        //Fct.-ID
  requestarray[2] =request;               //request type
  Offset =3;

  switch (request)
  {
    case Changed_REQ:
      /***ArrayHeader***/
      requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
      Offset++;
                
      if (indexsize)
      {   
        requestarray[Offset] =(requested_startelement &0x00FF);
        Offset++;
        requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
        Offset++;

        requestarray[Offset] =(elements &0x00FF);
        Offset++;
        requestarray[Offset] =((elements &0xFF00) /0x100);
        Offset++;
      }
      else
      {   
        requestarray[Offset] =requested_startelement;
        Offset++;

        requestarray[Offset] =elements;
        Offset++;
      }

      AddressListLine =startelement;
           
      if (getvalue(env_NaviSD_AL_CA_switch)) //ArrayData
      {
        //copy data
        switch (recordaddress)
        {
          case 0: //complete record
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }
                //LastName
                requestarray[Offset] =strlen(gAddressList_LastName[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_LastName[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_LastName[AddressListLine][i];    
                  Offset++;
                }
                //FirstName
                requestarray[Offset] =strlen(gAddressList_FirstName[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_FirstName[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_FirstName[AddressListLine][i];    
                  Offset++;
                }
                //Street
                requestarray[Offset] =strlen(gAddressList_Street[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Street[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Street[AddressListLine][i];    
                  Offset++;
                }
                //City
                requestarray[Offset] =strlen(gAddressList_City[AddressListLine]);
                Offset++;
                
                for (i=0;i<strlen(gAddressList_City[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_City[AddressListLine][i];    
                  Offset++;
                }
                //Region
                requestarray[Offset] =strlen(gAddressList_Region[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Region[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Region[AddressListLine][i];    
                  Offset++;
                }
                //PostalCode
                requestarray[Offset] =strlen(gAddressList_PostalCode[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_PostalCode[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_PostalCode[AddressListLine][i];    
                  Offset++;
                }
                //Country
                requestarray[Offset] =strlen(gAddressList_Country[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Country[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Country[AddressListLine][i];    
                  Offset++;
                }
                //Coordinates
                requestarray[Offset] =strlen(gAddressList_Coordinates[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Coordinates[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Coordinates[AddressListLine][i];    
                  Offset++;
                }
                //POI_Description
                requestarray[Offset] =strlen(gAddressList_POIDescription[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_POIDescription[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_POIDescription[AddressListLine][i];    
                  Offset++;
                }
                //POI_Type
                requestarray[Offset] =gAddressList_POIType[AddressListLine];
                Offset++;
                //Address_Type
                requestarray[Offset] =gAddressList_AddressType[AddressListLine];
                Offset++;       
              } // list_entry_valid-end
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;

          case 1: //Street, City, Country, PostalCode, Coordinates, Address_Type
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }
                //Street
                requestarray[Offset] =strlen(gAddressList_Street[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Street[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Street[AddressListLine][i];    
                  Offset++;
                }
                //City
                requestarray[Offset] =strlen(gAddressList_City[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_City[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_City[AddressListLine][i];    
                  Offset++;
                }
                  //PostalCode
                  requestarray[Offset] =strlen(gAddressList_PostalCode[AddressListLine]);
                  Offset++;
                  for (i=0;i<strlen(gAddressList_PostalCode[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_PostalCode[AddressListLine][i];    
                  Offset++;
                }
                //Country
                requestarray[Offset] =strlen(gAddressList_Country[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Country[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Country[AddressListLine][i];    
                  Offset++;
                }
                //Coordinates
                requestarray[Offset] =strlen(gAddressList_Coordinates[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Coordinates[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Coordinates[AddressListLine][i];    
                  Offset++;
                }
                //Address_Type
                requestarray[Offset] =gAddressList_AddressType[AddressListLine];
                Offset++;
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;

          case 3: //Street, City, Region, PostalCode, Country, Coordinates, POI_Description, POI_Type, Address_Type
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }                                                             
                //Street
                requestarray[Offset] =strlen(gAddressList_Street[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Street[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Street[AddressListLine][i];    
                  Offset++;
                }
                //City
                requestarray[Offset] =strlen(gAddressList_City[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_City[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_City[AddressListLine][i];    
                  Offset++;
                }
                //Region
                requestarray[Offset] =strlen(gAddressList_Region[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Region[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Region[AddressListLine][i];    
                  Offset++;
                }
                //PostalCode
                requestarray[Offset] =strlen(gAddressList_PostalCode[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_PostalCode[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_PostalCode[AddressListLine][i];    
                  Offset++;
                }
                //Country
                requestarray[Offset] =strlen(gAddressList_Country[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Country[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Country[AddressListLine][i];    
                  Offset++;
                }
                //Coordinates
                requestarray[Offset] =strlen(gAddressList_Coordinates[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Coordinates[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Coordinates[AddressListLine][i];    
                  Offset++;
                }
                //POI_Description
                requestarray[Offset] =strlen(gAddressList_POIDescription[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_POIDescription[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_POIDescription[AddressListLine][i];    
                  Offset++;
                }
                //POI_Type
                requestarray[Offset] =gAddressList_POIType[AddressListLine];
                Offset++;
                //Address_Type
                requestarray[Offset] =gAddressList_AddressType[AddressListLine];
                Offset++;
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;
                
          case 4: //Street, City, PostalCode, Coordinates, Address_Type
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }
                //Street
                requestarray[Offset] =strlen(gAddressList_Street[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Street[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Street[AddressListLine][i];    
                  Offset++;
                }
                //City
                requestarray[Offset] =strlen(gAddressList_City[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_City[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_City[AddressListLine][i];    
                  Offset++;
                }
                //PostalCode
                requestarray[Offset] =strlen(gAddressList_PostalCode[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_PostalCode[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_PostalCode[AddressListLine][i];    
                  Offset++;
                }
                //Coordinates
                requestarray[Offset] =strlen(gAddressList_Coordinates[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Coordinates[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Coordinates[AddressListLine][i];    
                  Offset++;
                }
                //Address_Type
                requestarray[Offset] =gAddressList_AddressType[AddressListLine];
                Offset++;
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;   
                
          case 5: //POI_Description, POI_Type
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }  
                //POI_Description
                requestarray[Offset] =strlen(gAddressList_POIDescription[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_POIDescription[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_POIDescription[AddressListLine][i];    
                  Offset++;
                }
                //POI_Type
                requestarray[Offset] =gAddressList_POIType[AddressListLine];
                Offset++;
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;

          case 6: //Street, City
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }
                //Street
                requestarray[Offset] =strlen(gAddressList_Street[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Street[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Street[AddressListLine][i];    
                  Offset++;
                }
                //City
                requestarray[Offset] =strlen(gAddressList_City[AddressListLine]);
                Offset++;
                for(i=0;i<strlen(gAddressList_City[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_City[AddressListLine][i];    
                  Offset++;
                }      
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;

          case 15:    //Pos
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;

          default:
            write("NaviSD AddressList_Request: invalid recordaddress %d", recordaddress);
            break;
        } //end switch "recordaddress"
      }
      else /* Bewe - This ELSE is a must! (besides the fact that there is never CA with DATA) */
      { set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); }
      break; //end Changed_REQ
        
    case Data_REQ:
      //changes from Jran Karl (28.03.2012)
      //MR 63336    02.07.2014
      //if (getvalue(env_NaviSD_AL_Timeout) != TRUE)
      //VAGH-10511
      ASGID = gAddressList_ASGID;
      TAID = gAddressList_TAID;
      if ( /*getvalue(env_NaviSD_AL_Timeout) != */ TRUE)
      {
        if (getvalue(env_NaviSD_AL_ASGID_error) != FALSE)
        {
          ASGID += 2;
        }
        if (getvalue(env_NaviSD_AL_TAID_error) != FALSE)
        {
          TAID += 0x02;
        }
      //end of changes from Jran Karl (28.03.2012)
        requestarray[Offset] =((ASGID *0x10) &0xF0) +(TAID &0x0F);    
        Offset++;
        requestarray[Offset] =gAddressList_OtherListType;    
        Offset++;
        requestarray[Offset] =(gAddressList_OtherListReference &0x00FF);    
        Offset++;
        requestarray[Offset] =((gAddressList_OtherListReference &0xFF00) /0x100);    
        Offset++;
        requestarray[Offset] =(gAddressList_TotalNumListElements &0x00FF);    
        Offset++;
        requestarray[Offset] =((gAddressList_TotalNumListElements &0xFF00) /0x100);    
        Offset++;

        /***ArrayHeader***/
        requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
        Offset++;
        if (indexsize)
        {   
          requestarray[Offset] =(requested_startelement &0x00FF);
          Offset++;
          requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
          Offset++;

          requestarray[Offset] =(elements &0x00FF);
          Offset++;
          requestarray[Offset] =((elements &0xFF00) /0x100);
          Offset++;
        }
        else
        {   
          requestarray[Offset] =requested_startelement;
          Offset++;

          requestarray[Offset] =elements;
          Offset++;
        }

        AddressListLine =startelement;
        //copy data
        switch (recordaddress)
        {
          case 0: //complete record
            // Bewe (2013-10-17) - Handling StartElement=f(OLT), thus change removed
            //changes from Jran Karl (28.03.2012)
            //if (gAddressList_OtherListReference != 0xFFFF)
            //{
            //  for (i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
            //  {
            //    if (gAddressList_Pos[i] == gAddressList_OtherListReference)
            //    {
            //      AddressListLine = i;
            //    }
            //  }
            //}
            //end of changes from Jran Karl (28.03.2012)
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }
                //LastName
                requestarray[Offset] =strlen(gAddressList_LastName[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_LastName[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_LastName[AddressListLine][i];    
                  Offset++;
                }
                //FirstName
                requestarray[Offset] =strlen(gAddressList_FirstName[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_FirstName[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_FirstName[AddressListLine][i];    
                  Offset++;
                }
                //Street
                requestarray[Offset] =strlen(gAddressList_Street[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Street[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Street[AddressListLine][i];    
                  Offset++;
                }
                //City
                requestarray[Offset] =strlen(gAddressList_City[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_City[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_City[AddressListLine][i];    
                  Offset++;
                }
                //Region
                requestarray[Offset] =strlen(gAddressList_Region[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Region[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Region[AddressListLine][i];    
                  Offset++;
                }
                //PostalCode
                requestarray[Offset] =strlen(gAddressList_PostalCode[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_PostalCode[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_PostalCode[AddressListLine][i];    
                  Offset++;
                }
                //Country
                requestarray[Offset] =strlen(gAddressList_Country[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Country[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Country[AddressListLine][i];    
                  Offset++;
                }
                //Coordinates
                requestarray[Offset] =strlen(gAddressList_Coordinates[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Coordinates[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Coordinates[AddressListLine][i];    
                  Offset++;
                }
                //POI_Description
                requestarray[Offset] =strlen(gAddressList_POIDescription[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_POIDescription[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_POIDescription[AddressListLine][i];    
                  Offset++;
                }
                //POI_Type
                requestarray[Offset] =gAddressList_POIType[AddressListLine];
                Offset++;
                //Address_Type
                requestarray[Offset] =gAddressList_AddressType[AddressListLine];
                Offset++;       
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;

          case 1: //Street, City, Country, PostalCode, Coordinates, Address_Type
            // Bewe (2013-10-17) - Handling StartElement=f(OLT), thus change removed
            //changes from Jran Karl (28.03.2012)
            //if (gAddressList_OtherListReference != 0xFFFF)
            //{
            //  for (i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
            //  {
            //    if (gAddressList_Pos[i] == gAddressList_OtherListReference)
            //    {
            //      AddressListLine = i;
            //    }
            //  }
            //}
            //end of changes from Jran Karl (28.03.2012)
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }
                //Street
                requestarray[Offset] =strlen(gAddressList_Street[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Street[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Street[AddressListLine][i];    
                  Offset++;
                }
                //City
                requestarray[Offset] =strlen(gAddressList_City[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_City[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_City[AddressListLine][i];    
                  Offset++;
                }
                //PostalCode
                requestarray[Offset] =strlen(gAddressList_PostalCode[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_PostalCode[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_PostalCode[AddressListLine][i];    
                  Offset++;
                }
                //Country
                requestarray[Offset] =strlen(gAddressList_Country[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Country[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Country[AddressListLine][i];    
                  Offset++;
                }
                //Coordinates
                requestarray[Offset] =strlen(gAddressList_Coordinates[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Coordinates[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Coordinates[AddressListLine][i];    
                  Offset++;
                }
                //Address_Type
                requestarray[Offset] =gAddressList_AddressType[AddressListLine];
                Offset++;
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;

          case 3: //Street, City, Region, PostalCode, Country, Coordinates, POI_Description, POI_Type, Address_Type
            // Bewe (2013-10-17) - Handling StartElement=f(OLT), thus change removed
            //changes from Jran Karl (28.03.2012)
            //if (gAddressList_OtherListReference != 0xFFFF)
            //{
            //  for (i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
            //  {
            //    if (gAddressList_Pos[i] == gAddressList_OtherListReference)
            //    {
            //      AddressListLine = i;
            //    }
            //  }
            //}
            //end of changes from Jran Karl (28.03.2012)
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }                                                             
                //Street
                requestarray[Offset] =strlen(gAddressList_Street[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Street[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Street[AddressListLine][i];    
                  Offset++;
                }
                //City
                requestarray[Offset] =strlen(gAddressList_City[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_City[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_City[AddressListLine][i];    
                  Offset++;
                }
                //Region
                requestarray[Offset] =strlen(gAddressList_Region[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Region[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Region[AddressListLine][i];    
                  Offset++;
                }
                //PostalCode
                requestarray[Offset] =strlen(gAddressList_PostalCode[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_PostalCode[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_PostalCode[AddressListLine][i];    
                  Offset++;
                }
                //Country
                requestarray[Offset] =strlen(gAddressList_Country[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Country[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Country[AddressListLine][i];    
                  Offset++;
                }
                //Coordinates
                requestarray[Offset] =strlen(gAddressList_Coordinates[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Coordinates[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Coordinates[AddressListLine][i];    
                  Offset++;
                }
                //POI_Description
                requestarray[Offset] =strlen(gAddressList_POIDescription[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_POIDescription[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_POIDescription[AddressListLine][i];    
                  Offset++;
                }
                //POI_Type
                requestarray[Offset] =gAddressList_POIType[AddressListLine];
                Offset++;
                //Address_Type
                requestarray[Offset] =gAddressList_AddressType[AddressListLine];
                Offset++;
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;
                
          case 4: //Street, City, PostalCode, Coordinates, Address_Type
            // Bewe (2013-10-17) - Handling StartElement=f(OLT), thus change removed
            //changes from Jran Karl (28.03.2012)
            //if (gAddressList_OtherListReference != 0xFFFF)
            //{
            //  for (i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
            //  {
            //    if (gAddressList_Pos[i] == gAddressList_OtherListReference)
            //    {
            //      AddressListLine = i;
            //    }
            //  }
            //}
            //end of changes from Jran Karl (28.03.2012)
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }
                //Street
                requestarray[Offset] =strlen(gAddressList_Street[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Street[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Street[AddressListLine][i];    
                  Offset++;
                }
                //City
                requestarray[Offset] =strlen(gAddressList_City[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_City[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_City[AddressListLine][i];    
                  Offset++;
                }
                //PostalCode
                requestarray[Offset] =strlen(gAddressList_PostalCode[AddressListLine]);
                Offset++;
                
                for (i=0;i<strlen(gAddressList_PostalCode[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_PostalCode[AddressListLine][i];    
                  Offset++;
                }
                //Coordinates
                requestarray[Offset] =strlen(gAddressList_Coordinates[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_Coordinates[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Coordinates[AddressListLine][i];    
                  Offset++;
                }
                //Address_Type
                requestarray[Offset] =gAddressList_AddressType[AddressListLine];
                Offset++;
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;   
                
          case 5: //POI_Description, POI_Type
            // Bewe (2013-10-17) - Handling StartElement=f(OLT), thus change removed
            //changes from Jran Karl (28.03.2012)
            //if (gAddressList_OtherListReference != 0xFFFF)
            //{
            //  for (i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
            //  {
            //    if (gAddressList_Pos[i] == gAddressList_OtherListReference)
            //    {
            //      AddressListLine = i;
            //    }
            //  }
            //}
            //end of changes from Jran Karl (28.03.2012)
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }  
                //POI_Description
                requestarray[Offset] =strlen(gAddressList_POIDescription[AddressListLine]);
                Offset++;
                for (i=0;i<strlen(gAddressList_POIDescription[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_POIDescription[AddressListLine][i];    
                  Offset++;
                }
                //POI_Type
                requestarray[Offset] =gAddressList_POIType[AddressListLine];
                Offset++;
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;

          case 6: //Street, City
            // Bewe (2013-10-17) - Handling StartElement=f(OLT), thus change removed
            //changes from Jran Karl (28.03.2012)
            //if (gAddressList_OtherListReference != 0xFFFF)
            //{
            //  for (i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
            //  {
            //    if (gAddressList_Pos[i] == gAddressList_OtherListReference)
            //    {
            //      AddressListLine = i;
            //    }
            //  }
            //}
            //end of changes from Jran Karl (28.03.2012)
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }
                //Street
                requestarray[Offset] =strlen(gAddressList_Street[AddressListLine]);
                Offset++;
                for(i=0;i<strlen(gAddressList_Street[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_Street[AddressListLine][i];    
                  Offset++;
                }
                //City
                requestarray[Offset] =strlen(gAddressList_City[AddressListLine]);
                Offset++;
                for(i=0;i<strlen(gAddressList_City[AddressListLine]);i++)
                {
                  requestarray[Offset] =gAddressList_City[AddressListLine][i];    
                  Offset++;
                }     
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;

          case 15:    //Pos
            while (current_element <elements)
            {
              if (AddressListLine ==0xff) //Invalid "list entry"
              {
                write("NaviSD AddressList_Request: invalid AddressListLine");
                current_element =elements;
              }
              else //"list entry" valid
              {   
                /***Array Data***/
                if (transmitpos) // Pos  ->Array position transmitted
                {
                  if (indexsize)
                  {
                    requestarray[Offset] =(gAddressList_Pos[AddressListLine] &0x00FF);
                    Offset++;
                    requestarray[Offset] =((gAddressList_Pos[AddressListLine]&0xFF00) /0x100);
                    Offset++;
                  }
                  else
                  {
                    requestarray[Offset] =gAddressList_Pos[AddressListLine];
                    Offset++;
                  }
                }
              }
              current_element++;
              AddressListLine =AddressList_nextvalidLine(AddressListLine, direction);
            }//end while
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence);
            break;

          default:
            write("NaviSD AddressList_Request: invalid recordaddress %d", recordaddress);
            break;
        } //end switch "recordaddress"
      //changes from Jran Karl (28.03.2012)
      }
      else
      {
          write("NaviSD AddressList_Request: Simulate timeout of Status-Array!");
      }
      //end of changes from Jran Karl (28.03.2012)
      break; //end Data_REQ

    case Error_REQ:
      requestarray[3] =errorcode;
      set_status_requestbuffer (requestarray, 4, Bap_Error);
      break; //end Error_REQ
    
  } //end switch "request"   
}

byte AddressList_nextvalidLine (byte current_AddressListLine, byte direction)
{
    byte next_AddressListLine;
    int i;
         
    //init lokal variables
    next_AddressListLine  =0;
    i                     =0;

    //search next "list entry"
    if(((gAddressListLine_sum-1)==current_AddressListLine && FORWARD ==direction) || (0 ==current_AddressListLine && BACKWARD ==direction))    //last-/fist-element of array reached
        next_AddressListLine =0xFF;
    else
    {
            next_AddressListLine =current_AddressListLine +1-2*direction;       //increment or decrement array-line (depends on direction);
                 
            //IssueList #71
            if (next_AddressListLine < NAV_ADDRESSLIST_ENTRIES)
            {
            if(0 ==gAddressList_ListEntryValidInformation[next_AddressListLine])    // check if next element is "valid"
                next_AddressListLine =0xff; 
                
            }                    
    }

    return(next_AddressListLine);
}

AddressList_init_CSV () //Byte & file selection
{
    dword CSVfileHandle =0, ConfigFileHandle =0, i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
    char buffer_string[NAV_BUFFERSIZE], Path_CSV[NAV_BUFFERSIZE], Path_Config[NAV_BUFFERSIZE];
    byte AddressListLine =0, buffer_byte[NAV_BUFFERSIZE];
    char AddressList_Pos_string [NAV_ADDRESSLIST_ENTRIES][NAV_TEXTLENGTH];           //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
    char AddressList_POIType_string [NAV_ADDRESSLIST_ENTRIES][NAV_TEXTLENGTH];       //help value ->"POIType" is stored in the ASCII(UTF-8) code in the *.csv
    char AddressList_AddressType_string [NAV_ADDRESSLIST_ENTRIES][NAV_TEXTLENGTH];           //help value ->"POIType" is stored in the ASCII(UTF-8) code in the *.csv    
    
    if(getvalue(env_NaviSD_AL_DataSource) == NAV_EXTERNAL_LIST) //output data in write window "FSGAddressList"  
    {
        writeClear(gAddressList_writeWindow);
        writelineEx(gAddressList_writeWindow, 0,"*******External AddressList_List*******");
        writelineEx(gAddressList_writeWindow, 0, "");
        writelineEx(gAddressList_writeWindow, 0, "**********************Start load new AddressList_List**********************");   
    
        for(j=0;j<NAV_ADDRESSLIST_ENTRIES;j++) //clear "AddressList Array"
        {
            gAddressList_ListEntryValidInformation[j]  =FALSE;

            gAddressList_Pos[j]             =0;
            gAddressList_POIType[j]         =0;
            gAddressList_AddressType[j]     =0;

            for(i=0;i<NAV_ADDRESSLIST_LASTNAME_LENGTH;i++)
                gAddressList_LastName[j][i]=0;
            
            for(i=0;i<NAV_ADDRESSLIST_FIRSTNAME_LENGTH;i++)
                gAddressList_FirstName[j][i]=0;
                
            for(i=0;i<NAV_ADDRESSLIST_STREET_LENGTH;i++)
                gAddressList_Street[j][i]=0;
            
            for(i=0;i<NAV_ADDRESSLIST_CITY_LENGTH;i++)
                gAddressList_City[j][i]=0;
                
            for(i=0;i<NAV_ADDRESSLIST_REGION_LENGTH;i++)
                gAddressList_Region[j][i]=0;
                
            for(i=0;i<NAV_ADDRESSLIST_POSTALCODE_LENGTH;i++)
                gAddressList_PostalCode[j][i]=0;
                
            for(i=0;i<NAV_ADDRESSLIST_COUNTRY_LENGTH;i++)
                gAddressList_Country[j][i]=0;
                
            for(i=0;i<NAV_ADDRESSLIST_COORDINATES_LENGTH;i++)
                gAddressList_Coordinates[j][i]=0;  
    // MR78172                    
        for(i=0;i<NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH;i++)
            gAddressList_POIDescription[j][i]=0;         
        }

        for(i=0;i<NAV_FILENAME_SIZE; i++) //clear "filename"
            gAddressList_CSV_filename[i] =0;       
        
        for(j=0;j<NAV_ADDRESSLIST_ENTRIES; j++) //clear "buffer"
        {
            buffer_string[j]    =0;
            buffer_byte[j]      =0;

            for(i=0;i<NAV_TEXTLENGTH;i++) //clear help value
                AddressList_Pos_string[j][i]       =0;
        }        

        i =0; j =0; AddressListLine =0; current_CSV_line =0; //reset values 
                      
        getvalue(env_NaviSD_AL_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
        
        //write("complete path *.csv: %s", Path_CSV); //debug
        
        i =0;

        while (Path_CSV[i] !=0) //scan "path"
        {
            if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
                count1++;                
            
            //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
            i++;
        }  
         
        i =0; j =0; //reset values

        while (Path_CSV[i] !=0) //seperate "path" and "filename"
        {
            if(count2==count1) //get filename after last "\"
            {              
                gAddressList_CSV_filename[j] =Path_CSV[i];
                j++;

                Path_CSV[i] =0;              
            }

            if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
                count2++;
                               
            i++;
        }

        writelineEx(gAddressList_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 

        writelineEx(gAddressList_writeWindow, 0,"filename of *.csv: '%s'", gAddressList_CSV_filename);  //output filename 

        putvalue(env_NaviSD_AL_DataSource_file, gAddressList_CSV_filename); //output current loaded *.csv-file on panel

        setFilePath(Path_CSV, 0); //set path for *.csv file

        CSVfileHandle =openFileRead(gAddressList_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        

        if (CSVfileHandle!=0) //*.csv file access successful
        {
            writelineEx(gAddressList_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gAddressList_CSV_filename);    //output result  
            
            putvalue(env_NaviSD_AL_DataSource_result, "successful");   //output result on panel                      
            
            Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
            write("Num_of_csv_byte =%d", Num_of_csv_byte);
            for (i=0; i<Num_of_csv_byte; i++) //copy data into "AddressList"
            {      
                if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
                {
                    if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in AddressList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                    {
                        if(current_CSV_line>0 && AddressListLine<NAV_ADDRESSLIST_ENTRIES) //ignore first line in *.csv file
                        {   
                            writelineEx(gAddressList_writeWindow, 0, "");
                            writelineEx(gAddressList_writeWindow, 0,"*******Element %d*******",AddressListLine);

                            //transform 'string' to 'long' for "POS", "POIType" and "AddressType"
                            gAddressList_Pos[AddressListLine]           =atol(AddressList_Pos_string[AddressListLine]);
                            gAddressList_POIType[AddressListLine]       =atol(AddressList_POIType_string[AddressListLine]);
                            gAddressList_AddressType[AddressListLine]   =atol(AddressList_AddressType_string[AddressListLine]);                        
                            
                            writelineEx(gAddressList_writeWindow, 0,"Pos[%d]: 0x%x",AddressListLine, gAddressList_Pos[AddressListLine]);

                            writelineEx(gAddressList_writeWindow, 0,"LastName[%d]: %s",AddressListLine, gAddressList_LastName[AddressListLine]);                            
                            
                            writelineEx(gAddressList_writeWindow, 0,"FirstName[%d]: %s",AddressListLine, gAddressList_FirstName[AddressListLine]);

                            writelineEx(gAddressList_writeWindow, 0,"Street[%d]: %s",AddressListLine, gAddressList_Street[AddressListLine]);

                            writelineEx(gAddressList_writeWindow, 0,"City[%d]: %s",AddressListLine, gAddressList_City[AddressListLine]);

                            writelineEx(gAddressList_writeWindow, 0,"Region[%d]: %s",AddressListLine, gAddressList_Region[AddressListLine]);

                            writelineEx(gAddressList_writeWindow, 0,"PostalCode[%d]: %s",AddressListLine, gAddressList_PostalCode[AddressListLine]);

                            writelineEx(gAddressList_writeWindow, 0,"Country[%d]: %s",AddressListLine, gAddressList_Country[AddressListLine]);

                            writelineEx(gAddressList_writeWindow, 0,"Coordinates[%d]: %s",AddressListLine, gAddressList_Coordinates[AddressListLine]);

                            writelineEx(gAddressList_writeWindow, 0,"POI_Description[%d]: %s",AddressListLine, gAddressList_POIDescription[AddressListLine]);

                            writelineEx(gAddressList_writeWindow, 0,"POI_Type[%d]: 0x%x",AddressListLine, gAddressList_POIType[AddressListLine]);
                            if(gAddressList_POIType[AddressListLine] <0xA0)
                                writeEx(gAddressList_writeWindow, 0," -> '%s'", gAddressList_POIType_s[gAddressList_POIType[AddressListLine]]);
        
                            else if (gAddressList_POIType[AddressListLine] ==0xFF)
                                writeEx(gAddressList_writeWindow, 0," -> '%s'", gstring_unknown);
                            else
                                writeEx(gAddressList_writeWindow, 0," -> '%s'", gstring_reserved);

                            writelineEx(gAddressList_writeWindow, 0,"Address_Type[%d]: 0x%x",AddressListLine, gAddressList_AddressType[AddressListLine]);
                            if(gAddressList_AddressType[AddressListLine] <0x03)
                                writeEx(gAddressList_writeWindow, 0," -> '%s'", gAddressList_AddressType_s[gAddressList_AddressType[AddressListLine]]);
        
                            else if (gAddressList_AddressType[AddressListLine] ==0xFF)
                                writeEx(gAddressList_writeWindow, 0," -> '%s'", gstring_unknown);
                            else
                                writeEx(gAddressList_writeWindow, 0," -> '%s'", gstring_reserved);
                            
                            gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
                                                
                            AddressListLine++; // -> next line in *.csv (next record element)
                        }

                        current_CSV_line++; //next line in *.csv file
                        element =0; //start at 'POS' (first record element of "array data")
                        j=0; //reset value
                    }
                      
                    else if(current_CSV_line>0 && AddressListLine<NAV_ADDRESSLIST_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                    {
                        switch (element)
                        {
                            case 0: //POS
                                    AddressList_Pos_string[AddressListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //LastName
                                    gAddressList_LastName[AddressListLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 2: //FirstName
                                    gAddressList_FirstName[AddressListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;
                            case 3: //Street
                                    gAddressList_Street[AddressListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 4: //City
                                    gAddressList_City[AddressListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;
                            
                            case 5: //Region
                                    gAddressList_Region[AddressListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 6: //PostalCode
                                    gAddressList_PostalCode[AddressListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;


                            case 7: //Country
                                    gAddressList_Country[AddressListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;


                            case 8: //Coordinates
                                    gAddressList_Coordinates[AddressListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;


                            case 9: //POI_Description
                                    gAddressList_POIDescription[AddressListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 10: //POI_Type
                                    AddressList_POIType_string[AddressListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 11: //Address_Type
                                    AddressList_AddressType_string[AddressListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            default:
                             break;
                        }
                    }                               
                }
                               
                else  // ";" is detected ->next record element of "array data"
                {                                          
                    element++;
                    j=0; //reset value  
                }                                              
        
            }         
            
            gAddressList_TotalNumListElements =gAddressListLine_sum =AddressListLine; //get "total number of list elements"
            
            putvalue(env_NaviSD_AL_TotalNumLE, gAddressList_TotalNumListElements);

            writelineEx(gAddressList_writeWindow, 0, "");

            writelineEx(gAddressList_writeWindow, 0,"Anzahl der Listenelemente: %d", gAddressListLine_sum); //output total number of list elements

            writelineEx(gAddressList_writeWindow, 0, "");

            if(fileClose (CSVfileHandle) !=0) //close *.csv file
                writelineEx(gAddressList_writeWindow, 0,"Datei '%s' geschlossen", gAddressList_CSV_filename); //output result
             
            else
                writelineEx(gAddressList_writeWindow, 0,"Fehler beim Schlieen der Datei '%s'", gAddressList_CSV_filename);//output result
        }

        else //*.csv file access not successful
        {
            writelineEx(gAddressList_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gAddressList_CSV_filename); //output result
            
            putvalue(env_NaviSD_AL_DataSource_result,"not successful"); //output result
        }
    }
}

AddressList_init_static()
{
    byte j, i, AddressListLine;
    
    //clear
    AddressListLine       =0;
    gAddressListLine_sum  =0;

    for(j=0;j<NAV_ADDRESSLIST_ENTRIES;j++) //clear "AddressList Array"
        {
            gAddressList_ListEntryValidInformation[j]  =FALSE;

            gAddressList_Pos[j]             =0;
            gAddressList_POIType[j]         =0;
            gAddressList_AddressType[j]     =0;

            for(i=0;i<NAV_ADDRESSLIST_LASTNAME_LENGTH;i++)
                gAddressList_LastName[j][i]=0;
            
            for(i=0;i<NAV_ADDRESSLIST_FIRSTNAME_LENGTH;i++)
                gAddressList_FirstName[j][i]=0;
                
            for(i=0;i<NAV_ADDRESSLIST_STREET_LENGTH;i++)
                gAddressList_Street[j][i]=0;
            
            for(i=0;i<NAV_ADDRESSLIST_CITY_LENGTH;i++)
                gAddressList_City[j][i]=0;
                
            for(i=0;i<NAV_ADDRESSLIST_REGION_LENGTH;i++)
                gAddressList_Region[j][i]=0;
                
            for(i=0;i<NAV_ADDRESSLIST_POSTALCODE_LENGTH;i++)
                gAddressList_PostalCode[j][i]=0;
                
            for(i=0;i<NAV_ADDRESSLIST_COUNTRY_LENGTH;i++)
                gAddressList_Country[j][i]=0;
                
            for(i=0;i<NAV_ADDRESSLIST_COORDINATES_LENGTH;i++)
                gAddressList_Coordinates[j][i]=0;            
    // MR78172                
            for(i=0;i<NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH;i++)
                gAddressList_POIDescription[j][i]=0;
            
        }
          
    //entry 0
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x8745;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_0",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_0",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_0",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_0",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_0",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_0",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_0",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_0",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_0",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_NOPOI;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPARCELADDRESS;
    AddressListLine++;
    
    //entry 1
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x34FA;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_1",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_1",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_1",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_1",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_1",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_1",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_1",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_1",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_1",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_ALLRESTAURANTS;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPRIVATE;
    AddressListLine++;

    //entry 2
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0xEA84;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_2",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_2",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_2",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_2",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_2",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_2",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_2",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_2",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_2",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_COURT;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_PRIVATE;
    AddressListLine++;

    //entry 3
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x9145;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_3",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_3",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_3",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_3",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_3",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_3",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_3",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_3",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_3",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_DINNINGSHOPPING;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_PRIVATE;
    AddressListLine++;

    //entry 4
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x1;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_4",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_4",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_4",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_4",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_4",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_4",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_4",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_4",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_4",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_CORPORATIONS;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPARCELADDRESS;
    AddressListLine++;

    //entry 5
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x2;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_5",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_5",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_5",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_5",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_5",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_5",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_5",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_5",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_5",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_CITYHALL;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPARCELADDRESS;
    AddressListLine++;

    //entry 6
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x9;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_6",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_6",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_6",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_6",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_6",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_6",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_6",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_6",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_6",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_CARTRAIN;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPRIVATE;
    AddressListLine++;

    //entry 7
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x3751;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_7",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_7",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_7",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_7",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_7",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_7", NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_7",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_7",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_7",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_TRAVEL;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_PRIVATE;
    AddressListLine++;

    //entry 8
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0xAB41;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_8",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_8",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_8",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_8",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_8",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_8",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_8",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_8",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_8",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_TRANSPORTATION;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPARCELADDRESS;
    AddressListLine++;

    //entry 9
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x3005;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_9",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_9",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_9",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_9",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_9", NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_9",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_9",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_9",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_9",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_SPORTGOODS;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPRIVATE;
    AddressListLine++;

    //entry 10
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x3107;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_10",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_10",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_10",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_10",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_10",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_10",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_10",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_10",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_10",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_CARMAN;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPARCELADDRESS;
    AddressListLine++;

    //entry 11
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x1983;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_11",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_11",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_11",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_11",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_11",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_11",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_0",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_11",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_11",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_UNKNOWN;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_PRIVATE;
    AddressListLine++;

    //entry 12
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0xFFE1;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_12",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_12",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_12",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_12",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_12",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_12",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_12",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_12",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_12",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_LIQGASSTATION;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_PRIVATE;
    AddressListLine++;

    //entry 13
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x742C;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_13",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_13",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_13",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_13",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_13",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_13",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_13",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_13",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_13",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_MAJORAPPLICANCE;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPRIVATE;
    AddressListLine++;

    //entry 14
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0xC78A;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_14",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_14",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_14",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_14",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_14",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_14",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_14",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_14",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_14",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_PUBLISHER;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPARCELADDRESS;
    AddressListLine++;

    //entry 15
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x52;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_15",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_15",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_15",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_15", NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_15",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_15",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_15",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_15",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_15",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_SOCIALSERVICE;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPRIVATE;
    AddressListLine++;

    //entry 16
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x97;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_16",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_16",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_16",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_16",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_16",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_16",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_16",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_16",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_16",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_GLASSANDWINDOW;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_PRIVATE;
    AddressListLine++;

    //entry 17
    gAddressList_ListEntryValidInformation[AddressListLine]  =TRUE;
    gAddressList_Pos [AddressListLine]                       =0x51;
    strncpy(gAddressList_LastName [AddressListLine], "LastName_17",NAV_ADDRESSLIST_LASTNAME_LENGTH);
    strncpy(gAddressList_FirstName [AddressListLine], "FirstName_17",NAV_ADDRESSLIST_FIRSTNAME_LENGTH);
    strncpy(gAddressList_Street [AddressListLine], "Street_17",NAV_ADDRESSLIST_STREET_LENGTH);
    strncpy(gAddressList_City [AddressListLine], "City_17",NAV_ADDRESSLIST_CITY_LENGTH);
    strncpy(gAddressList_Region [AddressListLine], "Region_17",NAV_ADDRESSLIST_REGION_LENGTH);
    strncpy(gAddressList_PostalCode [AddressListLine], "PostalCode_17",NAV_ADDRESSLIST_POSTALCODE_LENGTH);
    strncpy(gAddressList_Country [AddressListLine], "Country_17",NAV_ADDRESSLIST_COUNTRY_LENGTH);
    strncpy(gAddressList_Coordinates [AddressListLine], "Coordinates_17",NAV_ADDRESSLIST_COORDINATES_LENGTH);
    strncpy(gAddressList_POIDescription [AddressListLine], "POIDescription_17",NAV_ADDRESSLIST_POIDESCRIPTION_LENGTH);
    gAddressList_POIType [AddressListLine]                   =NAV_ADDRESSLIST_POITYPE_FUNERALDIRECTOR;
    gAddressList_AddressType [AddressListLine]               =NAV_ADDRESSLIST_ADDRESSTYPE_BUSINESSPRIVATE;
    AddressListLine++;
    
    gAddressListLine_sum               =AddressListLine;
    gAddressList_TotalNumListElements  =gAddressListLine_sum;

    //write Array in "write-window"
    /*
    writeClear(gAddressList_writeWindow);
    writelineEx(gAddressList_writeWindow, 0, "");
    writelineEx(gAddressList_writeWindow, 0,"*******Default AddressList_Array*******");
    writelineEx(gAddressList_writeWindow, 0, "");
    
    for (i=0;i<gAddressListLine_sum;i++)
    {
        writelineEx(gAddressList_writeWindow, 0,"*******Element %d*******",i);
        
        writelineEx(gAddressList_writeWindow, 0,"Pos[%d]: 0x%x", i, gAddressList_Pos [i]);
                     
        writelineEx(gAddressList_writeWindow, 0,"LastName[%d]: %s",i, gAddressList_LastName[i]);

        writelineEx(gAddressList_writeWindow, 0,"FirstName[%d]: %s",i, gAddressList_FirstName[i]);

        writelineEx(gAddressList_writeWindow, 0,"Street[%d]: %s",i, gAddressList_Street[i]);

        writelineEx(gAddressList_writeWindow, 0,"City[%d]: %s",i, gAddressList_City[i]);

        writelineEx(gAddressList_writeWindow, 0,"Region[%d]: %s",i, gAddressList_Region[i]);

        writelineEx(gAddressList_writeWindow, 0,"PostalCode[%d]: %s",i, gAddressList_PostalCode[i]);

        writelineEx(gAddressList_writeWindow, 0,"Country[%d]: %s",i, gAddressList_Country[i]);

        writelineEx(gAddressList_writeWindow, 0,"Coordinates[%d]: %s",i, gAddressList_Coordinates[i]);

        writelineEx(gAddressList_writeWindow, 0,"POI_Description[%d]: %s",i, gAddressList_POIDescription[i]);

        writelineEx(gAddressList_writeWindow, 0,"POI_Type[%d]: 0x%x",i, gFavoriteDestList_POIType[i]);
        if(gAddressList_POIType[i] <0xA0)
            writeEx(gAddressList_writeWindow, 0," -> '%s'", gAddressList_POIType_s[gAddressList_POIType[i]]);
        
        else if (gAddressList_POIType[i] ==0xFF)
            writeEx(gAddressList_writeWindow, 0," -> '%s'", gstring_unknown);
        else
            writeEx(gAddressList_writeWindow, 0," -> '%s'", gstring_reserved);

        writelineEx(gAddressList_writeWindow, 0,"Address_Type[%d]: 0x%x",i, gAddressList_AddressType[i]);
        if(gAddressList_AddressType[i] <0x03)
            writeEx(gAddressList_writeWindow, 0," -> '%s'", gAddressList_AddressType_s[gAddressList_AddressType[i]]);
        
        else if (gAddressList_AddressType[i] ==0xFF)
            writeEx(gAddressList_writeWindow, 0," -> '%s'", gstring_unknown);
        else
            writeEx(gAddressList_writeWindow, 0," -> '%s'", gstring_reserved);

        writelineEx(gAddressList_writeWindow, 0, "");
    }

    writelineEx(gAddressList_writeWindow, 0,"Anzahl der Listenelemente: %d", gAddressListLine_sum);
    */
    putvalue(env_NaviSD_AL_TotalNumLE, gAddressList_TotalNumListElements);
}

on envVar env_NaviSD_AL_CA
{
    word requested_startelement, startelement, elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        if(getvalue(env_NaviSD_AL_AH_start) >255 && getvalue(env_NaviSD_AL_AH_IS) ==0)// check if 8 or 16 bit
            putvalue(env_NaviSD_AL_AH_IS,1);

        //get data from Panel
        recordaddress   =getvalue(env_NaviSD_AL_AH_RA);
        shift           =getvalue(env_NaviSD_AL_AH_shift);
        direction       =getvalue(env_NaviSD_AL_AH_dir);
        transmitpos     =getvalue(env_NaviSD_AL_AH_POS);
        indexsize       =getvalue(env_NaviSD_AL_AH_IS);
        startelement    =getvalue(env_NaviSD_AL_AH_start);
        elements        =getvalue(env_NaviSD_AL_AH_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        requested_startelement =startelement;

        if(getvalue(env_NaviSD_AL_CA_switch)) // ArrayHeader (+ Data)
        {/***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
        {
            if(FORWARD==direction)  //forward-start
            {
                valid_startelement =0;                                                           

                if(NAV_ADDRESSLIST_ENTRIES <=elements) //1. more elements requested, than in array
                {
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
                        {
                            if(0 !=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i =NAV_ADDRESSLIST_ENTRIES;
                        }
                    }
                    else 
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if (shift ==FALSE)
                    {
                        for(i=0;i<elements;i++)
                        {
                            if(0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i =NAV_ADDRESSLIST_ENTRIES;
                        }
                    }
                    else 
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
            {   
                //searching for valid startelement
                for(i=(NAV_ADDRESSLIST_ENTRIES-1);i>=0;i--)
                {
                    if(0!=gAddressList_ListEntryValidInformation[i])        //found valid startelement
                    {
                        valid_startelement =i;                                
                        i =0;                                                
                    }
                }
                        
                //searching for valid elements
                if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  =startelement;
                    valid_elements      =0;
                }
                else if(0==valid_startelement)                                
                    valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for(i=valid_startelement;i>=0;i--)
                    {
                        if(0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                    {
                        if(0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }                   
                }                                                            
            }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID                
        {
            //searching for valid startelement
            for(i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
            {
                if(gAddressList_Pos[i] ==startelement)                        //found a valid element
                {                                       
                    if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                    {
                        if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement =i+1-2*direction;
                                                            
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gAddressListLine_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
                    
                    else
                        valid_startelement =i;                              //found element is valid_startelement

                    i =NAV_ADDRESSLIST_ENTRIES;
                }
                else
                    valid_startelement =0xff;
            }

            if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
            {   
                valid_startelement  =startelement;
                valid_elements      =0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if(BACKWARD==direction)                                            //backward-start
                {
                    if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                        valid_elements=1;
                            
                    else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for(i=valid_startelement;i>=0;i--)
                        {
                            if(0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for(i=valid_startelement;i>(valid_startelement-elements);i--)
                        {
                            if(0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements)>=NAV_ADDRESSLIST_ENTRIES)
                    {
                        for(i=valid_startelement;i<NAV_ADDRESSLIST_ENTRIES;i++)
                        {
                            if(0!=gAddressList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_ADDRESSLIST_ENTRIES;
                        }
                    }
                    else
                    {
                        for(i=valid_startelement;i<(valid_startelement+elements);i++)
                        {
                            if(0!=gAddressList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_ADDRESSLIST_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue(env_NaviSD_AL_AH_elements, valid_elements);
        }
        else
        {
            valid_startelement      =startelement;
            valid_elements          =elements;
        }
        
        requested_startelement =startelement;

        AddressList_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
    }
}

on envVar env_NaviSD_AL_DataSource
{
    if (getvalue(this) ==NAV_DEFAULT_LIST)
    {
        AddressList_init_static();
        putvalue(env_NaviSD_AL_DataSource_file, empty_string);
        putvalue(env_NaviSD_AL_DataSource_result, empty_string);
    }
}

on envVar env_NaviSD_AL_reload //load external LastDestList from *.csv
{
    if(getvalue(this) && getvalue(env_NaviSD_AL_DataSource) ==NAV_EXTERNAL_LIST)
        AddressList_init_CSV(); 

    else if(getvalue(env_NaviSD_AL_DataSource) != NAV_EXTERNAL_LIST)
        putvalue(env_NaviSD_AL_DataSource_result,"not successful, select 'external *.csv'");
}

on envVar env_NaviSD_AL_StatusArray
{ /* Bewe(2013-10-17) - Clean-Up Indents */
  word requested_startelement, startelement, elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
  //MR 76047 
  int i, transSuppression;
  
  // Init local variables. 
  mode                    =0;
  shift                   =0;
  direction               =0;
  transmitpos             =0;
  indexsize               =0;
  recordaddress           =0;
  requested_startelement  =0;
  startelement            =0;
  elements                =0;
  valid_startelement      =0;
  i                       =0;
  valid_elements          =0;
  //MR 76047 
  transSuppression        = getvalue(env_NaviSD_AL_StatusOFF);

  if (gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
  {
    if (getvalue(env_NaviSD_AL_AH_start) >255 && getvalue(env_NaviSD_AL_AH_IS) ==0)// check if 8 or 16 bit
    { putvalue(env_NaviSD_AL_AH_IS,1); }

    //get data from Panel
    gAddressList_ASGID                 =getvalue(env_NaviSD_AL_ASGID);
    gAddressList_TAID                  =getvalue(env_NaviSD_AL_TAID);
    
    //MR 63332 #3   02.07.2014
    //gAddressList_TotalNumListElements  =getvalue(env_NaviSD_AL_TotalNumLE);
    
    gAddressList_OtherListType         =getvalue(env_NaviSD_AL_OtherListType); 
    gAddressList_OtherListReference    =getvalue(env_NaviSD_AL_OtherList_Ref); 

    recordaddress   =getvalue(env_NaviSD_AL_AH_RA);
    shift           =getvalue(env_NaviSD_AL_AH_shift);
    direction       =getvalue(env_NaviSD_AL_AH_dir);
    transmitpos     =getvalue(env_NaviSD_AL_AH_POS);
    indexsize       =getvalue(env_NaviSD_AL_AH_IS);
    startelement    =getvalue(env_NaviSD_AL_AH_start);
    elements        =getvalue(env_NaviSD_AL_AH_elements);

    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
    
    requested_startelement =startelement;
    // Bewe (2013-10-17) - Handling StartElement for OLT
    if (gAddressList_OtherListType!=0x0F)
    { /* OLT is NOT CompleteListe - use OL_Ref as startelement */
      startelement = gAddressList_OtherListReference;
    }
    /***Startelement=0***/
    if (0==startelement) //Startelement-ID =0 -> start at first array-entry
    {
      if (FORWARD==direction)  //forward-start
      {
        valid_startelement =0;                                                           

        if (NAV_ADDRESSLIST_ENTRIES <=elements) //1. more elements requested, than in array
        {
          if (shift ==FALSE)  
          {
            for (i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
            {
              if (0 !=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
              { valid_elements++;    }                            //increment elements
              else                                                //no valid element, loop finished
              { i =NAV_ADDRESSLIST_ENTRIES; }
            }
          }
          else 
          {   
            valid_startelement  =startelement;
            valid_elements      =0;
          }
        }
        else    //2. number of requested elements < elements in array
        {
          if (shift ==FALSE)
          {
            for (i=0;i<elements;i++)
            {
              if (0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
              { valid_elements++;    }                            //increment elements
              else                                                //no valid element, loop finished
              { i =NAV_ADDRESSLIST_ENTRIES; }
            }
          }
          else 
          {   
            valid_startelement  =startelement;
            valid_elements      =0;
          }
        }
      } //forward-end
      else if (BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
      {   
        //searching for valid startelement
        for (i=(NAV_ADDRESSLIST_ENTRIES-1);i>=0;i--)
        {
          if (0!=gAddressList_ListEntryValidInformation[i])        //found valid startelement
          {
            valid_startelement =i;                                
            i =0;                                                
          }
        }
        //searching for valid elements
        if (0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
        {
          valid_startelement  =startelement;
          valid_elements      =0;
        }
        else if (0==valid_startelement)                                
        { valid_elements=1; }                                      //only 1 element because valid startelement is on position 0    
        else if (elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
        {
          for (i=valid_startelement;i>=0;i--)
          {
            if (0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
            { valid_elements++;    }                            //increment elements
            else                                                //no valid element, loop finished
            { i=0; }
          }
        }
        else                                                        //enougth array-elements available
        {
          for (i=valid_startelement;i>(valid_startelement-elements);i--)
          {
            if (0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
            { valid_elements++;    }                            //increment elements
            else                                                //no valid element, loop finished
            { i=0; }
          }                   
        }                                                            
      } //backward-end
    } //(startelement==0)-end
    /***Startelement!=0***/
    else                                                                //searching for Startelement-ID                
    {
      //searching for valid startelement
      for (i=0;i<NAV_ADDRESSLIST_ENTRIES;i++)
      {
        if (gAddressList_Pos[i] ==startelement)                        //found a valid element
        {                                       
          if (shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
          {
            if (i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
            { valid_startelement =i+1-2*direction; }
            else if (i==0 && BACKWARD==direction) 
            { valid_startelement =gAddressListLine_sum; }    //valid element is last element in Array                                                
            else if (i==0 && FORWARD==direction) 
            { valid_startelement =0; }                         //valid element is first element in Array
          }
          else
          { valid_startelement =i; }                             //found element is valid_startelement
          i =NAV_ADDRESSLIST_ENTRIES;
        }
        else
        { valid_startelement =0xff; }
      }

      if (0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
      {   
        valid_startelement  =startelement;
        valid_elements      =0;
      }
      else                                                                //found valid entry for startelement in array
      {
        //verify number of valid elements
        if (BACKWARD==direction)                                            //backward-start
        {
          if (valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
          { valid_elements=1; }
          else if (elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
          {
            for (i=valid_startelement;i>=0;i--)
            {
              if (0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
              { valid_elements++;    }                            //increment elements
              else                                                //no valid element, loop finished
              { i=0; }
            }
          }
          else                                                        //enougth array-elements available
          {
            for (i=valid_startelement;i>(valid_startelement-elements);i--)
            {
              if (0!=gAddressList_ListEntryValidInformation[i])    //if there is an valid element
              { valid_elements++;    }                            //increment elements
              else                                                //no valid element, loop finished
              { i=0; }
            }
          }
        }                                                                //backward-end
        else                                                            //forward-start
        {
          if ((valid_startelement+elements)>=NAV_ADDRESSLIST_ENTRIES)
          {
            for (i=valid_startelement;i<NAV_ADDRESSLIST_ENTRIES;i++)
            {
              if (0!=gAddressList_Pos[i])                            //if there is an valid element
              { valid_elements++;    }                            //increment elements
              else                                                //no valid element, loop finished
              { i=NAV_ADDRESSLIST_ENTRIES; }
            }
          }
          else
          {
            for (i=valid_startelement;i<(valid_startelement+elements);i++)
            {
              if (0!=gAddressList_Pos[i])                            //if there is an valid element
              { valid_elements++;    }                            //increment elements
              else                                                //no valid element, loop finished
              { i=NAV_ADDRESSLIST_ENTRIES; }
            }
          }
        }
      }
    }
    putvalue(env_NaviSD_AL_AH_elements, valid_elements);
    //send StatusArray
    //MR 76047 
    if(!transSuppression)
    AddressList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);
  }
}

on timer RGActDeact_MethodHandling_Timer
{
    gNav_RG_ActDeact_Result =getvalue(env_NaviSD_RGActDeact_Res);
    switch( gNav_RG_ActDeact_Result )
    {
        case 0x00:      // successful
            break;
        case 0x02:      // abort successful                
                if(TRUE == gNav_RGActDeact_Status)                                //method active    
                {
                    putvalue(env_NaviSD_RG_Status, 0x00);
                }
        case 0x03:      // abort not successful
        case 0x01:      // not successful
        case 0x04:      // RG not active
        case 0x05:      // RG already active
        case 0x06:      // not successful - ControlInformation does not match to FSG internal destination (RG not started!)
        case 0x07:      // not successful - destination address needs to be refined/detailed at head unit
        case 0x08:      // not successful - home address not specified in FSG
        case 0x09:      // not successful - select Route at FSG
        case 0x0A:      // not successful - select home address at FSG (several home addresses available) (DF4.1)
        default:
            gNav_RG_ActDeact_MethodHandling = 0x00;
            break;
    }

    switch (gNav_RG_ActDeact_MethodHandling)
    {
        case 1:
                ManeuverDescriptor_Request(Data_REQ, 0);    //send status
                gNav_RG_ActDeact_MethodHandling =2;
                settimer(RGActDeact_MethodHandling_Timer,gNav_RG_ActDeact_MethodHandling_Time);
         break;
        
        case 2: 
                DistanceToDestination_Request(Data_REQ, 0);    //send status
                gNav_RG_ActDeact_MethodHandling =3;
                settimer(RGActDeact_MethodHandling_Timer,gNav_RG_ActDeact_MethodHandling_Time);
         break;
        
        case 3: 
                TimeToDestination_Request(Data_REQ, 0);    //send status
                gNav_RG_ActDeact_MethodHandling =4;
                settimer(RGActDeact_MethodHandling_Timer,gNav_RG_ActDeact_MethodHandling_Time);
         break;
        
        case 4: 
                CurrentPositionInfo_Request(Data_REQ, 0);    //send status
                gNav_RG_ActDeact_MethodHandling =5;
                settimer(RGActDeact_MethodHandling_Timer,gNav_RG_ActDeact_MethodHandling_Time);
         break;
        
        case 5: 
                // gRG_Status =NAV_RGSTATUS_RG_ACTIVE;
                //IssueList #14
                //gRG_Status = ((gNav_RGActDeact_ControlType) ? 0 : 1);
                if( getvalue(env_NaviSD_RGActDeact_Res)==NAV_RGACTDEACT_SUCCESSFUL )
                {
                    if( gNav_RGActDeact_ControlType == NAV_STARTROUTEGUIDANCE )
                    {
                        gRG_Status = 0x01;
                        //IssueList #98
                        gMD_MainElement_1 = 0x14;
                    }
                    else
                    {
                        gRG_Status = 0x00;
                        //IssueList #98
                        gMD_MainElement_1 = 0x00;

                    }
                }
                putvalue(env_NaviSD_RG_Status,gRG_Status);
                //IssueList #98
                putValue(env_NaviSD_MD_MainElement1,gMD_MainElement_1); 
                RG_Status_Request(Data_REQ, 0);    //send status

                //IssueList #98
                ManeuverDescriptor_Request(Data_REQ,0);

                gNav_RG_ActDeact_MethodHandling =0;       
         break;
        
        default:
         break;
    }   
}

on envVar env_NaviSD_LG_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        //get data from Panel
        gLaneGuidance_LaneGuidanceOnOff  =getvalue(env_NaviSD_LG_LGOnOff);
        
        recordaddress   =0;
        shift           =0;
        direction       =0;
        transmitpos     =0;
        indexsize       =0;
        startelement    =0;
        elements        =255;
        
        //MR 63332 #2 02.07.2014
        /*
        putvalue(env_NaviSD_LG_CA_switch, FALSE);

        putvalue(env_NaviSD_LG_AH_RA, recordaddress);
        putvalue(env_NaviSD_LG_AH_shift, shift);
        putvalue(env_NaviSD_LG_AH_dir, direction);
        putvalue(env_NaviSD_LG_AH_POS, transmitpos);
        putvalue(env_NaviSD_LG_AH_IS, indexsize);
        putvalue(env_NaviSD_LG_AH_start, startelement);
        putvalue(env_NaviSD_LG_AH_elements, elements);
        */

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        //send ChangedArray
        LaneGuidance_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
    }
}

on envVar env_NaviSD_AL_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        recordaddress   =0;
        shift           =0;
        direction       =0;
        transmitpos     =0;
        indexsize       =1;
        startelement    =0;
        elements        =65535;
        
        //MR 63332 #2 02.07.2014
        /*
        putvalue(env_NaviSD_AL_AH_RA, recordaddress);
        putvalue(env_NaviSD_AL_AH_shift, shift);
        putvalue(env_NaviSD_AL_AH_dir, direction);
        putvalue(env_NaviSD_AL_AH_POS, transmitpos);
        putvalue(env_NaviSD_AL_AH_IS, indexsize);
        putvalue(env_NaviSD_AL_AH_start, startelement);
        putvalue(env_NaviSD_AL_AH_elements, elements);
        */

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        //send ChangedArray
        AddressList_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
    }
}

on envVar env_NaviSD_NB_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        recordaddress   =0;
        shift           =0;
        direction       =0;
        transmitpos     =0;
        indexsize       =1;
        startelement    =0;
        elements        =65535;
        
        //MR 63332 #2 02.07.2014
        /*
        putvalue(env_NaviSD_NB_AH_RA, recordaddress);
        putvalue(env_NaviSD_NB_AH_shift, shift);
        putvalue(env_NaviSD_NB_AH_dir, direction);
        putvalue(env_NaviSD_NB_AH_POS, transmitpos);
        putvalue(env_NaviSD_NB_AH_IS, indexsize);
        putvalue(env_NaviSD_NB_AH_start, startelement);
        putvalue(env_NaviSD_NB_AH_elements, elements);
        */

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        //send ChangedArray
        NavBook_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
    }
}

on envVar env_NaviSD_LDL_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        
        recordaddress   =0;
        shift           =0;
        direction       =0;
        transmitpos     =0;
        indexsize       =0;
        startelement    =0;
        elements        =255;
        
        //MR 63332 #2 02.07.2014
        /*
        putvalue(env_NaviSD_LDL_AH_RA, recordaddress);
        putvalue(env_NaviSD_LDL_AH_shift, shift);
        putvalue(env_NaviSD_LDL_AH_dir, direction);
        putvalue(env_NaviSD_LDL_AH_POS, transmitpos);
        putvalue(env_NaviSD_LDL_AH_IS, indexsize);
        putvalue(env_NaviSD_LDL_AH_start, startelement);
        putvalue(env_NaviSD_LDL_AH_elements, elements);
        putvalue(env_NaviSD_LDL_CA_switch, FALSE);
        */

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        //send ChangedArray
        //MR 63667 11.07.2014 -TNLE with SA-button
        //LastDestList_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
        LastDestList_Request(Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0);
    }
}

on envVar env_NaviSD_FDL_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
        
        recordaddress   =0;
        shift           =0;
        direction       =0;
        transmitpos     =0;
        indexsize       =0;
        startelement    =0;
        elements        =255;
        
        //MR 63332 #2 02.07.2014
        /*
        putvalue(env_NaviSD_FDL_AH_RA, recordaddress);
        putvalue(env_NaviSD_FDL_AH_shift, shift);
        putvalue(env_NaviSD_FDL_AH_dir, direction);
        putvalue(env_NaviSD_FDL_AH_POS, transmitpos);
        putvalue(env_NaviSD_FDL_AH_IS, indexsize);
        putvalue(env_NaviSD_FDL_AH_start, startelement);
        putvalue(env_NaviSD_FDL_AH_elements, elements);
        */

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        //send ChangedArray
        FavoriteDestList_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
    }
}

on envVar BAPCFG_FSG_NaviSD_ProtocolMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = 0x32;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP170_ChangeConfig(NODE_INDEX, 7, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Major Protocol Version.",NODE_INDEX, ret);
        }
        else
        {
            writeLineEx(gBAP_Trace, 0, "Major Protocol version is set to %d.", getValue(this) );
        }
    }

}

on envVar BAPCFG_FSG_NaviSD_ProtocolMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = 0x32;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP170_ChangeConfig(NODE_INDEX, 8, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor  Protocol Version.",NODE_INDEX, ret);
        }
        else
        {
            writeLineEx(gBAP_Trace, 0, "Minor Protocol version is set to %d node is %d.", getValue(this), NODE_INDEX );
        }
    }
}

on envVar BAPCFG_FSG_NaviSD_LsgClassMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = 0x32;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP170_ChangeConfig(NODE_INDEX, 5, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Major LSG Class Version.",NODE_INDEX, ret);
        }
    }

}

on envVar BAPCFG_FSG_NaviSD_LsgClassMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = 0x32;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP170_ChangeConfig(NODE_INDEX, 6, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor LSG Class Version.",NODE_INDEX, ret);
        }
    }
}

on envVar BAPCFG_FSG_NaviSD_DFMinor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = 0x32;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP170_ChangeConfig(NODE_INDEX, 10, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret);
        }
    }
}

on envVar BAPCFG_FSG_NaviSD_DFMajor
{
    long temp[3];
    byte ret,i ;
    for (i = 0; i < 4; i++)
    {
        temp[0] = 0x32;
        temp[1] = i;
        temp[2] = getValue(this);
        ret = BAP170_ChangeConfig(NODE_INDEX, 9, temp);
        if (ret != 0)
        {
            writeLineEx(gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Major DF Version.",NODE_INDEX, ret);
        }
    }

}

initBapConfig()
{
    long config[3];
    config[0] = 0x32;
    config[1] = 0;
    config[2] = getValue(BAPCFG_FSG_NaviSD_ProtocolMajor);
    ChangeConfig(0x0012,config);
    config[2] = getValue(BAPCFG_FSG_NaviSD_ProtocolMinor);
    ChangeConfig(0x0013,config);
    config[2] = getValue(BAPCFG_FSG_NaviSD_LsgClassMajor);
    ChangeConfig(0x0010,config);
    config[2] = getValue(BAPCFG_FSG_NaviSD_LsgClassMinor);
    ChangeConfig(0x0011,config);
    config[2] = getValue(BAPCFG_FSG_NaviSD_DFMajor);
    ChangeConfig(0x0014,config);
    config[2] = getValue(BAPCFG_FSG_NaviSD_DFMinor);
    ChangeConfig(0x0015,config);    
}

ChangeConfig(long paramIndex,long config[])
{

        byte temp ;
        temp = BAP170_ChangeConfig(NODE_INDEX, paramIndex, config);
        if(temp == 0)
            writelineEx(gBAP_Trace, 0, "BAP170_ChangeConfig succesful (LSG %d, NODE_INDEX %d)", 0x32, NODE_INDEX);
        else
            writelineEx(gError_Trace, 0, "BAP170_ChangeConfig error 0x%X (LSG %d, NODE_INDEX %d)", temp, 0x32, NODE_INDEX);        
}

//MR48598
on envVar env_NaviSD_FctList_0x11
{
    if (getValue(this)==0x00)
    {
        putValue(env_NaviSD_RG_Status,0);
        gRG_Status = 0;
        RG_Status_Request(Data_REQ,0); //send status
     }
}

//IssueList #9
on envVar env_FSG_Navi_HB_button
{
    long data[2];
    //IssueList #213
    data[0] = LSG_NaviSD;
    if(getValue(this))
    {
        data[1]=getValue(env_FSG_Navi_HB_input);
    }
    else
    {
        data[1] = 0;
    }
    ChangeConfig(0x00,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x0F_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_FSG_OperationState;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x10_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_CompassInfo;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x11_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_RG_Status;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x12_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_DistanceToNextManeuver;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x13_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_CurrentPositionInfo;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x14_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_TurnToInfo;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x15_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_DistanceToDestination;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x16_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_TimeToDestination;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x17_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_ManeuverDescriptor;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x19_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_TMCinfo;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x1A_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_MagnetFieldZone;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x1B_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_Calibration;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x1C_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_ASGcapabilities;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x1F_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_PreferredDestList;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x27_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_ActiveRgType;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x24_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_VoiceGiudance;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x25_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_FunctionSynchronisation;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x26_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_InfoStates;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #9
on envVar env_NaviSD_FctList_0x28_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_TrafficBlock_Indication;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//Updates from J.Karl 07.11.2013
on envVar env_NaviSD_FctList_0x2B_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_MapColorAndType_Indication;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//Updates from J.Karl 07.11.2013
on envVar env_NaviSD_FctList_0x2C_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_MapViewAndOrientation_Indication;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//Updates from J.Karl 07.11.2013
on envVar env_NaviSD_FctList_0x2D_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_MapScale_Indication;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//Updates from J.Karl 07.11.2013
on envVar env_NaviSD_FctList_0x2E_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_DestinationInfo_Indication;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//Updates from J.Karl 07.11.2013
on envVar env_NaviSD_FctList_0x2F_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_Altitude_Indication;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//Updates from J.Karl 07.11.2013
on envVar env_NaviSD_FctList_0x32_HB
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_SemidynamicRouteGuidance_Indication;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #68
on timer gNaviFctList_0x22_ProcessingTimer
{
    if (gNaviFctList_0x22_Processing_flg==0x01)
    {
        gNaviFctList_0x22_Processing_flg = 0x00;
        gNav_RG_ActDeact_Result = NAV_RGACTDEACT_NOTSUCCESSFUL;
        RGActDeact_Request(Result_REQ, 0);    
        putValue(env_NaviSD_FctList_0x22_3min_TO,0);
    }
}

//IssueList #68
on timer gNaviFctList_0x29_ProcessingTimer
{
    if (gNaviFctList_0x29_Processing_flg==0x01)
    {
        gNaviFctList_0x29_Processing_flg = 0x00;
        gNav_GetNextListPos_Result = NAV_GETNEXTLISTPOS_NOT_SUCCESSFUL;
        GetNextListPos_Request(Result_REQ, 0);    
        putValue(env_NaviSD_FctList_0x29_3min_TO,0);
    }
}

//IssueList #68
on timer gNaviFctList_0x2A_ProcessingTimer
{
    if (gNaviFctList_0x2A_Processing_flg==0x01)
    {
        gNaviFctList_0x2A_Processing_flg = 0x00;
        gNav_NbSpeller_Result = NAV_NBSPELLER_NOT_SUCCESSFUL;
        NbSpeller_Request(Result_REQ, 0);
        putValue(env_NaviSD_FctList_0x2A_3min_TO,0);    
    }
}

//IssueList #68
on timer gNaviFctList_0x23_ProcessingTimer
{
    if (gNaviFctList_0x23_Processing_flg==0x01)
    {
        gNaviFctList_0x23_Processing_flg = 0x00;
        gNav_RepeatLastNavAnn_Result = NAV_REPEATLASTNAVANN_NOT_SUCCESSFUL;
        RepeatLastNavAnnouncement_Request(Result_REQ, 0);
        putValue(env_NaviSD_FctList_0x23_3min_TO,0);    
    }
}

//IssueList #68
on envVar env_NaviSD_FctList_0x22_3min_TO
{
gNaviFctList_0x22_Processing_flg = getValue(this);

if (gNaviFctList_0x22_Processing_flg == 0x00)
cancelTimer(gNaviFctList_0x22_ProcessingTimer);
}

//IssueList #68
on envVar env_NaviSD_FctList_0x29_3min_TO
{
gNaviFctList_0x29_Processing_flg = getValue(this);

if (gNaviFctList_0x29_Processing_flg == 0x00)
cancelTimer(gNaviFctList_0x29_ProcessingTimer);
}

//IssueList #68
on envVar env_NaviSD_FctList_0x2A_3min_TO
{
gNaviFctList_0x2A_Processing_flg = getValue(this);

if (gNaviFctList_0x2A_Processing_flg == 0x00)
cancelTimer(gNaviFctList_0x2A_ProcessingTimer);
}

//IssueList #68
on envVar env_NaviSD_FctList_0x23_3min_TO
{
gNaviFctList_0x23_Processing_flg = getValue(this);

if (gNaviFctList_0x23_Processing_flg == 0x00)
cancelTimer(gNaviFctList_0x23_ProcessingTimer);
}

//IssueList #119
on envVar env_NaviSD_TTD_Reserved0_VI
{
 TTD_VI[0]=getValue(this);
 timeToDestination_VI_compute();
}

//IssueList #119
timeToDestination_VI_compute ()
{
byte ttd_vi_final;
ttd_vi_final =  TTD_VI[0]*0x01 + TTD_VI[1]*0x02 +TTD_VI[2]*0x04 +TTD_VI[3]*0x08 +TTD_VI[4]*0x10 +TTD_VI[5]*0x20 +TTD_VI[6]*0x40+TTD_VI[7]*0x80;
putValue(env_NaviSD_TTD_VI_Disp,ttd_vi_final);
}

//IssueList #119
on envVar env_NaviSD_TTD_Reserved6_VI
{
 TTD_VI[6]=getValue(this);
 timeToDestination_VI_compute();
}

//IssueList #119
on envVar env_NaviSD_TTD_Reserved7_VI
{
 TTD_VI[7]=getValue(this);
 timeToDestination_VI_compute();
}

//IssueList #119
on envVar env_NaviSD_TTD_Minute_VI
{
 TTD_VI[1]=getValue(this);
 timeToDestination_VI_compute();
}

//IssueList #119
on envVar env_NaviSD_TTD_Hour_VI
{
 TTD_VI[2]=getValue(this);
 timeToDestination_VI_compute();
}

//IssueList #119
on envVar env_NaviSD_TTD_Day_VI
{
 TTD_VI[3]=getValue(this);
 timeToDestination_VI_compute();
}

//IssueList #119
on envVar env_NaviSD_TTD_Month_VI
{
 TTD_VI[4]=getValue(this);
 timeToDestination_VI_compute();
}

//IssueList #119
on envVar env_NaviSD_TTD_Year_VI
{
 TTD_VI[5]=getValue(this);
 timeToDestination_VI_compute();
}

//IssueList #119
on envVar env_NaviSD_TTD_VI
{
byte VI_lowByte, VI_hiByte,VI_hiByteMod,VI_lowByteMod;

putValue(env_NaviSD_TTD_Reserved0_VI,0);
putValue(env_NaviSD_TTD_Minute_VI ,0);
putValue(env_NaviSD_TTD_Hour_VI, 0);
putValue(env_NaviSD_TTD_Day_VI, 0);

putValue(env_NaviSD_TTD_Month_VI,0);
putValue(env_NaviSD_TTD_Year_VI,0);
putValue(env_NaviSD_TTD_Reserved6_VI,0);
putValue(env_NaviSD_TTD_Reserved7_VI,0); 
   

VI_hiByte = getValue(this)>>4;
VI_hiByteMod = VI_hiByte%8;

VI_lowByte = getValue(this) & 0x0F;
VI_lowByteMod = VI_lowByte%8;


if (VI_hiByte >= 0x08)
putValue(env_NaviSD_TTD_Reserved7_VI,1);

    switch(VI_hiByteMod)
    {
    case 7: putValue(env_NaviSD_TTD_Month_VI,1);
            putValue(env_NaviSD_TTD_Year_VI,1);
            putValue(env_NaviSD_TTD_Reserved6_VI,1);
            break;


    case 6: putValue(env_NaviSD_TTD_Year_VI,1);
            putValue(env_NaviSD_TTD_Reserved6_VI,1);   
            break;

    case 5: putValue(env_NaviSD_TTD_Month_VI,1);
            putValue(env_NaviSD_TTD_Reserved6_VI,1);  
            break;

    case 4: putValue(env_NaviSD_TTD_Reserved6_VI,1);
            break;

    case 3: putValue(env_NaviSD_TTD_Month_VI,1);
            putValue(env_NaviSD_TTD_Year_VI,1);
            break;

    case 2: putValue(env_NaviSD_TTD_Year_VI,1);
            break;

    case 1: putValue(env_NaviSD_TTD_Month_VI,1);
            break;
    }

if (VI_lowByte >= 0x08)
putValue(env_NaviSD_TTD_Day_VI,1);

    switch(VI_lowByteMod)
    {
    case 7: putValue(env_NaviSD_TTD_Reserved0_VI,1);
            putValue(env_NaviSD_TTD_Minute_VI ,1);
            putValue(env_NaviSD_TTD_Hour_VI, 1);
            break;


    case 6: putValue(env_NaviSD_TTD_Minute_VI ,1);
            putValue(env_NaviSD_TTD_Hour_VI, 1);
            break;

    case 5: putValue(env_NaviSD_TTD_Reserved0_VI,1);
            putValue(env_NaviSD_TTD_Hour_VI, 1);
            break;

    case 4: putValue(env_NaviSD_TTD_Hour_VI, 1);
            break;

    case 3: putValue(env_NaviSD_TTD_Reserved0_VI,1);
            putValue(env_NaviSD_TTD_Minute_VI ,1);
            break;

    case 2: putValue(env_NaviSD_TTD_Minute_VI ,1);
            break;

    case 1: putValue(env_NaviSD_TTD_Reserved0_VI,1);
            break;
    }

}

//IssueList #128
LaneGuidance_init_ENVAR()
{
    byte j, i, LaneGuidanceEntry;
    //IssueList #202
    byte LaneSidestreets_0[50];
    byte LaneSidestreets_1[50];
    byte LaneSidestreets_2[50];
    byte LaneSidestreets_3[50];
    byte LaneSidestreets_4[50];
    byte LaneSidestreets_5[50];
    byte LaneSidestreets_6[50];
    byte LaneSidestreets_7[50];

   
    
    //clear
    LaneGuidanceEntry       =0;
    gLaneGuidanceLine_sum  =0;
    
    for(j=0;j<NAV_LANEGUIDANCE_ENTRIES;j++) 
    {
        gLaneGuidance_Pos[j]                        =0;
        gLaneGuidance_LaneDirection[j]              =0;
        gLaneGuidance_LaneType[j]                   =0;
        gLaneGuidance_LaneMarking_right[j]          =0;
        gLaneGuidance_LaneMarking_left[j]           =0;
        gLaneGuidance_LaneDescription[j]            =0;
        gLaneGuidance_GuidanceInfo[j]               =0;
        gLaneGuidance_ListEntryValidInformation[j]  =0;

        for(i=0;i<NAV_LANESIDESTREETS_LENGTH;i++)
            gLaneGuidance_LaneSidestreets[j][i] =0;

        //IssueList #202
        for(i=0;i<50;i++)
        {
    LaneSidestreets_0[i] =0;
            LaneSidestreets_1[i] =0;
            LaneSidestreets_2[i] =0;
            LaneSidestreets_3[i] =0;
            LaneSidestreets_4[i] =0;
            LaneSidestreets_5[i] =0;
            LaneSidestreets_6[i] =0;
            LaneSidestreets_7[i] =0;

        }
    }
          
    //entry 0
    if (getValue(env_NaviLG_Enable_0)==0x01)
    {
        gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
        gLaneGuidance_Pos [LaneGuidanceEntry]               =getValue(env_NaviLG_Pos_0);    
        gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =getValue(env_NaviLG_LaneDir_0);
        //IssueList #202
        //getvalue(env_NaviLG_LaneSide_0, gLaneGuidance_LaneSidestreets [LaneGuidanceEntry]);
        getvalue(env_NaviLG_LaneSide_0, LaneSidestreets_0);
        for(i=0;i<=LaneSidestreets_0[0];i++)
           gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i] =LaneSidestreets_0[i];

        gLaneGuidance_LaneType [LaneGuidanceEntry]          =getValue(env_NaviLG_LaneType_0);
        gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =getValue(env_NaviLG_LaneMark_L_0);
        gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =getValue(env_NaviLG_LaneMark_R_0);
        gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =getValue(env_NaviLG_LaneDesc_0);
        gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =getValue(env_NaviLG_GuidInfo_0);
        LaneGuidanceEntry++;
    }
    
    //entry 1
    if (getValue(env_NaviLG_Enable_1)==0x01)
    {
        gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
        gLaneGuidance_Pos [LaneGuidanceEntry]               =getValue(env_NaviLG_Pos_1);    
        gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =getValue(env_NaviLG_LaneDir_1);
        //IssueList #202
        //getvalue(env_NaviLG_LaneSide_1, gLaneGuidance_LaneSidestreets [LaneGuidanceEntry]);
        getvalue(env_NaviLG_LaneSide_1, LaneSidestreets_1);
        for(i=0;i<=LaneSidestreets_1[0];i++)
           gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i] =LaneSidestreets_1[i];

        gLaneGuidance_LaneType [LaneGuidanceEntry]          =getValue(env_NaviLG_LaneType_1);
        gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =getValue(env_NaviLG_LaneMark_L_1);
        gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =getValue(env_NaviLG_LaneMark_R_1);
        gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =getValue(env_NaviLG_LaneDesc_1);
        gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =getValue(env_NaviLG_GuidInfo_1);
        LaneGuidanceEntry++;
    }        

    //entry 2
    if (getValue(env_NaviLG_Enable_2)==0x01)
    {
        gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
        gLaneGuidance_Pos [LaneGuidanceEntry]               =getValue(env_NaviLG_Pos_2);    
        gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =getValue(env_NaviLG_LaneDir_2);
        //IssueList #202
        //getvalue(env_NaviLG_LaneSide_2, gLaneGuidance_LaneSidestreets [LaneGuidanceEntry]);
        getvalue(env_NaviLG_LaneSide_2, LaneSidestreets_2);
        for(i=0;i<=LaneSidestreets_2[0];i++)
           gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i] =LaneSidestreets_2[i];

        gLaneGuidance_LaneType [LaneGuidanceEntry]          =getValue(env_NaviLG_LaneType_2);
        gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =getValue(env_NaviLG_LaneMark_L_2);
        gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =getValue(env_NaviLG_LaneMark_R_2);
        gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =getValue(env_NaviLG_LaneDesc_2);
        gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =getValue(env_NaviLG_GuidInfo_2);
        LaneGuidanceEntry++;
    }

    //entry 3
    if (getValue(env_NaviLG_Enable_3)==0x01)
    {
        gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
        gLaneGuidance_Pos [LaneGuidanceEntry]               =getValue(env_NaviLG_Pos_3);    
        gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =getValue(env_NaviLG_LaneDir_3);
        //IssueList #202
        //getvalue(env_NaviLG_LaneSide_3, gLaneGuidance_LaneSidestreets [LaneGuidanceEntry]);
        getvalue(env_NaviLG_LaneSide_3, LaneSidestreets_3);
        for(i=0;i<=LaneSidestreets_3[0];i++)
           gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i] =LaneSidestreets_3[i];

        gLaneGuidance_LaneType [LaneGuidanceEntry]          =getValue(env_NaviLG_LaneType_3);
        gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =getValue(env_NaviLG_LaneMark_L_3);
        gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =getValue(env_NaviLG_LaneMark_R_3);
        gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =getValue(env_NaviLG_LaneDesc_3);
        gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =getValue(env_NaviLG_GuidInfo_3);
        LaneGuidanceEntry++;
    }

    //entry 4
    if (getValue(env_NaviLG_Enable_4)==0x01)
    {
        gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
        gLaneGuidance_Pos [LaneGuidanceEntry]               =getValue(env_NaviLG_Pos_4);    
        gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =getValue(env_NaviLG_LaneDir_4);
        //IssueList #202
        //getvalue(env_NaviLG_LaneSide_4, gLaneGuidance_LaneSidestreets [LaneGuidanceEntry]);
        getvalue(env_NaviLG_LaneSide_4, LaneSidestreets_4);
        for(i=0;i<=LaneSidestreets_4[0];i++)
           gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i] =LaneSidestreets_4[i];

        gLaneGuidance_LaneType [LaneGuidanceEntry]          =getValue(env_NaviLG_LaneType_4);
        gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =getValue(env_NaviLG_LaneMark_L_4);
        gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =getValue(env_NaviLG_LaneMark_R_4);
        gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =getValue(env_NaviLG_LaneDesc_4);
        gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =getValue(env_NaviLG_GuidInfo_4);
        LaneGuidanceEntry++;
    }

    //entry 5
    if (getValue(env_NaviLG_Enable_5)==0x01)
    {
        gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
        gLaneGuidance_Pos [LaneGuidanceEntry]               =getValue(env_NaviLG_Pos_5);    
        gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =getValue(env_NaviLG_LaneDir_5);
        //IssueList #202
        //getvalue(env_NaviLG_LaneSide_5, gLaneGuidance_LaneSidestreets [LaneGuidanceEntry]);
        getvalue(env_NaviLG_LaneSide_5, LaneSidestreets_5);
        for(i=0;i<=LaneSidestreets_5[0];i++)
           gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i] =LaneSidestreets_5[i];

        gLaneGuidance_LaneType [LaneGuidanceEntry]          =getValue(env_NaviLG_LaneType_5);
        gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =getValue(env_NaviLG_LaneMark_L_5);
        gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =getValue(env_NaviLG_LaneMark_R_5);
        gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =getValue(env_NaviLG_LaneDesc_5);
        gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =getValue(env_NaviLG_GuidInfo_5);
        LaneGuidanceEntry++;
    }

    //entry 6
    if (getValue(env_NaviLG_Enable_6)==0x01)
    {
        gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
        gLaneGuidance_Pos [LaneGuidanceEntry]               =getValue(env_NaviLG_Pos_6);    
        gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =getValue(env_NaviLG_LaneDir_6);
        //IssueList #202
        //getvalue(env_NaviLG_LaneSide_6, gLaneGuidance_LaneSidestreets [LaneGuidanceEntry]);
        getvalue(env_NaviLG_LaneSide_6, LaneSidestreets_6);
        for(i=0;i<=LaneSidestreets_6[0];i++)
           gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i] =LaneSidestreets_6[i];

        gLaneGuidance_LaneType [LaneGuidanceEntry]          =getValue(env_NaviLG_LaneType_6);
        gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =getValue(env_NaviLG_LaneMark_L_6);
        gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =getValue(env_NaviLG_LaneMark_R_6);
        gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =getValue(env_NaviLG_LaneDesc_6);
        gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =getValue(env_NaviLG_GuidInfo_6);
        LaneGuidanceEntry++;
    }

    //entry 7
    if (getValue(env_NaviLG_Enable_7)==0x01)
    {
        gLaneGuidance_ListEntryValidInformation[LaneGuidanceEntry]  =TRUE;
        gLaneGuidance_Pos [LaneGuidanceEntry]               =getValue(env_NaviLG_Pos_7);    
        gLaneGuidance_LaneDirection [LaneGuidanceEntry]     =getValue(env_NaviLG_LaneDir_7);
        //IssueList #202
        //getvalue(env_NaviLG_LaneSide_7, gLaneGuidance_LaneSidestreets [LaneGuidanceEntry]);
        getvalue(env_NaviLG_LaneSide_7, LaneSidestreets_7);
        for(i=0;i<=LaneSidestreets_7[0];i++)
           gLaneGuidance_LaneSidestreets[LaneGuidanceEntry][i] =LaneSidestreets_7[i];

        gLaneGuidance_LaneType [LaneGuidanceEntry]          =getValue(env_NaviLG_LaneType_7);
        gLaneGuidance_LaneMarking_left [LaneGuidanceEntry]  =getValue(env_NaviLG_LaneMark_L_7);
        gLaneGuidance_LaneMarking_right [LaneGuidanceEntry] =getValue(env_NaviLG_LaneMark_R_7);
        gLaneGuidance_LaneDescription [LaneGuidanceEntry]   =getValue(env_NaviLG_LaneDesc_7);
        gLaneGuidance_GuidanceInfo [LaneGuidanceEntry]      =getValue(env_NaviLG_GuidInfo_7);
        LaneGuidanceEntry++;
    }
    
    gLaneGuidanceLine_sum  =LaneGuidanceEntry;
    if (LaneGuidanceEntry == 0x00)
    putValue(env_NaviSD_LG_DataS_result_EV,"Unsuccessful");
    else
    putValue(env_NaviSD_LG_DataS_result_EV,"Successful");

    //write Array in "write-window"
    writeClear(gLaneGuidance_writeWindow);
    writelineEx(gLaneGuidance_writeWindow, 0, "");
    writelineEx(gLaneGuidance_writeWindow, 0,"*******Default LaneGuidance_Array*******");
    writelineEx(gLaneGuidance_writeWindow, 0, "");

    for (i=0;i<=gLaneGuidanceLine_sum;i++)
    {
        writelineEx(gLaneGuidance_writeWindow, 0,"*******Element %d*******",i);
        
        writelineEx(gLaneGuidance_writeWindow, 0,"Pos[%d]: 0x%x", i, gLaneGuidance_Pos [i]);
        
        writelineEx(gLaneGuidance_writeWindow, 0,"LaneDirection[%d]: 0x%x",i, gLaneGuidance_LaneDirection[i]);
        switch (gLaneGuidance_LaneDirection[i])
        {
            case NAV_LANEGUIDANCE_STRAIGHT:
                    writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_STRAIGHT);
            break;

            case NAV_LANEGUIDANCE_LEFT:
                    writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_LEFT);
            break;

            case NAV_LANEGUIDANCE_BACK:
                    writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_BACK);
            break;

            case NAV_LANEGUIDANCE_RIGHT:
                    writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDirection_RIGHT);
            break;

            default:             
            break;
        }

        writelineEx(gLaneGuidance_writeWindow, 0,"LaneSidestreets[%d]: %s",i, gLaneGuidance_LaneSidestreets[i]);        
        
        writelineEx(gLaneGuidance_writeWindow, 0,"LaneType[%d]: 0x%x",i, gLaneGuidance_LaneType[i]);
        if(gLaneGuidance_LaneType[i] <0x1A)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneType_s[gLaneGuidance_LaneType[i]]);

        writelineEx(gLaneGuidance_writeWindow, 0,"LaneMarking_left[%d]: 0x%x",i, gLaneGuidance_LaneMarking_left[i]);
        if(gLaneGuidance_LaneMarking_left[i] <0x03)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneMarking_left_s[gLaneGuidance_LaneMarking_left[i]]);

        writelineEx(gLaneGuidance_writeWindow, 0,"LaneMarking_right[%d]: 0x%x",i, gLaneGuidance_LaneMarking_right[i]);
        if(gLaneGuidance_LaneMarking_right[i] <0x03)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneMarking_right_s[gLaneGuidance_LaneMarking_right[i]]);

        writelineEx(gLaneGuidance_writeWindow, 0,"LaneDescription[%d]: 0x%x",i, gLaneGuidance_LaneDescription[i]);
        if(gLaneGuidance_LaneDescription[i] <0x0B)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_LaneDescription_s[gLaneGuidance_LaneDescription[i]]);
        else if(gLaneGuidance_LaneDescription[i] ==0xF)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gstring_not_supported);

        writelineEx(gLaneGuidance_writeWindow, 0,"GuidanceInfo[%d]: 0x%x",i, gLaneGuidance_GuidanceInfo[i]); 
        if(gLaneGuidance_GuidanceInfo[i] <0x03)
            writeEx(gLaneGuidance_writeWindow, 0," -> '%s'", gLaneGuidance_GuidanceInfo_s[gLaneGuidance_GuidanceInfo[i]]);

        writelineEx(gLaneGuidance_writeWindow, 0, "");
        //IssueList #54
        putValue(env_NaviSD_LG_AH_elements, gLaneGuidanceLine_sum);
    }
}

//IssueList #128
on envVar env_NaviLG_Enable_0
{
    if (getValue(this))
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_0", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_0", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_0", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_0", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_0", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_0", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_0", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_0", 1);
    }
    else
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_0", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_0", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_0", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_0", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_0", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_0", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_0", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_0", 0);
    }
}

//IssueList #128
on envVar env_NaviLG_Enable_1
{
    if (getValue(this))
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_1", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_1", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_1", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_1", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_1", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_1", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_1", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_1", 1);
    }
    else
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_1", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_1", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_1", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_1", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_1", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_1", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_1", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_1", 0);
    }
}

//IssueList #128
on envVar env_NaviLG_Enable_2
{
    if (getValue(this))
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_2", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_2", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_2", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_2", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_2", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_2", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_2", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_2", 1);
    }
    else
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_2", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_2", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_2", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_2", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_2", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_2", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_2", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_2", 0);
    }
}

//IssueList #128
on envVar env_NaviLG_Enable_3
{
    if (getValue(this))
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_3", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_3", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_3", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_3", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_3", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_3", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_3", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_3", 1);
    }
    else
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_3", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_3", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_3", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_3", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_3", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_3", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_3", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_3", 0);
    }
}

//IssueList #128
on envVar env_NaviLG_Enable_4
{
    if (getValue(this))
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_4", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_4", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_4", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_4", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_4", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_4", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_4", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_4", 1);
    }
    else
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_4", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_4", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_4", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_4", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_4", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_4", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_4", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_4", 0);
    }
}

//IssueList #128
on envVar env_NaviLG_Enable_5
{
    if (getValue(this))
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_5", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_5", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_5", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_5", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_5", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_5", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_5", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_5", 1);
    }
    else
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_5", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_5", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_5", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_5", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_5", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_5", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_5", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_5", 0);
    }
}

//IssueList #128
on envVar env_NaviLG_Enable_6
{
    if (getValue(this))
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_6", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_6", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_6", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_6", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_6", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_6", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_6", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_6", 1);
    }
    else
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_6", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_6", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_6", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_6", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_6", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_6", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_6", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_6", 0);
    }
}

//IssueList #128
on envVar env_NaviLG_Enable_7
{
    if (getValue(this))
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_7", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_7", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_7", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_7", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_7", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_7", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_7", 1);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_7", 1);
    }
    else
    {
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_Pos_7", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDir_7", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneSide_7", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneType_7", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_L_7", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneMark_R_7", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_LaneDesc_7", 0);
        EnableControl("Lane Guidance - EnvVar","EnvVar:NaviLG_GuidInfo_7", 0);
    }
}

//IssueList #128
on envVar env_NaviLG_Switch
{
    if (getValue(this))
    {
        putValue(env_NaviLG_Enable_0,1);
        putValue(env_NaviLG_Enable_1,1);
        putValue(env_NaviLG_Enable_2,1);
        putValue(env_NaviLG_Enable_3,1);
        putValue(env_NaviLG_Enable_4,1);
        putValue(env_NaviLG_Enable_5,1);
        putValue(env_NaviLG_Enable_6,1);
        putValue(env_NaviLG_Enable_7,1);
    }
    else
    {
        putValue(env_NaviLG_Enable_0,0);
        putValue(env_NaviLG_Enable_1,0);
        putValue(env_NaviLG_Enable_2,0);
        putValue(env_NaviLG_Enable_3,0);
        putValue(env_NaviLG_Enable_4,0);
        putValue(env_NaviLG_Enable_5,0);
        putValue(env_NaviLG_Enable_6,0);
        putValue(env_NaviLG_Enable_7,0);
    }
}

//IssueList #128
// For Lane Guidance ENV data source
on envVar env_NaviLG_reload
{
    if (getValue(this))
    putValue(env_NaviSD_LG_DataS_result_EV,"");
    else
    {
        if (getValue(env_NaviSD_LG_DataSource)==0x02)
        LaneGuidance_init_ENVAR();
        else
        putValue(env_NaviSD_LG_DataS_result_EV,"Please select list from Env Variable in Data Source");

    }
}

//IssueList #76 - MR49870 : LDL
on envVar env_NaviSD_LDL_delete
{
    word startelement, elements, PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[NAV_LASTDESTLIST_ENTRIES]; 
    dword requestarray [BAP_BUFFER_SIZE], Offset, i;

    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    i                       =0;
    Offset                  =0;

    for(i =0; i<NAV_LASTDESTLIST_ENTRIES; i++)
        POS[i] =0;
    
    for(i =0; i<BAP_BUFFER_SIZE; i++)
        requestarray[i] =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {
    gLDL_DelInvalidCtr =0;
    gLDL_DelValidCtr =0;

    for(i =0; i<NAV_LASTDESTLIST_ENTRIES; i++)
        gLDL_InvalidDel[i] =0;

    for(i =0; i<NAV_LASTDESTLIST_ENTRIES; i++)
        gLDL_Send[i][0] =0;   //POS value


     putvalue (env_NaviSD_LDL_Insert_Message, empty_string);
    //MR 63332 #3   02.07.2014
    //gLDL_TotalElem = getValue(env_NaviSD_LDL_TotalNumLE); 
    gLDL_TotalElem = gLastDestList_TotalNumListElements; 
    
       
        //get data from Panel
        recordaddress   =0x0F;
        shift           =0x1;
        direction       =0x1;
        transmitpos     =0x1;
        indexsize       =getvalue(env_NaviSD_LDL_delete_size);;

        //message
        requestarray[0] =LSG_NaviSD;                //LSG-ID
        requestarray[1] =FctID_LastDest_List;            //Fct.-ID
        requestarray[2] =Changed_REQ;               //request type  
        Offset =3;

    switch ( indexsize ) // POS size
    {
        case 0: //8Bit
        getvalue(env_NaviSD_LDL_delete_POS_8, POS);
        //startelement    =POS[0];
        startelement = getvalue(env_NaviSD_LDL_delete_start);
        elements     =getValueSize(env_NaviSD_LDL_delete_POS_8);
                
            //ErrHandler = ON
            if (getValue(env_NaviSD_LDL_delete_ErrHand)==0x01)
            {
                if (elements==0x00)   // if no data
                    putValue(env_NaviSD_LDL_delete_Message, "NO DATA TO SEND");

                else     // with data
                {
                    LastDestList_delete_ErrHandler_8 (POS,elements);
                    //if all elements are invalid
                    if (elements ==gLDL_DelInvalidCtr)
                        putValue(env_NaviSD_LDL_delete_Message, "POS INVALID");
                    else
                        elements = gLDL_DelValidCtr;
                }
            }
            else  // no errorhandling
            {
                if (elements==0x00)   // if no data
                    transmitpos     =0x0;
            }
        
        
        //mode
        mode            =shift +(direction*0x02) +(transmitpos*0x04) +(indexsize*0x08);
        
        /***ArrayHeader***/
        requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
        Offset++;

        requestarray[Offset] =startelement;
        Offset++;  

        requestarray[Offset] =elements;
        Offset++;
                
        /***ArrayData***/
        if (getValue(env_NaviSD_LDL_delete_ErrHand)==0x00)
        {
            for ( i = 0; i < elements; i++ )
            {
            requestarray[Offset] =POS[i];
            Offset++;
            }
        }//if
        else
        {
            for (i=0; i<gLDL_DelValidCtr; i++)
                   {
                    requestarray[Offset] =gLDL_Send[i][0];
                    Offset++;
                }
        }
         break;
            
      case 1:  //16Bit
        getvalue(env_NaviSD_LDL_delete_POS_16, POS);
        startelement  = getvalue(env_NaviSD_LDL_delete_start);
        elements      = getValueSize(env_NaviSD_LDL_delete_POS_16)/2;

        if (getValue(env_NaviSD_LDL_delete_ErrHand)==0x01)
          { 
                    if (elements==0)   // if insufficient data
                    {
                    putValue(env_NaviSD_LDL_delete_Message, "NO DATA TO SEND");
                    break;
                    }
                    
                    else     // with data
                    {
                    LastDestList_delete_ErrHandler_16 (POS,elements*2);
                        //if all elements are invalid
                        if (elements ==gLDL_DelInvalidCtr/2)
                        {
                        putValue(env_NaviSD_LDL_delete_Message, "ALL POS INVALID");
                        break;
                        }
                    
                        else
                       elements = gLDL_DelValidCtr/2;
                    }
            }
        else  // no errorhandling
            {
            if (elements==0x00)   // if no data
            transmitpos     =0x0;
            }
        
                //mode
                mode  = shift + (direction*0x02) + (transmitpos*0x04) + (indexsize*0x08);

                /***ArrayHeader***/
                requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
                Offset++;

                requestarray[Offset] =startelement &0xff; 
                Offset++; 
                requestarray[Offset] =(startelement &0xff00) /0x100;
                Offset++;
                
                
                requestarray[Offset] =elements &0xff;
                Offset++;
                requestarray[Offset] =(elements &0xff00) /0x100;
                Offset++;

                /***ArrayData***/

                if (getValue(env_NaviSD_LDL_delete_ErrHand)==0x00)
                {
                    for ( i = 0; i < elements; i++ )    //2 elements are inserted to the array below
                    {
                       requestarray[Offset] = POS[(2*i)+1];
                       Offset++;

                       requestarray[Offset] = POS[(2*i)];
                       Offset++;
                    }
                }
                 else    // with error handling
                 {
                    for (i=0; i<elements; i++)
                    {
                           PosVal = 0x00;
                           requestarray[Offset] =gLDL_Send[(2*i)+1][0];
                           PosVal = requestarray[Offset];
                           Offset++;
                           
                            requestarray[Offset] = gLDL_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;
                            
                    } //for (i=0; i<gLDL_DelValidCtr; i++)

                } //else ERRORHANDLING
                
        break;

      default:
        break;
    }
        
        //DATA SENDING
        if (getValue(env_NaviSD_LDL_delete_ErrHand)==0x00)
       set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 

        else
        {
            if (gLDL_DelInvalidCtr!=0)
                putValue(env_NaviSD_LDL_delete_Invalid,gLDL_InvalidDel);

            if (gLDL_DelValidCtr != 0x00)
            {
                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
                
                //MR 63332 #3   02.07.2014
                //if (indexsize == 0x00)
                //putValue(env_NaviSD_LDL_TotalNumLE, gLDL_TotalElem -gLDL_DelValidCtr);
                //else
                //putValue(env_NaviSD_LDL_TotalNumLE, gLDL_TotalElem -(gLDL_DelValidCtr/2));
                //gLastDestList_TotalNumListElements = getValue(env_NaviSD_LDL_TotalNumLE);

                if (indexsize == 0x00)
                gLastDestList_TotalNumListElements = gLDL_TotalElem - gLDL_DelValidCtr;
                else
                gLastDestList_TotalNumListElements = gLDL_TotalElem -(gLDL_DelValidCtr/2);

                putValue(env_NaviSD_LDL_TotalNumLE,gLastDestList_TotalNumListElements);
            }//if
        } //else

   }
}

//IssueList #76 - MR49870 : LDL
on envVar env_NaviSD_LDL_insert
{
    word startelement, elements,successor, ctr, PosCtr,LDLlistCtr,elemTemp,PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[NAV_LASTDESTLIST_ENTRIES], posInBetweenCheck;
    dword requestarray [BAP_BUFFER_SIZE], Offset, i;
 
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    startelement            =0;
    elements                =0;
    i                       =0;
    Offset                  =0;
    elemTemp                =0;
    PosVal                  =0;


    if(gNaviSD_PowerOnOff==POWER_ON && getvalue(this))
    {

        for(i =0; i<NAV_LASTDESTLIST_ENTRIES; i++)
            POS[i] =0;

        for(i =0; i<BAP_BUFFER_SIZE; i++)
            requestarray[i] =0;

        for(i =0; i<NAV_LASTDESTLIST_ENTRIES; i++)
            gLDL_InvalidIns[i] =0;

        for(i =0; i<NAV_LASTDESTLIST_ENTRIES; i++)
            gLDL_Send[i][0] =0;
    
        putValue(env_NaviSD_LDL_Insert_Invalid,gLDL_InvalidIns);

        gLDL_InsInvalidCtr=0;
        gLDL_InsValidCtr =0;
        putValue(env_NaviSD_LDL_Insert_Message, empty_string);

        //get data from Panel
        //Patch GB 11.07.2014 -commented
        //recordaddress   =0x0F;

        putvalue (env_NaviSD_LDL_Insert_Message, empty_string);
        //MR 63332 #3   02.07.2014
        //gLDL_TotalElem = getValue(env_NaviSD_LDL_TotalNumLE);
        gLDL_TotalElem = gLastDestList_TotalNumListElements;

        if (getValue(env_NaviSD_LDL_insert_UPD_button)==0x00)
        {
            shift           =0x01; //insert
            //Patch GB 11.07.2014
            recordaddress   =0x0F;
        }
        else
        {
            shift           =0x0; //update
            //Patch GB 11.07.2014
            recordaddress   =getValue(env_NaviSD_LDL_AH_RA);
        }

        direction       =0x0;
        transmitpos     =0x01;

        indexsize       =getvalue(env_NaviSD_LDL_insert_size);
        //mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        //message
        requestarray[0] =LSG_NaviSD;                //LSG-ID
        requestarray[1] =FctID_LastDest_List;        //Fct.-ID
        requestarray[2] =Changed_REQ;                  //request type  
        Offset =3;
        
        startelement    =getValue(env_NaviSD_LDL_insert_start);
        
        successor = getValue(env_NaviSD_LDL_insert_successor);
      
        switch (indexsize) // POS size
        {
            case 0: //8Bit
                getvalue(env_NaviSD_LDL_insert_POS_8, POS);
                ctr = getValueSize(env_NaviSD_LDL_insert_POS_8);

                if (getValue(env_NaviSD_LDL_insert_Err)==0x01)
                {

                    if (ctr == 0)   // if no data
                    {
                        putValue(env_NaviSD_LDL_Insert_Message, "NO DATA TO SEND");
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid for Insert
                        if (getvalue(env_NaviSD_LDL_insert_start) == 0x00 && getvalue(env_NaviSD_LDL_insert_successor) == 0x00 && getvalue(env_NaviSD_LDL_insert_UPD_button) == 0x00)
                        {
                            //check if not all elements are deleted
                            if (gLDL_totalDELctr < gLDL_CSVtotalElem)
                            {
                            putValue(env_NaviSD_LDL_Insert_Message, "INVALID START & SUCCESSOR");
                            break;
                            }
                        }
                        
                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                        posInBetweenCheck       =0;
                        if (ctr >1)
                        {
                            posInBetweenCheck =  LDLPosSequence_check (indexsize,POS,ctr);
                            if (posInBetweenCheck == 0x01)
                            {
                                putValue(env_NaviSD_LDL_Insert_Message, "INCORRECT POS SEQUENCE!");
                                break;
                            }
                        }
                     
                       //ERROR CHECKING
                        LastDestList_insert_ErrHandler_8 (POS,ctr);
                        
                        //if update has invalid POS - do not send
                        if (getvalue(env_NaviSD_LDL_insert_UPD_button) == 0x01)  //update
                        {
                            if (gLDL_InsInvalidCtr>0)
                            {
                                putValue(env_NaviSD_LDL_Insert_Message, "INVALID POS EXISTS");
                                break;
                            }
                        }
                      
                        //if all elements are INVALID for INSERT
                        if (ctr == gLDL_InsInvalidCtr)
                        {
                            putValue(env_NaviSD_LDL_Insert_Message, "POS INVALID / STILL EXIST");
                            break;
                        }
                        else
                        {
                            elements = gLDL_InsValidCtr+1;   //+ successor
                            ctr = gLDL_InsValidCtr;
                        }

                    }//else with data
                }
                else   // no error handling
                {
                    elements = ctr+1;
                    if (ctr==0)    // if no data
                    {
                        transmitpos     =0x0;

                        if (successor == 0x00)  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                            elements = successor - startelement;
                    }    
                 }

                //mode
                mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***ArrayHeader***/
                requestarray[Offset] = ((mode *0x10) &0xF0) +(recordaddress &0x0F);
                Offset++;

                //start
                requestarray[Offset] = startelement;
                Offset++;  
                
                //elements
                requestarray[Offset] = elements;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if (getValue(env_NaviSD_LDL_insert_Err)==0x01)
                {
                    //ARRAY DATA
                        for (i=0; i<ctr; i++)
                            {
                                //store in array the inserted item
                                requestarray[Offset] = gLDL_Send[i][0];
                                Offset++;
                            }
                  
                } //end if with ERROR handling

                //ArrayData WITHOUT error handling
                else
                {
                     for (i=0; i<ctr; i++)
                     {
                        requestarray[Offset] =POS[i];
                        Offset++;
                     }
                }

                //successor
                if (ctr > 0)
                {
                    requestarray[Offset] = successor;
                    Offset++;    
                }

            break;
            
            case 1:  //16Bit
                getvalue(env_NaviSD_LDL_insert_POS_16, POS);
                elements = getValueSize(env_NaviSD_LDL_insert_POS_16);
                elemTemp = (getValueSize(env_NaviSD_LDL_insert_POS_16)/2);

                if (getValue(env_NaviSD_LDL_insert_Err)==0x01)
                {
                    if (elemTemp==0)   // if no data
                    {
                        putValue(env_NaviSD_LDL_Insert_Message, "NO DATA TO SEND");
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid
                        if ((getvalue(env_NaviSD_LDL_insert_start) == 0x00) && (getvalue(env_NaviSD_LDL_insert_successor) == 0x00)&& (getvalue(env_NaviSD_LDL_insert_UPD_button) == 0x00))
                        {
                            //check if not all elements are deleted
                            if (gLDL_totalDELctr < gLDL_CSVtotalElem)
                            {
                            putValue(env_NaviSD_LDL_Insert_Message, "INVALID START & SUCCESSOR");
                            break;
                            }
                        }
                          
                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                            if (ctr >1)
                            {
                                posInBetweenCheck =  LDLPosSequence_check (indexsize,POS,elemTemp);
                                if (posInBetweenCheck == 0x01)
                                {
                                    putValue(env_NaviSD_LDL_Insert_Message, "INCORRECT POS SEQUENCE!");
                                    break;
                                }
                            }

                       LastDestList_insert_ErrHandler_16 (POS,elements);
                        //if all elements are INVALID

                        //if update has invalid POS - do not send
                        if (getvalue(env_NaviSD_LDL_insert_UPD_button) == 0x01)  //update
                        {
                            if (gLDL_InsInvalidCtr>0)
                            {
                                putValue(env_NaviSD_LDL_Insert_Message, "INVALID POS EXISTS");
                                break;
                            }
                        }
                    
                        if (elemTemp == gLDL_InsInvalidCtr)
                        {
                            putValue(env_NaviSD_LDL_Insert_Message, "POS INVALID / STILL EXIST");
                            break;
                        }
                        else
                        {
                            elements = (gLDL_InsValidCtr/2)+1;     //including successor
                            elemTemp = gLDL_InsValidCtr/2;
                        }

                    } //else with data
                } //with errorHandling
                else   // no error handling
                {
                    elements = elemTemp + 1;  //including successor
                    if (elemTemp==0)    // if no data
                    {
                        transmitpos = 0x0;
                         if (successor == 0x00)  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                        elements = successor - startelement;
                    }
                }

                //mode
                mode = shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

                /***ArrayHeader***/
                requestarray[Offset] = ((mode*0x10)&0xF0) + (recordaddress&0x0F);
                Offset++;

                requestarray[Offset] = startelement&0xff; 
                Offset++;
                requestarray[Offset] = (startelement&0xff00) / 0x100;
                Offset++;
                
                requestarray[Offset] = elements&0xff;
                Offset++;
                requestarray[Offset] = (elements&0xff00) / 0x100;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if (getValue(env_NaviSD_LDL_insert_Err)==0x01)
                {
                    for ( i = 0; i < elemTemp; i++ )
                        {
                            PosVal = 0x00;

                            //store in array the inserted item
                            requestarray[Offset] = gLDL_Send[(2*i)+1][0];
                            PosVal = requestarray[Offset];
                            Offset++;
                            requestarray[Offset] = gLDL_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;
                         }
                    
                    
                } // end if with Errorhandling
                //ArrayData WITHOUT error handling
                else
                {
                    for ( i = 0; i < elemTemp; i++ )
                    {
                        requestarray[Offset] = POS[(2*i)+1];
                        Offset++;
                        requestarray[Offset] = POS[(2*i)+0];
                        Offset++;
                    }
                }

                //successor
                if (elemTemp > 0)
                {
                    requestarray[Offset] = successor&0xff; 
                    Offset++;
                    requestarray[Offset] = (successor&0xff00) / 0x100;
                    Offset++;
                }
                break; 

            default:
                break; //default

        }//switch

        if (indexsize==0x01)
        gLDL_InsValidCtr = gLDL_InsValidCtr/2;

        //updating the totalDeletedCtr;
           gLDL_totalDELctr = gLDL_totalDELctr - gLDL_InsValidCtr;
        
        if (gLDL_totalDELctr > gLDL_CSVtotalElem)
        gLDL_totalDELctr=0;

                
        //just send the data when errorhandler is OFF
        if (getValue(env_NaviSD_LDL_insert_Err)==0x00)
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
        
        else if (getValue(env_NaviSD_LDL_insert_Err)==0x01)  //with ERROR HANDLER
        {
            if (getValue(env_NaviSD_LDL_insert_UPD_button)==0x00)  //insert
            {
                // if there's a Valid POS and Sequence is correct
                if (gLDL_InsValidCtr != 0x00 && posInBetweenCheck == 0x00)
                {
                    set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
                    
                    if (gLDL_TotalElem +gLDL_InsValidCtr <=gLDL_CSVtotalElem)
                    {
                        //MR 63332 #3   02.07.2014
                        //putValue(env_NaviSD_LDL_TotalNumLE, gLDL_TotalElem +gLDL_InsValidCtr);
                        //gLastDestList_TotalNumListElements = getValue(env_NaviSD_LDL_TotalNumLE);
                        gLastDestList_TotalNumListElements = gLDL_TotalElem + gLDL_InsValidCtr;
                        putValue(env_NaviSD_LDL_TotalNumLE, gLastDestList_TotalNumListElements);
                    } //if
               
                
                }// if gLDL_InsValidCtr
            }// if insert
            else
            {
                //send only UPDATE if all POS are valid and DATA!=0
                if (gLDL_InsInvalidCtr == 0x00 && gLDL_InsValidCtr!=0)
                    set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
            }// else UPD button
        } //else if 
    }
    //else
    //putValue(env_NaviSD_LDL_insert_UPD_button,0);
}

//IssueList #76 - MR49870 : LDL
on envVar env_NaviSD_LDL_delete_ErrHand
{
if (getValue(this)==0x00)
putValue(env_NaviSD_LDL_TotalNumLE,gLDL_CSVtotalElem);
}

//IssueList #76 - MR49870 : LDL
on envVar env_NaviSD_LDL_delete_POS_8
{
byte DEL_POS_8[NAV_LASTDESTLIST_ENTRIES];

putValue(env_NaviSD_LDL_delete_Message, empty_string);
 
    //AUTOMATIC START VALUE
    if (getValue(env_NaviSD_LDL_delete_ErrHand)==0x01)
    {
    getValue(this, DEL_POS_8);
    putValue(env_NaviSD_LDL_delete_start, DEL_POS_8[0]);
    }

}

//IssueList #76 - MR49870 : LDL
on envVar env_NaviSD_LDL_delete_POS_16
{
byte DEL_POS_16[NAV_LASTDESTLIST_ENTRIES];
word PosVal_16;

putValue(env_NaviSD_LDL_delete_Message, empty_string);
 

    //AUTOMATIC START VALUE
    if (getValue(env_NaviSD_LDL_delete_ErrHand)==0x01)
    {
    getValue(this, DEL_POS_16);
    PosVal_16 = DEL_POS_16[0] << 8;
    PosVal_16 = PosVal_16|DEL_POS_16[1];

    putValue(env_NaviSD_LDL_delete_start, PosVal_16);
    }

}

//IssueList #76 - MR49870 : LDL
on envVar env_NaviSD_LDL_insert_Err
{
if (getValue(this)==0x00)
putValue(env_NaviSD_LDL_TotalNumLE,gLDL_CSVtotalElem);
}

//IssueList #76 - MR49870 : LDL
//Automatic START AND SUCCESSOR VALUES
on envVar env_NaviSD_LDL_insert_POS_8
{
byte INS_POS_8[NAV_LASTDESTLIST_ENTRIES];
int inputCtr,i,j;
byte valid_INS_POS_8;
byte validInputFlg_start, validInputFlg_succ;

putvalue (env_NaviSD_LDL_Insert_Message, empty_string);


    //if (getValue(env_NaviSD_LDL_insert_ErrHandler)==0x01 && getValue(env_NaviSD_LDL_insert_UPD_button)==0x00)
    if (getValue(env_NaviSD_LDL_insert_Err)==0x01)
    {
    getValue(this, INS_POS_8);
    validInputFlg_start =0;
    validInputFlg_succ = 0;

     inputCtr=  getValueSize(env_NaviSD_LDL_insert_POS_8);

     if (inputCtr>0)
     {       
        //look for the valid reference for Start and successor
         for (j=0; j<inputCtr;j++)
         {
             valid_INS_POS_8 = INS_POS_8[j];
     
             for (i=0; i<gLDL_CSVtotalElem;i++)
             {
             //check if input is valid and deleted
                 if (valid_INS_POS_8 == gLDL_Pos_insDel[i][0] && gLDL_Pos_insDel[i][1]==0x01)
                 {
                 validInputFlg_start = 1;
                 break;
                 }
             } 
             if (validInputFlg_start == 0x01) 
             break;   
          }

            if (validInputFlg_start == 0x01)
            {
            //start
             if (valid_INS_POS_8==gLDL_Pos_insDel[0][0])
                 putValue(env_NaviSD_LDL_insert_start,0);
             
             else
             {   
                ///look for the next existing element upwards
                 for (i=0; i<gLDL_CSVtotalElem;i++)
                 {
                     if (valid_INS_POS_8==gLDL_Pos_insDel[i][0])
                     {   
                        for (j=i-1;j>=0;j--)
                         {
                         if (gLDL_Pos_insDel[j][1]!=0x01)
                            {
                             putValue(env_NaviSD_LDL_insert_start,gLDL_Pos_insDel[j][0]);
                             break;
                             }//if
                         }//for
                      }
                 }//for
             }//else
            } //validInputFlg

                //successor
                //look for the valid reference for Start and successor

                for (j=inputCtr-1; j>=0;j--)
                {
                     valid_INS_POS_8 = INS_POS_8[j];
     
                     for (i=0; i<gLDL_CSVtotalElem;i++)
                     {
                     //check if input is valid and deleted
                         if (valid_INS_POS_8 == gLDL_Pos_insDel[i][0] && gLDL_Pos_insDel[i][1]==0x01)
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     } 
                     if (validInputFlg_succ == 0x01) 
                     break;     
                }
                if (validInputFlg_succ == 0x01)
                {
                    putValue(env_NaviSD_LDL_insert_successor,0);
                
                    for (i=0; i<gLDL_CSVtotalElem;i++)
                    {
                        if (valid_INS_POS_8==gLDL_Pos_insDel[i][0])
                         {
                         if (i==gLDL_CSVtotalElem-1)
                         putValue(env_NaviSD_LDL_insert_successor,0);
                         else
                            {
                                 //look for the next existing element downwards
                                 for (j=i+1;j<gLDL_CSVtotalElem;j++)
                                 {
                                     if (gLDL_Pos_insDel[j][1]!=0x01)
                                     {
                                     putValue(env_NaviSD_LDL_insert_successor,gLDL_Pos_insDel[j][0]);
                                     break;
                                     }
                                 }
                             }//else

                        }//if
                 }//for
               }
          
        } //inputCtr
    }

}

//IssueList #76 - MR49870 : LDL
//Automatic START AND SUCCESSOR VALUES
on envVar env_NaviSD_LDL_insert_POS_16
{
byte INS_POS_16[NAV_LASTDESTLIST_ENTRIES];
int  inputCtr,i,j;
word PosVal_16_first,PosVal_16_last;
byte validInputFlg_start, validInputFlg_succ;

inputCtr=0;
PosVal_16_first=0;
PosVal_16_last=0;
validInputFlg_start = 0;
validInputFlg_succ=0;


putvalue (env_NaviSD_LDL_Insert_Message, empty_string);

    //if (getValue(env_NaviSD_LDL_insert_ErrHandler)==0x01 && getValue(env_NaviSD_LDL_insert_UPD_button)==0x00)
    if (getValue(env_NaviSD_LDL_insert_Err)==0x01)
    {
    getValue(this, INS_POS_16);

     inputCtr=  getValueSize(env_NaviSD_LDL_insert_POS_16);
     
         if (inputCtr > 1)
         {
            //look for the valid reference for Start and successor
             for (j=0; j<inputCtr;j++)
             {
             //valid_INS_POS_8 = INS_POS_8[j];

             PosVal_16_first = INS_POS_16[j] << 8;
             PosVal_16_first = PosVal_16_first | INS_POS_16[j+1];

     
                for (i=0; i<gLDL_CSVtotalElem;i++)
                 {
                 //check if input is valid and deleted
                     if (PosVal_16_first == gLDL_Pos_insDel[i][0] && gLDL_Pos_insDel[i][1]==0x01)
                     {
                     validInputFlg_start = 1;
                     break;
                     }
                 } 
                 if (validInputFlg_start == 0x01) 
                 break;   
               }

                if (validInputFlg_start == 0x01)
                {
                    //start
                     if (PosVal_16_first==gLDL_Pos_insDel[0][0])
                         putValue(env_NaviSD_LDL_insert_start,0);
             
                     else
                     {   
                        ///look for the next existing element upwards
                         for (i=2; i<gLDL_CSVtotalElem;i++)
                         {
                             if (PosVal_16_first==gLDL_Pos_insDel[i][0])
                             {   
                                for (j=i-1;j>0;j--)
                                 {
                                 if (gLDL_Pos_insDel[j][1]!=0x01)
                                    {
                                     putValue(env_NaviSD_LDL_insert_start,gLDL_Pos_insDel[j][0]);
                                     break;
                                     }//if
                                 }//for
                              }
                         }//for
                     }//else
                }

                   //successor
                for (j=inputCtr; j>0;j--)
                {

                     PosVal_16_last = INS_POS_16[j-1] << 8;
                     PosVal_16_last = PosVal_16_last | INS_POS_16[j];
     
                     for (i=0; i<gLDL_CSVtotalElem;i++)
                     {
                     //check if input is valid and deleted
                         if (PosVal_16_last == gLDL_Pos_insDel[i][0] && gLDL_Pos_insDel[i][1]==0x01)
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     } 
                     if (validInputFlg_succ == 0x01) 
                     break;     
                }

                if (validInputFlg_succ == 0x01)
                {

                   putValue(env_NaviSD_LDL_insert_successor,0);
                    for (i=0; i<gLDL_CSVtotalElem;i++)
                    {
                
                         if (PosVal_16_last==gLDL_Pos_insDel[i][0])
                         {
                             if (i==gLDL_CSVtotalElem-1)
                             putValue(env_NaviSD_LDL_insert_successor,0);
                             else
                             {
                                 //look for the next existing element downwards
                                 for (j=i+1;j<gLDL_CSVtotalElem;j++)
                                 {
                                     if (gLDL_Pos_insDel[j][1]!=0x01)
                                     {
                                     putValue(env_NaviSD_LDL_insert_successor,gLDL_Pos_insDel[j][0]);
                                     break;
                                     }
                                 }
                             }

                        }//if
                 }//for
               } //validInputFlg_succ
           }//inputCtr
    }

}

//IssueList #76 - MR49870 : LDL
LastDestList_delete_ErrHandler_8 (byte pos[],word elementsCtr)
{
    byte i, result,delFlg;
    word LDLlistCtr, PosCtr;
    
    result = 0x01;
    delFlg=0;
    gLDL_DelInvalidCtr = 0;
    gLDL_DelValidCtr =0;
    putValue(env_NaviSD_LDL_delete_Message, empty_string);
    
    for (PosCtr =0; PosCtr<elementsCtr; PosCtr++)
    {

         result =0x00;
         delFlg = 0x00;

      for (LDLlistCtr = 0;LDLlistCtr<gLDL_CSVtotalElem; LDLlistCtr++)
      {    

           if (pos[PosCtr]==gLDL_Pos_insDel[LDLlistCtr][0])   //check if POS is valid
           {
             if (gLDL_Pos_insDel[LDLlistCtr][1]!=0x01)  //check if POS still exists
               {
               gLDL_Pos_insDel[LDLlistCtr][1] = 0x01;    //tagging deleted Pos
               gLDL_Send[gLDL_DelValidCtr][0] = pos[PosCtr];
               
               gLDL_DelValidCtr++;
               gLDL_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue(env_NaviSD_LDL_delete_Message, "POS already deleted!");
              gLDL_InvalidDel[gLDL_DelInvalidCtr] = pos[PosCtr];
              gLDL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }
              
           }//if
           
       }//for
        if (result == 0x00 && delFlg == 0x00)
        {
          gLDL_InvalidDel[gLDL_DelInvalidCtr]=pos[PosCtr];
          gLDL_DelInvalidCtr++;
          putValue(env_NaviSD_LDL_delete_Message, "INVALID POS!");
         }

     }
}

//IssueList #76 - MR49870 : LDL
void LastDestList_delete_ErrHandler_16 (byte pos[],word elementsCtr)
{
    byte i, result,delFlg;
    word LDLlistCtr, PosCtr,PosVal;
    
    result = 0x01;
    delFlg=0;
    gLDL_DelInvalidCtr = 0;
    gLDL_DelValidCtr =0;
    putValue(env_NaviSD_LDL_delete_Message, empty_string);
    PosVal = 0;

    for (PosCtr =0; PosCtr<elementsCtr; PosCtr = PosCtr+2)
    {
         result =0x00;
         delFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+1];

      for (LDLlistCtr = 0;LDLlistCtr<gLDL_CSVtotalElem; LDLlistCtr++)
      {    
           if (PosVal==gLDL_Pos_insDel[LDLlistCtr][0])   //check if POS is valid
           {
             if (gLDL_Pos_insDel[LDLlistCtr][1]!=0x01)  //check if POS still exists
               {
               gLDL_Pos_insDel[LDLlistCtr][1] = 0x01;    //tagging deleted Pos
               gLDL_Send[gLDL_DelValidCtr][0] = pos[PosCtr];
               gLDL_DelValidCtr++;
               gLDL_Send[gLDL_DelValidCtr][0] = pos[PosCtr+1];
               gLDL_DelValidCtr++;
               gLDL_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue(env_NaviSD_LDL_delete_Message, "POS already deleted!");
              gLDL_InvalidDel[gLDL_DelInvalidCtr] = pos[PosCtr];
              gLDL_DelInvalidCtr++;
              gLDL_InvalidDel[gLDL_DelInvalidCtr] = pos[PosCtr+1];
              gLDL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }
              
           }//if
           
       }//for
        if (result == 0x00 && delFlg == 0x00)
        {
            gLDL_InvalidDel[gLDL_DelInvalidCtr] = pos[PosCtr];
            gLDL_DelInvalidCtr++;
            gLDL_InvalidDel[gLDL_DelInvalidCtr] = pos[PosCtr+1];
            gLDL_DelInvalidCtr++;
            putValue(env_NaviSD_LDL_delete_Message, "INVALID POS!");
         }
     }
}

//IssueList #76 - MR49870 : LDL
void LastDestList_insert_ErrHandler_8 (byte pos[],word elementsCtr)
{
    byte i, result,InsFlg;
    word LDLlistCtr, PosCtr;
    
    result = 0x01;
    InsFlg=0;

  
    for (PosCtr =0; PosCtr<elementsCtr; PosCtr++)
    {
         result =0x00;
         InsFlg = 0x00;
        
      for (LDLlistCtr = 0;LDLlistCtr<gLDL_CSVtotalElem; LDLlistCtr++)
      {    
           if (pos[PosCtr]==gLDL_Pos_insDel[LDLlistCtr][0])   //check if POS is valid
           {
            //UPDATE      
                if  (getValue(env_NaviSD_LDL_insert_UPD_button) == 0x01) 
                 {  
                        if (gLDL_Pos_insDel[LDLlistCtr][1]==0x00)  //check if POS is not deleted            {
                        {
                        result = 0x01; 
                        gLDL_Send[gLDL_InsValidCtr][0] = pos[PosCtr];  
                        gLDL_InsValidCtr++;
                        }
                    
                        else
                          {
                          putValue(env_NaviSD_LDL_Insert_Message, "POS is already deleted!");
                          gLDL_InvalidIns[gLDL_InsInvalidCtr] = pos[PosCtr];
                          gLDL_InsInvalidCtr++;
                          InsFlg = 0x01;
                          break;
                          }

                }  //update

                 else   //INSERT
                 {
                     if (gLDL_Pos_insDel[LDLlistCtr][1]==0x01)  //check if POS does not exist
                       {
                       gLDL_Pos_insDel[LDLlistCtr][1] = 0x00;
                       gLDL_Send[gLDL_InsValidCtr][0] = pos[PosCtr];

                       gLDL_InsValidCtr++;
                       result = 0x01;
                       }
                      else
                      {
                      putValue(env_NaviSD_LDL_Insert_Message, "POS still exists!");
                      gLDL_InvalidIns[gLDL_InsInvalidCtr] = pos[PosCtr];
                      gLDL_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                      }
               }//if
            } //else
       }//for
        if (result == 0x00 && InsFlg == 0x00)
           {
           gLDL_InvalidIns[gLDL_InsInvalidCtr]=pos[PosCtr];
            gLDL_InsInvalidCtr++;
             putValue(env_NaviSD_LDL_Insert_Message, "INVALID POS!");
            }
     }//for LDLlistCtr

     if (gLDL_InsInvalidCtr!=0)
            putValue(env_NaviSD_LDL_Insert_Invalid,gLDL_InvalidIns);
}

//IssueList #76 - MR49870 : LDL
void LastDestList_insert_ErrHandler_16 (byte pos[],word elementsCtr)
{
    byte i, result,InsFlg;
    word PosVal,LDLlistCtr, PosCtr;

    result = 0x01;
    InsFlg=0;
    PosVal = 0;

    for (PosCtr =0; PosCtr<elementsCtr; PosCtr = PosCtr+2)
    {
         result =0x00;
         InsFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+1];
        
      for (LDLlistCtr = 0;LDLlistCtr<gLDL_CSVtotalElem; LDLlistCtr++)
      {    
           if (PosVal==gLDL_Pos_insDel[LDLlistCtr][0])   //check if POS is valid
           {
            //UPDATE      
            if  (getValue(env_NaviSD_LDL_insert_UPD_button) == 0x01) 
             {  
                if (gLDL_Pos_insDel[LDLlistCtr][1]==0x00)  //check if POS is not deleted            {
                    {
                    result = 0x01; 
                    gLDL_Send[gLDL_InsValidCtr][0] = pos[PosCtr];  
                    gLDL_InsValidCtr++;
                    gLDL_Send[gLDL_InsValidCtr][0] = pos[PosCtr+1];  
                    gLDL_InsValidCtr++;
                    }
                        else
                      {
                      putValue(env_NaviSD_LDL_Insert_Message, "POS is already deleted!");
                      gLDL_InvalidIns[gLDL_InsInvalidCtr] = pos[PosCtr];
                      gLDL_InsInvalidCtr++;
                      gLDL_InvalidIns[gLDL_InsInvalidCtr] = pos[PosCtr+1];
                      gLDL_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                  }

            }  //update

             else   //INSERT
             {
                 if (gLDL_Pos_insDel[LDLlistCtr][1]==0x01)  //check if POS does not exist
                   {
                   gLDL_Pos_insDel[LDLlistCtr][1] = 0x00;
                   gLDL_Send[gLDL_InsValidCtr][0] = pos[PosCtr];
                   gLDL_InsValidCtr++;
                   gLDL_Send[gLDL_InsValidCtr][0] = pos[PosCtr+1];
                   gLDL_InsValidCtr++;
                   result = 0x01;
                   
                   }
                  else
                  {
                  putValue(env_NaviSD_LDL_Insert_Message, "POS still exists!");
                  gLDL_InvalidIns[gLDL_InsInvalidCtr] = pos[PosCtr];
                  gLDL_InsInvalidCtr++;
                  gLDL_InvalidIns[gLDL_InsInvalidCtr] = pos[PosCtr+1];
                  gLDL_InsInvalidCtr++;
                  InsFlg = 0x01;
                  break;
                  }
               }//if
            } //else
       }//for
        if (result == 0x00 && InsFlg == 0x00)
           {
            gLDL_InvalidIns[gLDL_InsInvalidCtr]=pos[PosCtr];
            gLDL_InsInvalidCtr++;
            gLDL_InvalidIns[gLDL_InsInvalidCtr] = pos[PosCtr+1];
            gLDL_InsInvalidCtr++;
             putValue(env_NaviSD_LDL_Insert_Message, "INVALID POS!");
            }
     }//for LDLlistCtr

     if (gLDL_InsInvalidCtr!=0)
            putValue(env_NaviSD_LDL_Insert_Invalid,gLDL_InvalidIns);
}

//IssueList #76 - MR49870 : Phonebook
byte ldlPosSequence_check (byte Index, byte inputArray[],word inputCtr)
{
    byte posInBetween;
    word ctr,ctr1,ctr2,PosVal1_,PosVal2_;

    posInBetween = 0;
    
    for (ctr = 0; ctr < inputCtr; ctr++)
    {
        // adjust for 8bit and 16bit handling
        if (Index==0x00)
        {
            PosVal1_ = inputArray[ctr];
            PosVal2_ = inputArray[ctr+1];
        }
        else
        {
            PosVal1_ = 0x0000;
            PosVal1_ = inputArray[(2*ctr)+1];
            PosVal1_ = PosVal1_|((inputArray[(2*ctr)+0])<<8);
            PosVal2_ = 0x0000;
            PosVal2_ = inputArray[(2*ctr)+2+1];
            PosVal2_ = PosVal2_|((inputArray[(2*ctr)+2+0])<<8);            
        }
        
        // search send item in insdel array
        for( ctr1 = 0; ctr1 < gLDL_CSVtotalElem; ctr1++ )
        {
            if( PosVal1_ == gLDL_Pos_insDel[ctr1][0]) // 1st send item is found in array            
            {
                break;
            }
        }
        
        // search insdel array for next send item
        for( ctr2 = ctr1+1; ctr2 < gLDL_CSVtotalElem; ctr2++ ) // loop from 1st inserted item in insdel array
        {

            if (PosVal2_ == gLDL_Pos_insDel[ctr2][0]) // 2nd send item immediately next to 1st send item            
            {
                break;
            }
            else
            {
                if (gLDL_Pos_insDel[ctr2][1] == 0 && PosVal2_ !=0)    // in between item is not deleted
                {
                    posInBetween = 0x01;
                    break;
                }
            }
        }
        
        if( posInBetween == 0x01)
        {
            break;
        }
    }
    
    return posInBetween;

    }

//IssueList #76 - MR49870 : AllList
//IssueList #190
//byte ldl_deleteCheck (word currentPos, word audioList_Pos_insDel[][], word totalElem)
byte ldl_deleteCheck (word currentPos)
{
byte i, posDeletedFlg;

posDeletedFlg = 0;

    for (i=0;i<gLDL_CSVtotalElem;i++)
    {
        if (currentPos == gLDL_Pos_insDel[i][0])
        {
            if (gLDL_Pos_insDel[i][1]==0x01)  //check if POS is deleted
            {
            posDeletedFlg = 0x01;
            break;
            }
        }
    }
        return posDeletedFlg;
}

//IssueList #183 - GetAll
on envVar env_FSG_NaviSD_GetAll_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(env_FSG_NaviSD_GetAll_SegmEn,0);
           intertelegram_err(FctID_GetAll);
       }
       else
       {
           intertelegram_err_off(FctID_GetAll);
       }
}

//IssueList #183
intertelegram_err(long fctId)
{
    long data[4];
    data[0]=LSG_NaviSD;
    data[1]=fctId;
    data[2]=1;
    data[3]=940;
    ChangeConfig(0x0020,data);
}

//IssueList #183
intertelegram_err_off(long fctId)
{
    long data[4];
    data[0]=LSG_NaviSD;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    ChangeConfig(0x0020,data);
}

//IssueList #183
on envVar env_FSG_NaviSD_GetAll_SegmEn
{
       if(getValue(this)) 
       {
           putValue(env_FSG_NaviSD_GetAll_IntTlgEn,0);
           sequence_err(FctID_GetAll,154);
       }
       else
       {
              sequence_err_off(FctID_GetAll);
       }
}

//IssueList #183
sequence_err_off(long fctId)
{
    long data[5];

    data[0]=LSG_NaviSD;
    data[1]=fctId;
    data[2]=5000;
    data[3]=0;
    data[4]=0;
    ChangeConfig(0x0021,data);
}

//IssueList #183
sequence_err(long fctId, long size)
{
    long data[5];
    long lastSeg;

    lastSeg = size-5;

    data[0]=LSG_NaviSD;
    data[1]=fctId;
    data[2]=lastSeg/7+1;
    data[3]=1;
    data[4]=(lastSeg/7+4) & 15;
    ChangeConfig(0x0021,data);
}

//IssueList #182 - FunctionList
on envVar env_FSG_NaviSD_FctList_SegmEn
{
       if(getValue(this)) 
       {
           putValue(env_FSG_NaviSD_FctList_IntTlgEn,0);
           sequence_err(FctID_FunctionList,8);
       }
       else
       {
              sequence_err_off(FctID_FunctionList);
       }
}

//IssueList #182 - FunctionList
on envVar env_FSG_NaviSD_FctList_IntTlgEn
{
       if(getValue(this)) 
       {
           putValue(env_FSG_NaviSD_FctList_SegmEn,0);
           intertelegram_err(FctID_FunctionList);
       }
       else
       {
           intertelegram_err_off(FctID_FunctionList);
       }
}

//IssueList #182
Request_error (byte fctID, byte errorCode)
{
word Offset;
dword requestarray [BAP_BUFFER_SIZE];

    requestarray[0]=LSG_NaviSD;    //LSG-ID
    requestarray[1]=fctID;    //Fct.-ID
    requestarray[2]=Error_REQ;    
    requestarray[3]=errorCode;
    Offset=4;
    set_status_requestbuffer (requestarray, Offset, Bap_Error);
}

//IssueList #159
on envVar env_FSG_NaviSD_GetAll_ErrEn
{
if (getValue(this))
putValue(env_FSG_NaviSD_GetAll_FctEn,0);
}

//IssueList #182
on envVar env_FSG_NaviSD_FctList_ErrEn
{
if (getValue(this))
putValue(env_FSG_NaviSD_FctList_FctEn,0);
}

//IssueList #184
//resending BAPconfig when this button is pressed
on envVar env_FSG_NaviSD_BAPCFG_ResetSet
{
   message 0x100 _mBAPconfig;    

    if (getValue(this))
    {
        //for BAPconfig Set/Reset button
         _mBAPconfig.CAN=1; 
         _mBAPconfig.ID=0x97333210; 
         _mBAPconfig.DLC=8; 
                    
         _mBAPconfig.byte(0) = 0x0c;
         _mBAPconfig.byte(1) = 0x82;
         _mBAPconfig.byte(2) = getValue(BAPCFG_FSG_NaviSD_ProtocolMajor);
         _mBAPconfig.byte(3) = getValue(BAPCFG_FSG_NaviSD_ProtocolMinor);
         _mBAPconfig.byte(4) = getValue(BAPCFG_FSG_NaviSD_LsgClassMajor);
         _mBAPconfig.byte(5) = getValue(BAPCFG_FSG_NaviSD_LsgClassMinor);
         _mBAPconfig.byte(6) = getValue(BAPCFG_FSG_NaviSD_DFMajor);
         _mBAPconfig.byte(7) = getValue(BAPCFG_FSG_NaviSD_DFMinor);
      
        output(_mBAPconfig);    
   }
}

//IssueList #184
on envVar env_BAPCFG_FSG_NaviSD_FctEn
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_BAP_Config;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #184
on envVar env_FSG_NaviSD_GetAll_FctEn
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_GetAll;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #184
on envVar env_FSG_NaviSD_FctList_FctEn
{
    long data[3];
    data[0]=LSG_NaviSD;
    data[1]=FctID_FunctionList;
    data[2]=getValue(this);
    ChangeConfig(0x0031,data);
}

//IssueList #216 15S1 update 17.01.2014
OnlineNaviState_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataGet_IND:
                OnlineNaviState_Request(Data_REQ, 0);                       //send status
         break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD Indication_OnlineNaviState: invalid indication %d", Indication_array[2]);
         break;
    }
}

//IssueList #216 15S1 update 17.01.2014
ExitView_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataGet_IND:
                ExitView_Request(Data_REQ, 0);                       //send status
         break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD Indication_ExitView: invalid indication %d", Indication_array[2]);
         break;
    }
}

//IssueList #216 15S1 update 17.01.2014
POI_Search_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2])
    {
        case Processing_CNF:
             POISearch_Request(Processing_REQ, 0);                                    //send Processing
        break;
        
        case StartResult_IND:
            if(getValue(env_NaviSD_POISearch_error_state))
                POISearch_Request(Error_REQ, getValue(env_NaviSD_POISearch_error_code));     //send result-message        
            else
            {         
                putValue(env_NaviSD_POISearch_SearchTypeH , Indication_array[3]);
                putValue(env_NaviSD_POISearch_POI_TypeHex , Indication_array[4]);
                POISearch_Request(Result_REQ, 0);                                //send result-message                
            }
        break;
        
        case Abort_IND:
            if(getValue(env_NaviSD_POISearch_error_state))
                POISearch_Request(Error_REQ, getValue(env_NaviSD_POISearch_error_code));     //send result-message        
            else
            POISearch_Request(Result_REQ, 0);                                //send result-message                

        break;
        default:
            writelineEx(gError_Trace, 0, "NaviSD POI_Search_Indication: unknown indication %d", Indication_array[2]);
        break;
        }
}

//IssueList #216 15S1 update 17.01.2014
POIList_Indication(dword Indication_array [], int datalength)
{
    byte mode, shift, direction, recordaddress, indexsize, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements, Offset, valid_elements;
    int i=0, transSuppression;
    // Init local variables. 
    mode                    =0;
    direction               =0;
    shift                   =0;
    Offset                  =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    transmitpos             =0;        
    indexsize               =0;
    valid_startelement      =0xff;
    valid_elements          =0;
    //MR 76047 
    transSuppression        = getvalue(env_NaviSD_POIList_StatusOFF);
    
        switch (Indication_array[2]) // indication
        {
            case DataGet_IND:
                //VAGH-10511
                if(getvalue(env_NaviSD_POI_List_Error_on))
                {
                    POIList_Request(Error_REQ, 0, 0, 0, 0, 0, getValue(env_NaviSD_POI_List_ErrorCode));
                }
                //MR 63336    02.07.2014
                else if ( getValue(env_NaviSD_POI_List_TimeOut)== TRUE)
                {
                /* NOP */
                }
                else
                {
                    //getData
                    gPOIList_ASGID =(gBAP_Indication[3] &0xF0) /0x10;
                    gPOIList_TAID  =gBAP_Indication[3] &0x0F;
            
                    /***ArrayHeader***/
                    mode            =(Indication_array[4] &0xF0) /0x10;
                    recordaddress   =Indication_array[4] &0x0F;
                    Offset =5;
                
                    // decode "mode-byte"
                    shift       =mode &0x01;
                    direction   =(mode &0x02)/0x02;
                    transmitpos =(mode &0x04)/0x04;
                    indexsize   =(mode &0x08)/0x08;              
            
                    if (indexsize)
                    {   
                        startelement =Indication_array[Offset];
                        Offset++;
                        startelement +=(Indication_array[Offset] *0x100);
                        Offset++;

                        elements =Indication_array[Offset];
                        Offset++;
                        elements +=(Indication_array[Offset] *0x100);
                        Offset++;
                    }
                    else
                    {   
                        startelement =Indication_array[Offset];
                        Offset++;

                        elements =Indication_array[Offset];
                        Offset++;
                    }   

                    requested_startelement =startelement;
                  

                    /***Startelement=0***/
                    if(0==startelement) //Startelement-ID =0 -> start at first array-entry
                    {
                        if(FORWARD==direction)  //forward-start
                        {
                            valid_startelement =0;                                                           

                            if(NAV_POILIST_ENTRIES <=elements) //1. more elements requested, than in array
                            {
                                if (shift ==FALSE)  
                                {
                                    for(i=0;i<NAV_POILIST_ENTRIES;i++)
                                    {
                                        if(0 !=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;

                                            valid_elements++;                                //increment elements
                                        }    
                
                                        else                                                //no valid element, loop finished
                                            i =NAV_POILIST_ENTRIES;
                                    }
                                }
                                else
                                {   
                                    valid_startelement  =startelement;
                                    valid_elements      =0;
                                }
                            }
                            else    //2. number of requested elements < elements in array
                            {
                                if (shift ==FALSE)
                                {
                                    for(i=0;i<elements;i++)
                                    {
                                        if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;
                                            
                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i =NAV_POILIST_ENTRIES;
                                    }
                                }
                                else
                                {
                                    valid_startelement  =startelement;
                                    valid_elements      =0;
                                }
                            }
                        }                                                               //forward ends

                        else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
                        {   
                            //searching for valid startelement
                            for(i=(NAV_POILIST_ENTRIES-1);i>=0;i--)
                            {
                                if(0!=gPOIList_ListEntryValidInformation[i])        //found valid startelement
                                {
                                    valid_startelement =i;                                
                                    i =0;                                                
                                }
                            }
                        
                            //searching for valid elements
                            if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                            {
                                valid_startelement  =startelement;
                                valid_elements      =0;
                            }
                            else if(0==valid_startelement)                                
                                valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                            else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                            {
                                for(i=valid_startelement;i>=0;i--)
                                {
                                    if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                    {
                                        if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;
                                     
                                        valid_elements++;                                //increment elements
                                    }
                                    else                                                //no valid element, loop finished
                                        i=0;
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for(i=valid_startelement;i>(valid_startelement-elements);i--)
                                {
                                    if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                    {
                                        valid_elements++;                                //increment elements
                                        
                                        if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;
                                    }
                                    else                                                //no valid element, loop finished
                                        i=0;
                                }                 
                            }                                                            
                        }                                                               //backward-end
                    }                                                                   //startelement ==0 -end

                    /***Startelement!=0***/
                    else                                                                //searching for Startelement-ID                
                    {
                        //searching for valid startelement
                        for(i=0;i<NAV_POILIST_ENTRIES;i++)
                        {
                                if(gPOIList_Pos[i] ==startelement)                        //found a valid element
                                {                                          
                                if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                                {
                                    if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                                        valid_startelement =i+1-2*direction;
                                                            
                                    else if(i==0 && BACKWARD==direction) 
                                        valid_startelement =gPOIListLine_sum;           //valid element is last element in Array                                                
                            
                                    else if(i==0 && FORWARD==direction) 
                                        valid_startelement =0;                          //valid element is first element in Array
                                }
                    
                                else
                                    valid_startelement =i;                              //found element is valid_startelement

                                i=NAV_POILIST_ENTRIES;
                            }
                        }

                        if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
                        {
                            valid_startelement  =startelement;
                            valid_elements      =0;
                        }
                        else                                                                //found valid entry for startelement in array
                        {
                            //verify number of valid elements
                            if(BACKWARD==direction)                                            //backward-start
                            {
                                if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                                    valid_elements=1;
                            
                                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                                {
                                    for(i=valid_startelement;i>=0;i--)
                                    {
                                        if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                                else                                                        //enougth array-elements available
                                {
                                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                                    {
                                        if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                            }                                                                //backward-end
                            else                                                            //forward-start
                            {
                                if((valid_startelement+elements)>=NAV_POILIST_ENTRIES)
                                {
                                    for(i=valid_startelement;i<NAV_POILIST_ENTRIES;i++)
                                    {   
                                        if(0!=gPOIList_Pos[i])                            //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                    //no valid element, loop finished
                                            i=NAV_POILIST_ENTRIES;
                                    }
                                }
                                else
                                {
                                    for(i=valid_startelement;i<(valid_startelement+elements);i++)
                                    {
                                        if(0!=gPOIList_Pos[i])                            //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i=NAV_POILIST_ENTRIES;
                                    }
                                }
                            }
                        } //END: if(BACKWARD==direction)    
                    } //END: if(0==startelement)
                
                    transmitpos =TRUE;
                    if((requested_startelement >0xFF) || (valid_startelement >0xFF))
                        indexsize =TRUE;
                    
                    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                    //send StatusArray
            //MR 76047 
            if(!transSuppression)
                    POIList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);                   
                }
             break;
            
            case Error_IND:
                writelineEx(gError_Trace, 0, "FSG_NaviSD POIList_Indication: received error, errorcode:0x%x", Indication_array[3]);
            break;

            default:
                writelineEx(gError_Trace, 0, "FSG_NaviSD POIList_Indication: invalid indication %d", Indication_array[2]);
             break;
    }
}

//IssueList #216 15S1 update 17.01.2014
FSG_Setup_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataGet_IND:
                FSG_Setup_Request(Data_REQ, 0);                       //send status
         break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD IndicationFSG_Setup: invalid indication %d", Indication_array[2]);
         break;
    }
}

//IssueList #216 15S1 update 17.01.2014
MapPresentation_Indication (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataGet_IND:
                MapPresentation_Request(Data_REQ, 0);                       //send status
        break;
        case DataSetGet_IND:
                putValue(env_NaviSD_MapPres_0,Indication_array[3] & 00000001);
                putValue(env_NaviSD_MapPres_1 ,(Indication_array[3] & 00000010) >> 1);
                putValue(env_NaviSD_MapPres_2 , (Indication_array[3] & 00000100) >> 2);
                MapPresentation_Request(Data_REQ, 0);                       //send status
        break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD Indication_MapPresentation: invalid indication %d", Indication_array[2]);
         break;
    }
}

//IssueList #216 15S1 update 17.01.2014
OnlineNaviState_Request(byte request, byte errorcode)
{
    int  i, tempReserved1, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;            //LSG-ID
    requestarray[1]=FctID_OnlineNavigationState;        //Fct.-ID
    requestarray[2]=request;            //request type

    switch(request)
    {
        case Data_REQ:        
            requestarray[3] = getValue(env_NaviSD_OnlineNavS_StateHex);
            requestarray[4] = getValue(env_NaviSD_OnlineNavS_Progress);
            requestarray[5] = getValue(env_NaviSD_OnlineNavS_ONSysHex);            

            set_status_requestbuffer (requestarray, 6, Bap_ByteSequence);
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD Request_OnlineNaviState: invalid request %d", request);
        break;
    }
}

//IssueList #216 15S1 update 17.01.2014
ExitView_Request(byte request, byte errorcode)
{
    int  i, tempReserved1, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;            //LSG-ID
    requestarray[1]=FctID_ExitView;        //Fct.-ID
    requestarray[2]=request;            //request type

    switch(request)
    {
        case Data_REQ:        
            requestarray[3] = getValue(env_NaviSD_ExitV_VariantHex);
            requestarray[4] = (getValue(env_NaviSD_ExitV_ExitVID)>>8)&255;
            requestarray[5] = getValue(env_NaviSD_ExitV_ExitVID);            

            set_status_requestbuffer (requestarray, 6, Bap_ByteSequence);
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD Request_ExitView: invalid request %d", request);
        break;
    }
}

//IssueList #216 15S1 update 17.01.2014
POISearch_Request (byte request, byte errorcode)
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                    //LSG-ID
    requestarray[1] =FctID_POI_Search;                //Fct.-ID
    requestarray[2] =request;
    
    switch(request)
    {
        case Processing_REQ:        
            requestarray[3] = getValue(env_NaviSD_POISearch_AOFE);
            requestarray[4] = getValue(env_NaviSD_POISearch_ProgressIndicator);
            set_status_requestbuffer (requestarray, 5, Bap_ByteSequence);
        break;
        case Result_REQ:
            requestarray[3] = getValue(env_NaviSD_POISearch_AOFE);
            requestarray[4] = getValue(env_NaviSD_POISearch_POISRHex);
            set_status_requestbuffer (requestarray, 5, Bap_ByteSequence);
        break;
        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    //error
            writelineEx(gError_Trace, 0, "NaviSD Request_POI_Search: unknown request %d", request);
        break;
    }
}

//IssueList #216 15S1 update 17.01.2014
POIList_Request(byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode)
{ 
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element; 
    word POIListLine, Offset;
            
    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;
    
    shift               =0;
    direction           =0;
    transmitpos         =0;
    indexsize           =0;
    POIListLine         =0;
    current_element     =0;
    Offset              =0;

    // decode "mode-byte"
    shift       =mode &0x01;
    direction   =(mode &0x02)/0x02;
    transmitpos =(mode &0x04)/0x04;
    indexsize   =(mode &0x08)/0x08;

    // Handle request.
    requestarray[0] =LSG_NaviSD;                //LSG-ID
    requestarray[1] =FctID_POI_List;            //Fct.-ID
    requestarray[2] =request;                   //request type
    Offset =3;



    //-------------------------------------------------------------------------
    //-------------------------------------------------------------------------
    switch(request)
    {
        case Changed_REQ:
            /***ArrayHeader***/
            requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
            Offset++;        
            if (indexsize)
            {   requestarray[Offset] =(requested_startelement &0x00FF);
                Offset++;
                requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
                Offset++;
                requestarray[Offset] =(elements &0x00FF);
                Offset++;
                requestarray[Offset] =((elements &0xFF00) /0x100);
                Offset++;
            }
            else
            {   
                requestarray[Offset] =requested_startelement;
                Offset++;

                requestarray[Offset] =elements;
                Offset++;
            }

            POIListLine =startelement;           
        if (getValue(env_NaviSD_POI_List_AH)|| getValue(env_NaviSD_POI_List_AHD)) //ArrayData
        {
        //   if(elements != 0xffff)                                  // if FullRangeUpdate
         //   {
               //copy data
                for(i =0;i<BAP_BUFFER_SIZE;i++)
                {
                    requestarrayPOIListGlobal[i] = requestarray[i];
                }
               offsetPOIListGlobal = Offset;
              if(elements != 0xffff)                                  // if no FullRangeUpdate
                POIList_Request_RecordAddress (recordaddress, transmitpos, indexsize, elements, POIListLine);
            for(i =0;i<BAP_BUFFER_SIZE;i++)
                {
                    requestarray[i] = requestarrayPOIListGlobal[i];
                }
                Offset = offsetPOIListGlobal;
           // }
                set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
       }

        break; //end Changed_REQ
        
        case Data_REQ:
        //VAGH-10511
        ASGID = gPOIList_ASGID;
        TAID = gPOIList_TAID;
        if(getvalue(env_NaviSD_POI_List_ASGID_error) != FALSE)
        {
            ASGID += 0x2;
        }
        if(getvalue(env_NaviSD_POI_List_TAID_error) != FALSE)
        {
            TAID += 0x02;
        }
                
            requestarray[Offset] =((ASGID *0x10) &0xF0) +(TAID &0x0F);    
            Offset++;
            requestarray[Offset] =gPOIList_TotalNumListElements;    
            Offset++;

            /***ArrayHeader***/
            requestarray[Offset] =((mode *0x10) &0xF0) +(recordaddress &0x0F);
            Offset++;
              
            if (indexsize)
            {   
                requestarray[Offset] =(requested_startelement &0x00FF);
                Offset++;
                requestarray[Offset] =((requested_startelement &0xFF00) /0x100);
                Offset++;

                requestarray[Offset] =(elements &0x00FF);
                Offset++;
                requestarray[Offset] =((elements &0xFF00) /0x100);
                Offset++;
            }
            else
            {   
                requestarray[Offset] =requested_startelement;
                Offset++;

                requestarray[Offset] =elements;
                Offset++;
            }
            //writelineEx(gBAP_Trace, 0, "POI_List_request_2 ");                        //debug
            POIListLine =startelement; 
           //copy data
            for(i =0;i<BAP_BUFFER_SIZE;i++)
            {
                requestarrayPOIListGlobal[i] = requestarray[i];
            }
           offsetPOIListGlobal = Offset;
           POIList_Request_RecordAddress (recordaddress, transmitpos, indexsize, elements, POIListLine);
           
           for(i =0;i<BAP_BUFFER_SIZE;i++)
            {
                requestarray[i] = requestarrayPOIListGlobal[i];
            }
            Offset = offsetPOIListGlobal;
            set_status_requestbuffer (requestarray, Offset, Bap_ByteSequence); 
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
         break; //end Error_REQ
    
    } //end switch "request"   
}

//IssueList #216 15S1 update 17.01.2014
FSG_Setup_Request(byte request, byte errorcode)
{
    int  i, tempReserved1, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;            //LSG-ID
    requestarray[1]=FctID_FSG_Setup;        //Fct.-ID
    requestarray[2]=request;            //request type

    switch(request)
    {
        case Data_REQ:        
            requestarray[3] = getValue(env_NaviSD_FSGS_VG2) <<2; 
            requestarray[3]+= getValue(env_NaviSD_FSGS_VG1) <<1; 
            requestarray[3]+= getValue(env_NaviSD_FSGS_VG0);
            requestarray[4] = getValue(env_NaviSD_FSGS_SPOIT0);
            requestarray[5] = 0;
            requestarray[6] = 0;
            requestarray[7] = 0;
            requestarray[8] = 0;

            set_status_requestbuffer (requestarray, 9, Bap_ByteSequence);
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD Request_FSG_Setup: invalid request %d", request);
        break;
    }
}

//IssueList #216 15S1 update 17.01.2014
MapPresentation_Request(byte request, byte errorcode)
{
    int  i, tempReserved1, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;            //LSG-ID
    requestarray[1]=FctID_Map_Preasentation;        //Fct.-ID
    requestarray[2]=request;            //request type

    switch(request)
    {
        case Data_REQ:        
                requestarray[3] = getValue(env_NaviSD_MapPres_2)<<2;
                requestarray[3]+= getValue(env_NaviSD_MapPres_1)<<1;
                requestarray[3]+= getValue(env_NaviSD_MapPres_0);

            set_status_requestbuffer (requestarray, 4, Bap_UInt8);
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD Request_MapPresentation: invalid request %d", request);
        break;
    }
}

//IssueList #216 15S1 update 17.01.2014
POIList_Request_RecordAddress (byte recordaddress, byte transmitpos, byte indexsize, word elements, word POIListLine)
{
    int  i, temp =0, first =1;
    dword requestarray [BAP_BUFFER_SIZE];
    byte  current_element, direction;
    word  Offset;
    current_element =0;
    direction =0;
    temp =0;
    //writelineEx(gBAP_Trace, 0, "POI_List_RA_start");                        //debug    
    for(i =0;i<BAP_BUFFER_SIZE;i++)
    {
        requestarray[i] = requestarrayPOIListGlobal[i];
    }

    Offset  =offsetPOIListGlobal;

            if(POIListLine == 0xff) // invalid "list entry"
            {
                write("NaviSD POIList_Request: invalid POIListLine");
                current_element =elements;
            }//----------------------
            else //valid "list entry"
             {
               
                //------------------------------------------------------------------------------------------------------
                //------------------------------------------------------------------------------------------------------
                // Direction_Symbolic, POI_Type, DistanceType, Distance, Unit, MainDescription, Street, City, PostalCode
                switch(recordaddress)
                {
                    case 0: //complete record
                        while(current_element <elements)
                        {       
                        
                                             /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gPOIList_Pos[POIListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gPOIList_Pos[POIListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gPOIList_Pos[POIListLine];
                                        Offset++;
                                    }
                                }
                                                                                              
                            // -------------------------------------------------
                            // Direction_Symolic
                                requestarray[Offset] =gPOIList_DirectionSymbolic[POIListLine];
                                Offset++;

                            // -------------------------------------------------
                            // POI_Type
                                requestarray[Offset] =gPOIList_POIType[POIListLine];
                                Offset++;

                            // -------------------------------------------------
                            // DistanceType
                                requestarray[Offset] =gPOIList_DistanceType[POIListLine];
                                Offset++;

                            // -------------------------------------------------
                            // Distance
                               requestarray[Offset] =gPOIList_Distance[POIListLine];
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x00001100) >> 2);
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x00110000) >> 4);
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x11000000) >> 6);
                               Offset++;


                            // -------------------------------------------------
                            // Unit
                               requestarray[Offset] =gPOIList_Unit[POIListLine];
                               Offset++;

                            // -------------------------------------------------
                            // MainDescription
                               requestarray[Offset] =strlen(gPOIList_MainDescription[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_MainDescription[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_MainDescription[POIListLine][i];    
                                    Offset++;
                                }
                            // -------------------------------------------------
                            // Street
                               requestarray[Offset] =strlen(gPOIList_Street[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_Street[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_Street[POIListLine][i];    
                                    Offset++;
                                }

                            // -------------------------------------------------
                            // City
                               requestarray[Offset] =strlen(gPOIList_City[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_City[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_City[POIListLine][i];    
                                    Offset++;
                                }

                            // -------------------------------------------------
                            // PostalCode
                               requestarray[Offset] =strlen(gPOIList_PostalCode[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_PostalCode[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_PostalCode[POIListLine][i];    
                                    Offset++;
                                }
                            current_element++;
                            POIListLine =POIList_nextvalidLine(POIListLine, direction);
                        }//end while
                    break;

                    case 1: //Distance, Unit, MainDescription, Street, City, PostalCode
                        while(current_element <elements)
                        {
                         //writelineEx(gBAP_Trace, 0, "POI_List_RA1_elements: %x", elements);        //debug    
                                             /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gPOIList_Pos[POIListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gPOIList_Pos[POIListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gPOIList_Pos[POIListLine];
                                        Offset++;
                                    }
                                }
                                                

                            // -------------------------------------------------
                            // Distance
                               requestarray[Offset] =gPOIList_Distance[POIListLine];
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x00001100) >> 2);
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x00110000) >> 4);
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x11000000) >> 6);
                               Offset++;


                            // -------------------------------------------------
                            // Unit
                               requestarray[Offset] =gPOIList_Unit[POIListLine];
                               Offset++;

                            // -------------------------------------------------
                            // MainDescription
                               requestarray[Offset] =strlen(gPOIList_MainDescription[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_MainDescription[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_MainDescription[POIListLine][i];    
                                    Offset++;
                                }

                            // -------------------------------------------------
                            // Street
                               requestarray[Offset] =strlen(gPOIList_Street[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_Street[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_Street[POIListLine][i];    
                                    Offset++;
                                }

                            // -------------------------------------------------
                            // City
                               requestarray[Offset] =strlen(gPOIList_City[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_City[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_City[POIListLine][i];    
                                    Offset++;
                                }

                            // -------------------------------------------------
                            // PostalCode
                               requestarray[Offset] =strlen(gPOIList_PostalCode[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_PostalCode[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_PostalCode[POIListLine][i];    
                                    Offset++;
                                }    
                                current_element++;
                                POIListLine =POIList_nextvalidLine(POIListLine, direction);                                
                               
                        }//end while
                    break;

                    case 2: //Distance, Unit
                        while(current_element <elements)
                        {


                                             /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gPOIList_Pos[POIListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gPOIList_Pos[POIListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gPOIList_Pos[POIListLine];
                                        Offset++;
                                    }
                                }
                                                
                            // -------------------------------------------------
                            // Distance
                               requestarray[Offset] =gPOIList_Distance[POIListLine];
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x00001100) >> 2);
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x00110000) >> 4);
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x11000000) >> 6);
                               Offset++;


                            // -------------------------------------------------
                            // Unit
                               requestarray[Offset] =gPOIList_Unit[POIListLine];
                               Offset++;


                            current_element++;
                            POIListLine =POIList_nextvalidLine(POIListLine, direction);
                            
                        }//end while
                    break;
                  
                    case 3: //Direction_Symbolic
                        while(current_element <elements)
                        {


                                             /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gPOIList_Pos[POIListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gPOIList_Pos[POIListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gPOIList_Pos[POIListLine];
                                        Offset++;
                                    }
                                }
                                                
                           // -------------------------------------------------
                            // Direction_Symolic
                                requestarray[Offset] =gPOIList_DirectionSymbolic[POIListLine];
                                Offset++;


                            current_element++;
                            POIListLine =POIList_nextvalidLine(POIListLine, direction);
                            
                        }//end while
                    break;
                
                    case 4: //MainDescription, Street, City, PostalCode
                        while(current_element <elements)
                        {
 

                                             /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gPOIList_Pos[POIListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gPOIList_Pos[POIListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gPOIList_Pos[POIListLine];
                                        Offset++;
                                    }
                                }
                                                

                            // -------------------------------------------------
                            // MainDescription
                               requestarray[Offset] =strlen(gPOIList_MainDescription[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_MainDescription[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_MainDescription[POIListLine][i];    
                                    Offset++;
                                }

                            // -------------------------------------------------
                            // Street
                               requestarray[Offset] =strlen(gPOIList_Street[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_Street[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_Street[POIListLine][i];    
                                    Offset++;
                                }

                            // -------------------------------------------------
                            // City
                               requestarray[Offset] =strlen(gPOIList_City[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_City[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_City[POIListLine][i];    
                                    Offset++;
                                }

                            // -------------------------------------------------
                            // PostalCode
                               requestarray[Offset] =strlen(gPOIList_PostalCode[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_PostalCode[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_PostalCode[POIListLine][i];    
                                    Offset++;
                                }
                            current_element++;
                            POIListLine =POIList_nextvalidLine(POIListLine, direction);
                        }//end while
                    break;   
                
                    case 5: //Direction_Symbolic, POI_Type, DistanceType, Distance, Unit, MainDescription
                        while(current_element <elements)
                        {


                                             /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gPOIList_Pos[POIListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gPOIList_Pos[POIListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gPOIList_Pos[POIListLine];
                                        Offset++;
                                    }
                                }
                                                
                          // -------------------------------------------------
                            // Direction_Symolic
                                requestarray[Offset] =gPOIList_DirectionSymbolic[POIListLine];
                                Offset++;

                            // -------------------------------------------------
                            // POI_Type
                                requestarray[Offset] =gPOIList_POIType[POIListLine];
                                Offset++;

                            // -------------------------------------------------
                            // DistanceType
                                requestarray[Offset] =gPOIList_DistanceType[POIListLine];
                                Offset++;

                            // -------------------------------------------------
                            // Distance
                                requestarray[Offset] =gPOIList_Distance[POIListLine];
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x00001100) >> 2);
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x00110000) >> 4);
                               Offset++;
                               requestarray[Offset] =((gPOIList_Distance[POIListLine] & 0x11000000) >> 6);
                               Offset++;


                            // -------------------------------------------------
                            // Unit
                               requestarray[Offset] =gPOIList_Unit[POIListLine];
                               Offset++;

                            // -------------------------------------------------
                            // MainDescription
                               requestarray[Offset] =strlen(gPOIList_MainDescription[POIListLine]);
                                Offset++;
                                
                                for(i=0;i<strlen(gPOIList_MainDescription[POIListLine]);i++)
                                {
                                    requestarray[Offset] =gPOIList_MainDescription[POIListLine][i];    
                                    Offset++;
                                }
                            current_element++;
                            POIListLine =POIList_nextvalidLine(POIListLine, direction);                            
                        }//end while
                    break;

                    case 15:    //Pos
                        while(current_element <elements)
                        {
                                             /***Array Data***/
                                if (transmitpos) // Pos  ->Array position transmitted
                                {
                                    if (indexsize)
                                    {
                                        requestarray[Offset] =(gPOIList_Pos[POIListLine] &0x00FF);
                                        Offset++;
                                        requestarray[Offset] =((gPOIList_Pos[POIListLine]&0xFF00) /0x100);
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] =gPOIList_Pos[POIListLine];
                                        Offset++;
                                    }
                                }
                                                

                             current_element++;
                            POIListLine =POIList_nextvalidLine(POIListLine, direction);                           
                        }//end while
                    break;

                    default:
                        write("NaviSD POIList_Request: invalid recordaddress %d", recordaddress);
                    break;
                } //end switch "recordaddress"
             }//end if(POIListLine == 0xff)

            //clear
           for(i =0;i<BAP_BUFFER_SIZE;i++)
            {
                requestarrayPOIListGlobal[i] = 0;
            }
            offsetPOIListGlobal = 0;
            //save data
           for(i =0;i<BAP_BUFFER_SIZE;i++)
            {
                requestarrayPOIListGlobal[i] = requestarray[i];
            }
            offsetPOIListGlobal = Offset; 
             //writelineEx(gBAP_Trace, 0, "POI_List_RA_end");                        //debug                
}

//IssueList #216 15S1 update 17.01.2014
byte POIList_nextvalidLine (byte current_POIListLine, byte direction)
{
    byte next_POIListLine;
    int i;
         
    //init lokal variables
    next_POIListLine  =0;
    i                      =0;

    //search next "list entry"
    if(((gPOIListLine_sum-1)==current_POIListLine && FORWARD ==direction) || (0 ==current_POIListLine && BACKWARD ==direction))    //last-/fist-element of array reached
        next_POIListLine =0xFF;
    else
    {
            next_POIListLine =current_POIListLine +1-2*direction;       //increment or decrement array-line (depends on direction);
                 
            if(0 ==gPOIList_ListEntryValidInformation[next_POIListLine])    // check if next element is "valid"
                next_POIListLine =0xff;                     
    }

    return(next_POIListLine);
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_OnlineNavS_State
{
    if(getValue(env_NaviSD_OnlineNavS_State) <3 || !tempONS)
       gONS_Stateact = getValue(this);
    tempONS =0;
    if(getValue(env_NaviSD_OnlineNavS_StateHex) != gONS_Stateact)
        putValue(env_NaviSD_OnlineNavS_StateHex , getValue(this));
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_OnlineNavS_StateHex
{
    if(getValue(this) >3)
       {
        gONS_Stateact =getValue(env_NaviSD_OnlineNavS_StateHex);
        tempONS =1;
        putValue(env_NaviSD_OnlineNavS_State,3);
       }
       else
       {
        if(getValue(env_NaviSD_OnlineNavS_StateHex) != gONS_Stateact)
            putValue(env_NaviSD_OnlineNavS_State,getValue(this));
       }
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_OnlineNavS_ONSys
{
    if(getValue(this) <2 || !tempONS2)
       gONS_ONSact = getValue(this);
    else if(getValue(this) ==255 ||!tempONS2)
    {
       gONS_ONSact = getValue(this);
       tempONS2 =0;
    }
    if(getValue(env_NaviSD_OnlineNavS_ONSysHex) != gONS_ONSact)
        putValue(env_NaviSD_OnlineNavS_ONSysHex,getValue(this));
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_OnlineNavS_ONSysHex
{
    if(getValue(this) >2 && getValue(this) != 255)
       {
        gONS_ONSact =getValue(this);
        tempONS2 =1;
        putValue(env_NaviSD_OnlineNavS_ONSys,2);
       }
       else
       {
        if(getValue(env_NaviSD_OnlineNavS_ONSysHex) != gONS_ONSact)
            putValue(env_NaviSD_OnlineNavS_ONSys,getValue(this));
       }
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_ExitV_Variant
{
    if(getValue(env_NaviSD_ExitV_Variant) <4 || !tempEV)
       gEV_Variact = getValue(env_NaviSD_ExitV_Variant);
    if(getValue(env_NaviSD_ExitV_Variant) ==4 || !tempEV)
       gEV_Variact = getValue(env_NaviSD_ExitV_Variant);
       tempEV =0;
    if(getValue(env_NaviSD_ExitV_VariantHex) != gEV_Variact)
        putValue(env_NaviSD_ExitV_VariantHex,getValue(env_NaviSD_ExitV_Variant));
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_ExitV_VariantHex
{
    if(getValue(env_NaviSD_ExitV_VariantHex) >4 && getValue(env_NaviSD_ExitV_VariantHex) != 255)
       {
        gEV_Variact =getValue(env_NaviSD_ExitV_VariantHex);
        tempEV =1;
        putValue(env_NaviSD_ExitV_Variant,4);
       }
       else
       {
        if(getValue(env_NaviSD_ExitV_VariantHex) != gEV_Variact)
            putValue(env_NaviSD_ExitV_Variant,getValue(env_NaviSD_ExitV_VariantHex));
       }
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_prop4
{
if(getvalue(this))
    openPanel("FSG_Properties_4");
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_openMeth2
{
if(getvalue(this))
    openPanel("MethodMIB2FSG");
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POISearch_SearchType
{
    if(getValue(this) <2 || !tempPOIS_1)
    {
       gPOIS_STact = getValue(this);
       tempPOIS_1 =0;
    }
    if(getValue(env_NaviSD_POISearch_SearchTypeH) != gPOIS_STact)
        putValue(env_NaviSD_POISearch_SearchTypeH,getValue(this));
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POISearch_SearchTypeH
{
    if(getValue(this) >2)
       {
        gPOIS_STact =getValue(this);
        tempPOIS_1 =1;
        putValue(env_NaviSD_POISearch_SearchType,2);
       }
       else
       {
        if(getValue(this) != gPOIS_STact)
            putValue(env_NaviSD_POISearch_SearchType,getValue(this));
       }

}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POISearch_POI_TypeHex
{

    if(getValue(this) < 63)
    {
        gPOIS_POITyact =getValue(this);
        tempPOIS_3 =1;
        putValue(env_NaviSD_POISearch_POI_Type,0);    
    }else if(getValue(env_NaviSD_POISearch_POI_TypeHex) < 103)
       {
        if(getValue(env_NaviSD_POISearch_POI_TypeHex) >64)
           {
            gPOIS_POITyact =getValue(env_NaviSD_POISearch_POI_TypeHex);
            tempPOIS_3 =1;
            putValue(env_NaviSD_POISearch_POI_Type,0);
           }
           else
           {
            if(getValue(env_NaviSD_POISearch_POI_TypeHex) != gPOIS_POITyact)
                putValue(env_NaviSD_POISearch_POI_Type ,getValue(env_NaviSD_POISearch_POI_TypeHex));
           }
       }else
       {
        if(getValue(env_NaviSD_POISearch_POI_TypeHex) >103)
           {
            gPOIS_POITyact =getValue(env_NaviSD_POISearch_POI_TypeHex);
            tempPOIS_3 =1;
            putValue(env_NaviSD_POISearch_POI_Type,0);
           }
           else
           {
            if(getValue(env_NaviSD_POISearch_POI_TypeHex) != gPOIS_POITyact)
                putValue(env_NaviSD_POISearch_POI_Type,getValue(env_NaviSD_POISearch_POI_TypeHex));
           }
       }
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POISearch_POI_Type
{
    if(getValue(env_NaviSD_POISearch_POI_Type) <5 || !tempPOIS_3)
       gPOIS_POITyact = getValue(env_NaviSD_POISearch_POI_Type);
    tempPOIS_3 =0;
    if(getValue(env_NaviSD_POISearch_POI_TypeHex) != gPOIS_POITyact)
        putValue(env_NaviSD_POISearch_POI_TypeHex,getValue(env_NaviSD_POISearch_POI_Type));
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POISearch_POISR
{
    if(getValue(env_NaviSD_POISearch_POISR) <5 || !tempPOIS_2)
       gPOIS_POISRact = getValue(env_NaviSD_POISearch_POISR);
    tempPOIS_2 =0;
    if(getValue(env_NaviSD_POISearch_POISRHex) != gPOIS_POISRact)
        putValue(env_NaviSD_POISearch_POISRHex,getValue(env_NaviSD_POISearch_POISR));
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POISearch_POISRHex
{
    if(getValue(env_NaviSD_POISearch_POISRHex) >5)
       {
        gPOIS_POISRact =getValue(env_NaviSD_POISearch_POISRHex);
        tempPOIS_2 =1;
        putValue(env_NaviSD_POISearch_POISR,6);
       }
       else
       {
        if(getValue(env_NaviSD_POISearch_POISRHex) != gPOIS_POISRact)
            putValue(env_NaviSD_POISearch_POISR,getValue(env_NaviSD_POISearch_POISRHex));
       }

}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_OnlineNavS_Status
{
if(getValue(env_NaviSD_OnlineNavS_Status))
    OnlineNaviState_Request(Data_REQ,0); 
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_ExitV_Status
{
if(getValue(env_NaviSD_ExitV_Status))
    ExitView_Request(Data_REQ,0); 
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_FSGS_Status
{
if(getValue(env_NaviSD_FSGS_Status))
    FSG_Setup_Request(Data_REQ,0); 
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_MapPres_Status
{
if(getValue(env_NaviSD_MapPres_Status))
    MapPresentation_Request(Data_REQ,0); 
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_openPOIList
{
if(getvalue(this))
    openPanel("POI_List_FSG2");
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POI_List_AH
{
    if(getValue(env_NaviSD_POI_List_AH))
        putValue(env_NaviSD_POI_List_AHD, 0);
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POI_List_AHD
{
    if(getValue(env_NaviSD_POI_List_AHD))
        putValue(env_NaviSD_POI_List_AH,0);
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POI_List_CangedArray
{
    word requested_startelement, startelement, elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getValue(env_NaviSD_POI_List_CangedArray))
    {
        if(getValue(env_NaviSD_POI_List_start) >255 && getValue(env_NaviSD_POI_List_index) ==1)// check if 8 or 16 bit
            putValue(env_NaviSD_POI_List_index,1);

        //get data from Panel
        recordaddress   =getValue(env_NaviSD_POI_List_RecordAdd);
        shift           =getValue(env_NaviSD_POI_List_shift);
        direction       =getValue(env_NaviSD_POI_List_direction);
        transmitpos     =getValue(env_NaviSD_POI_List_transmitPos);
        indexsize       =getValue(env_NaviSD_POI_List_index);
        startelement    =getValue(env_NaviSD_POI_List_start);
        elements        =getValue(env_NaviSD_POI_List_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        requested_startelement =startelement;

        if(getValue(env_NaviSD_POI_List_AH) || getValue(env_NaviSD_POI_List_AHD)) // ArrayHeader (+ Data)
        {


                    /***Startelement=0***/
                    if(0==startelement) //Startelement-ID =0 -> start at first array-entry
                    {
                        if(FORWARD==direction)  //forward-start
                        {
                            valid_startelement =0;                                                           

                            if(NAV_POILIST_ENTRIES <=elements) //1. more elements requested, than in array
                            {
                                if (shift ==FALSE)  
                                {
                                    for(i=0;i<NAV_POILIST_ENTRIES;i++)
                                    {
                                        if(0 !=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;

                                            valid_elements++;                                //increment elements
                                        }    
                
                                        else                                                //no valid element, loop finished
                                            i =NAV_POILIST_ENTRIES;
                                    }
                                }
                                else
                                {   
                                    valid_startelement  =startelement;
                                    valid_elements      =0;
                                }
                            }
                            else    //2. number of requested elements < elements in array
                            {
                                if (shift ==FALSE)
                                {
                                    for(i=0;i<elements;i++)
                                    {
                                        if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;
                                            
                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i =NAV_POILIST_ENTRIES;
                                    }
                                }
                                else
                                {
                                    valid_startelement  =startelement;
                                    valid_elements      =0;
                                }
                            }
                        }                                                               //forward ends

                        else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
                        {   
                            //searching for valid startelement
                            for(i=(NAV_POILIST_ENTRIES-1);i>=0;i--)
                            {
                                if(0!=gPOIList_ListEntryValidInformation[i])        //found valid startelement
                                {
                                    valid_startelement =i;                                
                                    i =0;                                                
                                }
                            }
                        
                            //searching for valid elements
                            if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                            {
                                valid_startelement  =startelement;
                                valid_elements      =0;
                            }
                            else if(0==valid_startelement)                                
                                valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                            else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                            {
                                for(i=valid_startelement;i>=0;i--)
                                {
                                    if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                    {
                                        if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;
                                     
                                        valid_elements++;                                //increment elements
                                    }
                                    else                                                //no valid element, loop finished
                                        i=0;
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for(i=valid_startelement;i>(valid_startelement-elements);i--)
                                {
                                    if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                    {
                                        valid_elements++;                                //increment elements
                                        
                                        if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;
                                    }
                                    else                                                //no valid element, loop finished
                                        i=0;
                                }                 
                            }                                                            
                        }                                                               //backward-end
                    }                                                                   //startelement ==0 -end

                    /***Startelement!=0***/
                    else                                                                //searching for Startelement-ID                
                    {
                        //searching for valid startelement
                        for(i=0;i<NAV_POILIST_ENTRIES;i++)
                        {
                            if(gPOIList_Pos[i] ==startelement)                        //found a valid element
                            {                                          
                                if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                                {
                                    if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                                        valid_startelement =i+1-2*direction;
                                                            
                                    else if(i==0 && BACKWARD==direction) 
                                        valid_startelement =gPOIListLine_sum;     //valid element is last element in Array                                                
                            
                                    else if(i==0 && FORWARD==direction) 
                                        valid_startelement =0;                          //valid element is first element in Array
                                }
                    
                                else
                                    valid_startelement =i;                              //found element is valid_startelement

                                i=NAV_POILIST_ENTRIES;
                            }
                        }

                        if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
                        {
                            valid_startelement  =startelement;
                            valid_elements      =0;
                        }
                        else                                                                //found valid entry for startelement in array
                        {
                            //verify number of valid elements
                            if(BACKWARD==direction)                                            //backward-start
                            {
                                if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                                    valid_elements=1;
                            
                                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                                {
                                    for(i=valid_startelement;i>=0;i--)
                                    {
                                        if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                                else                                                        //enougth array-elements available
                                {
                                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                                    {
                                        if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i=0;
                                    }
                                }
                            }                                                                //backward-end
                            else                                                            //forward-start
                            {
                                if((valid_startelement+elements)>=NAV_POILIST_ENTRIES)
                                {
                                    for(i=valid_startelement;i<NAV_POILIST_ENTRIES;i++)
                                    {   
                                        if(0!=gPOIList_Pos[i])                            //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                    //no valid element, loop finished
                                            i=NAV_POILIST_ENTRIES;
                                    }
                                }
                                else
                                {
                                    for(i=valid_startelement;i<(valid_startelement+elements);i++)
                                    {
                                        if(0!=gPOIList_Pos[i])                            //if there is an valid element
                                        {
                                            if(gPOIList_Pos[i] >0xff)
                                                indexsize =TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i=NAV_POILIST_ENTRIES;
                                    }
                                }
                            }
                        } //END: if(BACKWARD==direction)    
                    } //END: if(0==startelement)
                
                    transmitpos =TRUE;
                    if((requested_startelement >0xFF) || (valid_startelement >0xFF))
                        indexsize =TRUE;
                    
                    mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
                    //send StatusArray
                    POIList_Request(Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);   
            } // END: if(getvalue(env_NaviSD_AL_CA_switch))

        }//END: if(gNaviSD_PowerOnOff==POWER_ON && getValue(env_NaviSD_POI_List_CangedArray)

}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POI_List_StatusArray
{
    word requested_startelement, startelement, elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
    //MR 76047
    int i, transSuppression;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;
    //MR 76047
    transSuppression        = getvalue(env_NaviSD_POIList_StatusOFF);

    if(gNaviSD_PowerOnOff==POWER_ON && getValue(env_NaviSD_POI_List_StatusArray))
    {
        if(getValue(env_NaviSD_POI_List_start) >255 && getValue(env_NaviSD_POI_List_index) ==1)// check if 8 or 16 bit
            putValue(env_NaviSD_POI_List_index,1);

        //get data from Panel
        gPOIList_ASGID                 =getValue(env_NaviSD_POI_List_ASG_IDhex);
        gPOIList_TAID                  =getValue(env_NaviSD_POI_List_TAID);
        
        //MR 63332 #3   02.07.2014
        //gPOIList_TotalNumListElements  =getValue(env_NaviSD_POI_List_TNLE);
 
        recordaddress   =getValue(env_NaviSD_POI_List_RecordAdd);
        shift           =getValue(env_NaviSD_POI_List_shift);
        direction       =getValue(env_NaviSD_POI_List_direction);
        transmitpos     =getValue(env_NaviSD_POI_List_transmitPos);
        indexsize       =getValue(env_NaviSD_POI_List_index);
        startelement    =getValue(env_NaviSD_POI_List_start);
        elements        =getValue(env_NaviSD_POI_List_elements);

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;
        
        requested_startelement =startelement;


        /***Startelement=0***/
        if(0==startelement) //Startelement-ID =0 -> start at first array-entry
        {
            if(FORWARD==direction)  //forward-start
            {
                valid_startelement =0;                                                           

                if(NAV_POILIST_ENTRIES <=elements) //1. more elements requested, than in array
                {
                    if (shift ==FALSE)  
                    {
                        for(i=0;i<NAV_POILIST_ENTRIES;i++)
                        {
                            if(0 !=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i =NAV_POILIST_ENTRIES;
                        }
                    }
                    else 
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if (shift ==FALSE)
                    {
                        for(i=0;i<elements;i++)
                        {
                            if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i =NAV_POILIST_ENTRIES;
                        }
                    }
                    else 
                    {   
                        valid_startelement  =startelement;
                        valid_elements      =0;
                    }
                }
            }                                                               //forward ends
            
            else if(BACKWARD==direction && TRUE==shift)                        //backward-start, only if the shift bit is set (this means starting with the last element of the array)
            {   
                //searching for valid startelement
                for(i=(NAV_POILIST_ENTRIES-1);i>=0;i--)
                {
                    if(0!=gPOIList_ListEntryValidInformation[i])        //found valid startelement
                    {
                        valid_startelement =i;                                
                        i =0;                                                
                    }
                }
                        
                //searching for valid elements
                if(0xff==valid_startelement)                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  =startelement;
                    valid_elements      =0;
                }
                else if(0==valid_startelement)                                
                    valid_elements=1;                                       //only 1 element because valid startelement is on position 0    
                        
                else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for(i=valid_startelement;i>=0;i--)
                    {
                        if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for(i=valid_startelement;i>(valid_startelement-elements);i--)
                    {
                        if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i=0;
                    }                   
                }                                                            
            }                                                               //backward-end
        }                                                                   //startelement ==0 -end

        /***Startelement!=0***/
        else                                                                //searching for Startelement-ID                
        {
            //searching for valid startelement
            for(i=0;i<NAV_POILIST_ENTRIES;i++)
            {
                if(gPOIList_Pos[i] ==startelement)                        //found a valid element
                {                                       
                    if(shift==TRUE)                                            //shift ist set, this means starting with the next/previous element (depending on the direction-setting)
                    {
                        if(i!=0 || BACKWARD!=direction)                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement =i+1-2*direction;
                                                            
                        else if(i==0 && BACKWARD==direction) 
                            valid_startelement =gPOIListLine_sum;     //valid element is last element in Array                                                
                            
                        else if(i==0 && FORWARD==direction) 
                            valid_startelement =0;                          //valid element is first element in Array
                    }
                    
                    else
                        valid_startelement =i;                              //found element is valid_startelement

                    i =NAV_POILIST_ENTRIES;
                }
                else
                    valid_startelement =0xff;
            }

            if(0xff==valid_startelement)                                        //Startelement-ID doesn't exist in array
            {   
                valid_startelement  =startelement;
                valid_elements      =0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if(BACKWARD==direction)                                            //backward-start
                {
                    if(valid_startelement==0)                                    //only 1 element because valid startelement is on position 0
                        valid_elements=1;
                            
                    else if(elements>(valid_startelement+1))                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for(i=valid_startelement;i>=0;i--)
                        {
                            if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for(i=valid_startelement;i>(valid_startelement-elements);i--)
                        {
                            if(0!=gPOIList_ListEntryValidInformation[i])    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements)>=NAV_POILIST_ENTRIES)
                    {
                        for(i=valid_startelement;i<NAV_POILIST_ENTRIES;i++)
                        {
                            if(0!=gPOIList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_POILIST_ENTRIES;
                        }
                    }
                    else
                    {
                        for(i=valid_startelement;i<(valid_startelement+elements);i++)
                        {
                            if(0!=gPOIList_Pos[i])                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i=NAV_POILIST_ENTRIES;
                        }
                    }
                }
            }
        }
        putValue(env_NaviSD_POI_List_elements,valid_elements);
        //send StatusArray
        //writeEX(gBAP_Trace, 0, "StatusArray_valid_elements %x",valid_elements); //debug
    //VAGH-10511
    if(!transSuppression)
        POIList_Request(Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0);   
}


}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POI_List_CSV_Load
{

    if(getValue(env_NaviSD_POI_List_CSV_Load))
    {
        if (getValue(env_NaviSD_POI_List_DataSource))
        {
            POIList_init_CSV();
            }
    }
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POI_List_ASG_ID
{
    if(getValue(env_NaviSD_POI_List_ASG_ID) <1 || !tempDI)
       gID_POIact = getValue(env_NaviSD_POI_List_ASG_ID);
    if(getValue(env_NaviSD_POI_List_ASG_ID) ==9 || !tempDI)
    {
       gID_POIact = getValue(env_NaviSD_POI_List_ASG_ID);
       tempID =0;
    }
    if(getValue(env_NaviSD_POI_List_ASG_IDhex) != gID_POIact)
        putValue(env_NaviSD_POI_List_ASG_IDhex,getValue(env_NaviSD_POI_List_ASG_ID));
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POI_List_ASG_IDhex
{
    if(getValue(env_NaviSD_POI_List_ASG_IDhex) >1 && getValue(env_NaviSD_POI_List_ASG_IDhex) != 9)
       {
        gID_POIact =getValue(env_NaviSD_POI_List_ASG_IDhex);
        tempID =1;
        putValue(env_NaviSD_POI_List_ASG_ID,9);
       }
       else
       {
        if(getValue(env_NaviSD_POI_List_ASG_IDhex) != gID_POIact)
            putValue(env_NaviSD_POI_List_ASG_ID,getValue(env_NaviSD_POI_List_ASG_IDhex));
       }
}

//IssueList #216 15S1 update 17.01.2014
on envVar env_NaviSD_POI_List_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;
    
    // Init local variables. 
    mode                    =0;
    shift                   =0;
    direction               =0;
    transmitpos             =0;
    indexsize               =0;
    recordaddress           =0;
    requested_startelement  =0;
    startelement            =0;
    elements                =0;
    valid_startelement      =0;
    i                       =0;
    valid_elements          =0;

    if(gNaviSD_PowerOnOff==POWER_ON && getValue(env_NaviSD_POI_List_FRU))
    {
        recordaddress   =0;
        shift           =0;
        direction       =0;
        transmitpos     =0;
        indexsize       =0;
        startelement    =0;
        elements        =65535;
        
        //MR 63332 #2 02.07.2014
        /*
        putValue(env_NaviSD_POI_List_RecordAdd,recordaddress);
        putValue(env_NaviSD_POI_List_shift,shift);
        if(!shift)
            putValue(env_NaviSD_POI_List_shift,1);
        putValue(env_NaviSD_POI_List_direction,direction);
        if(!direction)
            putValue(env_NaviSD_POI_List_direction, 1);
        putValue(env_NaviSD_POI_List_transmitPos,transmitpos);
        if(!transmitpos)
            putValue(env_NaviSD_POI_List_transmitPos,1);
        putValue(env_NaviSD_POI_List_index, indexsize);
        putValue(env_NaviSD_POI_List_start, startelement);
        putValue(env_NaviSD_POI_List_elements, elements);
        */

        mode            =shift +(direction*0x02) +(transmitpos*0x04) +indexsize*0x08;

        //send ChangedArray
        POIList_Request(Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0);
    }
}

on envVar env_NaviSD_MapVAO_Status
{
{
if(getValue(env_NaviSD_MapVAO_Status))
    //Request_MapViewAndOrient(Data_REQ,0); 
    MapViewAndOrientation_Request(Data_REQ,0);
}
}

on envVar env_NaviSD_MapS_Status
{
if(getValue(env_NaviSD_MapS_Status))
    //Request_MapScale(Data_REQ,0); 
    MapScale_Request(Data_REQ,0); 
}

on envVar env_NaviSD_DestInfo_Status
{
if(getValue(env_NaviSD_DestInfo_Status))
    //Request_DestinationInfo(Data_REQ,0); 
    DestinationInfo_Request(Data_REQ,0); 
}

on envVar env_NaviSD_SemidRG_Status
{
if(getValue(env_NaviSD_SemidRG_Status))
    //Request_SemiDynRouGuidance(Data_REQ,0); 
    SemidynamicRouteGuidance_Request(Data_REQ,0); 
}

on envVar env_NaviSD_MapCAT_Status
{
if(getValue(env_NaviSD_MapCAT_Status))
    MapColorAndType_Request(Data_REQ,0); 
}

on envVar env_NaviSD_MapCAT_Color
{
    if(getValue(env_NaviSD_MapCAT_Color) <3 || !temp1)
       gMCAT_Cact = getValue(env_NaviSD_MapCAT_Color);
    temp1 =0;
    if(getValue(env_NaviSD_MapCAT_ColorHex) != gMCAT_Cact)
        putValue(env_NaviSD_MapCAT_ColorHex,getValue(env_NaviSD_MapCAT_Color));
}

on envVar env_NaviSD_MapCAT_ColorHex
{
    if(getValue(env_NaviSD_MapCAT_ColorHex) >3)
       {
        gMCAT_Cact =getValue(env_NaviSD_MapCAT_ColorHex);
        temp1 =1;
        putValue(env_NaviSD_MapCAT_Color,3);
       }
       else
       {
        if(getValue(env_NaviSD_MapCAT_ColorHex) != gMCAT_Cact)
            putValue(env_NaviSD_MapCAT_Color,getValue(env_NaviSD_MapCAT_ColorHex));
       }
}

on envVar env_NaviSD_MapCAT_AMT
{
    if(getValue(env_NaviSD_MapCAT_AMT) <5 || !temp2)
       gMCAT_AMTact = getValue(env_NaviSD_MapCAT_AMT);
    temp2 =0;
    if(getValue(env_NaviSD_MapCAT_AMTHex) != gMCAT_AMTact)
        putValue(env_NaviSD_MapCAT_AMTHex,getValue(env_NaviSD_MapCAT_AMT));
}

on envVar env_NaviSD_MapCAT_AMTHex
{
    if(getValue(env_NaviSD_MapCAT_AMTHex) >5)
       {
        gMCAT_AMTact =getValue(env_NaviSD_MapCAT_AMTHex);
        temp2 =1;
        putValue(env_NaviSD_MapCAT_AMT,5);
       }
       else
       {
        if(getValue(env_NaviSD_MapCAT_AMTHex) != gMCAT_AMTact)
            putValue(env_NaviSD_MapCAT_AMT,getValue(env_NaviSD_MapCAT_AMTHex));
       }
}

on envVar env_NaviSD_MapCAT_MMS
{
    if(getValue(env_NaviSD_MapCAT_MMS) <3 || !temp3)
       gMCAT_MMSact = getValue(env_NaviSD_MapCAT_MMS);
    if(getValue(env_NaviSD_MapCAT_MMS) ==255 || !temp3)
       gMCAT_MMSact = getValue(env_NaviSD_MapCAT_MMS);
       temp3 =0;
    if(getValue(env_NaviSD_MapCAT_MMSHex) != gMCAT_MMSact)
        putValue(env_NaviSD_MapCAT_MMSHex,getValue(env_NaviSD_MapCAT_MMS));
}

on envVar env_NaviSD_MapCAT_MMSHex
{
    if(getValue(env_NaviSD_MapCAT_MMSHex) >3 && getValue(env_NaviSD_MapCAT_MMSHex) != 255)
       {
        gMCAT_MMSact =getValue(env_NaviSD_MapCAT_MMSHex);
        temp3 =1;
        putValue(env_NaviSD_MapCAT_MMS,3);
       }
       else
       {
        if(getValue(env_NaviSD_MapCAT_MMSHex) != gMCAT_MMSact)
            putValue(env_NaviSD_MapCAT_MMS,getValue(env_NaviSD_MapCAT_MMSHex));
       }
}

on envVar env_NaviSD_MapVAO_MapV
{
    if(getValue(env_NaviSD_MapVAO_MapV) <3 || !tempMVAO_1)
    {
       gMVAO_MVact = getValue(env_NaviSD_MapVAO_MapV);
    tempMVAO_1 =0;
    }
    if(getValue(env_NaviSD_MapVAO_MapVHex) != gMVAO_MVact)
        putValue(env_NaviSD_MapVAO_MapVHex,getValue(env_NaviSD_MapVAO_MapV));
}

on envVar env_NaviSD_MapVAO_MapVHex
{
    if(getValue(env_NaviSD_MapVAO_MapVHex) >3)
       {
        gMVAO_MVact =getValue(env_NaviSD_MapVAO_MapVHex);
        tempMVAO_1 =1;
        putValue(env_NaviSD_MapVAO_MapV,3);
       }
       else
       {
        if(getValue(env_NaviSD_MapVAO_MapVHex) != gMVAO_MVact)
            putValue(env_NaviSD_MapVAO_MapV,getValue(env_NaviSD_MapVAO_MapVHex));
       }
}

on envVar env_NaviSD_MapVAO_SMV
{
    if(getValue(env_NaviSD_MapVAO_SMV) <4 || !tempMVAO_2)
       gMVAO_SMVact = getValue(env_NaviSD_MapVAO_SMV);
    tempMVAO_2 =0;
    if(getValue(env_NaviSD_MapVAO_SMVHex) != gMVAO_SMVact)
        putValue(env_NaviSD_MapVAO_SMVHex,getValue(env_NaviSD_MapVAO_SMV));
}

on envVar env_NaviSD_MapVAO_SMVHex
{
    if(getValue(env_NaviSD_MapVAO_SMVHex) >4)
       {
        gMVAO_SMVact =getValue(env_NaviSD_MapVAO_SMVHex);
        tempMVAO_2 =1;
        putValue(env_NaviSD_MapVAO_SMV,4);
       }
       else
       {
        if(getValue(env_NaviSD_MapVAO_SMVHex) != gMVAO_SMVact)
            putValue(env_NaviSD_MapVAO_SMV,getValue(env_NaviSD_MapVAO_SMVHex));
       }
}

on envVar env_NaviSD_MapVAO_MO
{
    if(getValue(env_NaviSD_MapVAO_MO) <3 || !tempMVAO_3)
       gMVAO_MOact = getValue(env_NaviSD_MapVAO_MO);
    tempMVAO_3 =0;
    if(getValue(env_NaviSD_MapVAO_MOHex) != gMVAO_MOact)
        putValue(env_NaviSD_MapVAO_MOHex,getValue(env_NaviSD_MapVAO_MO));
}

on envVar env_NaviSD_MapVAO_MOHex
{
    if(getValue(env_NaviSD_MapVAO_MOHex) >3)
       {
        gMVAO_MOact =getValue(env_NaviSD_MapVAO_MOHex);
        tempMVAO_3 =1;
        putValue(env_NaviSD_MapVAO_MO,3);
       }
       else
       {
        if(getValue(env_NaviSD_MapVAO_MOHex) != gMVAO_MOact)
            putValue(env_NaviSD_MapVAO_MO,getValue(env_NaviSD_MapVAO_MOHex));
       }
}

on envVar env_NaviSD_MapS_Unit
{
    if(getValue(env_NaviSD_MapS_Unit) <8 || !tempMS_1)
       gMS_unitact = getValue(env_NaviSD_MapS_Unit);
    else if(getValue(env_NaviSD_MapS_Unit) ==255 || !tempMS_1)
       gMS_unitact = getValue(env_NaviSD_MapS_Unit);

       tempMS_1 =0;
    if(getValue(env_NaviSD_MapS_UnitHex) != gMS_unitact)
        putValue(env_NaviSD_MapS_UnitHex,getValue(env_NaviSD_MapS_Unit));

}

on envVar env_NaviSD_MapS_UnitHex
{

    if(getValue(env_NaviSD_MapS_UnitHex) >8 && getValue(env_NaviSD_MapS_UnitHex) != 255)
       {
        gMS_unitact =getValue(env_NaviSD_MapS_UnitHex);
        tempMS_1 =1;
        putValue(env_NaviSD_MapS_Unit,8);
       }
       else
       {
        if(getValue(env_NaviSD_MapS_UnitHex) != gMS_unitact)
            putValue(env_NaviSD_MapS_Unit,getValue(env_NaviSD_MapS_UnitHex));
       }

}

on envVar env_NaviSD_MapS_AutoZoom
{

    if(getValue(env_NaviSD_MapS_AutoZoom) <3 || !tempMS_2)
       gMS_AZact = getValue(env_NaviSD_MapS_AutoZoom);
    else if(getValue(env_NaviSD_MapS_AutoZoom) ==15 || !tempMS_2)
       gMS_AZact = getValue(env_NaviSD_MapS_AutoZoom);
       tempMS_2 =0;
    if(getValue(env_NaviSD_MapS_AutoZoomHex) != gMS_AZact)
        putValue(env_NaviSD_MapS_AutoZoomHex,getValue(env_NaviSD_MapS_AutoZoom));


}

on envVar env_NaviSD_MapS_AutoZoomHex
{

    if(getValue(env_NaviSD_MapS_AutoZoomHex) >3 && getValue(env_NaviSD_MapS_AutoZoomHex) != 15)
       {
        gMS_AZact =getValue(env_NaviSD_MapS_AutoZoomHex);
        tempMS_2 =1;
        putValue(env_NaviSD_MapS_AutoZoom,3);
       }
       else
       {
        if(getValue(env_NaviSD_MapS_AutoZoomHex) != gMS_AZact)
            putValue(env_NaviSD_MapS_AutoZoom,getValue(env_NaviSD_MapS_AutoZoomHex));
       }
}

on envVar env_NaviSD_SemidRG_NewDTD_unit
{
    if(getValue(env_NaviSD_SemidRG_NewDTD_unit) <6 || !tempSDRG1)
       gSDRG_NDTD_Unitact = getValue(env_NaviSD_SemidRG_NewDTD_unit);

    else if(getValue(env_NaviSD_SemidRG_NewDTD_unit) ==255 || !tempSDRG1)
       gSDRG_NDTD_Unitact = getValue(env_NaviSD_SemidRG_NewDTD_unit);
       tempSDRG1 =0;

    if(getValue(env_NaviSD_SemidRG_NewDTD_unitH) != gSDRG_NDTD_Unitact)
        putValue(env_NaviSD_SemidRG_NewDTD_unitH,getValue(env_NaviSD_SemidRG_NewDTD_unit));
}

on envVar env_NaviSD_SemidRG_NewDTD_unitH
{
    if(getValue(this) >6 && getValue(this) != 255)
       {
        gSDRG_NDTD_Unitact =getValue(this);
        tempSDRG1 =1;
        putValue(env_NaviSD_SemidRG_NewDTD_unit,6);
       }
       else
       {
        if(getValue(this) != gSDRG_NDTD_Unitact)
            putValue(env_NaviSD_SemidRG_NewDTD_unit,getValue(this));
       }
}

on envVar env_NaviSD_SemidRG_NewDTD_typeOD
{
    if(getValue(env_NaviSD_SemidRG_NewDTD_typeOD) <2 || !tempSDRG2)
       gSDRG_NDTD_TyODact = getValue(env_NaviSD_SemidRG_NewDTD_typeOD);

    else if(getValue(env_NaviSD_SemidRG_NewDTD_typeOD) ==255 || !tempSDRG2)
       gSDRG_NDTD_TyODact = getValue(env_NaviSD_SemidRG_NewDTD_typeOD);
       tempSDRG2 =0;
    if(getValue(env_NaviSD_SemidRG_NewDTD_typeH) != gSDRG_NDTD_TyODact)
        putValue(env_NaviSD_SemidRG_NewDTD_typeH,getValue(env_NaviSD_SemidRG_NewDTD_typeOD));
}

on envVar env_NaviSD_SemidRG_NewDTD_typeH
{
    if(getValue(this) >2 && getValue(this) != 255)
       {
        gSDRG_NDTD_TyODact =getValue(this);
        tempSDRG2 =1;
        putValue(env_NaviSD_SemidRG_NewDTD_typeOD,2);
       }
       else
       {
        if(getValue(this) != gSDRG_NDTD_TyODact)
            putValue(env_NaviSD_SemidRG_NewDTD_typeOD,getValue(this));
       }

}

on envVar env_NaviSD_SemidRG_NewTTD_NTFHex
{
    if(getValue(env_NaviSD_SemidRG_NewTTD_NTFHex) >2)
       {
        gSDRG_NTTD_NTFact =getValue(env_NaviSD_SemidRG_NewTTD_NTFHex);
        tempSDRG3 =1;
        putValue(env_NaviSD_SemidRG_NewTTD_NTF,2);
       }
       else
       {
        if(getValue(env_NaviSD_SemidRG_NewTTD_NTFHex) != gSDRG_NTTD_NTFact)
            putValue(env_NaviSD_SemidRG_NewTTD_NTF,getValue(env_NaviSD_SemidRG_NewTTD_NTFHex));
       }
}

on envVar env_NaviSD_SemidRG_NewTTD_NTF
{
    if(getValue(env_NaviSD_SemidRG_NewTTD_NTF) <2 || !tempSDRG3)
       gSDRG_NTTD_NTFact = getValue(env_NaviSD_SemidRG_NewTTD_NTF);
    tempSDRG3 =0;
    if(getValue(env_NaviSD_SemidRG_NewTTD_NTFHex) != gSDRG_NTTD_NTFact)
        putValue(env_NaviSD_SemidRG_NewTTD_NTFHex,getValue(env_NaviSD_SemidRG_NewTTD_NTF));
}

on envVar env_NaviSD_SemidRG_NewTTD_TITHex
{
    if(getValue(this) >3 && getValue(this) != 15)
       {
        gSDRG_NTTD_TITact =getValue(this);
        tempSDRG4 =1;
        putValue(env_NaviSD_SemidRG_NewTTD_TIT,3);
       }
       else
       {
        if(getValue(this) != gSDRG_NTTD_TITact)
            putValue(env_NaviSD_SemidRG_NewTTD_TIT,getValue(this));
       }

}

on envVar env_NaviSD_SemidRG_NewTTD_TIT
{
    if(getValue(env_NaviSD_SemidRG_NewTTD_TIT) <3 || !tempSDRG4)
       gSDRG_NTTD_TITact = getValue(env_NaviSD_SemidRG_NewTTD_TIT);
    else if(getValue(env_NaviSD_SemidRG_NewTTD_TIT) ==15 || !tempSDRG4)
       gSDRG_NTTD_TITact = getValue(env_NaviSD_SemidRG_NewTTD_TIT);
       tempSDRG4 =0;
    if(getValue(env_NaviSD_SemidRG_NewTTD_TITHex) != gSDRG_NTTD_TITact)
        putValue(env_NaviSD_SemidRG_NewTTD_TITHex,getValue(env_NaviSD_SemidRG_NewTTD_TIT));
}

//IssueList #216 15S1 update 17.01.2014
POIList_init_CSV () //Byte & file selection
{   
    dword CSVfileHandle =0, ConfigFileHandle =0, i =0, j =0, Num_of_csv_byte =0, element =0, current_CSV_line =0, count1 =0, count2 =0;
    char buffer_string[NAV_BUFFERSIZE], Path_CSV[NAV_BUFFERSIZE], Path_Config[NAV_BUFFERSIZE];
    byte POIListLine =0, buffer_byte[NAV_BUFFERSIZE];
    char POIList_Pos_string [NAV_POILIST_ENTRIES][NAV_TEXTLENGTH];           //help value ->"POS" is stored in the ASCII(UTF-8) code in the *.csv   
    char POIList_POIType_string [NAV_POILIST_ENTRIES][NAV_TEXTLENGTH];       //help value ->"POIType" is stored in the ASCII(UTF-8) code in the *.csv
    char POIList_DirectionSym_string [NAV_POILIST_ENTRIES][NAV_TEXTLENGTH];           //help value ->"POIType" is stored in the ASCII(UTF-8) code in the *.csv        
    char POIList_DistanceTye_string[NAV_POILIST_ENTRIES][NAV_TEXTLENGTH];           //help value ->"POIType" is stored in the ASCII(UTF-8) code in the *.csv        
    char POIList_Distance_string[NAV_POILIST_ENTRIES][NAV_TEXTLENGTH];           //help value ->"POIType" is stored in the ASCII(UTF-8) code in the *.csv        
    char POIList_Unit_string[NAV_POILIST_ENTRIES][NAV_TEXTLENGTH];           //help value ->"POIType" is stored in the ASCII(UTF-8) code in the *.csv        
    int CSV_Name_Size = 0, stop =0;
    if(getValue(env_NaviSD_POI_List_DataSource)) //output data in write window "FSGPOIList"  
    {
        writeClear(gPOIList_writeWindow);
        writelineEx(gPOIList_writeWindow, 0,"*******External POIList_List*******");
        writelineEx(gPOIList_writeWindow, 0, "");
        writelineEx(gPOIList_writeWindow, 0, "**********************Start load new POIList_List**********************");   
     
        for(j=0;j<NAV_POILIST_ENTRIES;j++) //clear "POIList Array"
        {
            gPOIList_ListEntryValidInformation[j]  =FALSE;
            gPOIList_Pos[j]             =0;
            gPOIList_POIType[j]         =0;
            gPOIList_DirectionSymbolic[j]=0;
            gPOIList_DistanceType[j]    =0;
            gPOIList_Distance[j]        =0;
            gPOIList_Unit[j]            =0;
            for(i=0;i<NAV_POILIST_MAINDESCRIPTION_LENGTH;i++)
                gPOIList_MainDescription[j][i]=0;
            for(i=0;i<NAV_POILIST_STREET_LENGTH;i++)
                gPOIList_Street[j][i]=0;            
            for(i=0;i<NAV_POILIST_CITY_LENGTH;i++)
                gPOIList_City[j][i]=0;        
            for(i=0;i<NAV_POILIST_POSTALCODE_LENGTH;i++)
                gPOIList_PostalCode[j][i]=0;            
        }
        for(i=0;i<NAV_FILENAME_SIZE; i++) //clear "filename"
            gPOIList_CSV_filename[i] =0;       
        for(j=0;j<NAV_POILIST_ENTRIES; j++) //clear "buffer"
        {
            buffer_string[j]    =0;
            buffer_byte[j]      =0;

            for(i=0;i<NAV_TEXTLENGTH;i++) //clear help value
                POIList_Pos_string[j][i]       =0;
        }        
        for(i=0;i<NAV_BUFFERSIZE;i++)
            Path_CSV[i] =0;

            getvalue(env_NaviSD_POI_List_CSVPath, Path_CSV);
            
     //   while(putValue(env_NaviSD_POI_List_CSVPath[CSV_Name_Size] != 0x2E && getValue(env_NaviSD_POI_List_CSVPath[CSV_Name_Size+1] != 0x63 &&putValue(env_NaviSD_POI_List_CSVPath[CSV_Name_Size+2] != 0x73 && getValue(env_NaviSD_POI_List_CSVPath[CSV_Name_Size+3] != 0x76)
        /*while(!stop)
             {  
             if(getValue(env_NaviSD_POI_List_CSVPath)[CSV_Name_Size] == 0x2E && getValue(env_NaviSD_POI_List_CSVPath)[CSV_Name_Size+1] == 0x63 && getValue(env_NaviSD_POI_List_CSVPath)[CSV_Name_Size+2] == 0x73 && getValue(env_NaviSD_POI_List_CSVPath)[CSV_Name_Size+3] == 0x76) 
                {
                stop=1;
                CSV_Name_Size = CSV_Name_Size+4;
                }
             else
                CSV_Name_Size++;
             }
           // CSV_Name_Size =CSV_Name_Size + 3;
        for(i=0;i<CSV_Name_Size;i++)
            Path_CSV[i] = getValue(env_NaviSD_POI_List_CSVPath)[i];//get filename & path of *.csv-file from Panel   
            */  
        i =0; j =0; POIListLine =0; current_CSV_line =0; //reset values 
 //       write("complete path *.csv: %s", Path_CSV); //debug

        i =0;

        while (Path_CSV[i] !=0) //scan "path"
        {
            if(Path_CSV[i] ==0x5C) //count "/" to seperate later "path" & "filename" 
                count1++;                
            
            //write("Path[%d] of *.csv: %x",i, Path_CSV[i]); //debug
            i++;
        }  
         
        i =0; j =0; //reset values

        while (Path_CSV[i] !=0) //seperate "path" and "filename"
        {
            if(count2==count1) //get filename after last "\"
            {              
                gPOIList_CSV_filename[j] =Path_CSV[i];
                j++;

                Path_CSV[i] =0;              
            }

            if(Path_CSV[i]==0x5C) //count "\" to get filename after last "\"            
                count2++;
                               
            i++;
        }

        writelineEx(gPOIList_writeWindow, 0,"path of *.csv: %s", Path_CSV);        //output file path 
        write("CSV = %s",Path_CSV);
        write("filename = %s",gPOIList_CSV_filename);



        writelineEx(gPOIList_writeWindow, 0,"filename of *.csv: '%s'", gPOIList_CSV_filename);  //output filename 

   //     writelineEx(gPOIList_writeWindow, 0,"gPOIList_CSV_filename: %s", gPOIList_CSV_filename);        //debug
     //   for(i=0;i<CSV_Name_Size;i++)
    //        putValue(env_NaviSD_POI_List_CSVcurrent[i] = CSV_Name[i]; //output current loaded *.csv-file on panel
        putValue(env_NaviSD_POI_List_CSVcurrent, gPOIList_CSV_filename);
        setFilePath(Path_CSV, 0); //set path for *.csv file

        CSVfileHandle =openFileRead(gPOIList_CSV_filename,1); //open *.csv (binary-mode ->get the ASCII/UTF-8 code)        
        if (CSVfileHandle!=0) //*.csv file access successful
        {
            writelineEx(gPOIList_writeWindow, 0,"Dateizugriff auf '%s' erfolgreich", gPOIList_CSV_filename);    //output result  
            
            putValue(env_NaviSD_POI_List_CSVresult,"successful");   //output result on panel                      

            Num_of_csv_byte =fileGetBinaryBlock (buffer_byte, elcount(buffer_byte), CSVfileHandle);//get data from *.csv and store the total number of byte in *.csv-file
            write("Num_of_csv_byte =%d", Num_of_csv_byte);
            for (i=0; i<Num_of_csv_byte; i++) //copy data into "POIList"
            {     
                if (buffer_byte[i] !=0x3B) //read data if no ";" is detected
                {
                    if(buffer_byte[i] ==0x0D && buffer_byte[i+1] ==0x0A) //nextline in *.csv (next "record element" in POIList) -> "LF" and "CR" detected -> copy (transform string -> long) data from help values in global values
                    {
                        if(current_CSV_line>0 && POIListLine<NAV_POILIST_ENTRIES) //ignore first line in *.csv file
                        {   
                            writelineEx(gPOIList_writeWindow, 0, "");
                            writelineEx(gPOIList_writeWindow, 0,"*******Element %d*******",POIListLine);

                            //transform 'string' to 'long' for "POS", "POIType" and "POIType"
                            gPOIList_Pos[POIListLine]               =atol(POIList_Pos_string[POIListLine]);
                            gPOIList_POIType[POIListLine]           =atol(POIList_POIType_string[POIListLine]);
                            gPOIList_DirectionSymbolic[POIListLine] =atol(POIList_DirectionSym_string[POIListLine]);                        
                            gPOIList_DistanceType[POIListLine]      =atol(POIList_DistanceTye_string[POIListLine]);
                            gPOIList_Distance[POIListLine]          =atol(POIList_Distance_string[POIListLine]);
                            gPOIList_Unit[POIListLine]              =atol(POIList_Unit_string[POIListLine]);                        

                            writelineEx(gPOIList_writeWindow, 0,"*******Element %d*******",     POIListLine);        
                            writelineEx(gPOIList_writeWindow, 0,"Pos[%d]: 0x%x",                POIListLine, gPOIList_Pos[POIListLine]);                     
                            writelineEx(gPOIList_writeWindow, 0,"DirectionSymbolic[%d]: 0x%x",  POIListLine, gPOIList_DirectionSymbolic[POIListLine]);
                            writelineEx(gPOIList_writeWindow, 0,"POIType[%d]: 0x%x",            POIListLine, gPOIList_POIType[POIListLine]);
                            writelineEx(gPOIList_writeWindow, 0,"DistanceType[%d]: 0x%x",       POIListLine, gPOIList_DistanceType[POIListLine]);
                            writelineEx(gPOIList_writeWindow, 0,"Distance[%d]: %x",             POIListLine, gPOIList_Distance[POIListLine]);
                            writelineEx(gPOIList_writeWindow, 0,"Unit[%d]: 0x%x",               POIListLine, gPOIList_Unit[POIListLine]);
                            writelineEx(gPOIList_writeWindow, 0,"MainDescription[%d]: %s",      POIListLine, gPOIList_MainDescription[POIListLine]);
                            writelineEx(gPOIList_writeWindow, 0,"Street[%d]: %s",               POIListLine, gPOIList_Street[POIListLine]);
                            writelineEx(gPOIList_writeWindow, 0,"City[%d]: %s",                 POIListLine, gPOIList_City[POIListLine]);
                            writelineEx(gPOIList_writeWindow, 0,"PostalCode[%d]: %s",           POIListLine, gPOIList_PostalCode[POIListLine]);  
  
                            gPOIList_ListEntryValidInformation[POIListLine]  =TRUE;
                                                
                            POIListLine++; // -> next line in *.csv (next record element)
                        }

                        current_CSV_line++; //next line in *.csv file
                        element =0; //start at 'POS' (first record element of "array data")
                        j=0; //reset value
                    }
                      
                    else if(current_CSV_line>0 && POIListLine<NAV_POILIST_ENTRIES) //copy data from "buffer_byte" (data from *.csv file) in help values and "name" until end of line is not detected
                    {
                        switch (element)
                        {
                            case 0: //POS
                                    POIList_Pos_string[POIListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //Direction_Symbolic
                                    POIList_DirectionSym_string[POIListLine][j] =buffer_byte[i];                                   
                                    j++;
                             break;

                            case 2: //POI_Type
                                    POIList_POIType_string[POIListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;
                            case 3: //DistanceType
                                    POIList_DistanceTye_string[POIListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 4: //Distance
                                    POIList_Distance_string[POIListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;
                            
                            case 5: //Unit
                                    POIList_Unit_string[POIListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;

                            case 6: //MainDescription
                                    gPOIList_MainDescription[POIListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;


                            case 7: //Street
                                    gPOIList_Street[POIListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;


                            case 8: //City
                                    gPOIList_City[POIListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;


                            case 9: //PostalCode
                                    gPOIList_PostalCode[POIListLine][j] =buffer_byte[i];
                                    j++;                                
                             break;
                            default:
                             break;
                        }
                    }                               
                }
                               
                else  // ";" is detected ->next record element of "array data"
                {                                          
                    element++;
                    j=0; //reset value  
                }                                              
        
            }         
            
            gPOIList_TotalNumListElements =gPOIListLine_sum =POIListLine; //get "total number of list elements"
            putValue(env_NaviSD_POI_List_TNLE,gPOIList_TotalNumListElements);

            writelineEx(gPOIList_writeWindow, 0, "");

            writelineEx(gPOIList_writeWindow, 0,"Anzahl der Listenelemente: %d", gPOIListLine_sum); //output total number of list elements

            writelineEx(gPOIList_writeWindow, 0, "");

            if(fileClose (CSVfileHandle) !=0) //close *.csv file
                writelineEx(gPOIList_writeWindow, 0,"Datei '%s' geschlossen", gPOIList_CSV_filename); //output result
             
            else
                writelineEx(gPOIList_writeWindow, 0,"Fehler beim Schlieen der Datei '%s'", gPOIList_CSV_filename);//output result
        }

        else //*.csv file access not successful
        {
            writelineEx(gPOIList_writeWindow, 0,"Fehler beim Dateizugriff auf '%s'",gPOIList_CSV_filename); //output result
            
            putValue(env_NaviSD_POI_List_CSVresult,"not successful");  //output result
        }
    }
}

on envVar env_NaviSD_DestInfo_POI_TypeHex
{
    if(getValue(env_NaviSD_DestInfo_POI_TypeHex) >166 && getValue(env_NaviSD_DestInfo_POI_TypeHex) != 255)
       {
        gDI_POIact =getValue(env_NaviSD_DestInfo_POI_TypeHex);
        tempDI =1;
        putValue(env_NaviSD_DestInfo_POI_Type,66);
       }
       else
       {
        if(getValue(env_NaviSD_DestInfo_POI_TypeHex) != gDI_POIact)
            putValue(env_NaviSD_DestInfo_POI_Type,getValue(env_NaviSD_DestInfo_POI_TypeHex));
       }
}

on envVar env_NaviSD_Altitude_Unit
{
if(getValue(this) == 0 || getValue(this) == 1)
    {
       gAlt_modByBut =1;
    }
}

on envVar env_NaviSD_Altitude_Status
{
if(getValue(this))
    //Request_Altitude(Data_REQ,0); 
    Altitude_Request(Data_REQ,0); 
}

on envVar env_NaviSD_DestInfo_POI_Type
{
    if(getValue(env_NaviSD_DestInfo_POI_Type) <166 || !tempDI)
       gDI_POIact = getValue(env_NaviSD_DestInfo_POI_Type);

    else if(getValue(env_NaviSD_DestInfo_POI_Type) ==255 || !tempDI)
    {
       gDI_POIact = getValue(env_NaviSD_DestInfo_POI_Type);
       tempDI =0;
    }
    if(getValue(env_NaviSD_DestInfo_POI_TypeHex) != gDI_POIact)
        putValue(env_NaviSD_DestInfo_POI_TypeHex,getValue(this));
}

Request_ManeuverState(byte request, byte errorcode)
{
    int  i, tempReserved1, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;            //LSG-ID
    requestarray[1]=FctID_ManeuverState;//Fct.-ID
    requestarray[2]=request;            //request type

    switch(request)
    {
        case Data_REQ:        
            requestarray[3]= getvalue(env_NaviSD_ManeuverState_StateHex);
            requestarray[4]= 0; //Dummy 1
            requestarray[5]= 0; //Dummy 2
               requestarray[6]= 0; //Dummy 3

            set_status_requestbuffer (requestarray, 7, Bap_ByteSequence);
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
        //    set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD Request_Altitude: invalid request %d", request);
        break;
    }
}

Indication_ManeuverState (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataGet_IND:
                Request_ManeuverState(Data_REQ, 0);                       //send status
         break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD Indication_Altitude: invalid indication %d", Indication_array[2]);
         break;
    }
}

on envVar env_NaviSD_ManeuverState_State
{
write("env_NaviSD_ManeuverState_State - %d",getvalue(env_NaviSD_ManeuverState_State));
    if(getvalue(env_NaviSD_ManeuverState_State) <5 || !tempMS)
       gMS_StateAct = getvalue(env_NaviSD_ManeuverState_State);
    tempMS =0;
    if(getvalue(env_NaviSD_ManeuverState_StateHex) != gMS_StateAct)
        putvalue(env_NaviSD_ManeuverState_StateHex, getvalue(env_NaviSD_ManeuverState_State));
}

on envVar env_NaviSD_ManeuverState_StateHex
{
write("env_NaviSD_ManeuverState_StateHex - %d",getvalue(env_NaviSD_ManeuverState_StateHex));
    if(getvalue(env_NaviSD_ManeuverState_StateHex) >5)
       {
        gMS_StateAct = getvalue(env_NaviSD_ManeuverState_StateHex);
        tempMS =1;
        putvalue(env_NaviSD_ManeuverState_State, 5);
       }
       else
       {
        if(getvalue(env_NaviSD_ManeuverState_StateHex) != gMS_StateAct)
            putvalue(env_NaviSD_ManeuverState_State, getvalue(env_NaviSD_ManeuverState_StateHex));
       }
}

on envVar env_NaviSD_ManeuverState_update
{
write("env_NaviSD_ManeuverState_update - %d",getvalue(env_NaviSD_ManeuverState_update));
{
if(getvalue(env_NaviSD_ManeuverState_update))
    Request_ManeuverState(Data_REQ,0); 
}
}

/*on message BAP_Navigation_ASG_05
{
    int i, error;
    byte RX_Data[8];        //received CAN-DATA
    dword RX_Header[3];        //received CAN-Header

    RX_Header[0]=this.CAN; 
    RX_Header[1]=this.ID; 
    RX_Header[2]=this.DLC; // received length
    
    // extract CAN data                                                                        
    for (i=0; i<this.DLC; i++)                                                         
        RX_Data[i]=this.byte(i);          
            
    //send received CAN-data with CAN-header to BAP-DLL
    error =Bap170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    
    if(error !=0)
        write("FSG-NaviSD: BAP_CAN_SetRxData: %d", error);
}

on message BAP_Navigation_ASG_06
{
    int i, error;
    byte RX_Data[8];        //received CAN-DATA
    dword RX_Header[3];        //received CAN-Header

    RX_Header[0]=this.CAN; 
    RX_Header[1]=this.ID; 
    RX_Header[2]=this.DLC; // received length
    
    // extract CAN data                                                                        
    for (i=0; i<this.DLC; i++)                                                         
        RX_Data[i]=this.byte(i);          
            
    //send received CAN-data with CAN-header to BAP-DLL
    error =Bap170_CAN_SetRxDat(NODE_INDEX,RX_Header,RX_Data);    
    if(error !=0)
        write("FSG-NaviSD: BAP_CAN_SetRxData: %d", error);
}*/

Indication_ETC_Status (dword Indication_array [], int datalength)
{
    switch (Indication_array[2]) // indication
    {   
        case DataGet_IND:
            Request_ETC_Status(Data_REQ, 0);                       //send status
            break;
        default:
            writelineEx(gError_Trace, 0, "FSG_NaviSD Indication_DestinationInfo: invalid indication %d", Indication_array[2]);
         break;
    }
}

Request_ETC_Status (byte request, byte errorcode)
{
    int  i, Offset =0;
    dword requestarray [BAP_BUFFER_SIZE];

    // Init local variables. 
    for(i=0;i<BAP_BUFFER_SIZE;i++)
        requestarray [i]=0;

    // Handle request.
    requestarray[0]=LSG_NaviSD;            //LSG-ID
    requestarray[1]=FctID_ETC_Status;    //Fct.-ID
    requestarray[2]=request;            //request type

    switch(request)
    {
        case Data_REQ:                
            
            temp_CardStatus = getvalue(env_NaviSD_ETC_Status_CardStatus);
            temp_Extension1 = getvalue(env_NaviSD_ETC_Status_Extension1);

            requestarray[3] = temp_CardStatus;
            requestarray[4] = temp_Extension1;


            set_status_requestbuffer (requestarray, 5, Bap_ByteSequence);
        break;

        case Error_REQ:    
            requestarray[3] =errorcode;
            
            set_status_requestbuffer (requestarray, 4, Bap_Error);
        break;
        default:    
            writelineEx(gError_Trace, 0, "FSG_NaviSD Request_ETC_Status: invalid request %d", request);
        break;
    }
}

on envVar env_NaviSD_ETC_Status_Status
{
write("env_NaviSD_ETC_Status_Status - %d",getvalue(env_NaviSD_ETC_Status_Status));
write("env_NaviSD_ETC_Status_CardStatus - %d",getvalue(env_NaviSD_ETC_Status_CardStatus));
write("(env_NaviSD_LG_StatusOFF) - %d",getvalue(env_NaviSD_LG_StatusOFF));
write("(env_NaviSD_LDL_StatusOFF) - %d",getvalue(env_NaviSD_LDL_StatusOFF));
write("(env_NaviSD_FDL_StatusOFF) - %d",getvalue(env_NaviSD_FDL_StatusOFF));
write("(env_NaviSD_NB_StatusOFF) - %d",getvalue(env_NaviSD_NB_StatusOFF));
write("(env_NaviSD_AL_StatusOFF) - %d",getvalue(env_NaviSD_AL_StatusOFF));
write("(env_NaviSD_POIList_StatusOFF) - %d",getvalue(env_NaviSD_POIList_StatusOFF));
write("(env_NaviSD_FctList_0x37) - %d",getvalue(env_NaviSD_FctList_0x37));
write("(env_NaviSD_FctList_0x38) - %d",getvalue(env_NaviSD_FctList_0x38));
    if(getvalue(env_NaviSD_ETC_Status_Status))
        Request_ETC_Status(Data_REQ,0); 
}

on envVar env_NaviSD_ETC_Status_Extension1
{
write("env_NaviSD_ETC_Status_Extension1 - %d",getvalue(env_NaviSD_ETC_Status_Extension1));
    putValue(env_NaviSD_ETC_Status_Extension1_hex, getvalue(env_NaviSD_ETC_Status_Extension1));
}

on envVar env_NaviSD_ETC_Status_Extension1_hex
{
write("env_NaviSD_ETC_Status_Extension1_hex - %d",getvalue(env_NaviSD_ETC_Status_Extension1_hex));
    putValue(env_NaviSD_ETC_Status_Extension1, getvalue(env_NaviSD_ETC_Status_Extension1_hex));
}

