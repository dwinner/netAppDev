/*@!Encoding:1252*/
includes
{
    #include "..\..\_DLL\latest_BAP_DLL.cin"

    #include "FCatDefs.cin"
    #include "PicServerInterface.cin"
}

/********************************************************************************/
/*  Author:      Jonas Eduard Pagel                                             */
/*  Department:  IAV, VC-F-23                                                   */
/*  Email ( IAV): jonas.eduard.pagel@IAV.de                                      */
/*  Email (VW):  extern.jonas.eduard.pagel@Volkswagen.de                        */
/*  Phone:       + 49-5371-805-2920                                              */
/*  Mobil:       + 49 152 57952588                                               */
/*                                                                              */
/*  Substitute:  Christian Franz                                                */
/*  Department:  VW, EECF/1                                                     */
/*  Phone:       + 49-5361-9-42880                                               */
/*                                                                              */
/*  Purpose:     CANoe simulation for stand alone Navigation secondary Display    */
/********************************************************************************/

/* Global variables for the AudioSD CANoe BAP simulation */
variables
{
    dword gBAP_Trace;
    dword gError_Trace;
    byte boTraceStatus_ON = 0;

    const cPower_off = 0x00;
    const cPower_on  = 0x01;

    const cFALSE    = 0;
    const cTRUE     = 1;

    const REQUESTBUFFER_LINES   = 100;
    const BAP_BUFFER_SIZE       = 4000;

    char dbc_path[255] = "BAP\\_DBC\\BAP_only_MQB_MLBevo_v1.70.dbc";  //BAP_V9.04F.dbc";                //relative path for dbc-file
    //char xml_path[255] = "XML\\BAP_SW17_MIB2_Std_MQB_V1_81_F_mod.xml";           //relative path for xml-file
    char xml_path[255]  ="BAP\\AudioSD_P30DF48_v1.23_man\\XML\\BAP_SW18_MIB3_OI_CP_MQB_V1_00_F_mod.xml";         //relative path for xml-file

    int gBAP_Requestbuffer_status[REQUESTBUFFER_LINES];             //datalength
    int gBAP_Requestbuffer_BAPDataTyp[REQUESTBUFFER_LINES];         //data type

    dword gBAP_Indication[BAP_BUFFER_SIZE];                             //Bap-Indication-buffer
    dword gBAP_Request[REQUESTBUFFER_LINES] [BAP_BUFFER_SIZE];            //ringbuffer for BAP-Request

    int gwrite_requestbuffer_line = 0;                                  //next free position
    int gstatus_requestbuffer = 0;                                 //next position to send

    //Timers
    mstimer TaskTimer;                                                  //timer for BAP-Task
    mstimer Powerontimer;
    mstimer StartFSG_Timer;                                             //timer for start simulation FSG
    //IssueList #32
    msTimer Station_Handle_Timer;
    msTimer Station_Info_Timer;

    const gBAP_datalength_error = 0x41;

    // general values for readable code
    const FALSE             = 0;
    const TRUE              = 1;
    const NULL              = 0x00;
    const VALID             = 0x01;
    const INVALID           = 0x00;
    const FORWARD           = 0;
    const BACKWARD          = 1;
    char empty_string[3] = { 0, 0, 0 };

    char gstring_reserved[10] = "reserved";
    char gstring_defect[10] = "defect";
    char gstring_not_supported[20] = "not supported";
    char gstring_unknown[20] = "unknown";

    //BAP Data Type
    const Bap_Void              = 0;
    const Bap_UInt8             = 1;
    const Bap_UInt16            = 2;
    const Bap_UInt32            = 3;
    const Bap_ByteSequence      = 4;
    const Bap_Error             = 5;
    const Bap_Acknowledge       = 6;

    //BAP request types ( FSG)
    const Data_REQ          = 0x03;
    const DataAck           = 0x0A;
    const Changed_REQ       = 0x04;
    const Processing_REQ    = 0x08;
    const Result_REQ        = 0x09;
    const Invalid_REQ       = 0x1F;  // Interne Kennzeichnung fuer einen ungueltigen Request

    //eigene Error-Definition
    const Error_REQ= 0x55;


    //BAP indication types ( FSG)
    const DataSetGet_IND    = 0x06;
    const DataSet_IND       = 0x07;
    const DataGet_IND       = 0x08;
    const Acknowledge_Ind   = 0x09;
    const Processing_CNF    = 0x0A;
    const Start_IND         = 0x0B;
    const StartResult_IND   = 0x0C;
    const Abort_IND         = 0x0D;
    const Invalid_IND       = 0x1F;  // Interne Kennzeichnung fuer eine ungueltige Indication


    //eigene Error-Definition
    const Error_IND= 0x55;

    // node index and LSG-IDs
    dword NODE_INDEX;

    const LSG_AudioSD   = 0x31;
    const byte LSGID    = 49;
    char NODE_NAME[15]  = "AudioSD";

    // BAP and LSG-Version information ( these are not used, just informations; see XML-file for current definitions!)
    const BAP_VERSION_MAJOR = 0x03;
    const BAP_VERSION_MINOR = 0x01;
    const LSG_CLASS_1       = LSG_AudioSD;
    const LSG_SUBCLASS_1    = 0x00;
    const LSG_VERSION_MAJOR = 0x04;
    const LSG_VERSION_MINOR = 0x08;

    // BAP and BAL error codes
    const BAP_NO_ERROR               = 0x00;

    const BAP_BAL_OUT_OF_RANGE       = 0x41;
    const BAP_BAL_TEMP_NOT_AVAILABLE = 0x42;
    const BAP_BAL_MAX_DL_EXCEEDED    = 0x43;
    const BAP_BAL_UNIT_MISMATCH      = 0x44;

    // Error codes from BAP API ( refer to BAP manual)
    const BAP_ERR_OK = 0x00;

    // Function-IDs

    //common function-IDs
    const FctID_GetAll              = 0x01;
    const FctID_BAP_Config          = 0x02;
    const FctID_FunctionList        = 0x03;
    const FctID_HeartBeat           = 0x04;
    const FctID_FSG_Setup           = 0x0E;
    const FctID_FSG_OperationState  = 0x0F;

    // specific function-IDs
    const FctID_ActiveSource            = 0x10;
    const FctID_ActiveSourceName        = 0x11;
    const FctID_CurrentVolume           = 0x12;
    const FctID_Mute                    = 0x13;
    const FctID_SourceState             = 0x14;
    const FctID_CurrentStationInfo      = 0x15;
    const FctID_CurrentStation_Handle   = 0x16;
    const FctID_ReceptionList           = 0x17;
    const FctID_DedicatedAudioControl   = 0x18;
    const FctID_GeneralInfoSwitches     = 0x19;
    const FctID_TPMemoInfo              = 0x1A;
    const FctID_TPMemoList              = 0x1B;
    const FctID_AnnouncementInfo        = 0x1C;
    const FctID_AnnouncementEscape      = 0x1D;
    const FctID_InfoStates              = 0x1E;
    const FctID_ReceptionListType       = 0x1F;
    const FctID_SourceList              = 0x20;
    const FctID_RadioTV_PresetList      = 0x21;
    const FctID_SwitchSource            = 0x22;
    const FctID_MediaBrowser_FolderLevel= 0x23;
    const FctID_MediaBrowser            = 0x24;
    const FctID_MediaPath               = 0x25;
    const FctID_MediaBrowserControl     = 0x26;
    const FctID_MediaFileInfo           = 0x27;
    const FctID_PreferredList           = 0x28;
    const FctID_SDS_State               = 0x29;
    const FctID_FunctionSynchronisation = 0x2A;
    const FctID_ASG_Capabilities        = 0x2B;
    const FctID_GetNextListPos          = 0x2C;
    const FctID_SwitchRadioMedia        = 0x2D;
    const FctID_MediaImportState        = 0x2E;
    const FctID_CurrentVloumeExtended   = 0x2F;
    const FctID_CustomerDownloadState   = 0x30;
    const FctID_OnlineMusic_State       = 0x31;
    const FctID_CommonList              = 0x32;
    const FctID_SiriusAlertList         = 0x32;
    const FctID_CurrentStation_Handle2  = 0x33;
    const FctID_PlayPosition            = 0x34;
    const FctID_SDS_RecognizerState     = 0x35;
    const FctID_CurrentStationInfo2     = 0x36;
    const FctID_CurrentStation_Handle3  = 0x37;
    const FctID_LastStationList         = 0x38;
    const FctID_SiriusAlertInfo         = 0x39;
    const FctID_Picture                 = 0x3A;
    const FctID_FavoriteList            = 0x3B;
    const FctID_Station_Track_Switch    = 0x3C;
    // FSG specific global variables and consts.

    /***FunctionList***/
    byte gFunctionList[8] ={0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0};

    /***FSG-Setup***/
    byte gAudioSD_FSGSetup_maxVolume = 0;
    byte gAudioSD_FSGSetup_supportedVolumeTypes = 0;

    byte gAudioSD_FSGSetup_entertainmentVolume = FALSE;
    byte gAudioSD_FSGSetup_navigationVolume = FALSE;
    byte gAudioSD_FSGSetup_announcementVolume = FALSE;
    byte gAudioSD_FSGSetup_phoneVolume = FALSE;
    byte gAudioSD_FSGSetup_SDSVolume = FALSE;
    byte gAudioSD_FSGSetup_phoneRingVolume = FALSE;
    byte gAudioSD_FSGSetup_carParkingFader = FALSE;
    byte gAudioSD_FSGSetup_readMessageVolume = FALSE;

    byte gAudioSD_FSGSetup_ReceptionList_AutoUpdate = 0;

    byte gAudioSD_FSGSetup_FMReceptionList = FALSE;
    byte gAudioSD_FSGSetup_AMReceptionList = FALSE;
    byte gAudioSD_FSGSetup_DABReceptionList = FALSE;
    byte gAudioSD_FSGSetup_SDARSReceptionList = FALSE;
    byte gAudioSD_FSGSetup_AMLWReceptionList = FALSE;
    byte gAudioSD_FSGSetup_AMSWReceptionList = FALSE;
    byte gAudioSD_FSGSetup_TVDVBReceptionList = FALSE;
    byte gAudioSD_FSGSetup_ORReceptionList = FALSE;

    byte gAudioSD_FSGSetup_Setup_Extensions = 0;
    byte gAudioSD_FSGSetup_Setup_Extensions_DAB = FALSE;
    byte gAudioSD_FSGSetup_Setup_Extensions_CL = FALSE;
    byte gAudioSD_FSGSetup_Setup_Extensions_CA = FALSE;
    byte gAudioSD_FSGSetup_Setup_Extensions_SA = FALSE;
    byte gAudioSD_FSGSetup_Setup_Extensions_SAas = FALSE;

    /*** FSG-OperationState ***/
    const FSGOPERATIONSTATE_NORMALOPERATION = 0x00;
    const FSGOPERATIONSTATE_OFF             = 0x01;
    const FSGOPERATIONSTATE_INITIALIZING    = 0x03;
    const FSGOPERATIONSTATE_DEFECT          = 0x0F;

    byte gAudioSD_FSG_OperationState_OpState = FSGOPERATIONSTATE_OFF;

    const NO_ANIMATION_RUNNING_ON_FSG       = 0x00;
    const WELCOME_ANIMATION_RUNNING_ON_FSG  = 0x01;

    byte gAudioSD_FSG_OperationState_HMI_State = NO_ANIMATION_RUNNING_ON_FSG;

    /***activeSource ***/
    const ACTIVESOURCE_UNKNOWNSOURCE                = 0xFF;

    const ACTIVESOURCE_SOURCETYPE_FM                = 0x01;
    byte gAudioSD_activeSource_SourceType = 0;

    word gAudioSD_activeSource_SourceList_Reference = 0;

    const ACTIVESOURCE_INVALIDNUMBER                = 0xF;

    byte gAudioSD_activeSource_TypeOfNumber = 0;

    byte gAudioSD_activeSource_ListAvailable = 0;
    byte gAudioSD_activeSource_ListAvailable2 = 0;
    byte gAudioSD_activeSource_ReceptionList = 0;
    byte gAudioSD_activeSource_PresetList = 0;
    byte gAudioSD_activeSource_MediaBrowserList = 0;
    byte gAudioSD_activeSource_SiriusAlertList = 0;
    byte gAudioSD_activeSource_LastStationList = 0;
    byte gAudioSD_activeSource_FavoriteList = 0;

    const ACTIVESOURCE_LISTSTATE_COMPLETELY_LOADED  = 0x03;
    byte gAudioSD_activeSource_ListState = 0;

    byte gAudioSD_activeSource_Reserve = 0;
    byte gAudioSD_activeSource_Number = 0;

    /***activeSourceName ***/
    const ACTIVE_SOURCE_NAME_LENGTH = 61;
    char gAudioSD_activeSourceName[ACTIVE_SOURCE_NAME_LENGTH];

    /***currentVolume ***/
    byte gAudioSD_currentVolume_EntertainmentVolume = 0;
    byte gAudioSD_currentVolume_NavigationVolume = 0;
    byte gAudioSD_currentVolume_TaVolume = 0;
    byte gAudioSD_currentVolume_PhoneVolume = 0;
    byte gAudioSD_currentVolume_SDSVolume = 0;
    byte gAudioSD_currentVolume_ChangingVolumeType = 0;

    /***Mute ***/
    byte gAudioSD_Mute_MuteState = 0;
    byte gAudioSD_Mute_Entertainment = 0;
    byte gAudioSD_Mute_DAB = 0;
    byte gAudioSD_Mute_DVB = 0;
    byte gAudioSD_Mute_SDARS = 0;
    byte gAudioSD_Mute_IBOC = 0;
    byte gAudioSD_Mute_sync_IBOC = 0;
    byte gAudioSD_Mute_Phone = 0;
    byte gAudioSD_Mute_OnlineRadio = 0;
    /***SourceState ***/
    byte gAudioSD_SourceState_StateInfo = 0;

    char gAudioSD_SourceState_StateInfo_string[8][20] = {   "unknown",
                                                                          "scan",
                                                                          "mix",
                                                                          "repeat",
                                                            "repeat/mix",
                                                            "manual tuning",
                                                            "seek",
                                                            "play more like this"};
    byte gAudioSD_SourceState_Scope = 0;

    char gAudioSD_SourceState_Scope_string[9][40] ={   "unknown scope /any scope",
                                                        "file/track",
                                                        "device",
                                                        "medium",
                                                        "directory without subdirectories",
                                                        "directory with subdirectories",
                                                        "all directories /all folders",
                                                        "playlist",
                                                        "all playlists"};

    /***CurrentStationInfo***/
    const PRIMARYINFORMATION_TEXTLENGTH = 73;
    char gAudioSD_CSI_PrimaryInformation[PRIMARYINFORMATION_TEXTLENGTH];

    byte gAudioSD_CSI_PI_Type = 0;
    word gAudioSD_CSI_PIID = 0;

    const SECONDARYINFORMATION_TEXTLENGTH = 73;
    char gAudioSD_CSI_SecondaryInformation[SECONDARYINFORMATION_TEXTLENGTH];

    byte gAudioSD_CSI_SI_Type = 0;

    const TERTIARYINFORMATION_TEXTLENGTH = 73;
    char gAudioSD_CSI_TertiaryInformation[TERTIARYINFORMATION_TEXTLENGTH];

    byte gAudioSD_CSI_TI_Type = 0;

    const QUATERNARYINFORMATION_TEXTLENGTH = 73;
    char gAudioSD_CSI_QuarternaryInformation[QUATERNARYINFORMATION_TEXTLENGTH];

    byte gAudioSD_CSI_QI_Type = 0;

    byte gAudioSD_CSI_StationInfoSwitches = 0;

    byte gAudioSD_CSI_TATP = 0;
    byte gAudioSD_CSI_TMC = 0;
    byte gAudioSD_CSI_VICS = 0;
    byte gAudioSD_CSI_IBOC = 0;

    byte gAudioSD_CSI_StationProperties = 0;

    byte gAudioSD_CSI_StationProperties_DABlinked = 0;
    byte gAudioSD_CSI_StationProperties_IBOC = 0;
    byte gAudioSD_CSI_StationProperties_DABservice = 0;
    byte gAudioSD_CSI_StationProperties_OnlineServ = 0;

    word gAudioSD_CSI_ChannelID = 0;

    /***CurrentStation_Handle ***/
    word gAudioSD_CSIhandle_FSGhandle = 0;
    word gAudioSD_CSIhandle_FSGhandle_absolutePos = 0;
    byte gAudioSD_CSIhandle_PresetListRef = 0;
    byte gAudioSD_CSIhandle_PresetListabsolutePos = 0;
    word gAudioSD_CSIhandle_DABEnsembleHandle = 0;
    word gAudioSD_CSIhandle_DABEnsembleAbsPos = 0;

    /***GeneralInfoSwitches ***/
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches = 0;

    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA = 0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS = 0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic = 0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC = 0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS = 0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online = 0;
    byte gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB = 0;

    byte gAudioSD_GeneralInfoSwitches_Reserve = 0;

    byte gAudioSD_GeneralInfoSwitches_Modification = 0;

    byte gAudioSD_GeneralInfoSwitches_Modification_TPTA = 0;
    byte gAudioSD_GeneralInfoSwitches_Modification_RDS = 0;
    byte gAudioSD_GeneralInfoSwitches_Modification_JPtraffic = 0;
    byte gAudioSD_GeneralInfoSwitches_Modification_TMC = 0;
    byte gAudioSD_GeneralInfoSwitches_Modification_VICS = 0;
    byte gAudioSD_GeneralInfoSwitches_Modification_Online = 0;
    byte gAudioSD_GeneralInfoSwitches_Modification_DAB = 0;

    /***TPMemoInfo***/
    byte gAudioSD_TPMemoInfo_CurrentMsgNumber = 0;
    byte gAudioSD_TPMemoInfo_TotalMsgNumber = 0;
    byte gAudioSD_TPMemoInfo_hour = 0;
    byte gAudioSD_TPMemoInfo_minute = 0;

    const STATIONNAME_TEXTLENGTH = 49;
    char gAudioSD_TPMemoInfo_StationName[STATIONNAME_TEXTLENGTH];

    /***AnnouncementInfo***/
    const ANNOUNCEMENT_TYPE_NO_MESSAGE          = 0x00;
    byte gAudioSD_AnnouncementInfo_Type = 0;

    const ANNOUNCEMENT_STATIONNAME_TEXTLENGTH = 49;
    char gAudioSD_AnnouncementInfo_StationName[ANNOUNCEMENT_STATIONNAME_TEXTLENGTH];

    /***InfoStates ***/
    mstimer InfoStates_Start_Timer;
    byte gAudioSD_InfoStates_States = 0;

    /***ReceptionListType ***/
    byte gAudioSD_ReceptionListType_Type = 0;

    /***MediaBrowser_FolderLevel***/
    byte gAudioSD_MediaBrowser_FL_FolderLevel = 0;
    word gAudioSD_MediaBrowser_FL_RefMediaBrowser = 0;
    word gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos = 0;

    /***MediaPath***/
    byte gAudioSD_MediaPath_FolderType = 0;

    const MEDIAPATH_PATH_TEXTLENGTH = 152;
    char gAudioSD_MediaPath_Path[MEDIAPATH_PATH_TEXTLENGTH];

    /***PreferredList***/
    const PREFERRED_DEST_LIST_RECEPTION_LIST    = 0x01;
    byte gAudioSD_PreferredList_List = 0;

    /***SDS_State ***/
    byte gAudioSD_SDSState_State = 0;

    /***FunctionSynchronisation ***/
    byte gAudioSD_FunctionSynchronisation_FctList[8];

    byte gAudioSD_FunctionSynchronisation_FctList_Bit16;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit17;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit18;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit19;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit20;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit21;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit22;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit23;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit24;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit25;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit26;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit27;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit28;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit29;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit30;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit31;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit32;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit33;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit34;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit35;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit36;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit37;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit38;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit39;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit40;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit41;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit42;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit43;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit44;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit45;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit46;
    byte gAudioSD_FunctionSynchronisation_FctList_Bit47;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit00;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit01;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit02;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit03;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit04;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit05;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit06;
    byte gAudioSD_FunctionSynchronisation_FctList_2_Bit07;
    byte gAudioSD_FunctionSynchronisation_FctList_3_Bit00;
    byte gAudioSD_FunctionSynchronisation_FctList_3_Bit01;
    byte gAudioSD_FunctionSynchronisation_FctList_3_Bit02;
    byte gAudioSD_FunctionSynchronisation_FctList_3_Bit03;
    byte gAudioSD_FunctionSynchronisation_FctList_3_Bit04;

    /***ASG_Capabilities ***/
    byte gAudioSD_ASGCapabilities_PresentationCapabilities = 0;
    byte gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 = 0;

    char gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0_string[2][20] = {   "DAB short",
                                                                                   "DAB long"};
    byte gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 = 0;

    char gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1_string[2][20] = {   "SDARS short",
                                                                                   "SDARS long"};

    /***MediaImportState ***/
    byte gMIS_STact = 0;
    byte temp1 = 0;

    /***MediaImportState ***/
    byte gCVE_CVTact = 0;
    byte temp2 = 0;

    /***CustomerDownloadState ***/
    byte gCDS_Sact = 0;
    byte temp3 = 0;

    /***OnlineMusic_State ***/
    byte gOMS_Sact = 0;
    byte temp4 = 0;

    //Metods
    /***DedicatedAudioControl***/
    mstimer DAC_Timer;
    mstimer DAC_MethodHandling_Timer;
    word gAudioSD_DAC_TimerTime = 150;
    word gAudioSD_DAC_MethodHandling_Time = 100;
    byte gAudioSD_DAC_MethodHandling = 0;

    byte gAudioSD_DAC_Reserve = 0;
    byte gAudioSD_DAC_status = 0;                   //flag for status of the method ( 0 =not activ, 1 =activ)

    word gAudioSD_DAC_FSGHandle = 0;

    byte gAudioSD_DAC_Result = 0;
    const AUDIO_DAC_SUCCESSFUL          = 0x00;
    const AUDIO_DAC_NOTSUCCESSFUL       = 0x01;
    const AUDIO_DAC_ABORTSUCCESSFUL     = 0x02;
    const AUDIO_DAC_ABORTNOTSUCCESSFUL  = 0x03;

    byte gAudioSD_DAC_ControlType = 0;
    const AUDIO_DAC_SELECT_LIST_ENTRY         = 0x00;
    const AUDIO_DAC_NEXT                      = 0x01;
    const AUDIO_DAC_PREVIOUS                  = 0x02;
    const AUDIO_DAC_FASTFORWARD               = 0x03;
    const AUDIO_DAC_FASTBACKWARD              = 0x04;
    const AUDIO_DAC_UPDATESTATION             = 0x05;
    const AUDIO_DAC_CANCELSTATIONLISTUPDATE   = 0x06;
    const AUDIO_DAC_CANCELSEEKSCAN            = 0x07;
    char gAudioSD_DAC_ControlType_s[8][30] ={  "select list entry",
                                               "next",
                                               "previous",
                                               "fast forward",
                                               "fast backward",
                                               "update station list",
                                               "cancel station list update",
                                               "cancel seek/scan"};

    byte gAudioSD_DAC_ListType = 0;
    const AUDIO_DAC_NOLIST            = 0x00;
    const AUDIO_DAC_RECEPTIONLIST     = 0x01;
    const AUDIO_DAC_RADIOTVPRESETLIST = 0x02;
    const AUDIO_DAC_MEDIABROWSER      = 0x03;
    const AUDIO_DAC_TPMEMOLIST        = 0x04;
    const AUDIO_DAC_SIRIUSALERTLIST   = 0x05;
    const AUDIO_DAC_LASTSTATIONLIST   = 0x06;
    const AUDIO_DAC_FAVORITELIST      = 0x07;
    char gAudioSD_DAC_ListType_s[8][20] ={ "no list",
                                           "ReceptionList",
                                           "RadioTV_PresetList",
                                           "MediaBrowser",
                                           "TpMemoList",
                                           "SiriusAlertList",
                                           "LastStationList",
                                           "FavoriteList"};

    /***AnnouncementEscape ***/
    mstimer AnnouncementEscape_Timer;
    mstimer AnnouncementEscape_MethodHandling_Timer;
    const AnnouncementEscape_TimerTime              = 1000;
    byte gAudioSD_AnnouncementEscape_MethodHandling = 0;

    byte gAudioSD_AnnouncementEscape_status = 0;                    //flag for status of the method ( 0 =not activ, 1 =activ)

    byte gAudioSD_AnnouncementEscape_Reserve = 0;
    byte gAudioSD_AnnouncementEscape_Result = 0;

    const AUDIO_ANNOUNCEMENTESCAPE_SUCCESSFUL               = 0x00;
    const AUDIO_ANNOUNCEMENTESCAPE_NOTSUCCESSFUL            = 0x01;
    const AUDIO_ANNOUNCEMENTESCAPE_ABORTSUCCESSFUL          = 0x02;
    const AUDIO_ANNOUNCEMENTESCAPE_ABORTNOTSUCCESSFUL       = 0x03;
    const AUDIO_ANNOUNCEMENTESCAPE_ANNOUNCEMENTNOTACTIVE    = 0x04;

    /***SwitchSource ***/
    mstimer SwitchSource_Timer;
    //changes from J.Karl 30.11.2012
    //const SwitchSource_TimerTime      = 1000;
    const SwitchSource_TimerTime      = 200;

    byte gAudioSD_SwitchSource_status = 0;

    word gAudioSD_SwitchSource_Reference = 0;
    byte gAudioSD_SwitchSource_Reserve = 0;

    const AUDIO_SWITCHSOURCERESULT_SUCCESSFUL             = 0x00;
    const AUDIO_SWITCHSOURCERESULT_NOT_SUCCESSFUL         = 0x01;
    const AUDIO_SWITCHSOURCERESULT_ABORT_SUCCESSFUL       = 0x02;
    const AUDIO_SWITCHSOURCERESULT_ABORT_NOT_SUCCESSFUL   = 0x03;
    byte gAudioSD_SwitchSource_Result = AUDIO_SWITCHSOURCERESULT_SUCCESSFUL;

    /***MediaBrowserControl***/
    mstimer MediaBrowserControl_Timer;
    //const MediaBrowserControl_TimerTime         = 1000;
    const MediaBrowserControl_TimerTime         = 200;

    byte gAudioSD_MediaBrowserControl_status = FALSE;

    byte gAudioSD_MediaBrowserControl_Control = 0;
    char gAudioSD_MediaBrowserControl_Control_s[5][30] ={   "go to current file",
                                                                "go to root directory",
                                                                "go to parent directory",
                                                                "go to source",
                                                                "open folder/playlist"};

    byte gAudioSD_MediaBrowserControl_Reserve = 0;
    word gAudioSD_MediaBrowserControl_Reference = 0;

    const AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL             = 0x00;
    const AUDIO_MEDIABROWSERCONTROL_NOT_SUCCESSFUL         = 0x01;
    const AUDIO_MEDIABROWSERCONTROL_ABORT_SUCCESSFUL       = 0x02;
    const AUDIO_MEDIABROWSERCONTROL_ABORT_NOT_SUCCESSFUL   = 0x03;
    byte gAudioSD_MediaBrowserControl_Result = AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL;

    /***MediaFileInfo***/
    mstimer MediaFileInfo_Timer;
    const MediaFileInfo_TimerTime         = 1000;

    byte gAudioSD_MediaFileInfo_status = FALSE;

    byte gAudioSD_MediaFileInfo_Reserve = 0;
    word gAudioSD_MediaFileInfo_Reference = 0;

    const AUDIO_MEDIAFILINFO_ARTIST_LENGTH  = 76;
    char gAudioSD_MediaFileInfo_Artist_s[AUDIO_MEDIAFILINFO_ARTIST_LENGTH];

    const AUDIO_MEDIAFILINFO_TITLE_LENGTH  = 76;
    char gAudioSD_MediaFileInfo_Title_s[AUDIO_MEDIAFILINFO_TITLE_LENGTH];

    const AUDIO_MEDIAFILINFO_ALBUM_LENGTH  = 76;
    char gAudioSD_MediaFileInfo_Album_s[AUDIO_MEDIAFILINFO_ALBUM_LENGTH];

    const AUDIO_MEDIAFILEINFO_SUCCESSFUL             = 0x00;
    const AUDIO_MEDIAFILEINFO_NOT_SUCCESSFUL         = 0x01;
    const AUDIO_MEDIAFILEINFO_ABORT_SUCCESSFUL       = 0x02;
    const AUDIO_MEDIAFILEINFO_ABORT_NOT_SUCCESSFUL   = 0x03;
    byte gAudioSD_MediaFileInfo_Result = AUDIO_MEDIAFILEINFO_SUCCESSFUL;

    /***GetNextListPos ***/
    mstimer GetNextListPos_Timer;
    //IssueList #197
    //const GetNextListPos_TimerTime  = 1000;
    const GetNextListPos_TimerTime  = 100;

    byte gAudioSD_GetNextListPos_status = FALSE;

    word gAudioSD_GetNextListPos_CurrentPos = 0;
    int gAudioSD_GetNextListPos_Offset = 0;
    word gAudioSD_GetNextListPos_nextPos = 0;
    word gAudioSD_GetNextListPos_absoluteListPos = 0;
    byte gAudioSD_GetNextListPos_Reserve = 0;

    byte gAudioSD_GetNextListPos_ListType = 0;
    char gAudioSD_GetNextListPos_ListType_s[8][20] ={   "ReceptionList",
                                                            "TpMemoList",
                                                            "SourceList",
                                                            "RadioTV_PresetList",
                                                            "MediaBrowser",
                                                            "SiriusAlertList",
                                                            "LastStationList",
                                                            "FavoriteList"};

    const AUDIO_GETNEXTLISTPOS_SUCCESSFUL             = 0x00;
    const AUDIO_GETNEXTLISTPOS_NOT_SUCCESSFUL         = 0x01;
    const AUDIO_GETNEXTLISTPOS_ABORT_SUCCESSFUL       = 0x02;
    const AUDIO_GETNEXTLISTPOS_ABORT_NOT_SUCCESSFUL   = 0x03;
    byte gAudioSD_GetNextListPos_Result = 0;

    /***SwitchRadioMedia***/
    byte gSwRaMe_SwRaMeReact = 0;
    int tempSwRaMe = 0;
    byte gSwRaMe_Sourceeact = 0;
    int tempSwRaMe2 = 0;

    //Array's
    //values for reading *.csv-file
    const AUDIO_DEFAULT_LIST  = 0;
    const AUDIO_EXTERNAL_LIST = 1;
    const AUDIO_FILENAME_SIZE = 50;
    const AUDIO_BUFFERSIZE    = 0xFFFF;
    const AUDIO_TEXTLENGTH    = 500;
    const AUDIO_TEXTLENGTH_URI    = 600;
    
    const AUDIO_FAVORITELIST_ENTRIES = 0xFF;
    const AUDIO_SIRIUSALERTLIST_ENTRIES = 0xFF;

    /***ReceptionList***/
    byte gReceptionList_ASGID = 0;
    byte gReceptionList_TAID = 0;

    word gReceptionList_TotalNumListElements = 0;

    const AUDIO_RECEPTIONLISTTYPE_ELEMENTTYPE_ENSEMBLES = 0x00;
    byte gReceptionList_ElementType = AUDIO_RECEPTIONLISTTYPE_ELEMENTTYPE_ENSEMBLES;
    char gReceptionList_ElementType_s[6][70]    ={  "ensembles",
                                                        "primary service only",
                                                        "secondary and primary services",
                                                        "flat list ( ensembles, primary services and secondary services )",
                                                        "flat list (primary and secondary services )",
                                                        "flat list (primary services only )"};

    word gReceptionList_ParentID = 0x0000;

    const AUDIO_RECEPTIONLIST_ENTRIES = 0xFF;

    word gReceptionList_Pos[AUDIO_RECEPTIONLIST_ENTRIES];

    const AUDIO_RECEPTIONLIST_ENSEMBLES                     = 0x00;
    const AUDIO_RECEPTIONLIST_PRIMARYSERVICEONLY            = 0x01;
    const AUDIO_RECEPTIONLIST_SECONDARYANDPRIMARYSERVICE    = 0x02;
    const AUDIO_RECEPTIONLIST_FLATSLIST_0x03                = 0x03;
    const AUDIO_RECEPTIONLIST_FLATSLIST_0x04                = 0x04;
    const AUDIO_RECEPTIONLIST_FLATSLIST_0x05                = 0x05;
    byte gReceptionList_Type[AUDIO_RECEPTIONLIST_ENTRIES];
    char gReceptionList_Type_s[16][50]   ={  "any string / unknown",
                                                "station name",
                                                "DAB ensemble name",
                                                "DAB primary service name",
                                                "DAB secondary service name",
                                                "IBOC primary service name",
                                                "IBOC secondary service name",
                                                "DVB service name",
                                                "SDARS station name",
                                                "OnlineRadioPrimary ( DF4.1 )",
                                                "OnlineRadioSecondary ( DF4.1 )",
                                                "OnlineRadio Podcast ( DF4.7)",
                                                "OnlineRadio Live ( DF4.7)",
                                                "FM radio station ( DF4.7)",
                                                "AM radio station ( DF4.7)",
                                                "DMB ( DF4.7)"};

    byte gReceptionList_Attributes_available_Bit0[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_DVB_Bit1[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_DAB_Bit2[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_DAB_Bit3[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_DAB_Bit4[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_TP_Bit5[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_TMC_Bit6[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_SDARS_Bit7[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_DABServ_Bit8[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_FMOnlineRadio_Bit9[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_StationSelectable_Bit10[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_OnlineRadioMuting_Bit11[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_Attributes_LinkedToOnlineRadion_Bit12[AUDIO_RECEPTIONLIST_ENTRIES];
    word gReceptionList_Attributes[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_PresetID[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gReceptionList_FmRegCode[AUDIO_RECEPTIONLIST_ENTRIES];

    const AUDIO_RECEPTIONLIST_SCIENCE           = 0x08;
    const AUDIO_RECEPTIONLIST_TALK              = 0x27;
    const AUDIO_RECEPTIONLIST_OLDIES            = 0x2B;
    const AUDIO_RECEPTIONLIST_PERSONALITY       = 0x35;
    const AUDIO_RECEPTIONLIST_COLLEGE           = 0x37;
    const AUDIO_RECEPTIONLIST_TRAVEL            = 0x16;
    const AUDIO_RECEPTIONLIST_SERIOUSCLASSICAL  = 0x0D;
    const AUDIO_RECEPTIONLIST_FINANCE           = 0x11;
    byte gReceptionList_Category[AUDIO_RECEPTIONLIST_ENTRIES];
    char gReceptionList_Category_s[56][60]  ={  "unknown / none category",
                                                    "news",
                                                    "current affairs",
                                                    "information",
                                                    "sports",
                                                    "education",
                                                    "drama",
                                                    "culture",
                                                    "science",
                                                    "varied",
                                                    "pop music",
                                                    "rock music",
                                                    "easy listening music",
                                                    "light classical",
                                                    "serious classical",
                                                    "other music",
                                                    "weather",
                                                    "finance",
                                                    "childrens's programmes",
                                                    "social affairs",
                                                    "religion",
                                                    "phone in",
                                                    "travel",
                                                    "leisure",
                                                    "jazz music",
                                                    "country music",
                                                    "national music",
                                                    "oldies music",
                                                    "folk music",
                                                    "documentary",
                                                    "alarm test",
                                                    "alarm",
                                                    "reserved",
                                                    "reserved",
                                                    "reserved",
                                                    "reserved",
                                                    "talk",
                                                    "reserved",
                                                    "classic rock",
                                                    "adult hits",
                                                    "soft rock",
                                                    "top 40",
                                                    "reserved",
                                                    "oldies",
                                                    "soft",
                                                    "nostalgia",
                                                    "reserved",
                                                    "classical",
                                                    "rhythm and blues",
                                                    "soft rhythm and blues",
                                                    "foreign language",
                                                    "religious music",
                                                    "relegious talk",
                                                    "personality",
                                                    "public",
                                                    "college"};

    const AUDIO_RECEPTIONLIST_NAME_LENGTH = 49;
    char gReceptionList_Name[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_RECEPTIONLIST_NAME_LENGTH];

    const AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH = 31;
    char gReceptionList_Frequency[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH];

    byte gReceptionList_ListEntryValidInformation[AUDIO_RECEPTIONLIST_ENTRIES]; //indicates the existence of the "record element"

    byte gReceptionList_sum = 0;

    char gReceptionList_CSV_filename[AUDIO_FILENAME_SIZE];

    /***SourceList***/
    byte gSourceList_ASGID = 0;
    byte gSourceList_TAID = 0;

    word gSourceList_TotalNumListElements = 0;

    const AUDIO_SOURCELIST_ENTRIES = 0xFF;

    word gSourceList_Pos[AUDIO_SOURCELIST_ENTRIES];

    const AUDIO_SOURCELIST_ST_NOSOURCE          = 0x00;
    const AUDIO_SOURCELIST_ST_FM                = 0x01;
    const AUDIO_SOURCELIST_ST_AM                = 0x02;
    const AUDIO_SOURCELIST_ST_DAB               = 0x03;
    const AUDIO_SOURCELIST_ST_SDARSXM           = 0x04;
    const AUDIO_SOURCELIST_ST_SDARSSIRIUS       = 0x05;
    const AUDIO_SOURCELIST_ST_CD                = 0x06;
    const AUDIO_SOURCELIST_ST_CDC               = 0x07;
    const AUDIO_SOURCELIST_ST_DVD               = 0x08;
    const AUDIO_SOURCELIST_ST_TV                = 0x09;
    const AUDIO_SOURCELIST_ST_HDD               = 0x0A;
    const AUDIO_SOURCELIST_ST_SD                = 0x0B;
    const AUDIO_SOURCELIST_ST_TPMEMO            = 0x0C;
    const AUDIO_SOURCELIST_ST_AUXINAUDIO        = 0x0D;
    const AUDIO_SOURCELIST_ST_AUXINVIDEO        = 0x0E;
    const AUDIO_SOURCELIST_ST_MDI               = 0x0F;
    const AUDIO_SOURCELIST_ST_GENERICPLAYER     = 0x10;
    const AUDIO_SOURCELIST_ST_AMTI              = 0x11;
    const AUDIO_SOURCELIST_ST_DVDC              = 0x12;
    const AUDIO_SOURCELIST_ST_USB               = 0x13;
    const AUDIO_SOURCELIST_ST_JUKEBOX           = 0x14;
    const AUDIO_SOURCELIST_ST_BTSTREAM          = 0x15;
    const AUDIO_SOURCELIST_ST_BTRCP             = 0x16;
    const AUDIO_SOURCELIST_ST_DVBVIDEO          = 0x17;
    const AUDIO_SOURCELIST_ST_DVBAUDIO          = 0x18;
    const AUDIO_SOURCELIST_ST_AMSW              = 0x19;
    const AUDIO_SOURCELIST_ST_AMLW              = 0x1A;
    const AUDIO_SOURCELIST_ST_WLANMASSSTOR      = 0x1B;
    const AUDIO_SOURCELIST_ST_WLANRCP           = 0x1C;
    const AUDIO_SOURCELIST_ST_BLUERAY           = 0x1D;
    const AUDIO_SOURCELIST_ST_BLUERAYC          = 0x1E;
    const AUDIO_SOURCELIST_ST_FLASH             = 0x1F;
    const AUDIO_SOURCELIST_ST_AUXIN_VIDEO_TV    = 0x20;
    const AUDIO_SOURCELIST_ST_HDMI              = 0x21;
    const AUDIO_SOURCELIST_ST_ONLINEMASSSTORAGE = 0x22;
    const AUDIO_SOURCELIST_ST_ONLINERADIO       = 0x23;
    const AUDIO_SOURCELIST_ST_COMMONLIST        = 0x24;
    const AUDIO_SOURCELIST_ST_MOBDEVICEAPPLE    = 0x25;
    const AUDIO_SOURCELIST_ST_MOBDEVICEMIRROR   = 0x26;
    const AUDIO_SOURCELIST_ST_MOBDEVICEGOOGLE   = 0x27;
    const AUDIO_SOURCELIST_ST_MOBDEVICEBAIDU    = 0x28;
    const AUDIO_SOURCELIST_ST_RSE               = 0x29;
    const AUDIO_SOURCELIST_ST_DMB               = 0x2A;
    const AUDIO_SOURCELIST_ST_ONLINEMUSICSTREAM = 0x2B;
    const AUDIO_SOURCELIST_ST_ONLINETV          = 0x2C;
    const AUDIO_SOURCELIST_ST_ONLINEVIDEO       = 0x2D;
    const AUDIO_SOURCELIST_ST_UNKNOWN           = 0xFF;
    byte gSourceList_SourceType[AUDIO_SOURCELIST_ENTRIES];
    char gSourceList_SourceType_s[46][60]  ={  "no source",
                                                    "FM",
                                                    "AM",
                                                    "DAB",
                                                    "SDARS-XM",
                                                    "SDARS-SIRIUS",
                                                    "CD",
                                                    "CD changer",
                                                    "DVD",
                                                    "TV",
                                                    "HDD",
                                                    "SD",
                                                    "TP-Memo / TIM",
                                                    "Aux-In Audio",
                                                    "Aux-In Video",
                                                    "portable device (MDI, AMI)",
                                                    "generic player",
                                                    "AM-TI (Japan )",
                                                    "DVD changer",
                                                    "USB",
                                                    "Jukebox",
                                                    "BT connection - BT stream",
                                                    "BT connection - remote control protocol",
                                                    "DVB - video service",
                                                    "DVB - audio service",
                                                    "AM-SW ('Kurzwelle' / short wave )",
                                                    "AM-LW ('Langwelle' / long wave )",
                                                    "WLAN connection - mass storage",
                                                    "WLAN connection - RCP ( Remote Control Player )",
                                                    "BlueRay",
                                                    "BlueRay changer",
                                                    "Flash ( flash memory )",
                                                    "Aux-in Video ( TV)",
                                                    "HDMI ( DF4.1 )",
                                                    "Online mass storage ( DF4.1 )",
                                                    "Online radio ( DF4.1 )",
                                                    "CommonList ( DF4.2 )",
                                                    "MobileDevice ( AppleLink) ( DF4.2 )",
                                                    "MobileDevice (MirrorLink) ( DF4.2 )",
                                                    "MobileDevice (Google ) ( DF4.2 )",
                                                    "MobileDevice ( Baidu) ( DF4.4 )",
                                                    "RSE",
                                                    "DMB",
                                                    "Online music streaming",
                                                    "Online TV",
                                                    "Online video"};

    byte gSourceList_InstanceID[AUDIO_SOURCELIST_ENTRIES];

    const AUDIO_SOURCELIST_MT_NOTAVAILABLE      = 0x00;
    const AUDIO_SOURCELIST_MT_CDAUDIO           = 0x01;
    const AUDIO_SOURCELIST_MT_DVDAUDIO          = 0x02;
    const AUDIO_SOURCELIST_MT_DVDVIDEO          = 0x03;
    const AUDIO_SOURCELIST_MT_CDVIDEO           = 0x04;
    const AUDIO_SOURCELIST_MT_CDROM             = 0x05;
    const AUDIO_SOURCELIST_MT_DVDROM            = 0x06;
    const AUDIO_SOURCELIST_MT_FILESYSTEM        = 0x07;
    const AUDIO_SOURCELIST_MT_RAW               = 0x08;
    const AUDIO_SOURCELIST_MT_RCP               = 0x09;
    const AUDIO_SOURCELIST_MT_SOUNDBROADCAST    = 0x0A;
    const AUDIO_SOURCELIST_MT_VIDEOBROADCAST    = 0x0B;
    const AUDIO_SOURCELIST_MT_IPOD              = 0x0C;
    const AUDIO_SOURCELIST_MT_BLUERAY           = 0x0D;
    const AUDIO_SOURCELIST_MT_UNKNOWN           = 0xFF;
    byte gSourceList_MediaType[AUDIO_SOURCELIST_ENTRIES];
    char gSourceList_MediaType_s[14][50]  ={    "not avaialble / not applicable",
                                                    "CD Audio",
                                                    "DVD Audio",
                                                    "DVD Video",
                                                    "CD Video",
                                                    "CD ROM",
                                                    "DVD ROM",
                                                    "file system",
                                                    "raw",
                                                    "RCP ( Remote Control Protocol)",
                                                    "audio broadcasting ( radio)",
                                                    "video broadcasting ( TV, DVB)",
                                                    "iPOD",
                                                    "BlueRay"};

    byte gSourceList_Attributes_BuiltIn_Bit0[AUDIO_SOURCELIST_ENTRIES];
    char gSourceList_Attributes_BuiltIn_Bit0_s[2][30] ={ "built-in but not ready",
                                                            "built-in and ready"};

    byte gSourceList_Attributes_MediaError_Bit1[AUDIO_SOURCELIST_ENTRIES];
    char gSourceList_Attributes_MediaError_Bit1_s[2][30] ={  "media/audio source error",
                                                                "media/audio no error"};

    byte gSourceList_Attributes_MediaPlay_Bit2[AUDIO_SOURCELIST_ENTRIES];
    char gSourceList_Attributes_MediaPlay_Bit2_s[2][50] ={   "media is not playable (no playable files )",
                                                                "media is playable"};

    byte gSourceList_Attributes_MediaRead_Bit3[AUDIO_SOURCELIST_ENTRIES];
    char gSourceList_Attributes_MediaRead_Bit3_s[2][30] ={   "media is not readable",
                                                                "media is readable"};

    byte gSourceList_Attributes_MediaLoad_Bit4[AUDIO_SOURCELIST_ENTRIES];
    char gSourceList_Attributes_MediaLoad_Bit4_s[2][30] ={   "media is being loaded",
                                                                "media is not being loaded"};

    byte gSourceList_Attributes_ImportRun_Bit5[AUDIO_SOURCELIST_ENTRIES];
    char gSourceList_Attributes_ImportRun_Bit5_s[2][30] ={   "import running",
                                                                "no import running"};

    byte gSourceList_Attributes_MediaSupp_Bit6[AUDIO_SOURCELIST_ENTRIES];
    char gSourceList_Attributes_MediaSupp_Bit6_s[2][30] ={    "media not support browser",
                                                                 "media not support browser"};

    byte gSourceList_Attributes[AUDIO_SOURCELIST_ENTRIES];

    const AUDIO_SOURCELIST_NAME_LENGTH = 61;
    char gSourceList_Name[AUDIO_SOURCELIST_ENTRIES][AUDIO_SOURCELIST_NAME_LENGTH];

    byte gSourceList_ListEntryValidInformation[AUDIO_SOURCELIST_ENTRIES]; //indicates the existence of the "record element"

    byte gSourceList_sum = 0;

    char gSourceList_CSV_filename[AUDIO_FILENAME_SIZE];

    //BAP_MOST sync CoverArt
    const AUDIO_SOURCE_PICFILE_LENGTH = 100;
    char gSourceList_PictureFile [AUDIO_SOURCELIST_ENTRIES][AUDIO_SOURCE_PICFILE_LENGTH];
    word gSourceList_PictureFileIndex [AUDIO_SOURCELIST_ENTRIES][3];
    byte gSourceList_CoverArtType[AUDIO_SOURCELIST_ENTRIES];

    /***RadioTV_PresetList***/
    byte gRadioTVPresetList_ASGID = 0;
    byte gRadioTVPresetList_TAID = 0;

    byte gRadioTVPresetList_TotalNumListElements = 0;

    const AUDIO_RADIOTVPRESETLIST_ENTRIES = 0xFF;

    byte gRadioTVPresetList_Pos[AUDIO_RADIOTVPRESETLIST_ENTRIES];

    byte gRadioTVPresetList_PresetIndex[AUDIO_RADIOTVPRESETLIST_ENTRIES];

    const AUDIO_RADIOTVPRESETLIST_WB_UNKNOWN     = 0x00;
    const AUDIO_RADIOTVPRESETLIST_WB_FM          = 0x01;
    const AUDIO_RADIOTVPRESETLIST_WB_AMMW        = 0x02;
    const AUDIO_RADIOTVPRESETLIST_WB_AMSW        = 0x03;
    const AUDIO_RADIOTVPRESETLIST_WB_AMLW        = 0x04;
    const AUDIO_RADIOTVPRESETLIST_WB_SDARSXM     = 0x05;
    const AUDIO_RADIOTVPRESETLIST_WB_SDARSSIRIUS = 0x06;
    const AUDIO_RADIOTVPRESETLIST_WB_DAB         = 0x07;
    const AUDIO_RADIOTVPRESETLIST_WB_DVB         = 0x08;
    const AUDIO_RADIOTVPRESETLIST_WB_TV          = 0x09;
    const AUDIO_RADIOTVPRESETLIST_WB_ONLINERADIO = 0x0A;
    const AUDIO_RADIOTVPRESETLIST_WB_COMMONLIST  = 0x0B;
    const AUDIO_RADIOTVPRESETLIST_WB_DMB         = 0x0C;
    const AUDIO_RADIOTVPRESETLIST_WB_ONLINETV    = 0x0D;
    byte gRadioTVPresetList_Waveband[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    char gRadioTVPresetList_Waveband_s[14][60]  ={  "unknown / invalid",
                                                        "FM",
                                                        "AM (MW)",
                                                        "AM ( SW)",
                                                        "AM (LW)",
                                                        "SDARS - XM",
                                                        "SDARS - Sirius",
                                                        "DAB",
                                                        "DVB",
                                                        "TV",
                                                        "online radio ( DF4.1 )",
                                                        "CommonList",
                                                        "DMB",
                                                        "online TV"};

    byte gRadioTVPresetList_Attributes_IBOC_Bit0[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    char gRadioTVPresetList_Attributes_IBOC_Bit0_s[2][30] ={ "not an IBOC service",
                                                                "IBOC service"};

    byte gRadioTVPresetList_Attributes_DABSecServ_Bit1[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    char gRadioTVPresetList_Attributes_DABSecServ_Bit1_s[2][30] ={   "not a DAB secondary service",
                                                                        "DAB secondary service"};

    byte gRadioTVPresetList_Attributes_DABPrimServ_Bit2[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    char gRadioTVPresetList_Attributes_DABPrimServ_Bit2_s[2][80] ={  "DAB primary service contains no secondary service(s ) / no DAB primary service",
                                                                        "DAB primary service contains secondary service(s )"};

    byte gRadioTVPresetList_Attributes_TP_Bit5[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    char gRadioTVPresetList_Attributes_TP_Bit5_s[2][50] ={   "TP not available/not supported by station",
                                                                "TP available/supported by station"};

    byte gRadioTVPresetList_Attributes_TMC_Bit6[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    char gRadioTVPresetList_Attributes_TMC_Bit6_s[2][50] ={  "TMC not supported/not available by station",
                                                                "TMC available/supported by station"};

    byte gRadioTVPresetList_Attributes_SDRAS_Bit7[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    char gRadioTVPresetList_Attributes_SDARS_Bit7_s[2][50] ={ "SDARS station not subscribed",
                                                                 "SDARS station subscribed or not an SDARS station"};

    byte gRadioTVPresetList_Attributes_StatSelect_Bit8[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    char gRadioTVPresetList_Attributes_StatSelect_Bit8_s[2][50] ={ "Station not selected",
                                                                 "Station selected"};

    byte gRadioTVPresetList_Attributes_OnlineRadioMute_Bit9[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    char gRadioTVPresetList_Attributes_OnlineRadioMute_Bit9_s[2][50] ={ "OnlineRadio not muted",
                                                                 "OnlineRadio muted"};

    byte gRadioTVPresetList_Attributes_LinkedToOnlRadio_Bit10[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    char gRadioTVPresetList_Attributes_LinkedToOnlRadio_Bit10_s[2][50] ={ "Station not linked to online radio",
                                                                 "Station linked to online radio"};

    word gRadioTVPresetList_Attributes[AUDIO_RADIOTVPRESETLIST_ENTRIES];

    const AUDIO_RADIOTVPRESETLIST_NAME_LENGTH = 49;
    char gRadioTVPresetList_Name[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_RADIOTVPRESETLIST_NAME_LENGTH];

    byte gRadioTVPresetList_ListEntryValidInformation[AUDIO_RADIOTVPRESETLIST_ENTRIES]; //indicates the existence of the "record element"

    byte gRadioTVPresetList_sum = 0;

    char gRadioTVPresetList_CSV_filename[AUDIO_FILENAME_SIZE];

    /***TpMemoList***/
    byte gTpMemoList_ASGID = 0;
    byte gTpMemoList_TAID = 0;

    byte gTpMemoList_TotalNumListElements = 0;

    const AUDIO_TPMEMOLIST_ENTRIES = 0xFF;

    byte gTpMemoList_Pos[AUDIO_TPMEMOLIST_ENTRIES];

    byte gTpMemoList_Attributes_MessageNew_Bit0[AUDIO_TPMEMOLIST_ENTRIES];
    char gTpMemoList_Attributes_MessageNew_Bit0_s[2][30] ={  "message is not new",
                                                                "new message"};

    byte gTpMemoList_Attributes[AUDIO_TPMEMOLIST_ENTRIES];

    byte gTpMemoList_Hour[AUDIO_TPMEMOLIST_ENTRIES];

    byte gTpMemoList_Minute[AUDIO_TPMEMOLIST_ENTRIES];

    const AUDIO_TPMEMOLIST_STATIONNAME_LENGTH = 49;
    char gTpMemoList_StationName[AUDIO_TPMEMOLIST_ENTRIES][AUDIO_TPMEMOLIST_STATIONNAME_LENGTH];

    byte gTpMemoList_ListEntryValidInformation[AUDIO_TPMEMOLIST_ENTRIES]; //indicates the existence of the "record element"

    byte gTpMemoList_sum = 0;

    char gTpMemoList_CSV_filename[AUDIO_FILENAME_SIZE];

    /***LastStationList***/
    byte gLSL_ASGID = 0;
    byte gLSL_TAID = 0;
    word gLSL_TNLE = 0;
    //word gLSL_ALP = 0;

    const AUDIO_LASTSTATIONLIST_ENTRIES = 0xFF;
    const AUDIO_LASTSTATION_NAME_LENGTH = 0xFF;
    const AUDIO_LASTSTATION_FREQUENZ_LENGTH = 0xFF;
    
    byte gLastStationList_TotalNumListElements = 0;

    word gLSL_Pos[AUDIO_LASTSTATIONLIST_ENTRIES];
    word gLSL_PresentIndex[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Waveband[AUDIO_LASTSTATIONLIST_ENTRIES];
    char gLSL_Waveband_s[14][25] = {"unknown/invalid",
                                    "FM",
                                    "AM(MW:..Mittelwelle )",
                                    "AM( SW:..Kurzwelle )",
                                    "AM(LW:..Langwelle )",
                                    "SDARS-Sirus/XM",
                                    "DAB",
                                    "DVB",
                                    "TV",
                                    "online radio",
                                    "CommonList",
                                    "DMB",
                                    "online TV",
                                    "reverved"
                                    };
    word gLSL_Attributes[AUDIO_LASTSTATIONLIST_ENTRIES];

    byte gLSL_Attribute_IBOC_Bit0[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Attribute_DABsec_Bit1[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Attribute_DABprim_Bit2[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Attribute_OnlineRadioSec_Bit3[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Attribute_OnlineRadioPrim_Bit4[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Attribute_TP_Bit5[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Attribute_TMC_Bit6[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Attribute_SDARS_Bit7[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Attribute_StationSelc_Bit8[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Attribute_mute_Bit9[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Attribute_StationLinkedORadio_Bit10[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_Attribute_StationLinkedFM_Bit11[AUDIO_LASTSTATIONLIST_ENTRIES];

    char gLSL_Name[AUDIO_LASTSTATIONLIST_ENTRIES][AUDIO_LASTSTATION_NAME_LENGTH];
    char gLSL_Frequenz[AUDIO_LASTSTATIONLIST_ENTRIES][AUDIO_LASTSTATION_FREQUENZ_LENGTH];

    byte gLSL_ListEntryValidInformation[AUDIO_LASTSTATIONLIST_ENTRIES]; //indicates the existence of the "record element"
    byte gLSL_sum = 0;
    char gLSL_CSV_filename[AUDIO_FILENAME_SIZE];
    

    /***MediaBrowser***/
    byte gMediaBrowser_ASGID = 0;
    byte gMediaBrowser_TAID = 0;

    word gMediaBrowser_TotalNumListElements = 0;

    word gMediaBrowser_ActiveListPos = 0;

    const AUDIO_MEDIABROWSER_ENTRIES = 0xFF;

    word gMediaBrowser_Pos[AUDIO_MEDIABROWSER_ENTRIES];

    const AUDIO_MEDIABROWSER_FILETYPE_ITEM          = 0x02;
    const AUDIO_MEDIABROWSER_FILETYPE_SONG          = 0x24;
    const AUDIO_MEDIABROWSER_FILETYPE_DVDMAIN       = 0x40;
    const AUDIO_MEDIABROWSER_FILETYPE_NOTSUPPORTED  = 0xFF;
    const AUDIO_MEDIABROWSER_FILETYPE_DVDCHAPTER    = 0x41;
    const AUDIO_MEDIABROWSER_FILETYPE_YEAR          = 0x1C;
    const AUDIO_MEDIABROWSER_FILETYPE_VOICEMEMO     = 0x0F;
    const AUDIO_MEDIABROWSER_FILETYPE_IMAGEFILE     = 0x0B;
    const AUDIO_MEDIABROWSER_FILETYPE_UNKNOWNCAT    = 0x05;
    const AUDIO_MEDIABROWSER_FILETYPE_CATCOPMPOSER  = 0x18;
    const AUDIO_MEDIABROWSER_FILETYPE_CATCOMPOSERS  = 0x19;
    const AUDIO_MEDIABROWSER_FILETYPE_DYNPLAYLIST_2 = 0x2F;
    const AUDIO_MEDIABROWSER_FILETYPE_CATALL        = 0x2A;
    byte gMediaBrowser_FileType[AUDIO_MEDIABROWSER_ENTRIES];
    char gMediaBrowser_FileType_s[103][50]   ={  "any string / unknown",
                                                  "folder",
                                                  "track",
                                                  "playlist",
                                                  "playlist folder",
                                                  "any category / unknown category",
                                                  "audio file",
                                                  "video file",
                                                  "legacy audio track ( CD)",
                                                  "CD audio track - CD text",
                                                  "voicememo file",
                                                  "image file",
                                                  "audio folder",
                                                  "video folder",
                                                  "image folder",
                                                  "voicememo folder",
                                                  "category - genre",
                                                  "category - genres",
                                                  "category - unknown genre",
                                                  "category - unknown genres",
                                                  "category - artist",
                                                  "category - artists",
                                                  "category - unknown artist",
                                                  "category - unknown artists",
                                                  "category - composer",
                                                  "category - composers",
                                                  "category - unknown composer",
                                                  "category - unknown composers",
                                                  "category - year",
                                                  "category - unknown year",
                                                  "category - comment",
                                                  "category - unknown comment",
                                                  "category - album",
                                                  "category - albums",
                                                  "category - unknown album",
                                                  "category - unknown albums",
                                                  "category - song",
                                                  "category - songs",
                                                  "category - unknown song",
                                                  "category - unknown songs",
                                                  "category - audiobook",
                                                  "category - audiobooks",
                                                  "category - all",
                                                  "category - podcast",
                                                  "category - podcasts",
                                                  "category - dynamic playlist not rated",
                                                  "category - dynamic playlist 1 star",
                                                  "category - dynamic playlist 2 stars",
                                                  "category - dynamic playlist 3 stars",
                                                  "category - dynamic playlist 4 stars",
                                                  "category - dynamic playlist 5 stars",
                                                  "category - dynamic playlist most played",
                                                  "category - dynamic playlist last played",
                                                  "category - dynamic playlist on-the -go",
                                                  "category - dynamic playlists",
                                                  "category - movies ( DF4.1 )",
                                                  "category - music videos ( DF4.1 )",
                                                  "category - video podcasts ( DF4.1 )",
                                                  "category - borrowed videos ( DF4.1 )",
                                                  "category - last copied files ( DF4.1 )",
                                                  "category - favorites ( DF4.1 )",
                                                  "category - unknown podcast ( DF4.1 )",
                                                  "category - unknown podcasts ( DF4.1 )",
                                                  "category - various artists ( DF4.1 )",
                                                  "DVD main menue",
                                                  "DVD chapter",
                                                  "DVD title",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "category - unknown audiobook ( DF4.1 )",
                                                  "category - unknown audiobooks ( DF4.1 )",
                                                  "category - mood ( DF4.1 )",
                                                  "category - unknown mood ( DF4.1 )",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved",
                                                  "reserved ( in order to stay identical to 0x15)",
                                                  "online radio - live station",
                                                  "FM radio station",
                                                  "AM radio station",
                                                  "DAB radio station",
                                                  "SDARS - Sirius",
                                                  "DMB"};

    byte gMediaBrowser_FileState_emptyFolder_Bit0[AUDIO_MEDIABROWSER_ENTRIES];
    byte gMediaBrowser_FileState_DRM_Bit1[AUDIO_MEDIABROWSER_ENTRIES];
    byte gMediaBrowser_FileState_FileCorrupted_Bit2[AUDIO_MEDIABROWSER_ENTRIES];
    byte gMediaBrowser_FileState_DeadLink_Bit3[AUDIO_MEDIABROWSER_ENTRIES];
    byte gMediaBrowser_FileState_ImportFinished_Bit4[AUDIO_MEDIABROWSER_ENTRIES];
    byte gMediaBrowser_FileState_ImportPending_Bit5[AUDIO_MEDIABROWSER_ENTRIES];
    byte gMediaBrowser_FileState_ImportPlayable_Bit6[AUDIO_MEDIABROWSER_ENTRIES];

    word gMediaBrowser_FileState[AUDIO_MEDIABROWSER_ENTRIES];

    const AUDIO_MEDIABROWSER_FILENAME_LENGTH = 97;
    char gMediaBrowser_FileName[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_MEDIABROWSER_FILENAME_LENGTH];

    byte gMediaBrowser_ListEntryValidInformation[AUDIO_MEDIABROWSER_ENTRIES]; //indicates the existence of the "record element"

    byte gMediaBrowser_sum = 0;

    char gMediaBrowser_CSV_filename[AUDIO_FILENAME_SIZE];

    //BAP_MOST sync StationArt
    const AUDIO_MEDIABROWSER_PICFILE_LENGTH = 100;
    char gMediaBrowser_PictureFile [AUDIO_MEDIABROWSER_ENTRIES][AUDIO_MEDIABROWSER_PICFILE_LENGTH];
    word gMediaBrowser_PictureFileIndex [AUDIO_MEDIABROWSER_ENTRIES][2];
    byte gMediaBrowserSourceType[AUDIO_MEDIABROWSER_ENTRIES];
    byte gMediaBrowserStationArtType[AUDIO_MEDIABROWSER_ENTRIES];
    
    // FavoriteList
    byte gFavoriteList_TotalNumListElements = 0;
    
    // SiriusAlertList
    byte gSiriusAlertList_TotalNumListElements = 0;
    

    // ****** others.... *****

    byte gErrorCode;

    byte gAudioSD_PowerOnOff = FALSE;
    const POWER_OFF = 0x00;
    const POWER_ON  = 0x01;

    byte gBAP_Init = FALSE;

    char gstring_PowerOnOff[2][4] ={ "Off",
                                                   "On"};
    dword gRGB_red;
    dword gRGB_yellow;
    dword gRGB_green;
    dword gRGB_grey;
    dword gRGB_white;

    char Pri_Station_Name [30] = "";
    char Sec_Station_Name [30] = "Sec";
    char Ter_Station_Name [30] = "Ter";
    char Quart_Station_Name [30] = "Quart";

    dword audio_FSG_handle;

    //IssueList #34
    long Audio_HBdata[2];

    //IssueList #74
    byte gAudioFctList_0x18_TimeOut_flg= 0;
    byte gAudioFctList_0x1D_TimeOut_flg= 0;
    byte gAudioFctList_0x22_TimeOut_flg= 0;
    byte gAudioFctList_0x27_TimeOut_flg= 0;
    byte gAudioFctList_0x2C_TimeOut_flg= 0;
    byte gAudioFctList_0x26_TimeOut_flg= 0;

    //IssueList #68
    const AUDIOMAXPROCESSINGTIME = 180;
    Timer gAudioFctList_0x18_ProcessingTimer;
    Timer gAudioFctList_0x1D_ProcessingTimer;
    Timer gAudioFctList_0x22_ProcessingTimer;
    Timer gAudioFctList_0x27_ProcessingTimer;
    Timer gAudioFctList_0x2C_ProcessingTimer;
    Timer gAudioFctList_0x26_ProcessingTimer;

    byte gAudioFctList_0x18_Processing_flg= 0;
    byte gAudioFctList_0x1D_Processing_flg= 0;
    byte gAudioFctList_0x22_Processing_flg= 0;
    byte gAudioFctList_0x27_Processing_flg= 0;
    byte gAudioFctList_0x2C_Processing_flg= 0;
    byte gAudioFctList_0x26_Processing_flg= 0;

    //IssueList #76 - MR49870 : ReceptionList
    //RECEPTIONLIST
    //delete
    word gReceptionList_Pos_insDel [AUDIO_RECEPTIONLIST_ENTRIES][3];
    byte gRL_InvalidDel[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gRL_DelInvalidCtr, gRL_DelValidCtr;
    byte gReceptionList_Send[AUDIO_RECEPTIONLIST_ENTRIES][2];
    word gRL_totalDELctr;

    //insert
    byte gRL_InvalidIns[AUDIO_RECEPTIONLIST_ENTRIES];
    byte gRL_InsInvalidCtr, gRL_InsValidCtr;
    word gRL_TotalElem, gRL_CSVtotalElem;
    byte gRL_InsertFlg, gRL_loadReloadFlg;

    //SOURCELIST
    //delete
    word gSourceList_Pos_insDel [AUDIO_SOURCELIST_ENTRIES][3];
    byte gSL_InvalidDel[AUDIO_SOURCELIST_ENTRIES];
    byte gSL_DelInvalidCtr, gSL_DelValidCtr;
    byte gSourceList_Send[AUDIO_SOURCELIST_ENTRIES][2];
    word gSL_totalDELctr;

    //insert
    byte gSL_InvalidIns[AUDIO_SOURCELIST_ENTRIES];
    byte gSL_InsInvalidCtr, gSL_InsValidCtr;
    word gSL_TotalElem, gSL_CSVtotalElem;

    //RTPL
    //delete
    word gRTPL_Pos_insDel [AUDIO_RADIOTVPRESETLIST_ENTRIES][3];
    byte gRTPL_InvalidDel[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    byte gRTPL_DelInvalidCtr, gRTPL_DelValidCtr;
    byte gRTPL_Send[AUDIO_RADIOTVPRESETLIST_ENTRIES][2];
    word gRTPL_totalDELctr;

    //insert
    byte gRTPL_InvalidIns[AUDIO_RADIOTVPRESETLIST_ENTRIES];
    byte gRTPL_InsInvalidCtr, gRTPL_InsValidCtr;
    word gRTPL_TotalElem, gRTPL_CSVtotalElem;
    byte gRTPL_InsertFlg, gRTPL_loadReloadFlg;

    //MediaBrowserList
    //delete
    word gMediaBrowser_Pos_insDel [AUDIO_MEDIABROWSER_ENTRIES][3];
    byte gMB_InvalidDel[AUDIO_MEDIABROWSER_ENTRIES];
    byte gMB_DelInvalidCtr, gMB_DelValidCtr;
    byte gMediaBrowser_Send[AUDIO_MEDIABROWSER_ENTRIES][2];
    word gMB_totalDELctr;

    //insert
    byte gMB_InvalidIns[AUDIO_MEDIABROWSER_ENTRIES];
    byte gMB_InsInvalidCtr, gMB_InsValidCtr;
    word gMB_TotalElem, gMB_CSVtotalElem;
    byte gMB_InsertFlg, gMB_loadReloadFlg;
	
	//LastDestinationList
    //delete
    word gLastStationList_Pos_insDel [AUDIO_LASTSTATIONLIST_ENTRIES][3];
    byte gLSL_InvalidDel[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_DelInvalidCtr, gLSL_DelValidCtr;
    byte gLastStationList_Send[AUDIO_LASTSTATIONLIST_ENTRIES][2];
    word gLSL_totalDELctr;

    //insert
    byte gLSL_InvalidIns[AUDIO_LASTSTATIONLIST_ENTRIES];
    byte gLSL_InsInvalidCtr, gLSL_InsValidCtr;
    word gLSL_TotalElem, gLSL_CSVtotalElem;
    byte gLSL_InsertFlg, gLSL_loadReloadFlg;
	
	//FavoriteList
    //delete
    word gFavoriteList_Pos_insDel [AUDIO_FAVORITELIST_ENTRIES][3];
    byte gFL_InvalidDel[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_DelInvalidCtr, gFL_DelValidCtr;
    byte gFavoriteList_Send[AUDIO_FAVORITELIST_ENTRIES][2];
    word gFL_totalDELctr;

    //insert
    byte gFL_InvalidIns[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_InsInvalidCtr, gFL_InsValidCtr;
    word gFL_TotalElem, gFL_CSVtotalElem;
    byte gFL_InsertFlg, gFL_loadReloadFlg;
	
	//SiriusAlertList
    //delete
    word gSiriusAlertList_Pos_insDel [AUDIO_SIRIUSALERTLIST_ENTRIES][3];
    byte gSAL_InvalidDel[AUDIO_SIRIUSALERTLIST_ENTRIES];
    byte gSAL_DelInvalidCtr, gSAL_DelValidCtr;
    byte gSiriusAlertList_Send[AUDIO_SIRIUSALERTLIST_ENTRIES][2];
    word gSAL_totalDELctr;

    //insert
    byte gSAL_InvalidIns[AUDIO_SIRIUSALERTLIST_ENTRIES];
    byte gSAL_InsInvalidCtr, gSAL_InsValidCtr;
    word gSAL_TotalElem, gSAL_CSVtotalElem;
    byte gSAL_InsertFlg, gSAL_loadReloadFlg;

    //BAP_MOST sync
    //MediaBrowser & ReceptionList - Cover-/StationArt
    word gMemFSGhandle;

    /* 0x32 CommonList */
    byte gCommonList_ASGID = 0;
    byte gCommonList_TAID = 0;
    word gCommonList_TotalNumListElements = 0;

    const AUDIO_COMMONLIST_ENTRIES    = 245;

    int gCommonList_ListEntryValidInformation[AUDIO_COMMONLIST_ENTRIES];

    int gCommonList_Pos[AUDIO_COMMONLIST_ENTRIES];
    int gCommonListLine_sum = 0;

    byte CommonListLine = 0;

    byte gCommonList_SourceType[AUDIO_COMMONLIST_ENTRIES];
    word gCommonList_Attributes[AUDIO_COMMONLIST_ENTRIES];
    byte gCommonList_PresetID[AUDIO_COMMONLIST_ENTRIES];
    byte gCommonList_Category[AUDIO_COMMONLIST_ENTRIES];
    const AUDIO_COMMONLIST_NAME_LENGTH = 49;
    char gCommonList_Name[AUDIO_COMMONLIST_ENTRIES][AUDIO_COMMONLIST_NAME_LENGTH];
    const AUDIO_COMMONLIST_FREQUENCY_LENGTH = 31;
    char gCommonList_Frequency[AUDIO_COMMONLIST_ENTRIES][AUDIO_COMMONLIST_FREQUENCY_LENGTH];

    dword requestarrayCommonListGlobal[BAP_BUFFER_SIZE];
    word offsetCommonListGlobal = 0;

    char gCommonList_CSV_filename[AUDIO_FILENAME_SIZE];

    //VAGH-10511
    byte ASGID, TAID;

    //------------------------------------------------
    /***Picture ***/
    const AUDIO_PICTURE_ENTRIES = 254;
    byte gPicture_ListEntryValidInformation [AUDIO_PICTURE_ENTRIES]; //indicates the existence of the "record element"

    int gPicture_Pos[AUDIO_PICTURE_ENTRIES];

    int gPicture_Type[AUDIO_PICTURE_ENTRIES];
    const AUDIO_PICTURE_TYPE_NOPIC              = 0x00;
    const AUDIO_PICTURE_TYPE_STATIONART_NORMAL  = 0x01;
    const AUDIO_PICTURE_TYPE_COVERART_NORMAL    = 0x02;
    const AUDIO_PICTURE_TYPE_STATIONART_DEFAULT = 0x03;
    const AUDIO_PICTURE_TYPE_COVERART_DEFAULT   = 0x04;
    const AUDIO_PICTURE_TYPE_DYNAMIC            = 0x05;
    const AUDIO_PICTURE_TYPE_UNKNOWNPIC         = 0xFF;

    int gPicture_Handle[AUDIO_PICTURE_ENTRIES];

    const AUDIO_PICTURE_IPADDRESS_LENGTH = 17;
    char gPicture_IpAddress [AUDIO_PICTURE_ENTRIES][AUDIO_PICTURE_IPADDRESS_LENGTH];

    word gPicture_TcpPort[AUDIO_PICTURE_ENTRIES];

    const AUDIO_PICTURE_URI_LENGTH =602;
    char gPicture_Uri [AUDIO_PICTURE_ENTRIES][AUDIO_PICTURE_URI_LENGTH];

    byte gPictureLine_sum = 0;
    byte gPicture_TotalNumListElements = 0;
    byte gPicture_ASGID    = 0;
    byte gPicture_TAID     = 0;
    dword requestarrayPictureGlobal [BAP_BUFFER_SIZE];
    word offsetPictureGlobal;

    char gPicture_CSV_filename[AUDIO_FILENAME_SIZE];
    int tempPictureID = 0;
    int gID_PictureAct;

    /***FavoriteList***/
    byte gFL_ASGID = 0;
    byte gFL_TAID = 0;
    word gFL_TNLE = 0;
    //word gFL_ALP = 0;

    const AUDIO_FAVORITE_NAME_LENGTH = 0xFF;
    const AUDIO_FAVORITE_FREQUENZ_LENGTH = 0xFF;

    word gFL_Pos[AUDIO_FAVORITELIST_ENTRIES];
    word gFL_PresentIndex[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Waveband[AUDIO_FAVORITELIST_ENTRIES];
    char gFL_Waveband_s[14][25] = {"unknown/invalid",
                                    "FM",
                                    "AM(MW:..Mittelwelle )",
                                    "AM( SW:..Kurzwelle )",
                                    "AM(LW:..Langwelle )",
                                    "SDARS-Sirus/XM",
                                    "DAB",
                                    "DVB",
                                    "TV",
                                    "online radio",
                                    "CommonList",
                                    "DMB",
                                    "online TV",
                                    "reverved"
                                    };
    word gFL_Attributes[AUDIO_FAVORITELIST_ENTRIES];

    byte gFL_Attribute_IBOC_Bit0[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Attribute_DABsec_Bit1[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Attribute_DABprim_Bit2[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Attribute_OnlineRadioSec_Bit3[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Attribute_OnlineRadioPrim_Bit4[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Attribute_TP_Bit5[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Attribute_TMC_Bit6[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Attribute_SDARS_Bit7[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Attribute_StationSelc_Bit8[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Attribute_mute_Bit9[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Attribute_StationLinkedORadio_Bit10[AUDIO_FAVORITELIST_ENTRIES];
    byte gFL_Attribute_StationLinkedFM_Bit11[AUDIO_FAVORITELIST_ENTRIES];

    char gFL_Name[AUDIO_FAVORITELIST_ENTRIES][AUDIO_FAVORITE_NAME_LENGTH];
    char gFL_Frequenz[AUDIO_FAVORITELIST_ENTRIES][AUDIO_FAVORITE_FREQUENZ_LENGTH];

    byte gFL_ListEntryValidInformation[AUDIO_FAVORITELIST_ENTRIES]; //indicates the existence of the "record element"
    byte gFL_sum = 0;
    char gFL_CSV_filename[AUDIO_FILENAME_SIZE];

    /***SiriusAlertList***/
    byte gSAL_ASGID = 0;
    byte gSAL_TAID = 0;
    word gSAL_TNLE = 0;

    const AUDIO_SIRIUSALERT_NAME_LENGTH = 0xFF;
    const AUDIO_SIRIUSALERT_FREQUENZ_LENGTH = 0xFF;
    const AUDIO_SIRIUSALERT_ALERTNAME_LENGTH = 0xFF;
    const AUDIO_SIRIUSALERT_EXTENSION_LENGTH = 0xFF;

    word gSAL_Pos[AUDIO_SIRIUSALERTLIST_ENTRIES];
    word gSAL_PresentIndex[AUDIO_SIRIUSALERTLIST_ENTRIES];
    byte gSAL_AlertType[AUDIO_SIRIUSALERTLIST_ENTRIES];
    char gSAL_AlertType_s[8][25] = {"any alert/unknown",
                                    "traffic alert",
                                    "weather alert",
                                    "artist alert",
                                    "song alert",
                                    "sports alert",
                                    "game alert",
                                    "score alert"};

    word gSAL_Attributes[AUDIO_SIRIUSALERTLIST_ENTRIES];
    byte gSAL_Attribute_Available_Bit0[AUDIO_SIRIUSALERTLIST_ENTRIES];
    byte gSAL_Attribute_TP_Bit1[AUDIO_SIRIUSALERTLIST_ENTRIES];
    byte gSAL_Attribute_TMC_Bit2[AUDIO_SIRIUSALERTLIST_ENTRIES];
    byte gSAL_Attribute_SDARS_Bit3[AUDIO_SIRIUSALERTLIST_ENTRIES];
    byte gSAL_Attribute_StationSelect_Bit4[AUDIO_SIRIUSALERTLIST_ENTRIES];
    byte gSAL_Attribute_OnlineRadioMute_Bit5[AUDIO_SIRIUSALERTLIST_ENTRIES];
    byte gSAL_Attribute_StationLinked_Bit6[AUDIO_SIRIUSALERTLIST_ENTRIES];

    char gSAL_Name[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_SIRIUSALERT_NAME_LENGTH];
    char gSAL_Frequenz[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_SIRIUSALERT_FREQUENZ_LENGTH];
    char gSAL_AlertName[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_SIRIUSALERT_ALERTNAME_LENGTH];
    char gSAL_Extension[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_SIRIUSALERT_EXTENSION_LENGTH];

    byte gSAL_ListEntryValidInformation[AUDIO_SIRIUSALERTLIST_ENTRIES]; //indicates the existence of the "record element"
    byte gSAL_sum = 0;
    char gSAL_CSV_filename[AUDIO_FILENAME_SIZE];
    //MR 60227 - Simulation improvement for Integration Testing
    timer _tBapFirst_delayTime;
    timer _tMostFirst_delayTime;
    dword gAudio_Requestarray [BAP_BUFFER_SIZE];
    int gAudio_BuffSize;
    byte gAudio_BAPdataType;
    //for MediaBrowserControl
    timer _tMostFirst_delayTime_MedBrwCtrl;
    dword gAudio_Requestarray_mbCtrl [BAP_BUFFER_SIZE];
    int gAudio_BuffSize_mbCtrl;
    byte gAudio_BAPdataType_mbCtrl;
}

on envVar ON_OFF_FSG49_0
{
    if( getValue( this ) )
    {
        putValue( eAllVol, 1 );
        putValue( ENV_AudioSD_PowerOnOff, 0 );
    }
    else
    {
        putValue( eAllVol, 0 );
    }
}

//BAP_MOST sync
on timer _tMostFirst_delayTime_MedBrwCtrl
{
    set_status_requestbuffer( gAudio_Requestarray_mbCtrl, gAudio_BuffSize_mbCtrl, gAudio_BAPdataType_mbCtrl);
}
//BAP_MOST sync
on timer _tBapFirst_delayTime
{
    BAP2MOSTSync();
}
//BAP_MOST sync
on timer _tMostFirst_delayTime
{
    set_status_requestbuffer( gAudio_Requestarray, gAudio_BuffSize, gAudio_BAPdataType );
}
on preStart
{
}   /* end of method 149318 */

on start
{
    boTraceStatus_ON = getValue( FSG49_WriteTabActivation ); // sync between EnvVar and internal state

    if( boTraceStatus_ON )
    {
        gBAP_Trace = writecreate( "FSG49__AudioSD" );        // write -window for BAP-cummunication
        writeclear( gBAP_Trace );                      // clear BAP-window in write -window
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Audio: FSG Nodeindex:%d", LSGID );
    }

    gError_Trace = writecreate( "Error" );         // error-window for BAP-cummunication
    writeclear( gError_Trace );                    // clear error-window in write -window

    writeclear( 1 );                               // clear CAPL-window in write -window

    NODE_INDEX = Bap180_CreateNode();
    gAudioSD_PowerOnOff = cPower_off; // not yet started
    gBAP_Init = 0;      // not yet initialized
    // CANoe_Shutdown()
    canceltimer( TaskTimer );  //cancel real CAN-communication timer
  //  resetErrfieldColor();      // Ruecksetzen der Hintergrundfarbe der Error-Felder
 //   EnableConfigCtrl();        // deaktivate all active panel elements, except On/Off
}

on stopMeasurement
{
    //Bap180_Shutdown( NODE_INDEX, LSG_AudioSD );
}

on message BAP_Audio_ASG_01    //BAP-message
{
  int i, error;
  byte RX_Data[8];        //received CAN-DATA
  dword RX_Header[3];     //received CAN-Header

  RX_Header[0] =this.CAN;

  RX_Header[1] = this.ID;

  RX_Header[2] = this.DLC; // received length

    // extract CAN data
  for( i = 0; i <this.DLC; i++ ) RX_Data [i] =this.byte( i);

  //send recieved CAN-data with CAN-header to BAP-DLL
  //IssueList #159 - start
  error =Bap180_CAN_SetRxDat( NODE_INDEX,RX_Header,RX_Data );

  switch( ( RX_Data[1] & 0x0F ) )
  {
    //getAll
    case 1: //error
      if( getValue( env_FSG_AudioSD_GetAll_ErrEn )== 0x01 )
      Request_error( FctID_GetAll, getValue( env_FSG_AudioSD_GetAll_ErrCode ) );

      else if( getValue( env_FSG_AudioSD_GetAll_FctEn ) == 0x01 )
      error =Bap180_CAN_SetRxDat( NODE_INDEX,RX_Header,RX_Data );//send recieved CAN-data with CAN-header to BAP-DLL
      break;


    default: error =Bap180_CAN_SetRxDat( NODE_INDEX,RX_Header,RX_Data );    //send recieved CAN-data with CAN-header to BAP-DLL
      break;
  }
  //IssueList #159 - end
  if( error != 0 ) write( "FSG-AudioSD: BAP_CAN_SetRxData: %d", error );
}

on timer TaskTimer
{
  Bap180_Task( NODE_INDEX);    //DLL-Task


    BAP_DLL_Indication();


    BAP_DLL_Request();


    if( getValue( eSendEnabled ) )
    {
        if (getValue(KCAN__NMH_ICAS1_Gateway_CommActive))
	    {
		    BAP_CAN_TX_Request();
	    }
    }


    setTimer( TaskTimer, 10 );    //restart real CAN-communication timer
}

BAP_CAN_TX_Request()
{
    int i;
    byte TX_Data[8];                //CAN-data
    dword TX_Header[3];         //CAN-header
    message 0x100 TX_Message;   //dummy-message

    TX_Header[2] = 8;           // max-Length of TX_Data

    while ( Bap180_CAN_GetTxDat( NODE_INDEX, TX_Header, TX_Data ) == 0 )    //get BAP-data in CAN-format from DLL
    {
        TX_Message.CAN = TX_Header[0];      //CAN channel
        TX_Message.ID = TX_Header[1];       //Can ID
        TX_Message.DLC = TX_Header[2];      //received length

        for( i = 0; i < TX_Message.DLC; i++ )        //CAN data-bytes
            TX_Message.byte( i) = TX_Data[i];

        output( TX_Message );             //send CAN message

        TX_Header[2] = 8;                   // max-Length of TX_Data
    }
}

BAP_DLL_Indication()
{
    int i, length, datalength, temp;
    byte Indication_data[BAP_BUFFER_SIZE];    //indication data from DLL
    dword Indication_header[6];                //indication header from DLL
    byte BAP_data_type;

    //init lokal variables
    length = 0;
    datalength = 0;
    temp = 0;
    BAP_data_type = 0;

    for( i = 0; i < 6; i++ )
        Indication_header[i] = 0;

    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        Indication_data[i] = 0;
    //********************

    Indication_header[4] = BAP_BUFFER_SIZE;                                         //BAP-Stack needs this information for successful BAP_GetIndication

    temp = Bap180_GetInd( NODE_INDEX, Indication_header, Indication_data );               //get BAP-Indication data from DLL
                                                                                        //write( "BAP_GetIndication: %d", temp);                                            //debug

    if( temp == 0 )
    {
        //read header
        gBAP_Indication[0] = Indication_header[0];                                  //LSG-ID
        gBAP_Indication[1] = Indication_header[1];                                  //Function-ID
        gBAP_Indication[2] = Indication_header[2];                                  //indication

        BAP_data_type = Indication_header[3];                                           //BAP data type
                                                                                        //    writelineEx( gBAP_Trace, 0, "Data-Type: %d", BAP_data_type );                    //debug

        switch( BAP_data_type )
        {
            case Bap_Void:
                datalength = 3;
                writelineEx( gBAP_Trace, 0, "FSG-Indication: " );                     //BAL-Trace
                for( i = 0; i < datalength; i++ )                                            //BAL-Trace
                    writeEX( gBAP_Trace, 0, " %x", gBAP_Indication[i] );              //BAL-Trace

                BAP_Indication( datalength );                                                 //evaluate BAP-Indication data
                break;

            case Bap_UInt8:
                gBAP_Indication[3] = Indication_header[5];                          //unit8-value

                datalength = 4;

                /*writelineEx( gBAP_Trace, 0, "Indication_header:" );                    //debug
                    for( i = 0; i <6; i++ )                                                    //debug
                        writeEX( gBAP_Trace, 0, " %x",Indication_header [i] );            //debug
                */
                writelineEx( gBAP_Trace, 0, "FSG-Indication: " );                     //BAL-Trace

                for( i = 0; i < datalength; i++ )                                            //BAL-Trace
                    writeEX( gBAP_Trace, 0, " %x", gBAP_Indication[i] );              //BAL-Trace

                BAP_Indication( datalength );                                                 //evaluate BAP-Indication data
                break;

            case Bap_UInt16:
                gBAP_Indication[3] = Indication_header[5];                          //unit16-value

                datalength = 4;

                /*writelineEx(1, 0, "Indication_header:" );                            //debug
                    for( i = 0; i <6; i++ )                                                    //debug
                        writeEX(1, 0, " %x",Indication_header [i] );                        //debug
                */
                writelineEx( gBAP_Trace, 0, "FSG Indication: " );                     //BAL-Trace

                for( i = 0; i < datalength; i++ )                                            //BAL-Trace
                    writeEX( gBAP_Trace, 0, " %x", gBAP_Indication[i] );              //BAL-Trace

                BAP_Indication( datalength );                                                 //evaluate BAP-Indication data
                break;

            case Bap_UInt32:
                gBAP_Indication[3] = Indication_header[5];                          //unit32-value

                datalength = 4;

                /*writelineEx(1, 0, "Indication_header:" );                            //debug
                    for( i = 0; i <6; i++ )                                                    //debug
                        writeEX(1, 0, " %x",Indication_header [i] );                        //debug
                */

                writelineEx( gBAP_Trace, 0, "FSG Indication: " );                     //BAL-Trace

                for( i = 0; i < datalength; i++ )                                            //BAL-Trace
                    writeEX( gBAP_Trace, 0, " %x", gBAP_Indication[i] );              //BAL-Trace

                BAP_Indication( datalength );                                                 //evaluate BAP-Indication data
                break;

            case Bap_ByteSequence:                                                  //BAP-data-type is byte sequence
                                                                                    //read datalength
                length = Indication_header[4];                                      //length of date -array
                datalength = length + 3;                                                //length of indication-array

                //read data-array
                for( i = 0; i < length; i++ )
                    gBAP_Indication[i + 3] = Indication_data[i];

                /*writelineEx( gBAP_Trace, 0, "Indication_header:" );                    //debug
                for( i = 0; i <6; i++ )                                                    //debug
                    writeEX( gBAP_Trace, 0, " %x",Indication_header [i] );            //debug

                writelineEx( gBAP_Trace, 0, "Indication_data:" );                        //debug
                for( i = 0; i <length; i++ )                                                //debug
                    writeEX( gBAP_Trace, 0, " %x",Indication_data [i] );                //debug
                */

                writelineEx( gBAP_Trace, 0, "FSG-Indication: " );                     //BAL-Trace

                for( i = 0; i < datalength; i++ )                                            //BAL-Trace
                {
                    writeEX( gBAP_Trace, 0, " %x", gBAP_Indication[i] );              //BAL-Trace

                    if( i > 20 )
                    {
                        i = datalength;
                        writeEX( gBAP_Trace, 0, "..." );
                    }
                }

                BAP_Indication( datalength );                                                 //evaluate BAP-Indication data
                break;

            case Bap_Acknowledge: //not used, only at BAP 3.1
                break;

            case Bap_Error:
                gBAP_Indication[2] = Error_IND;                                     //internal indication-value for error
                gBAP_Indication[3] = Indication_header[5];                          //error-code
                datalength = 4;                                             //length of indication-array

                writelineEx( gBAP_Trace, 0, "FSG-Error-Indication: " );               //BAL-Trace
                writeEX( gBAP_Trace, 0, "LSG-ID: 0x%x   ", gBAP_Indication[0] );      //BAL-Trace
                writeEX( gBAP_Trace, 0, "Fct-ID: 0x%x   ", gBAP_Indication[1] );      //BAL-Trace
                                                                                    //writeEX( gBAP_Trace, 0, "Opcode: 0x%x   ", gBAP_Indication[2] );        //BAL-Trace
                writeEX( gBAP_Trace, 0, "Error-Code: 0x%x   ", gBAP_Indication[3] );  //BAL-Trace

                BAP_Indication( datalength );                                                 //evaluate BAP-Indication data
                break;

            default:
                writelineEx( gError_Trace, 0, "FSG BAP_DLL_Indication: invalid BAP-Data-Type: %d", BAP_data_type );
                break;
        }
    }
}

BAP_DLL_Request()
{
    int i, datalength;
    byte temp;
    byte Request_data[BAP_BUFFER_SIZE];    //Request data for DLL
    dword Request_header[6];            //Request header for DLL
    byte error;                         //data-error-flag (Gerusch )

    //init lokal variables
    datalength = 0;
    temp = 0;
    error = 1;

    for( i = 0; i < 6; i++ )
        Request_header[i] = 0;

    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        Request_data[i] = 0;
    //********************


    if( gBAP_Requestbuffer_status[gstatus_requestbuffer] > 0 )                           //if ready to send
    {
        //    writelineEx( gBAP_Trace, 0, "DataTyp: %d", gBAP_Requestbufffer_BAPDataTyp[gstatus_requestbuffer] );
        switch(  gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer] )
        {
            case Bap_Void:
                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
                Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
                Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
                Request_header[3] = gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];   //BAP data type
                Request_header[4] = 0;                                                      //not used
                Request_header[5] = 0;                                                      //not used
                break;

            case Bap_UInt8:
                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
                Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
                Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
                Request_header[3] = gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];   //BAP data type
                Request_header[4] = 0;                                                      //not used
                Request_header[5] = gBAP_Request[gstatus_requestbuffer][3];                 //unit8-value
                break;

            case Bap_UInt16:
                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
                Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
                Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
                Request_header[3] = gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];       //BAP data type
                Request_header[4] = 0;                                                      //not used
                Request_header[5] = gBAP_Request[gstatus_requestbuffer][3];                 //unit16-value
                break;

            case Bap_UInt32:
                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
                Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
                Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
                Request_header[3] = gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];   //BAP data type
                Request_header[4] = 0;                                                      //not used
                Request_header[5] = gBAP_Request[gstatus_requestbuffer][3];                 //unit32-value
                break;

            case Bap_ByteSequence:                  //BAP-data-type is byte sequence
                datalength = gBAP_Requestbuffer_status[gstatus_requestbuffer] - 3;

                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
                Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
                Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
                Request_header[3] = Bap_ByteSequence;                                           //BAP data type
                Request_header[4] = datalength;                                             //length of date -array

                //data-array for BAP-DLL funcion 'BAP_Request'
                for( i = 0; i < datalength; i++ )
                    Request_data[i] = gBAP_Request[gstatus_requestbuffer][i + 3];
			   


                /*writelineEx(1, 0, "Request_header:" );                            //debug
                    for( i = 0; i <6; i++ )                                                //debug
                        writeEX(1, 0, " %x",Request_header [i] );                    //debug

                writelineEx(1, 0, "Request_data:" );                                //debug
                for( i = 0; i <datalength; i++ )                                        //debug
                    writeEX(1, 0, " %x",Request_data [i] );                        //debug
                */
                break;

            case Bap_Acknowledge:// not used only BAP 3.1
                break;

            case Bap_Error:
                //request-array for BAP-DLL funcion 'BAP_Request'
                Request_header[0] = gBAP_Request[gstatus_requestbuffer][0];                 //LSG-ID
                Request_header[1] = gBAP_Request[gstatus_requestbuffer][1];                 //Function-ID
                Request_header[2] = gBAP_Request[gstatus_requestbuffer][2];                 //request
                Request_header[3] = gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer];   //BAP data type
                Request_header[4] = 0;                                                      //not used
                Request_header[5] = gBAP_Request[gstatus_requestbuffer][3];                 //error code
                break;

            default:
                writelineEx( gError_Trace, 0, "BAP_DLL_Request: invalid BAP-Data-Type: %d", gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer] );
                error = 0;
                break;
        }

        if( error )                                                                          //no data-error
        {
            temp = Bap180_Request( NODE_INDEX, Request_header, Request_data );                    //send data to BAP-DLL

            if( temp == 0 )                                                                      //BAP-Request succesful
            {
                //writelineEx( gBAP_Trace, 0, "FSG-Request:    " );                                //BAL-Trace
                //    for( i = 0; i < gBAP_Requestbuffer_status [gstatus_requestbuffer]; i++ )            //BAL-Trace
                //        writeEX( gBAP_Trace, 0, " %x", gBAP_Request [gstatus_requestbuffer] [i] );    //BAL-Trace
                //        write( "Send buffer-element %d to BAP-DLL", gstatus_requestbuffer );             //debug
            }

            else                                                                            //BAP-Request error
            {
                //writelineEx( gBAP_Trace, 0, "FSG Error BAP_Request, errorcode: %x. FSG-Request:", temp);             //debug
                //for( i = 0; i < gBAP_Requestbuffer_status[gstatus_requestbuffer]; i++ )                                  //debug
                //    writeEX( gBAP_Trace, 0, " %x", gBAP_Request[gstatus_requestbuffer][i] );                          //debug
            }
        }

        gBAP_Requestbuffer_status[gstatus_requestbuffer] = 0;       //reset position status -> free position
        gBAP_Requestbuffer_BAPDataTyp[gstatus_requestbuffer] = 0;   //reset BAP-datatyp of sendet buffer element

        //delete sendet request buffer elements
        for( i = 0; i < BAP_BUFFER_SIZE; i++ )
            gBAP_Request[gstatus_requestbuffer][i] = 0;             //delete sended array

        if( gstatus_requestbuffer < ( REQUESTBUFFER_LINES - 1 ) )          //last element of buffer is not reached
            gstatus_requestbuffer++;
        else                                                        //last element of buffer is reached
            gstatus_requestbuffer = 0;
    }
}

BAP_Indication( int datalength )
{
    switch(  gBAP_Indication[0] )
    {
        case LSG_AudioSD:
            AudioSD_functions( datalength );
            break;

        default:
            write( "error BAP_Indication: invalid/unhandled LSG-ID %x", gBAP_Indication[0] );
    }
}

AudioSD_functions( int datalength )
{
    switch(  gBAP_Indication[1] ) // function-ID
    {
        case FctID_FSG_Setup:
            FSG_Setup_Indication( gBAP_Indication, datalength );
            break;
        case FctID_FSG_OperationState:
            FSG_OperationState_Indication( gBAP_Indication, datalength );
            break;
        case FctID_ActiveSource:
            activeSource_Indication( gBAP_Indication, datalength );
            break;
        case FctID_ActiveSourceName:
            activeSourceName_Indication( gBAP_Indication, datalength );
            break;
        case FctID_CurrentVolume:
            currentVolume_Indication( gBAP_Indication, datalength );
            break;
        case FctID_Mute:
            Mute_Indication( gBAP_Indication, datalength );
            break;
        case FctID_SourceState:
            SourceState_Indication( gBAP_Indication, datalength );
            break;
        case FctID_CurrentStationInfo:
            CurrentStationInfo_Indication( gBAP_Indication, datalength );
            break;
        case FctID_CurrentStation_Handle:
            CurrentStationHandle_Indication( gBAP_Indication, datalength );
            break;
        case FctID_ReceptionList:
            ReceptionList_Indication( gBAP_Indication, datalength );
            break;
        case FctID_DedicatedAudioControl:
            DedicatedAudioControl_Indication( gBAP_Indication, datalength );
            break;
        case FctID_GeneralInfoSwitches:
            GeneralInfoSwitches_Indication( gBAP_Indication, datalength );
            break;
        case FctID_TPMemoInfo:
            TPMemoInfo_Indication( gBAP_Indication, datalength );
            break;
        case FctID_TPMemoList:
            TPMemoList_Indication( gBAP_Indication, datalength );
            break;
        case FctID_AnnouncementInfo:
            AnnouncementInfo_Indication( gBAP_Indication, datalength );
            break;
        case FctID_AnnouncementEscape:
            AnnouncementEscape_Indication( gBAP_Indication, datalength );
            break;
        case FctID_InfoStates:
            InfoStates_Indication( gBAP_Indication, datalength );
            break;
        case FctID_ReceptionListType:
            ReceptionListType_Indication( gBAP_Indication, datalength );
            break;
        case FctID_RadioTV_PresetList:
            RadioTVPresetList_Indication( gBAP_Indication, datalength );
            break;
        case FctID_SourceList:
            SourceList_Indication( gBAP_Indication, datalength );
            break;
        case FctID_SwitchSource:
            SwitchSource_Indication( gBAP_Indication, datalength );
            break;
        case FctID_MediaBrowser_FolderLevel:
            MediaBrowserFolderLevel_Indication( gBAP_Indication, datalength );
            break;
        case FctID_MediaBrowser:
            MediaBrowser_Indication( gBAP_Indication, datalength );
            break;
        case FctID_MediaPath:
            MediaPath_Indication( gBAP_Indication, datalength );
            break;
        case FctID_MediaBrowserControl:
            MediaBrowserControl_Indication( gBAP_Indication, datalength );
            break;
        case FctID_MediaFileInfo:
            MediaFileInfo_Indication( gBAP_Indication, datalength );
            break;
        case FctID_PreferredList:
            PreferredList_Indication( gBAP_Indication, datalength );
            break;
        case FctID_SDS_State:
            SDS_State_Indication( gBAP_Indication, datalength );
            break;
        case FctID_FunctionSynchronisation:
            FunctionSynchronisation_Indication( gBAP_Indication, datalength );
            break;
        case FctID_ASG_Capabilities:
            ASGCapabilities_Indication( gBAP_Indication, datalength );
            break;
        case FctID_GetNextListPos:
            GetNextListPos_Indication( gBAP_Indication, datalength );
            break;
        case FctID_SwitchRadioMedia:
            SwitchRadioMedia_Indication( gBAP_Indication, datalength );
            break;
        case FctID_MediaImportState:
            MediaImportState_Indication( gBAP_Indication, datalength );
            break;
        case FctID_CurrentVloumeExtended:
            CurrentVolumeExtended_Indication( gBAP_Indication, datalength );
            break;
        case FctID_CustomerDownloadState:
            CustomerDownloadState_Indication( gBAP_Indication, datalength );
            break;
        case FctID_OnlineMusic_State:
            OnlineMusic_State_Indication( gBAP_Indication, datalength );
            break;
        /*
        case FctID_CommonList:
            CommonList_Indication( gBAP_Indication, datalength );
            break;
        */
        case FctID_SiriusAlertList:
            SiriusAlertList_Indication( gBAP_Indication, datalength );
            break;
        case FctID_CurrentStation_Handle2:
            CurrentStation_Handle2_Indication( gBAP_Indication, datalength );
            break;
        case FctID_PlayPosition:
            PlayPosition_Indication( gBAP_Indication, datalength );
            break;
        case FctID_SDS_RecognizerState:
            SDS_RecognizerState_Indication( gBAP_Indication, datalength );
            break;
        case FctID_CurrentStationInfo2:
            SDS_RecognizerState_Indication( gBAP_Indication, datalength );
            break;
        case FctID_CurrentStation_Handle3:
            CurrentStationHandle3_Indication( gBAP_Indication, datalength );
            break;
        case FctID_LastStationList:
            LastStationList_Indication( gBAP_Indication, datalength );
            break;
        case FctID_SiriusAlertInfo:
            SiriusAlertInfo_Indication( gBAP_Indication, datalength );
            break;
        case FctID_Picture:
            Picture_Indication( gBAP_Indication, datalength );
            break;
        case FctID_FavoriteList:
            FavoriteList_Indication( gBAP_Indication, datalength );
            break;
        case FctID_Station_Track_Switch:
            Station_Track_Switch_Indication( gBAP_Indication, datalength );
            break;
        default:
            write( "FSG_functions: unknown funcion-ID %x", gBAP_Indication[1] );
            break;
    }
}

init_variables()    //initialize/reset all global variables
{
    dword i, j;

    //BAP communication
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        gBAP_Indication[i] = 0;

    //RGB-Values for background colors
    gRGB_red = MakeRGB(255, 0, 0 );
    gRGB_yellow = MakeRGB(255, 255, 0 );
    gRGB_green = MakeRGB( 0, 255, 0 );
    gRGB_grey = MakeRGB(192, 192, 192 );
    gRGB_white = MakeRGB(255, 255, 255);

    for( j = 0; j < REQUESTBUFFER_LINES; j++ )
    {
        gBAP_Requestbuffer_status[j] = 0;
        gBAP_Requestbuffer_BAPDataTyp[j] = 0;

        for( i = 0; i < BAP_BUFFER_SIZE; i++ )
            gBAP_Request[j][i] = 0;
    }

    gwrite_requestbuffer_line = 0;
    gstatus_requestbuffer = 0;


    putvalue( env_AudioSD_Config_SWConfig, xml_path );
    putvalue( env_AudioSD_Config_DBC, dbc_path );

    //FunctionList
    for( i = 0; i < 8; i++ )
        gFunctionList[i] = 0;

    //Byte0
    gFunctionList[0] += ( getvalue( env_AudioSD_FctList_0x01 ) * 0x40 );   //Bit1 - GetAll
    gFunctionList[0] += ( getvalue( env_AudioSD_FctList_0x02 ) * 0x20 );   //Bit2 - BAPConfig
    gFunctionList[0] += ( getvalue( env_AudioSD_FctList_0x03) * 0x10 );   //Bit3 - FunctionList
    gFunctionList[0] += ( getvalue( env_AudioSD_FctList_0x04 ) * 0x08 );   //Bit4 - Heartbeat

    //Byte1
    gFunctionList[1] += ( getvalue( env_AudioSD_FctList_0x0E ) * 0x02 );   //Bit14 - FSG_Setup
    gFunctionList[1] += ( getvalue( env_AudioSD_FctList_0x0F ) * 0x01 );   //Bit15 - FSG_OperationState

    //Byte2
    gFunctionList[2] += ( getvalue( env_AudioSD_FctList_0x10 ) * 0x80 );   //Bit16 - activeSource
    gFunctionList[2] += ( getvalue( env_AudioSD_FctList_0x11 ) * 0x40 );   //Bit17 - activeSourceName
    gFunctionList[2] += ( getvalue( env_AudioSD_FctList_0x12 ) * 0x20 );   //Bit18 - currentVolume
    gFunctionList[2] += ( getvalue( env_AudioSD_FctList_0x13) * 0x10 );   //Bit19 - Mute
    gFunctionList[2] += ( getvalue( env_AudioSD_FctList_0x14 ) * 0x08 );   //Bit20 - SourceState
    gFunctionList[2] += ( getvalue( env_AudioSD_FctList_0x15) * 0x04 );   //Bit21 - currentStationInfo
    gFunctionList[2] += ( getvalue( env_AudioSD_FctList_0x16 ) * 0x02 );   //Bit22 - currentStation_Handle
    gFunctionList[2] += ( getvalue( env_AudioSD_FctList_0x17) * 0x01 );   //Bit23 - ReceptionList

    //Byte3
    gFunctionList[3] += ( getvalue( env_AudioSD_FctList_0x18 ) * 0x80 );   //Bit24 - dedicatedAudioControl
    gFunctionList[3] += ( getvalue( env_AudioSD_FctList_0x19) * 0x40 );   //Bit25 - generalInfoSwitches
    gFunctionList[3] += ( getvalue( env_AudioSD_FctList_0x1A) * 0x20 );   //Bit26 - TpMemoInfo
    gFunctionList[3] += ( getvalue( env_AudioSD_FctList_0x1B) * 0x10 );   //Bit27 - TpMemoList
    gFunctionList[3] += ( getvalue( env_AudioSD_FctList_0x1C) * 0x08 );   //Bit28 - AnnouncementInfo
    gFunctionList[3] += ( getvalue( env_AudioSD_FctList_0x1D) * 0x04 );   //Bit29 - AnnouncementEscape
    gFunctionList[3] += ( getvalue( env_AudioSD_FctList_0x1E ) * 0x02 );   //Bit30 - InfoStates
    gFunctionList[3] += ( getvalue( env_AudioSD_FctList_0x1F ) * 0x01 );   //Bit31 - ReceptionListType

    //Byte4
    gFunctionList[4] += ( getvalue( env_AudioSD_FctList_0x20 ) * 0x80 );   //Bit32 - SourceList
    gFunctionList[4] += ( getvalue( env_AudioSD_FctList_0x21 ) * 0x40 );   //Bit33 - RadioTV_PresetList
    gFunctionList[4] += ( getvalue( env_AudioSD_FctList_0x22 ) * 0x20 );   //Bit34 - SwitchSource
    gFunctionList[4] += ( getvalue( env_AudioSD_FctList_0x23) * 0x10 );   //Bit35 - MediaBrowser_FolderLevel
    gFunctionList[4] += ( getvalue( env_AudioSD_FctList_0x24 ) * 0x08 );   //Bit36 - MediaBrowser
    gFunctionList[4] += ( getvalue( env_AudioSD_FctList_0x25) * 0x04 );   //Bit37 - MediaPath
    gFunctionList[4] += ( getvalue( env_AudioSD_FctList_0x26 ) * 0x02 );   //Bit38 - MediaBrowserControl
    gFunctionList[4] += ( getvalue( env_AudioSD_FctList_0x27) * 0x01 );   //Bit39 - MediaFileInfo

    //Byte5
    gFunctionList[5] += ( getvalue( env_AudioSD_FctList_0x28 ) * 0x80 );   //Bit40 - PreferredList
    gFunctionList[5] += ( getvalue( env_AudioSD_FctList_0x29) * 0x40 );   //Bit41 - MediaFileInfo
    gFunctionList[5] += ( getvalue( env_AudioSD_FctList_0x2A) * 0x20 );   //Bit42 - FunctionSynchronisation
    gFunctionList[5] += ( getvalue( env_AudioSD_FctList_0x2B) * 0x10 );   //Bit43 - ASG_Capabilities
    gFunctionList[5] += ( getvalue( env_AudioSD_FctList_0x2C) * 0x08 );   //Bit44 - GetNextListPos
    gFunctionList[5] += ( getvalue( env_AudioSD_FctList_0x2D) * 0x04 );   //Bit45 - SwitchRadioMedia
    gFunctionList[5] += ( getvalue( env_AudioSD_FctList_0x2E ) * 0x02 );   //Bit46 - MediaImportState
    gFunctionList[5] += ( getvalue( env_AudioSD_FctList_0x2F ) * 0x01 );   //Bit47 - CurrentVolumeExtended

    //Byte6
    gFunctionList[6] += ( getvalue( env_AudioSD_FctList_0x30 ) * 0x80 );   //Bit48 - CustomerDownloadState
    gFunctionList[6] += ( getvalue( env_AudioSD_FctList_0x31 ) * 0x40 );   //Bit49 - OnlineMusic_State
    gFunctionList[6] += ( getvalue( env_AudioSD_FctList_0x32 ) * 0x20 );   //Bit50 - CommonList
    gFunctionList[6] += ( getvalue( env_AudioSD_FctList_0x33) * 0x10 );   //Bit51 - CurrentStation_Handle2
    gFunctionList[6] += ( getvalue( env_AudioSD_FctList_0x34 ) * 0x08 );   //Bit52 - PlayPosition
    gFunctionList[6] += ( getvalue( env_AudioSD_FctList_0x35) * 0x04 );   //Bit53 - SDS_RecognizerState
    gFunctionList[6] += ( getvalue( env_AudioSD_FctList_0x36 ) * 0x02 );   //Bit54 - CurrentStationInfo2
    gFunctionList[6] += ( getvalue( env_AudioSD_FctList_0x37) * 0x01 );   //Bit55 - CurrentStation_Handle3

    //Byte7
    gFunctionList[7] += ( getvalue( env_AudioSD_FctList_0x38 ) * 0x80 );   //Bit56 - LastStationList
    gFunctionList[7] += ( getvalue( env_AudioSD_FctList_0x39) * 0x40 );   //Bit57 - SiriusAlertInfo
    gFunctionList[7] += ( getvalue( env_AudioSD_FctList_0x3A) * 0x20 );   //Bit58 - Picture
    gFunctionList[7] += ( getvalue( env_AudioSD_FctList_0x3B) * 0x10 );   //Bit59 - FavoriteList
    gFunctionList[7] += ( getvalue( env_AudioSD_FctList_0x3C) * 0x08 );   //Bit60 - Station_Track_Switch

    //deactivate FctList-Elements
    enableControl( "FSG_AudioSD_MainPanel", "FSG_0x03_FctList", FALSE );

    //FSG-Setup
    gAudioSD_FSGSetup_maxVolume = 0;
    gAudioSD_FSGSetup_supportedVolumeTypes = 0;
    gAudioSD_FSGSetup_ReceptionList_AutoUpdate = 0;

    gAudioSD_FSGSetup_entertainmentVolume = TRUE;
    gAudioSD_FSGSetup_navigationVolume = TRUE;
    gAudioSD_FSGSetup_announcementVolume = TRUE;
    gAudioSD_FSGSetup_phoneVolume = TRUE;
    gAudioSD_FSGSetup_SDSVolume = TRUE;
    gAudioSD_FSGSetup_phoneRingVolume = TRUE;
    gAudioSD_FSGSetup_carParkingFader = TRUE;
    gAudioSD_FSGSetup_readMessageVolume = TRUE;


    gAudioSD_FSGSetup_FMReceptionList = TRUE;
    gAudioSD_FSGSetup_AMReceptionList = TRUE;
    gAudioSD_FSGSetup_DABReceptionList = TRUE;
    gAudioSD_FSGSetup_SDARSReceptionList = TRUE;
    gAudioSD_FSGSetup_AMLWReceptionList = TRUE;
    gAudioSD_FSGSetup_AMSWReceptionList = TRUE;
    gAudioSD_FSGSetup_TVDVBReceptionList = TRUE;
    gAudioSD_FSGSetup_ORReceptionList = TRUE;

    gAudioSD_FSGSetup_Setup_Extensions_DAB = FALSE;
    gAudioSD_FSGSetup_Setup_Extensions_CL = FALSE;

    gAudioSD_FSGSetup_supportedVolumeTypes = gAudioSD_FSGSetup_entertainmentVolume + gAudioSD_FSGSetup_navigationVolume * 0x02 + gAudioSD_FSGSetup_announcementVolume * 0x04 + gAudioSD_FSGSetup_phoneVolume * 0x08 + gAudioSD_FSGSetup_SDSVolume * 0x10 + gAudioSD_FSGSetup_phoneRingVolume * 0x20 + gAudioSD_FSGSetup_carParkingFader * 0x40 + gAudioSD_FSGSetup_readMessageVolume * 0x80;
    gAudioSD_FSGSetup_ReceptionList_AutoUpdate = gAudioSD_FSGSetup_FMReceptionList + gAudioSD_FSGSetup_AMReceptionList * 0x02 + gAudioSD_FSGSetup_DABReceptionList * 0x04 + gAudioSD_FSGSetup_SDARSReceptionList * 0x08 + gAudioSD_FSGSetup_AMLWReceptionList * 0x10 + gAudioSD_FSGSetup_AMSWReceptionList * 0x20 + gAudioSD_FSGSetup_TVDVBReceptionList * 0x40 + gAudioSD_FSGSetup_ORReceptionList * 0x80;
    gAudioSD_FSGSetup_Setup_Extensions = gAudioSD_FSGSetup_Setup_Extensions_DAB + gAudioSD_FSGSetup_Setup_Extensions_CL * 0x02;

    putvalue( env_AudioSD_FSGSetup_MaxVol, gAudioSD_FSGSetup_maxVolume );

    putvalue( env_AudioSD_FSGSetup_entertainm, gAudioSD_FSGSetup_entertainmentVolume );
    putvalue( env_AudioSD_FSGSetup_Nav, gAudioSD_FSGSetup_navigationVolume );
    putvalue( env_AudioSD_FSGSetup_TA, gAudioSD_FSGSetup_announcementVolume );
    putvalue( env_AudioSD_FSGSetup_Phone, gAudioSD_FSGSetup_phoneVolume );
    putvalue( env_AudioSD_FSGSetup_SDS, gAudioSD_FSGSetup_SDSVolume );
    putvalue( env_AudioSD_FSGSetup_PRVol, gAudioSD_FSGSetup_phoneRingVolume );
    putvalue( env_AudioSD_FSGSetup_CarPF, gAudioSD_FSGSetup_carParkingFader );
    putvalue( env_AudioSD_FSGSetup_RMVol, gAudioSD_FSGSetup_readMessageVolume );

    putvalue( env_AudioSD_FSGSetup_FM, gAudioSD_FSGSetup_FMReceptionList );
    putvalue( env_AudioSD_FSGSetup_AM, gAudioSD_FSGSetup_AMReceptionList );
    putvalue( env_AudioSD_FSGSetup_DAB, gAudioSD_FSGSetup_DABReceptionList );
    putvalue( env_AudioSD_FSGSetup_SDARS, gAudioSD_FSGSetup_SDARSReceptionList );
    putvalue( env_AudioSD_FSGSetup_AMLW, gAudioSD_FSGSetup_AMLWReceptionList );
    putvalue( env_AudioSD_FSGSetup_AMSW, gAudioSD_FSGSetup_AMSWReceptionList );
    putvalue( env_AudioSD_FSGSetup_TV, gAudioSD_FSGSetup_TVDVBReceptionList );
    putvalue( env_AudioSD_FSGSetup_OR, gAudioSD_FSGSetup_ORReceptionList );

    putvalue( env_AudioSD_FSGSetup_Ext_DAB, gAudioSD_FSGSetup_Setup_Extensions_DAB);
    putvalue( env_AudioSD_FSGSetup_Ext_CL, gAudioSD_FSGSetup_Setup_Extensions_CL);

    //FSG-OperationState
    gAudioSD_FSG_OperationState_OpState = FSGOPERATIONSTATE_INITIALIZING;
    gAudioSD_FSG_OperationState_HMI_State = NO_ANIMATION_RUNNING_ON_FSG;

    putvalue( env_AudioSD_FSGOpState_OpState, gAudioSD_FSG_OperationState_OpState );
    putvalue( env_AudioSD_FSGOpState_HMIState, gAudioSD_FSG_OperationState_HMI_State );


    //activeSource
    gAudioSD_activeSource_SourceType = ACTIVESOURCE_SOURCETYPE_FM;
    //IssueList #76 : MR49870 SourceList
    gAudioSD_activeSource_SourceList_Reference   = 1;
    gAudioSD_activeSource_TypeOfNumber = 0;
    gAudioSD_activeSource_ListAvailable = 0;

    gAudioSD_activeSource_ListAvailable = 0;
    gAudioSD_activeSource_ReceptionList = TRUE;
    gAudioSD_activeSource_PresetList = TRUE;
    gAudioSD_activeSource_MediaBrowserList = TRUE;
    gAudioSD_activeSource_SiriusAlertList = TRUE;
    gAudioSD_activeSource_LastStationList = TRUE;
    gAudioSD_activeSource_FavoriteList = TRUE;
    gAudioSD_activeSource_ListAvailable = gAudioSD_activeSource_ReceptionList + gAudioSD_activeSource_PresetList * 0x02 + gAudioSD_activeSource_MediaBrowserList * 0x04 + gAudioSD_activeSource_SiriusAlertList * 0x08;
    gAudioSD_activeSource_ListAvailable2 = gAudioSD_activeSource_LastStationList + gAudioSD_activeSource_FavoriteList * 0x02;

    gAudioSD_activeSource_ListState = ACTIVESOURCE_LISTSTATE_COMPLETELY_LOADED;
    gAudioSD_activeSource_Number = 0;

    putvalue( env_AudioSD_activeSrc_Type, gAudioSD_activeSource_SourceType );
    putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_activeSource_SourceList_Reference );
    putvalue( env_AudioSD_activeSrc_TypeOfNum, gAudioSD_activeSource_TypeOfNumber );
    putvalue( env_AudioSD_activeSrc_ReceptList, gAudioSD_activeSource_ReceptionList );
    putvalue( env_AudioSD_activeSrc_PresetList, gAudioSD_activeSource_PresetList );
    putvalue( env_AudioSD_activeSrc_MedBrList, gAudioSD_activeSource_MediaBrowserList );
    putvalue( env_AudioSD_activeSrc_SAList, gAudioSD_activeSource_SiriusAlertList );
    putvalue( env_AudioSD_activeSrc_LSList, gAudioSD_activeSource_LastStationList );
    putvalue( env_AudioSD_activeSrc_FList, gAudioSD_activeSource_FavoriteList );
    putvalue( env_AudioSD_activeSrc_ListState, gAudioSD_activeSource_ListState );
    putvalue( env_AudioSD_activeSrc_number, gAudioSD_activeSource_Number );


    //activeSourceName
    for( i = 0; i < ACTIVE_SOURCE_NAME_LENGTH; i++ )
        gAudioSD_activeSourceName[i] = 0;

    strncpy( gAudioSD_activeSourceName, "'activeSourceName'", elcount( gAudioSD_activeSourceName ) );

    putvalue( env_AudioSD_activeSourceName, gAudioSD_activeSourceName );


    //currentVolume
    gAudioSD_currentVolume_EntertainmentVolume = 0;
    gAudioSD_currentVolume_NavigationVolume = 0;
    gAudioSD_currentVolume_TaVolume = 0;
    gAudioSD_currentVolume_PhoneVolume = 0;
    gAudioSD_currentVolume_SDSVolume = 0;
    gAudioSD_currentVolume_ChangingVolumeType = 0;

    putvalue( env_AudioSD_currentVolume_EntVol, gAudioSD_currentVolume_EntertainmentVolume );
    putvalue( env_AudioSD_currentVolume_NavVol, gAudioSD_currentVolume_NavigationVolume );
    putvalue( env_AudioSD_currentVolume_TaVol, gAudioSD_currentVolume_TaVolume );
    putvalue( env_AudioSD_currentVolume_PhoVol, gAudioSD_currentVolume_PhoneVolume );
    putvalue( env_AudioSD_currentVolume_SdsVol, gAudioSD_currentVolume_SDSVolume );
    putvalue( env_AudioSD_currentVolume_Change, gAudioSD_currentVolume_ChangingVolumeType );


    //Mute
    gAudioSD_Mute_MuteState = 0;
    gAudioSD_Mute_Entertainment = 0;
    gAudioSD_Mute_DAB = 0;
    gAudioSD_Mute_DVB = 0;
    gAudioSD_Mute_SDARS = 0;
    gAudioSD_Mute_IBOC = 0;
    gAudioSD_Mute_sync_IBOC = 0;
    gAudioSD_Mute_Phone = 0;

    putvalue( env_AudioSD_Mute_Mute, gAudioSD_Mute_Entertainment );
    putvalue( env_AudioSD_Mute_DAB, gAudioSD_Mute_DAB);
    putvalue( env_AudioSD_Mute_DVB, gAudioSD_Mute_DVB);
    putvalue( env_AudioSD_Mute_SDARS, gAudioSD_Mute_SDARS);
    putvalue( env_AudioSD_Mute_IBOC, gAudioSD_Mute_IBOC);
    putvalue( env_AudioSD_Mute_sync_IBOC, gAudioSD_Mute_sync_IBOC);
    putvalue( env_AudioSD_Mute_PhoneCall, gAudioSD_Mute_Phone );
    putvalue( env_AudioSD_Mute_Error_on, FALSE );
    putvalue( env_AudioSD_Mute_ErrorCode, 0 );

    //SourceState
    gAudioSD_SourceState_StateInfo = 0;
    gAudioSD_SourceState_Scope = 0;

    putvalue( env_AudioSD_SourceState_StInfo, gAudioSD_SourceState_StateInfo);
    putvalue( env_AudioSD_SourceState_Scope, gAudioSD_SourceState_Scope );
    putvalue( env_AudioSD_SourceState_StInfo_s, gAudioSD_SourceState_StateInfo_string[gAudioSD_SourceState_StateInfo] );
    putvalue( env_AudioSD_SourceState_Scope_s, gAudioSD_SourceState_Scope_string[gAudioSD_SourceState_Scope] );
    putvalue( env_AudioSD_SourceState_Error_on, FALSE );
    putvalue( env_AudioSD_SourceState_ErrorC, 0 );

    //CurrentStationInfo
    gAudioSD_CSI_PI_Type = 0;
    gAudioSD_CSI_PIID = 0;
    gAudioSD_CSI_SI_Type = 0;
    gAudioSD_CSI_TI_Type = 0;
    gAudioSD_CSI_QI_Type = 0;
    gAudioSD_CSI_StationInfoSwitches = 0;

    gAudioSD_CSI_TATP = TRUE;
    gAudioSD_CSI_TMC = 0;
    gAudioSD_CSI_VICS = 0;
    gAudioSD_CSI_IBOC = 0;
    gAudioSD_CSI_StationInfoSwitches = gAudioSD_CSI_TATP + ( gAudioSD_CSI_TMC * 0x02 ) + ( gAudioSD_CSI_VICS * 0x04 ) + ( gAudioSD_CSI_IBOC * 0x08 );

    gAudioSD_CSI_StationProperties_DABlinked = 0;
    gAudioSD_CSI_StationProperties_IBOC = 0;
    gAudioSD_CSI_StationProperties = gAudioSD_CSI_StationProperties_DABlinked + ( gAudioSD_CSI_StationProperties_IBOC * 0x02 );

    gAudioSD_CSI_ChannelID = 0;

    for( i = 0; i < PRIMARYINFORMATION_TEXTLENGTH; i++ )
        gAudioSD_CSI_PrimaryInformation[i] = 0;

    strncpy( gAudioSD_CSI_PrimaryInformation, "'CSI_PrimaryInformation'", elcount( gAudioSD_CSI_PrimaryInformation ) );

    for( i = 0; i < SECONDARYINFORMATION_TEXTLENGTH; i++ )
        gAudioSD_CSI_SecondaryInformation[i] = 0;

    strncpy( gAudioSD_CSI_SecondaryInformation, "'CSI_SecondaryInformation'", elcount( gAudioSD_CSI_SecondaryInformation ) );

    for( i = 0; i < TERTIARYINFORMATION_TEXTLENGTH; i++ )
        gAudioSD_CSI_TertiaryInformation[i] = 0;

    strncpy( gAudioSD_CSI_TertiaryInformation, "'CSI_TertiaryInformation'", elcount( gAudioSD_CSI_TertiaryInformation ) );

    for( i = 0; i < QUATERNARYINFORMATION_TEXTLENGTH; i++ )
        gAudioSD_CSI_QuarternaryInformation[i] = 0;

    strncpy( gAudioSD_CSI_QuarternaryInformation, "'CSI_QuarternaryInformation'", elcount( gAudioSD_CSI_QuarternaryInformation ) );

    putvalue( env_AudioSD_CSI_PI_s, gAudioSD_CSI_PrimaryInformation );
    putvalue( env_AudioSD_CSI_PIType, gAudioSD_CSI_PI_Type );
    putvalue( env_AudioSD_CSI_SI_s, gAudioSD_CSI_SecondaryInformation );
    putvalue( env_AudioSD_CSI_SIType, gAudioSD_CSI_SI_Type );
    putvalue( env_AudioSD_CSI_TI_s, gAudioSD_CSI_TertiaryInformation );
    putvalue( env_AudioSD_CSI_TIType, gAudioSD_CSI_TI_Type );
    putvalue( env_AudioSD_CSI_QI_s, gAudioSD_CSI_QuarternaryInformation );
    putvalue( env_AudioSD_CSI_QIType, gAudioSD_CSI_QI_Type );
    putvalue( env_AudioSD_CSI_PIID, gAudioSD_CSI_PIID);
    putvalue( env_AudioSD_CSI_ChannelID, gAudioSD_CSI_ChannelID);
    putvalue( env_AudioSD_CSI_StProp_linked, gAudioSD_CSI_StationProperties_DABlinked );
    putvalue( env_AudioSD_CSI_StProp_IBOC, gAudioSD_CSI_StationProperties_IBOC);
    putvalue( env_AudioSD_CSI_TATP, gAudioSD_CSI_TATP );
    putvalue( env_AudioSD_CSI_TMC, gAudioSD_CSI_TMC);
    putvalue( env_AudioSD_CSI_VICS, gAudioSD_CSI_VICS);
    putvalue( env_AudioSD_CSI_IBOC, gAudioSD_CSI_IBOC);
    //IssueList #189
    putValue( env_AudioSD_CSI_StProp_AuSignal, gAudioSD_CSI_StationProperties_DABservice );

    //CurrentStationInfo_Handle
    gAudioSD_CSIhandle_FSGhandle = 0x1;
    gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;
    gAudioSD_CSIhandle_PresetListRef = 0;
    gAudioSD_CSIhandle_PresetListabsolutePos = 0;
    gAudioSD_CSIhandle_DABEnsembleHandle = 0;
    gAudioSD_CSIhandle_DABEnsembleAbsPos = 0;

    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
    putvalue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
    putvalue( env_AudioSD_CSH_PresetListRef, gAudioSD_CSIhandle_PresetListRef );
    putvalue( env_AudioSD_CSH_PresetListAbsPos, gAudioSD_CSIhandle_PresetListabsolutePos );
    putvalue( env_AudioSD_CSH_DABEnsHandle, gAudioSD_CSIhandle_DABEnsembleHandle );
    putvalue( env_AudioSD_CSH_DABEnsAbsPos, gAudioSD_CSIhandle_DABEnsembleAbsPos );

    //GeneralInfoSwitches
    gAudioSD_GeneralInfoSwitches_OnOffSwitches = 0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA = 0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS = 0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic = 0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC = 0;
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS = 0;

    gAudioSD_GeneralInfoSwitches_Modification = 0;
    gAudioSD_GeneralInfoSwitches_Modification_TPTA = 0;
    gAudioSD_GeneralInfoSwitches_Modification_RDS = 0;
    gAudioSD_GeneralInfoSwitches_Modification_JPtraffic = 0;
    gAudioSD_GeneralInfoSwitches_Modification_TMC = 0;
    gAudioSD_GeneralInfoSwitches_Modification_VICS = 0;

    putvalue( env_AudioSD_GIS_OnOff_TPTA, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA);
    putvalue( env_AudioSD_GIS_OnOff_RDS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS);
    putvalue( env_AudioSD_GIS_OnOff_JPtraffic, gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic);
    putvalue( env_AudioSD_GIS_OnOff_TMC, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC);
    putvalue( env_AudioSD_GIS_OnOff_VICS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS);

    putvalue( env_AudioSD_GIS_Mod_TPTA, gAudioSD_GeneralInfoSwitches_Modification_TPTA);
    putvalue( env_AudioSD_GIS_Mod_RDS, gAudioSD_GeneralInfoSwitches_Modification_RDS);
    putvalue( env_AudioSD_GIS_Mod_JPtraffic, gAudioSD_GeneralInfoSwitches_Modification_JPtraffic);
    putvalue( env_AudioSD_GIS_Mod_TMC, gAudioSD_GeneralInfoSwitches_Modification_TMC);
    putvalue( env_AudioSD_GIS_Mod_VICS, gAudioSD_GeneralInfoSwitches_Modification_VICS);

    putvalue( env_AudioSD_GIS_Error_on, FALSE );
    putvalue( env_AudioSD_GIS_ErrorCode, 0 );

    //TPMemoInfo
    gAudioSD_TPMemoInfo_CurrentMsgNumber = 0;
    gAudioSD_TPMemoInfo_TotalMsgNumber = 0;
    gAudioSD_TPMemoInfo_hour = 0;
    gAudioSD_TPMemoInfo_minute = 0;

    for( i = 0; i < STATIONNAME_TEXTLENGTH; i++ )
        gAudioSD_TPMemoInfo_StationName[i] = 0;

    strncpy( gAudioSD_TPMemoInfo_StationName, "'TPMemo_StationName'", elcount( gAudioSD_TPMemoInfo_StationName ) );

    putvalue( env_AudioSD_TPMemInfo_CMN, 0 );
    putvalue( env_AudioSD_TPMemInfo_TMN, 0 );
    putvalue( env_AudioSD_TPMemInfo_hour, 0 );
    putvalue( env_AudioSD_TPMemInfo_min, 0 );
    putvalue( env_AudioSD_TPMemInfo_station_s, gAudioSD_TPMemoInfo_StationName );

    //AnnouncementInfo
    gAudioSD_AnnouncementInfo_Type = ANNOUNCEMENT_TYPE_NO_MESSAGE;

    for( i = 0; i < ANNOUNCEMENT_STATIONNAME_TEXTLENGTH; i++ )
        gAudioSD_AnnouncementInfo_StationName[i] = 0;

    strncpy( gAudioSD_AnnouncementInfo_StationName, "'Announcement_StationName'", elcount( gAudioSD_AnnouncementInfo_StationName ) );

    putvalue( env_AudioSD_AnInfo_Type, 0 );
    putvalue( env_AudioSD_AnInfo_StationName, gAudioSD_AnnouncementInfo_StationName );

    //AnnouncementEscape
    gAudioSD_AnnouncementEscape_Reserve = 0;
    gAudioSD_AnnouncementEscape_Result = 0;

    //InfoStates
    gAudioSD_InfoStates_States = 0;

    putvalue( env_AudioSD_InfoStates_states, gAudioSD_InfoStates_States );

    //ReceptionListType
    gAudioSD_ReceptionListType_Type = 1;

    putvalue( env_AudioSD_RecListType_Type, gAudioSD_ReceptionListType_Type );

    //MediaBrowser_FolderLevel
    gAudioSD_MediaBrowser_FL_FolderLevel = 0;
    gAudioSD_MediaBrowser_FL_RefMediaBrowser = 0;
    gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos = 0;

    putvalue( env_AudioSD_MedBrFoLev_FolLev, gAudioSD_MediaBrowser_FL_FolderLevel);
    putvalue( env_AudioSD_MedBrFoLev_Ref, gAudioSD_MediaBrowser_FL_RefMediaBrowser );
    putvalue( env_AudioSD_MedBrFoLev_Ref_abs, gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos );

    //MediaPath
    gAudioSD_MediaPath_FolderType = 0;

    for( i = 0; i < MEDIAPATH_PATH_TEXTLENGTH; i++ )
        gAudioSD_MediaPath_Path[i] = 0;

    strncpy( gAudioSD_MediaPath_Path, "'MediaPath'", elcount( gAudioSD_MediaPath_Path ) );

    putvalue( env_AudioSD_MedPath_Type, gAudioSD_MediaPath_FolderType );
    putvalue( env_AudioSD_MedPath_Path_s, gAudioSD_MediaPath_Path );

    //PreferredList
    gAudioSD_PreferredList_List = PREFERRED_DEST_LIST_RECEPTION_LIST;

    putvalue( env_AudioSD_PreferredList_List, gAudioSD_PreferredList_List );

    //SDS_State
    gAudioSD_SDSState_State = 0;

    putvalue( env_AudioSD_SDSState_State, gAudioSD_SDSState_State );

    //FunctionSynchronisation
    for( i = 0; i < 8; i++ )
        gAudioSD_FunctionSynchronisation_FctList[i] = 0;

    gAudioSD_FunctionSynchronisation_FctList_Bit16 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit17 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit18 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit19 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit20 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit21 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit22 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit23 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit24 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit25 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit26 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit27 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit28 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit29 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit30 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit31 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit32 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit33 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit34 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit35 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit36 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit37 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit38 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit39 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit40 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit41 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit42 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit43 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit44 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit45 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit46 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_Bit47 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_2_Bit00 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_2_Bit01 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_2_Bit02 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_2_Bit03 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_2_Bit04 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_2_Bit05 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_2_Bit06 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_2_Bit07 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_3_Bit00 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_3_Bit01 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_3_Bit02 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_3_Bit03 = FALSE;
    gAudioSD_FunctionSynchronisation_FctList_3_Bit04 = FALSE;

    putvalue( env_AudioSD_FctSync_Bit16_aS, gAudioSD_FunctionSynchronisation_FctList_Bit16 );
    putvalue( env_AudioSD_FctSync_Bit17_aSn, gAudioSD_FunctionSynchronisation_FctList_Bit17);
    putvalue( env_AudioSD_FctSync_Bit18_cV, gAudioSD_FunctionSynchronisation_FctList_Bit18 );
    putvalue( env_AudioSD_FctSync_Bit19_Mute, gAudioSD_FunctionSynchronisation_FctList_Bit19);
    putvalue( env_AudioSD_FctSync_Bit20_SrcS, gAudioSD_FunctionSynchronisation_FctList_Bit20 );
    putvalue( env_AudioSD_FctSync_Bit21_CSI, gAudioSD_FunctionSynchronisation_FctList_Bit21 );
    putvalue( env_AudioSD_FctSync_Bit22_CSH, gAudioSD_FunctionSynchronisation_FctList_Bit22 );
    putvalue( env_AudioSD_FctSync_Bit23_RL, gAudioSD_FunctionSynchronisation_FctList_Bit23);
    putvalue( env_AudioSD_FctSync_Bit24_DAC, gAudioSD_FunctionSynchronisation_FctList_Bit24 );
    putvalue( env_AudioSD_FctSync_Bit25_GIS, gAudioSD_FunctionSynchronisation_FctList_Bit25);
    putvalue( env_AudioSD_FctSync_Bit26_TPm, gAudioSD_FunctionSynchronisation_FctList_Bit26 );
    putvalue( env_AudioSD_FctSync_Bit27_TPmL, gAudioSD_FunctionSynchronisation_FctList_Bit27);
    putvalue( env_AudioSD_FctSync_Bit28_AnIn, gAudioSD_FunctionSynchronisation_FctList_Bit28 );
    putvalue( env_AudioSD_FctSync_Bit29_AnEs, gAudioSD_FunctionSynchronisation_FctList_Bit29);
    putvalue( env_AudioSD_FctSync_Bit30_InfS, gAudioSD_FunctionSynchronisation_FctList_Bit30 );
    putvalue( env_AudioSD_FctSync_Bit31_RLT, gAudioSD_FunctionSynchronisation_FctList_Bit31 );
    putvalue( env_AudioSD_FctSync_Bit32_SL, gAudioSD_FunctionSynchronisation_FctList_Bit32 );
    putvalue( env_AudioSD_FctSync_Bit33_RTPL, gAudioSD_FunctionSynchronisation_FctList_Bit33);
    putvalue( env_AudioSD_FctSync_Bit34_SwS, gAudioSD_FunctionSynchronisation_FctList_Bit34 );
    putvalue( env_AudioSD_FctSync_Bit35_MBFL, gAudioSD_FunctionSynchronisation_FctList_Bit35);
    putvalue( env_AudioSD_FctSync_Bit36_MB, gAudioSD_FunctionSynchronisation_FctList_Bit36 );
    putvalue( env_AudioSD_FctSync_Bit37_MPa, gAudioSD_FunctionSynchronisation_FctList_Bit37);
    putvalue( env_AudioSD_FctSync_Bit38_MBCt, gAudioSD_FunctionSynchronisation_FctList_Bit38 );
    putvalue( env_AudioSD_FctSync_Bit39_MFIn, gAudioSD_FunctionSynchronisation_FctList_Bit39);
    putvalue( env_AudioSD_FctSync_Bit40_PrfL, gAudioSD_FunctionSynchronisation_FctList_Bit40 );
    putvalue( env_AudioSD_FctSync_Bit41_SDS, gAudioSD_FunctionSynchronisation_FctList_Bit41 );
    putvalue( env_AudioSD_FctSync_Bit42_FctS, gAudioSD_FunctionSynchronisation_FctList_Bit42 );
    putvalue( env_AudioSD_FctSync_Bit43_ASGC, gAudioSD_FunctionSynchronisation_FctList_Bit43);
    putvalue( env_AudioSD_FctSync_Bit44_GNLP, gAudioSD_FunctionSynchronisation_FctList_Bit44 );
    putvalue( env_AudioSD_FctSync_Bit45_SwRdMd, gAudioSD_FunctionSynchronisation_FctList_Bit45);
    putvalue( env_AudioSD_FctSync_Bit46_MedImp, gAudioSD_FunctionSynchronisation_FctList_Bit46 );
    putvalue( env_AudioSD_FctSync_Bit47_CurVol, gAudioSD_FunctionSynchronisation_FctList_Bit47);

    putvalue( env_AudioSD_FctSync_2_Bit00_CurD, gAudioSD_FunctionSynchronisation_FctList_2_Bit00 );
    putvalue( env_AudioSD_FctSync_2_Bit01_ONRA, gAudioSD_FunctionSynchronisation_FctList_2_Bit01 );
    putvalue( env_AudioSD_FctSync_2_Bit02_ComL, gAudioSD_FunctionSynchronisation_FctList_2_Bit02 );
    putvalue( env_AudioSD_FctSync_2_Bit03_CurS, gAudioSD_FunctionSynchronisation_FctList_2_Bit03);
    putvalue( env_AudioSD_FctSync_2_Bit04_PPos, gAudioSD_FunctionSynchronisation_FctList_2_Bit04 );
    putvalue( env_AudioSD_FctSync_2_Bit05_SRS, gAudioSD_FunctionSynchronisation_FctList_2_Bit05);
    putvalue( env_AudioSD_FctSync_2_Bit06_CSI2, gAudioSD_FunctionSynchronisation_FctList_2_Bit06 );
    putvalue( env_AudioSD_FctSync_2_Bit07_CSH3, gAudioSD_FunctionSynchronisation_FctList_2_Bit07);

    putvalue( env_AudioSD_FctSync3_Bit00_LSL, gAudioSD_FunctionSynchronisation_FctList_3_Bit00 );
    putvalue( env_AudioSD_FctSync3_Bit01_SAI, gAudioSD_FunctionSynchronisation_FctList_3_Bit01 );
    putvalue( env_AudioSD_FctSync3_Bit02_Pic, gAudioSD_FunctionSynchronisation_FctList_3_Bit02 );
    putvalue( env_AudioSD_FctSync3_Bit03_FL, gAudioSD_FunctionSynchronisation_FctList_3_Bit03);
    putvalue( env_AudioSD_FctSync3_Bit04_STS, gAudioSD_FunctionSynchronisation_FctList_3_Bit04 );

    //ASG_Capabilities
    gAudioSD_ASGCapabilities_PresentationCapabilities = 0;
    gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 = 0;
    gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1  = 0;

    putvalue( env_AudioSD_ASGCapa_PresCa_DAB, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 );
    //IssueList #189
    putvalue( env_AudioSD_ASGCapa_PresCa_SDARS, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 );
    putvalue( env_AudioSD_ASGCapa_PresCa_DAB_s, empty_string );
    putvalue( env_AudioSD_ASGCapa_Error_on, FALSE );
    putvalue( env_AudioSD_ASGCapa_ErrorCode, 0 );

    //DedicatedAudioControl
    gAudioSD_DAC_status = FALSE;
    gAudioSD_DAC_FSGHandle = 0;
    gAudioSD_DAC_Result = AUDIO_DAC_SUCCESSFUL;
    gAudioSD_DAC_ControlType = AUDIO_DAC_SELECT_LIST_ENTRY;
    gAudioSD_DAC_ListType = AUDIO_DAC_NOLIST;

    putvalue( env_AudioSD_DAC_Res, AUDIO_DAC_SUCCESSFUL);
    putvalue( env_AudioSD_DAC_Abort, AUDIO_DAC_ABORTSUCCESSFUL);

    putvalue( env_AudioSD_DAC_CT_s, empty_string );
    putvalue( env_AudioSD_DAC_FSGHandle, gAudioSD_DAC_FSGHandle );
    putvalue( env_AudioSD_DAC_LT_s, empty_string );

    putvalue( env_AudioSD_DAC_Error_on, FALSE );
    putvalue( env_AudioSD_DAC_ErrorCode, 0 );

    //AnnouncementEscape
    gAudioSD_AnnouncementEscape_status = FALSE;
    gAudioSD_AnnouncementEscape_Result = AUDIO_ANNOUNCEMENTESCAPE_SUCCESSFUL;

    putvalue( env_AudioSD_AnE_Res, AUDIO_ANNOUNCEMENTESCAPE_SUCCESSFUL);
    putvalue( env_AudioSD_AnE_Abort, AUDIO_ANNOUNCEMENTESCAPE_ABORTSUCCESSFUL);
    putvalue( env_AudioSD_AnE_NotActive, 0 );
    putvalue( env_AudioSD_AnE_NotActive, FALSE );

    putvalue( env_AudioSD_AnE_Error_on, FALSE );
    putvalue( env_AudioSD_AnE_ErrorCode, 0 );

    //SwitchSource
    gAudioSD_SwitchSource_status = FALSE;

    gAudioSD_SwitchSource_Reference = 0;
    gAudioSD_SwitchSource_Reserve = 0;
    gAudioSD_SwitchSource_Result = AUDIO_SWITCHSOURCERESULT_SUCCESSFUL;

    putvalue( env_AudioSD_SwitchSource_Ref, 0 );
    putvalue( env_AudioSD_SwitchSource_Result, AUDIO_SWITCHSOURCERESULT_SUCCESSFUL);
    putvalue( env_AudioSD_SwitchSource_Abort, AUDIO_SWITCHSOURCERESULT_ABORT_SUCCESSFUL);

    putvalue( env_AudioSD_SwitchSource_ErrorON, FALSE );
    putvalue( env_AudioSD_SwitchSource_ErrorC, 0 );

    //MediaBrowserControl
    gAudioSD_MediaBrowserControl_status = FALSE;

    gAudioSD_MediaBrowserControl_Control = 0;
    gAudioSD_MediaBrowserControl_Reference = 0;
    gAudioSD_MediaBrowserControl_Reserve = 0;
    gAudioSD_MediaBrowserControl_Result = AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL;

    putvalue( env_AudioSD_MBrC_Ref, 0 );
    putvalue( env_AudioSD_MBrC_Control_s, empty_string );
    putvalue( env_AudioSD_MBrC_Res, AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL);
    putvalue( env_AudioSD_MBrC_Abort, AUDIO_MEDIABROWSERCONTROL_ABORT_SUCCESSFUL);

    putvalue( env_AudioSD_MBrC_Error_on, FALSE );
    putvalue( env_AudioSD_MBrC_ErrorCode, 0 );

    //MediaFileInfo
    gAudioSD_MediaFileInfo_status = FALSE;

    gAudioSD_MediaFileInfo_Reference = 0;
    gAudioSD_MediaFileInfo_Result = 0;

    for( i = 0; i < AUDIO_MEDIAFILINFO_ARTIST_LENGTH; i++ )
        gAudioSD_MediaFileInfo_Artist_s[i] = 0;

    for( i = 0; i < AUDIO_MEDIAFILINFO_TITLE_LENGTH; i++ )
        gAudioSD_MediaFileInfo_Title_s[i] = 0;

    for( i = 0; i < AUDIO_MEDIAFILINFO_ALBUM_LENGTH; i++ )
        gAudioSD_MediaFileInfo_Album_s[i] = 0;

    putvalue( env_AudioSD_MFI_Ref, gAudioSD_MediaFileInfo_Reference );
    putvalue( env_AudioSD_MFI_Artist_s, empty_string );
    putvalue( env_AudioSD_MFI_Title_s, empty_string );
    putvalue( env_AudioSD_MFI_Album_s, empty_string );
    putvalue( env_AudioSD_MFI_Result, AUDIO_MEDIAFILEINFO_SUCCESSFUL);
    putvalue( env_AudioSD_MFI_Abort, AUDIO_MEDIAFILEINFO_ABORT_SUCCESSFUL);

    putvalue( env_AudioSD_MFI_Error_on, FALSE );
    putvalue( env_AudioSD_MFI_ErrorCode, 0 );

    //GetNextListPos
    gAudioSD_GetNextListPos_status = FALSE;
    gAudioSD_GetNextListPos_CurrentPos = 0;
    gAudioSD_GetNextListPos_Offset = 0;
    gAudioSD_GetNextListPos_ListType = 0;
    gAudioSD_GetNextListPos_nextPos = 0;
    gAudioSD_GetNextListPos_absoluteListPos = 0;

    //IssueList #197
    //gAudioSD_GetNextListPos_Result = 0;
    gAudioSD_GetNextListPos_Result = AUDIO_GETNEXTLISTPOS_SUCCESSFUL;

    putvalue( env_AudioSD_GNLP_LT_s, empty_string );
    putvalue( env_AudioSD_GNLP_Offset, gAudioSD_GetNextListPos_Offset );
    putvalue( env_AudioSD_GNLP_CurrPos, gAudioSD_GetNextListPos_CurrentPos );
    putvalue( env_AudioSD_GNLP_nextPos, gAudioSD_GetNextListPos_nextPos );
    putvalue( env_AudioSD_GNLP_absPos, gAudioSD_GetNextListPos_absoluteListPos );
    putvalue( env_AudioSD_GNLP_Result, AUDIO_MEDIAFILEINFO_SUCCESSFUL);
    putvalue( env_AudioSD_GNLP_Abort, AUDIO_MEDIAFILEINFO_ABORT_SUCCESSFUL);
    putvalue( env_AudioSD_GNLP_Offset_VZ_s, empty_string );

    putvalue( env_AudioSD_GNLP_Error_on, FALSE );
    putvalue( env_AudioSD_GNLP_ErrorCode, 0 );

    //array's
    //ReceptionList
    gReceptionList_ASGID = 0;
    gReceptionList_TAID = 0;

    gReceptionList_TotalNumListElements = 0;
    gReceptionList_ElementType = AUDIO_RECEPTIONLISTTYPE_ELEMENTTYPE_ENSEMBLES;
    gReceptionList_ParentID = 0;
    gReceptionList_sum = 0;

    for( j = 0; j < AUDIO_RECEPTIONLIST_ENTRIES; j++ )
    {
        gReceptionList_ListEntryValidInformation[j] = 0;
        gReceptionList_Pos[j] = 0;
        gReceptionList_Type[j] = 0;

        gReceptionList_Attributes_available_Bit0[j] = 0;
        gReceptionList_Attributes_DVB_Bit1[j] = 0;
        gReceptionList_Attributes_DAB_Bit2[j] = 0;
        gReceptionList_Attributes_DAB_Bit3[j] = 0;
        gReceptionList_Attributes_DAB_Bit4[j] = 0;
        gReceptionList_Attributes_TP_Bit5[j] = 0;
        gReceptionList_Attributes_TMC_Bit6[j] = 0;
        gReceptionList_Attributes_SDARS_Bit7[j] = 0;
        gReceptionList_Attributes_DABServ_Bit8[j] = 0;
        gReceptionList_Attributes_FMOnlineRadio_Bit9[j] = 0;
        gReceptionList_Attributes[j] = 0;
        gReceptionList_PresetID[j] = 0;
        gReceptionList_FmRegCode[j] = 0;
        gReceptionList_Category[j] = 0;

        for( i = 0; i < AUDIO_RECEPTIONLIST_NAME_LENGTH; i++ )
            gReceptionList_Name[j][i] = 0;

        for( i = 0; i < AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH; i++ )
            gReceptionList_Frequency[j][i] = 0;
    }

    for( i = 0; i < AUDIO_FILENAME_SIZE; i++ )
        gReceptionList_CSV_filename[i] = 0;

    putvalue( env_AudioSD_RL_ASGID, gReceptionList_ASGID);
    putvalue( env_AudioSD_RL_TAID, gReceptionList_TAID);
    putvalue( env_AudioSD_RL_ParentID, gReceptionList_ParentID);
    putvalue( env_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements );
    putvalue( env_AudioSD_RL_ElementType, gReceptionList_ElementType );
    putvalue( env_AudioSD_RL_AH_shift, FALSE );
    putvalue( env_AudioSD_RL_AH_dir, FORWARD);
    putvalue( env_AudioSD_RL_AH_POS, TRUE );
    putvalue( env_AudioSD_RL_AH_IS, TRUE );
    putvalue( env_AudioSD_RL_AH_RA, 0 );
    //IssueList #76 - MR49870 : ReceptionList
    //putvalue( env_AudioSD_RL_AH_start, 0 );
    putvalue( env_AudioSD_RL_AH_start, 1 );
    putvalue( env_AudioSD_RL_AH_elements, 3);
    putvalue( env_AudioSD_RL_DataSource, 0 );
    putvalue( env_AudioSD_RL_CSVPath, empty_string );
    putvalue( env_AudioSD_RL_DataSource_result, empty_string );
    putvalue( env_AudioSD_RL_DataSource_file, empty_string );
    putvalue( env_AudioSD_RL_CA_switch, FALSE );

    putvalue( env_AudioSD_RL_Error_on, FALSE );
    putvalue( env_AudioSD_RL_ErrorCode, 0 );

    //SourceList
    gSourceList_ASGID = 0;
    gSourceList_TAID = 0;

    gSourceList_TotalNumListElements = 0;
    gSourceList_sum = 0;

    for( j = 0; j < AUDIO_SOURCELIST_ENTRIES; j++ )
    {
        gSourceList_ListEntryValidInformation[j] = 0;
        gSourceList_Pos[j] = 0;
        gSourceList_SourceType[j] = 0;
        gSourceList_InstanceID[j] = 0;
        gSourceList_MediaType[j] = 0;

        gSourceList_Attributes_BuiltIn_Bit0[j] = 0;
        gSourceList_Attributes_MediaError_Bit1[j] = 0;
        gSourceList_Attributes_MediaPlay_Bit2[j] = 0;
        gSourceList_Attributes_MediaRead_Bit3[j] = 0;
        gSourceList_Attributes_MediaLoad_Bit4[j] = 0;
        gSourceList_Attributes_ImportRun_Bit5[j] = 0;
        gSourceList_Attributes_MediaSupp_Bit6[j] = 0;
        gSourceList_Attributes[j] = 0;

        for( i = 0; i < AUDIO_SOURCELIST_NAME_LENGTH; i++ )
            gSourceList_Name[j][i] = 0;
    }

    for( i = 0; i < AUDIO_FILENAME_SIZE; i++ )
        gSourceList_CSV_filename[i] = 0;

    putvalue( env_AudioSD_SL_ASGID, gSourceList_ASGID);
    putvalue( env_AudioSD_SL_TAID, gSourceList_TAID);
    putvalue( env_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements );
    putvalue( env_AudioSD_SL_AH_shift, FALSE );
    putvalue( env_AudioSD_SL_AH_dir, FORWARD);
    putvalue( env_AudioSD_SL_AH_POS, TRUE );
    putvalue( env_AudioSD_SL_AH_IS, TRUE );
    putvalue( env_AudioSD_SL_AH_RA, 0 );
    //IssueList #76 - MR49870 : SourceList
    //putvalue( env_AudioSD_SL_AH_start, 0 );
    putvalue( env_AudioSD_SL_AH_start, 1 );
    putvalue( env_AudioSD_SL_AH_elements, 3);
    putvalue( env_AudioSD_SL_DataSource, 0 );
    putvalue( env_AudioSD_SL_CSVPath, empty_string );
    putvalue( env_AudioSD_SL_DataSource_result, empty_string );
    putvalue( env_AudioSD_SL_DataSource_file, empty_string );
    putvalue( env_AudioSD_SL_CA_switch, FALSE );

    putvalue( env_AudioSD_SL_Error_on, FALSE );
    putvalue( env_AudioSD_SL_ErrorCode, 0 );

    //RadioTVPresetList
    gRadioTVPresetList_ASGID = 0;
    gRadioTVPresetList_TAID = 0;

    gRadioTVPresetList_TotalNumListElements = 0;
    gRadioTVPresetList_sum = 0;

    for( j = 0; j < AUDIO_RADIOTVPRESETLIST_ENTRIES; j++ )
    {
        gRadioTVPresetList_ListEntryValidInformation[j] = 0;
        gRadioTVPresetList_Pos[j] = 0;
        gRadioTVPresetList_PresetIndex[j] = 0;
        gRadioTVPresetList_Waveband[j] = 0;

        gRadioTVPresetList_Attributes_IBOC_Bit0[j] = 0;
        gRadioTVPresetList_Attributes_DABSecServ_Bit1[j] = 0;
        gRadioTVPresetList_Attributes_DABPrimServ_Bit2[j] = 0;
        gRadioTVPresetList_Attributes_TP_Bit5[j] = 0;
        gRadioTVPresetList_Attributes_TMC_Bit6[j] = 0;
        gRadioTVPresetList_Attributes_SDRAS_Bit7[j] = 0;
        gRadioTVPresetList_Attributes[j] = 0;

        for( i = 0; i < AUDIO_RADIOTVPRESETLIST_NAME_LENGTH; i++ )
            gRadioTVPresetList_Name[j][i] = 0;
    }

    for( i = 0; i < AUDIO_FILENAME_SIZE; i++ )
        gRadioTVPresetList_CSV_filename[i] = 0;

    putvalue( env_AudioSD_RTPL_ASGID, gRadioTVPresetList_ASGID);
    putvalue( env_AudioSD_RTPL_TAID, gRadioTVPresetList_TAID);
    putvalue( env_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements );
    putvalue( env_AudioSD_RTPL_AH_shift, FALSE );
    putvalue( env_AudioSD_RTPL_AH_dir, FORWARD);
    putvalue( env_AudioSD_RTPL_AH_POS, TRUE );
    putvalue( env_AudioSD_RTPL_AH_IS, FALSE );
    putvalue( env_AudioSD_RTPL_AH_RA, 0 );
    putvalue( env_AudioSD_RTPL_AH_start, 0 );
    putvalue( env_AudioSD_RTPL_AH_elements, 3);
    putvalue( env_AudioSD_RTPL_DataSource, 0 );
    putvalue( env_AudioSD_RTPL_CSVPath, empty_string );
    putvalue( env_AudioSD_RTPL_DataSource_res, empty_string );
    putvalue( env_AudioSD_RTPL_DataSource_file, empty_string );
    putvalue( env_AudioSD_RTPL_CA_switch, FALSE );

    putvalue( env_AudioSD_RTPL_Error_on, FALSE );
    putvalue( env_AudioSD_RTPL_ErrorCode, 0 );

    //TpMemoList
    gTpMemoList_ASGID = 0;
    gTpMemoList_TAID = 0;

    gTpMemoList_TotalNumListElements = 0;
    gTpMemoList_sum = 0;

    for( j = 0; j < AUDIO_TPMEMOLIST_ENTRIES; j++ )
    {
        gTpMemoList_ListEntryValidInformation[j] = 0;
        gTpMemoList_Pos[j] = 0;

        gTpMemoList_Attributes_MessageNew_Bit0[j] = 0;
        gTpMemoList_Attributes[j] = 0;

        gTpMemoList_Hour[j] = 0;
        gTpMemoList_Minute[j] = 0;

        for( i = 0; i < AUDIO_TPMEMOLIST_STATIONNAME_LENGTH; i++ )
            gTpMemoList_StationName[j][i] = 0;
    }

    for( i = 0; i < AUDIO_FILENAME_SIZE; i++ )
        gTpMemoList_CSV_filename[i] = 0;

    putvalue( env_AudioSD_TML_ASGID, gTpMemoList_ASGID);
    putvalue( env_AudioSD_TML_TAID, gTpMemoList_TAID);
    putvalue( env_AudioSD_TML_TotalNumLE, gTpMemoList_TotalNumListElements );
    putvalue( env_AudioSD_TML_AH_shift, FALSE );
    putvalue( env_AudioSD_TML_AH_dir, FORWARD);
    putvalue( env_AudioSD_TML_AH_POS, TRUE );
    putvalue( env_AudioSD_TML_AH_IS, FALSE );
    putvalue( env_AudioSD_TML_AH_RA, 0 );
    putvalue( env_AudioSD_TML_AH_start, 0 );
    putvalue( env_AudioSD_TML_AH_elements, 3);
    putvalue( env_AudioSD_TML_DataSource, 0 );
    putvalue( env_AudioSD_TML_CSVPath, empty_string );
    putvalue( env_AudioSD_TML_DataSource_res, empty_string );
    putvalue( env_AudioSD_TML_DataSource_file, empty_string );
    putvalue( env_AudioSD_TML_CA_switch, FALSE );

    putvalue( env_AudioSD_TML_Error_on, FALSE );
    putvalue( env_AudioSD_TML_ErrorCode, 0 );

    //MediaBrowser
    gMediaBrowser_ASGID = 0;
    gMediaBrowser_TAID = 0;

    gMediaBrowser_TotalNumListElements = 0;
    //changes from Jran Karl (28.03.2012 )
    gMediaBrowser_ActiveListPos         = 0xFFFF;
    gMediaBrowser_sum = 0;

    for( j = 0; j < AUDIO_MEDIABROWSER_ENTRIES; j++ )
    {
        gMediaBrowser_ListEntryValidInformation[j] = 0;
        gMediaBrowser_Pos[j] = 0;
        gMediaBrowser_FileType[j] = 0;

        gMediaBrowser_FileState_emptyFolder_Bit0[j] = 0;
        gMediaBrowser_FileState_DRM_Bit1[j] = 0;
        gMediaBrowser_FileState_FileCorrupted_Bit2[j] = 0;
        gMediaBrowser_FileState_DeadLink_Bit3[j] = 0;
        gMediaBrowser_FileState_ImportFinished_Bit4[j] = 0;
        gMediaBrowser_FileState_ImportPending_Bit5[j] = 0;
        gMediaBrowser_FileState_ImportPlayable_Bit6[j] = 0;
        gMediaBrowser_FileState[j] = 0;

        for( i = 0; i < AUDIO_MEDIABROWSER_FILENAME_LENGTH; i++ )
            gMediaBrowser_FileName[j][i] = 0;
    }

    for( i = 0; i < AUDIO_FILENAME_SIZE; i++ )
        gMediaBrowser_CSV_filename[i] = 0;

    putvalue( env_AudioSD_MB_ASGID, gMediaBrowser_ASGID);
    putvalue( env_AudioSD_MB_TAID, gMediaBrowser_TAID);
    putvalue( env_AudioSD_MB_ActiveListPos, gMediaBrowser_ActiveListPos );
    putvalue( env_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements );
    putvalue( env_AudioSD_MB_AH_shift, FALSE );
    putvalue( env_AudioSD_MB_AH_dir, FORWARD);
    putvalue( env_AudioSD_MB_AH_POS, TRUE );
    putvalue( env_AudioSD_MB_AH_IS, TRUE );
    putvalue( env_AudioSD_MB_AH_RA, 0 );
    putvalue( env_AudioSD_MB_AH_start, 0 );
    putvalue( env_AudioSD_MB_AH_elements, 3);
    putvalue( env_AudioSD_MB_DataSource, 0 );
    putvalue( env_AudioSD_MB_CSVPath, empty_string );
    putvalue( env_AudioSD_MB_DataSource_result, empty_string );
    putvalue( env_AudioSD_MB_DataSource_file, empty_string );
    putvalue( env_AudioSD_MB_CA_switch, FALSE );

    putvalue( env_AudioSD_MB_Error_on, FALSE );
    putvalue( env_AudioSD_MB_ErrorCode, 0 );

    //ErrorGen
    putvalue( env_AudioSD_ErrorGen_FctID, 0x01 );
    putvalue( env_AudioSD_ErrorGen_ErrorCode, 0x41 );
    putvalue( env_AudioSD_ErrorGen_ErrorCode_h, 0x41 );

   //IssueList #34
   putValue( env_AudioSD_FctList_0x0E_HB , 1 );
   putValue( env_AudioSD_FctList_0x0F_HB , 1 );
   putValue( env_AudioSD_FctList_0x10_HB , 1 );
   putValue( env_AudioSD_FctList_0x11_HB , 1 );
   putValue( env_AudioSD_FctList_0x12_HB , 1 );
   putValue( env_AudioSD_FctList_0x13_HB , 1 );
   putValue( env_AudioSD_FctList_0x14_HB , 1 );
   putValue( env_AudioSD_FctList_0x15_HB , 1 );
   putValue( env_AudioSD_FctList_0x16_HB , 1 );
   putValue( env_AudioSD_FctList_0x19_HB , 1 );
   putValue( env_AudioSD_FctList_0x1A_HB , 1 );
   putValue( env_AudioSD_FctList_0x1C_HB , 1 );
   putValue( env_AudioSD_FctList_0x1E_HB , 1 );
   putValue( env_AudioSD_FctList_0x1F_HB , 1 )
   ;
   putValue( env_AudioSD_FctList_0x23_HB , 1 );
   putValue( env_AudioSD_FctList_0x25_HB , 1 );
   putValue( env_AudioSD_FctList_0x28_HB , 1 );
   putValue( env_AudioSD_FctList_0x29_HB , 1 );
   putValue( env_AudioSD_FctList_0x2A_HB , 1 );
   putValue( env_AudioSD_FctList_0x2B_HB , 1 );

      //IssueList #68
   putValue( env_AudioSD_FctList_0x18_3min_TO, 0 );
   putValue( env_AudioSD_FctList_0x1D_3min_TO, 0 );
   putValue( env_AudioSD_FctList_0x22_3min_TO, 0 );
   putValue( env_AudioSD_FctList_0x27_3min_TO, 0 );
   putValue( env_AudioSD_FctList_0x2C_3min_TO, 0 );
   putValue( env_AudioSD_FctList_0x26_3min_TO, 0 );

   //IssueList #129
   //ReceptionList
   enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar8", FALSE );
   enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar16", FALSE );
   enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Hex8", TRUE );
   enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Hex16", TRUE );

   //SourceList
   enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar8", FALSE );
   enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar16", FALSE );
   enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Hex8", TRUE );
   enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Hex16", TRUE );

   //MediaBrowser
   enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar8", FALSE );
   enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar16", FALSE );
   enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Hex8", TRUE );
   enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Hex16", TRUE );

   //TPMList
   enableControl( "FSG_AudioSD_0x1B - TpMemoList_(array )_delete", "FSG_0x1B_TpMemoList_Envar8", FALSE );
   enableControl( "FSG_AudioSD_0x1B - TpMemoList_(array )_delete", "FSG_0x1B_TpMemoList_Hex8", TRUE );

   //RTPL
   enableControl( "FSG_AudioSD_0x21 - RadioTV_PresetList_(array )_delete", "FSG_0x21_RadioTV_PresetList_Envar8", FALSE );
   enableControl( "FSG_AudioSD_0x21 - RadioTV_PresetList_(array )_delete", "FSG_0x21_RadioTV_PresetList_Hex8", TRUE );

    //IssueList #76 - MR49870
    //ReceptionList
    //insert
   putValue( env_AudioSD_RL_insert_ErrHandler,1 );
   putValue( env_AudioSD_RL_insert_successor, 0 );
   putValue( env_AudioSD_RL_insert_UPD_button, 0 );
   putValue( env_AudioSD_RL_insert_size, 0 );

    //delete
    putValue( env_AudioSD_RL_delete_ErrHandler,1 );
    putValue( env_AudioSD_RL_delete_size, 0 );

    //SourceList
    //insert
   putValue( env_AudioSD_SL_insert_ErrHandler,1 );
   putValue( env_AudioSD_SL_insert_successor, 0 );
   putValue( env_AudioSD_SL_insert_UPD_button, 0 );
   putValue( env_AudioSD_SL_insert_size, 0 );

    //delete
    putValue( env_AudioSD_SL_delete_ErrHandler,1 );
    putValue( env_AudioSD_SL_delete_size, 0 );

    //MediaBrowser
    //insert
   putValue( env_AudioSD_MB_insert_ErrHandler,1 );
   putValue( env_AudioSD_MB_insert_successor, 0 );
   putValue( env_AudioSD_MB_insert_UPD_button, 0 );
   putValue( env_AudioSD_MB_insert_size, 0 );

    //delete
    putValue( env_AudioSD_MB_delete_ErrHandler,1 );
    putValue( env_AudioSD_MB_delete_size, 0 );

    //RTPL
    //insert
   putValue( env_AudioSD_RTPL_insert_ErrHndlr,1 );
   putValue( env_AudioSD_RTPL_insert_succr, 0 );
   putValue( env_AudioSD_RTPL_insert_UPD_btn, 0 );
   putValue( env_AudioSD_RTPL_insert_size, 0 );

    //delete
    putValue( env_AudioSD_RTPL_del_ErrHandler,1 );
    putValue( env_AudioSD_RTPL_delete_size, 0 );


    // ---- Propertys / Methode / Array from DF 4.1


    // 0x2D
    @sysvar::FSG_AudioSD::SwRaMe_Source = 0;
    @sysvar::FSG_AudioSD::SwRaMe_Sourcehex = 0;
    @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRe = 0;
    @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRehex = 0;
    gSwRaMe_SwRaMeReact = 0;
    tempSwRaMe = 0;
    gSwRaMe_Sourceeact = 0;
    tempSwRaMe2 = 0;

    // 0x2E
    @sysvar::FSG_AudioSD::MeImSe_InID = 0;
    @sysvar::FSG_AudioSD::MeImSe_ST = 0;
    @sysvar::FSG_AudioSD::MeImSe_State0 = 1;
    @sysvar::FSG_AudioSD::MeImSe_State1 = 0;
    @sysvar::FSG_AudioSD::MeImSe_SThex = 0;

    // 0x31
    @sysvar::FSG_AudioSD::OnMuSt_BuLvl = 0;
    @sysvar::FSG_AudioSD::OnMuSt_State = 0;
    @sysvar::FSG_AudioSD::OnMuSt_Statehex = 0;

    // 0x30
    @sysvar::FSG_AudioSD::CuDoSt_CuDoSt = 0;
    @sysvar::FSG_AudioSD::CuDoSt_CuDoSthex = 0;
    @sysvar::FSG_AudioSD::CuDoSt_PCD = 0;

    // 0x33
    @sysvar::FSG_AudioSD::CuStHa2_CoList = 0;
    @sysvar::FSG_AudioSD::CuStHa2_CoListAbPo = 0;
    @sysvar::FSG_AudioSD::CuStHa2_CoListAbPohex = 0;
    @sysvar::FSG_AudioSD::CuStHa2_CoListhex = 0;

    // 0x2F
    @sysvar::FSG_AudioSD::CuVoEx_CVT = 0;
    @sysvar::FSG_AudioSD::CuVoEx_CVThex = 0;
    @sysvar::FSG_AudioSD::CuVoEx_GenVol = 0;
    @sysvar::FSG_AudioSD::CuVoEx_MaxVol = 0;
    @sysvar::FSG_AudioSD::CuVoEx_VolS0 = 1;
    @sysvar::FSG_AudioSD::CuVoEx_VolS1 = 0;


    // 0x32
    @sysvar::FSG_AudioSD::ComList_actListPos = 0;
    @sysvar::FSG_AudioSD::ComList_ASG_ID = 0;
    @sysvar::FSG_AudioSD::ComList_DataSource_default = 1;
    @sysvar::FSG_AudioSD::ComList_DataSource_external = 0;
    @sysvar::FSG_AudioSD::ComList_direction_b = 0;
    @sysvar::FSG_AudioSD::ComList_direction_f = 1;
    @sysvar::FSG_AudioSD::ComList_elements = 5;
    @sysvar::FSG_AudioSD::ComList_error_control = 0;
    @sysvar::FSG_AudioSD::ComList_error_code = 0;
    SysSetVariableString(sysvar::FSG_AudioSD::ComList_erternalFile_path, " " );
    @sysvar::FSG_AudioSD::ComList_indexSize_8bit = 1;
    @sysvar::FSG_AudioSD::ComList_indexSize_16bit = 0;
    @sysvar::FSG_AudioSD::ComList_recordaddress = 1;
    @sysvar::FSG_AudioSD::ComList_shift_0 = 1;
    @sysvar::FSG_AudioSD::ComList_shift_1 = 0;
    @sysvar::FSG_AudioSD::ComList_start = 0;
    @sysvar::FSG_AudioSD::ComList_TAID = 1;
    @sysvar::FSG_AudioSD::ComList_TNLE = 0;
    @sysvar::FSG_AudioSD::ComList_transmitPos_0 = 0;
    @sysvar::FSG_AudioSD::ComList_transmitPos_1 = 1;

}

BAP_Set_Cache()    //initialize BAP-FSG-Cache
{
    int Offset;
    dword Cache_Request_Header[6];
    byte Cache_Request_Data[255];
    byte i, error = 0;
    word wTemp;

    /***FctID_FunctionList***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_FunctionList;   //Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 8;                        //length
    Cache_Request_Header[5] = 0;                        //ignored

    for( i = 0; i < 8; i++ )
        Cache_Request_Data[i] = gFunctionList[i];

    Fct_initSendBuf( "FunctionList", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;

    //IssueList #34
    /***FctID_HearBeat***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;            //LSG-ID
    Cache_Request_Header[1] = FctID_HeartBeat;    //Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] =Bap_UInt8;        //data-type
    Cache_Request_Header[4] =8;                        //length
    if( getValue( env_FSG_Audio_HB_button ) )
        Cache_Request_Header[5] = getValue( env_FSG_Audio_HB_input );
    else
        Cache_Request_Header[5] = 0;

    Audio_HBdata[0] = LSG_AudioSD;
    Audio_HBdata[1] = Cache_Request_Header[5];

    ChangeConfig( 0x00,Audio_HBdata );

    Fct_initSendBuf( "Heartbeat", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;

    /***FSG-Setup***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_FSG_Setup;      //Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 4;                        //length
    Cache_Request_Header[5] = 0;                        //ignored

    Cache_Request_Data[0] = gAudioSD_FSGSetup_maxVolume;
    Cache_Request_Data[1] = gAudioSD_FSGSetup_supportedVolumeTypes;
    Cache_Request_Data[2] = gAudioSD_FSGSetup_ReceptionList_AutoUpdate;
    Cache_Request_Data[3] = gAudioSD_FSGSetup_Setup_Extensions;

    Fct_initSendBuf( "FSG-Setup", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***FSG-OperationState ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;              //LSG-ID
    Cache_Request_Header[1] = FctID_FSG_OperationState; //Fct-ID
    Cache_Request_Header[2] = 0;                            //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;         //data-type
    Cache_Request_Header[4] = 2;                            //length
    Cache_Request_Header[5] = 0;                         //ignored

    Cache_Request_Data[0] = gAudioSD_FSG_OperationState_OpState;
    Cache_Request_Data[1] = gAudioSD_FSG_OperationState_HMI_State;

    Fct_initSendBuf( "FSG-OperationState", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***activeSource ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;              //LSG-ID
    Cache_Request_Header[1] = FctID_ActiveSource;       //Fct-ID
    Cache_Request_Header[2] = 0;                            //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;         //data-type
    Cache_Request_Header[4] = 6;                            //length
    Cache_Request_Header[5] = 0;                            //ignored

    Cache_Request_Data[0] = gAudioSD_activeSource_SourceType;
    Cache_Request_Data[1] = gAudioSD_activeSource_SourceList_Reference & 0xff;
    Cache_Request_Data[2] = ( gAudioSD_activeSource_SourceList_Reference & 0xff00 ) / 0x100;
    Cache_Request_Data[3] = ( gAudioSD_activeSource_TypeOfNumber * 0x10 ) + gAudioSD_activeSource_ListAvailable;
    Cache_Request_Data[4] = ( gAudioSD_activeSource_ListState * 0x10 ) + gAudioSD_activeSource_ListAvailable2;
    Cache_Request_Data[5] = gAudioSD_activeSource_Number;

    Fct_initSendBuf( "activeSource", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***activeSourceName ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;                          //LSG-ID
    Cache_Request_Header[1] = FctID_ActiveSourceName;               //Fct-ID
    Cache_Request_Header[2] = 0;                                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;                     //data-type
    Cache_Request_Header[4] = strlen( gAudioSD_activeSourceName ) + 1;   //length
    Cache_Request_Header[5] = 0;                                        //ignored

    Cache_Request_Data[0] = strlen( gAudioSD_activeSourceName );
    Offset = 1;

    for( i = 0; i < strlen( gAudioSD_activeSourceName ); i++ )
    {
        Cache_Request_Data[Offset] = gAudioSD_activeSourceName[i];
        Offset++;
    }

    Fct_initSendBuf( "activeSourceName", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***currentVolume ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;              //LSG-ID
    Cache_Request_Header[1] = FctID_CurrentVolume;      //Fct-ID
    Cache_Request_Header[2] = 0;                            //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;         //data-type
    Cache_Request_Header[4] = 6;                            //length
    Cache_Request_Header[5] = 0;                            //ignored

    Cache_Request_Data[0] = gAudioSD_currentVolume_EntertainmentVolume;
    Cache_Request_Data[1] = gAudioSD_currentVolume_NavigationVolume;
    Cache_Request_Data[2] = gAudioSD_currentVolume_TaVolume;
    Cache_Request_Data[3] = gAudioSD_currentVolume_PhoneVolume;
    Cache_Request_Data[4] = gAudioSD_currentVolume_SDSVolume;
    Cache_Request_Data[5] = gAudioSD_currentVolume_ChangingVolumeType;

    Fct_initSendBuf( "currentVolume", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***Mute ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;              //LSG-ID
    Cache_Request_Header[1] = FctID_Mute;               //Fct-ID
    Cache_Request_Header[2] = 0;                            //ignored
    Cache_Request_Header[3] = Bap_UInt8;                    //data-type
    Cache_Request_Header[4] = 0;                            //ignored
    Cache_Request_Header[5] = gAudioSD_Mute_MuteState;  //value

    Fct_initSendBuf( "Mute", Cache_Request_Header, Cache_Request_Data );


    /***SourceState ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_SourceState;        //Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 2;                        //length
    Cache_Request_Header[5] = 0;                        //ignored

    Cache_Request_Data[0] = gAudioSD_SourceState_StateInfo;
    Cache_Request_Data[1] = gAudioSD_SourceState_Scope;

    Fct_initSendBuf( "SourceState", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***CurrentStationInfo***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;                  //LSG-ID
    Cache_Request_Header[1] = FctID_CurrentStationInfo;     //Fct-ID
    Cache_Request_Header[2] = 0;                                //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;             //data-type
    Cache_Request_Header[4] = strlen( gAudioSD_CSI_PrimaryInformation ) + strlen( gAudioSD_CSI_SecondaryInformation ) + strlen( gAudioSD_CSI_TertiaryInformation ) + strlen( gAudioSD_CSI_QuarternaryInformation ) + 14;//length
    Cache_Request_Header[5] = 0;                                //ignored

    //PrimaryInformation
    Cache_Request_Data[0] = strlen( gAudioSD_CSI_PrimaryInformation );
    Offset = 1;

    for( i = 0; i < strlen( gAudioSD_CSI_PrimaryInformation ); i++ )
    {
        Cache_Request_Data[Offset] = gAudioSD_CSI_PrimaryInformation[i];
        Offset++;
    }

    //PI_Type
    Cache_Request_Data[Offset] = gAudioSD_CSI_PI_Type;
    Offset++;

    //PI_ID
    Cache_Request_Data[Offset] = gAudioSD_CSI_PIID & 0xff;
    Offset++;
    Cache_Request_Data[Offset] = ( gAudioSD_CSI_PIID & 0xff00 ) / 0x100;
    Offset++;

    //SecondaryInformation
    Cache_Request_Data[Offset] = strlen( gAudioSD_CSI_SecondaryInformation );
    Offset++;

    for( i = 0; i < strlen( gAudioSD_CSI_SecondaryInformation ); i++ )
    {
        Cache_Request_Data[Offset] = gAudioSD_CSI_SecondaryInformation[i];
        Offset++;
    }

    //SI_Type
    Cache_Request_Data[Offset] = gAudioSD_CSI_SI_Type;
    Offset++;

    //TertiaryInformation
    Cache_Request_Data[Offset] = strlen( gAudioSD_CSI_TertiaryInformation );
    Offset++;

    for( i = 0; i < strlen( gAudioSD_CSI_TertiaryInformation ); i++ )
    {
        Cache_Request_Data[Offset] = gAudioSD_CSI_TertiaryInformation[i];
        Offset++;
    }

    //TI_Type
    Cache_Request_Data[Offset] = gAudioSD_CSI_TI_Type;
    Offset++;

    //QuaternaryInformation
    Cache_Request_Data[Offset] = strlen( gAudioSD_CSI_QuarternaryInformation );
    Offset++;

    for( i = 0; i < strlen( gAudioSD_CSI_QuarternaryInformation ); i++ )
    {
        Cache_Request_Data[Offset] = gAudioSD_CSI_QuarternaryInformation[i];
        Offset++;
    }

    //QI_Type
    Cache_Request_Data[Offset] = gAudioSD_CSI_QI_Type;
    Offset++;

    //StationInfoSwitches
    Cache_Request_Data[Offset] = gAudioSD_CSI_StationInfoSwitches;
    Offset++;

    //StationProperties
    Cache_Request_Data[Offset] = gAudioSD_CSI_StationProperties;
    Offset++;

    //Channel_ID
    Cache_Request_Data[Offset] = gAudioSD_CSI_ChannelID & 0xff;
    Offset++;
    Cache_Request_Data[Offset] = ( gAudioSD_CSI_ChannelID & 0xff00 ) / 0x100;
    Offset++;

    Fct_initSendBuf( "CurrentStationInfo", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***CurrentStation_Handle ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;                  //LSG-ID
    Cache_Request_Header[1] = FctID_CurrentStation_Handle;  //Fct-ID
    Cache_Request_Header[2] = 0;                                //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;             //data-type
    Cache_Request_Header[4] = 10;                            //length
    Cache_Request_Header[5] = 0;                                //ignored

    Cache_Request_Data[0] = gAudioSD_CSIhandle_FSGhandle & 0xff;
    Cache_Request_Data[1] = ( gAudioSD_CSIhandle_FSGhandle & 0xff00 ) / 0x100;

    Cache_Request_Data[2] = gAudioSD_CSIhandle_FSGhandle_absolutePos & 0xff;
    Cache_Request_Data[3] = ( gAudioSD_CSIhandle_FSGhandle_absolutePos & 0xff00 ) / 0x100;

    Cache_Request_Data[4] = gAudioSD_CSIhandle_PresetListRef;
    Cache_Request_Data[5] = gAudioSD_CSIhandle_PresetListabsolutePos;

    Cache_Request_Data[6] = gAudioSD_CSIhandle_DABEnsembleHandle & 0xff;
    Cache_Request_Data[7] = ( gAudioSD_CSIhandle_DABEnsembleHandle & 0xff00 ) / 0x100;

    Cache_Request_Data[8] = gAudioSD_CSIhandle_DABEnsembleAbsPos & 0xff;
    Cache_Request_Data[9] = ( gAudioSD_CSIhandle_DABEnsembleAbsPos & 0xff00 ) / 0x100;

    Fct_initSendBuf( "CurrentStation_Handle", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***GeneralInfoSwitches ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;              //LSG-ID
    Cache_Request_Header[1] = FctID_GeneralInfoSwitches; //Fct-ID
    Cache_Request_Header[2] = 0;                            //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;         //data-type
    Cache_Request_Header[4] = 2;                            //length
    Cache_Request_Header[5] = 0;                            //ignored

    Cache_Request_Data[0] = gAudioSD_GeneralInfoSwitches_OnOffSwitches;
    Cache_Request_Data[1] = gAudioSD_GeneralInfoSwitches_Modification;

    Fct_initSendBuf( "GeneralInfoSwitches", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***TPMemoInfo***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;                                  //LSG-ID
    Cache_Request_Header[1] = FctID_TPMemoInfo;                             //Fct-ID
    Cache_Request_Header[2] = 0;                                            //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;                             //data-type
    Cache_Request_Header[4] = 5 + strlen( gAudioSD_TPMemoInfo_StationName );  //length
    Cache_Request_Header[5] = 0;                                            //ignored

    Cache_Request_Data[0] = gAudioSD_TPMemoInfo_CurrentMsgNumber;
    Cache_Request_Data[1] = gAudioSD_TPMemoInfo_TotalMsgNumber;
    Cache_Request_Data[2] = gAudioSD_TPMemoInfo_hour;
    Cache_Request_Data[3] = gAudioSD_TPMemoInfo_minute;
    Cache_Request_Data[4] = strlen( gAudioSD_TPMemoInfo_StationName );
    Offset = 5;

    for( i = 0; i < strlen( gAudioSD_TPMemoInfo_StationName ); i++ )
    {
        Cache_Request_Data[Offset] = gAudioSD_TPMemoInfo_StationName[i];
        Offset++;
    }

    Fct_initSendBuf( "TPMemoInfo", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***AnnouncementInfo***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;                                      //LSG-ID
    Cache_Request_Header[1] = FctID_AnnouncementInfo;                           //Fct-ID
    Cache_Request_Header[2] = 0;                                                    //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;                                 //data-type
    Cache_Request_Header[4] = 2 + strlen( gAudioSD_AnnouncementInfo_StationName );    //length
    Cache_Request_Header[5] = 0;                                                    //ignored

    Cache_Request_Data[0] = gAudioSD_AnnouncementInfo_Type;
    Cache_Request_Data[1] = strlen( gAudioSD_AnnouncementInfo_StationName );
    Offset = 2;

    for( i = 0; i < strlen( gAudioSD_AnnouncementInfo_StationName ); i++ )
    {
        Cache_Request_Data[Offset] = gAudioSD_AnnouncementInfo_StationName[i];
        Offset++;
    }

    Fct_initSendBuf( "AnnouncementInfo", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***InfoStates ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;               //LSG-ID
    Cache_Request_Header[1] = FctID_InfoStates;          //Fct-ID
    Cache_Request_Header[2] = 0;                             //ignored
    Cache_Request_Header[3] = Bap_UInt8;                     //data-type
    Cache_Request_Header[4] = 0;                             //ignored
    Cache_Request_Header[5] = gAudioSD_InfoStates_States; //value

    Fct_initSendBuf( "InfoStates", Cache_Request_Header, Cache_Request_Data );


    /***ReceptionListType ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;                      //LSG-ID
    Cache_Request_Header[1] = FctID_ReceptionListType;          //Fct-ID
    Cache_Request_Header[2] = 0;                                //ignored
    Cache_Request_Header[3] = Bap_UInt8;                        //data-type
    Cache_Request_Header[4] = 0;                                //ignored
    Cache_Request_Header[5] = gAudioSD_ReceptionListType_Type;  //value

    Fct_initSendBuf( "ReceptionListType", Cache_Request_Header, Cache_Request_Data );


    /***MediaBrowser_FolderLevel***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_MediaBrowser_FolderLevel;       //Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 5;                        //length
    Cache_Request_Header[5] = 0;                        //ignored

    Cache_Request_Data[0] = gAudioSD_MediaBrowser_FL_FolderLevel;
    Cache_Request_Data[1] = gAudioSD_MediaBrowser_FL_RefMediaBrowser & 0xff;
    Cache_Request_Data[2] = ( gAudioSD_MediaBrowser_FL_RefMediaBrowser & 0xff00 ) / 0x100;
    Cache_Request_Data[3] = gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos & 0xff;
    Cache_Request_Data[4] = ( gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos & 0xff00 ) / 0x100;

    Fct_initSendBuf( "MediaBrowser_FolderLevel", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***MediaPath***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;                      //LSG-ID
    Cache_Request_Header[1] = FctID_MediaPath;                  //Fct-ID
    Cache_Request_Header[2] = 0;                                    //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;                 //data-type
    Cache_Request_Header[4] = strlen( gAudioSD_MediaPath_Path ) + 2; //length
    Cache_Request_Header[5] = 0;                                    //ignored

    Cache_Request_Data[0] = gAudioSD_MediaPath_FolderType;
    Cache_Request_Data[1] = strlen( gAudioSD_MediaPath_Path );
    Offset = 2;

    for( i = 0; i < strlen( gAudioSD_MediaPath_Path ); i++ )
    {
        Cache_Request_Data[Offset] = gAudioSD_MediaPath_Path[i];
        Offset++;
    }

    Fct_initSendBuf( "MediaPath", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***PreferredList***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;                  //LSG-ID
    Cache_Request_Header[1] = FctID_PreferredList;          //Fct-ID
    Cache_Request_Header[2] = 0;                            //ignored
    Cache_Request_Header[3] = Bap_UInt8;                    //data-type
    Cache_Request_Header[4] = 0;                            //ignored
    Cache_Request_Header[5] = gAudioSD_PreferredList_List;  //value

    Fct_initSendBuf( "PreferredList", Cache_Request_Header, Cache_Request_Data );


    /***SDS_State ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;                  //LSG-ID
    Cache_Request_Header[1] = FctID_SDS_State;              //Fct-ID
    Cache_Request_Header[2] = 0;                            //ignored
    Cache_Request_Header[3] = Bap_UInt8;                    //data-type
    Cache_Request_Header[4] = 0;                            //ignored
    Cache_Request_Header[5] = gAudioSD_SDSState_State;      //value

    Fct_initSendBuf( "SDS_State", Cache_Request_Header, Cache_Request_Data );


    /***FunctionSynchronisation ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;                      //LSG-ID
    Cache_Request_Header[1] = FctID_FunctionSynchronisation;    //Fct-ID
    Cache_Request_Header[2] = 0;                                //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;                 //data-type
    Cache_Request_Header[4] = 8;                                //length
    Cache_Request_Header[5] = 0;                                //ignored

    for( i = 0; i < 8; i++ )
        Cache_Request_Data[i] = gAudioSD_FunctionSynchronisation_FctList[i];

    Fct_initSendBuf( "FunctionSynchronisation", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***ASG_Capabilities ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;                                          //LSG-ID
    Cache_Request_Header[1] = FctID_ASG_Capabilities;                               //Fct-ID
    Cache_Request_Header[2] = 0;                                                    //ignored
    Cache_Request_Header[3] = Bap_UInt8;                                            //data-type
    Cache_Request_Header[4] = 0;                                                    //ignored
    Cache_Request_Header[5] = gAudioSD_ASGCapabilities_PresentationCapabilities;    //value

    Fct_initSendBuf( "ASG_Capabilities", Cache_Request_Header, Cache_Request_Data );




    /***MediaImportState ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_MediaImportState;//Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 4;                        //length
    Cache_Request_Header[5] = 0;                        //ignored

    Cache_Request_Data[0] = @sysvar::FSG_AudioSD::MeImSe_SThex;
    Cache_Request_Data[1] = @sysvar::FSG_AudioSD::MeImSe_InID;
    Cache_Request_Data[2] = @sysvar::FSG_AudioSD::MeImSe_State1;
    Cache_Request_Data[3] = @sysvar::FSG_AudioSD::MeImSe_Progress;

    Fct_initSendBuf( "MediaImportState", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***CurrentVolumeExtended***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_CurrentVloumeExtended;//Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 4;                        //length
    Cache_Request_Header[5] = 0;                        //ignored

    Cache_Request_Data[0] = @sysvar::FSG_AudioSD::CuVoEx_CVThex;
    Cache_Request_Data[1] = @sysvar::FSG_AudioSD::CuVoEx_VolS1;
    Cache_Request_Data[2] = @sysvar::FSG_AudioSD::CuVoEx_MaxVol;
    Cache_Request_Data[3] = @sysvar::FSG_AudioSD::CuVoEx_GenVol;

    Fct_initSendBuf( "CurrentVolumeExtended", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***CustomerDownloadState ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_CustomerDownloadState;//Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 2;                        //length
    Cache_Request_Header[5] = 0;                        //ignored

    Cache_Request_Data[0] = @sysvar::FSG_AudioSD::CuDoSt_CuDoSthex;
    Cache_Request_Data[1] = @sysvar::FSG_AudioSD::CuDoSt_PCD;

    Fct_initSendBuf( "CustomerDownloadState", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***OnlineMusic_State ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_OnlineMusic_State;//Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 4;                        //length
    Cache_Request_Header[5] = 0;                        //ignored

    Cache_Request_Data[0] = @sysvar::FSG_AudioSD::OnMuSt_Statehex;
    Cache_Request_Data[1] = @sysvar::FSG_AudioSD::OnMuSt_BuLvl;
    Cache_Request_Data[2] = 0;
    Cache_Request_Data[3] = 0;

    Fct_initSendBuf( "OnlineMusic_State", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;


    /***CurrentStation_Handle2***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_CurrentStation_Handle2;//Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 6;                        //length
    Cache_Request_Header[5] = 0;                        //ignored

    wTemp = @sysvar::FSG_AudioSD::CuStHa2_CoListhex;
    Cache_Request_Data[0] = wTemp & 0xff;
    Cache_Request_Data[1] = (wTemp & 0xff00 ) / 0x100;
    wTemp = @sysvar::FSG_AudioSD::CuStHa2_CoListAbPohex;
    Cache_Request_Data[2] = wTemp & 0xff;
    Cache_Request_Data[3] = (wTemp & 0xff00 ) / 0x100;
    Cache_Request_Data[4] = @sysvar::FSG_AudioSD::CuStHa2_LSListhex;;
    Cache_Request_Data[5] = @sysvar::FSG_AudioSD::CuStHa2_LSListAbPohex;

    Fct_initSendBuf( "CurrentStation_Handle2", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ )
        Cache_Request_Data[i] = 0;

    /***PlayPosition ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_PlayPosition;//Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 6;                        //length
    Cache_Request_Header[5] = 0;                        //ignored

    Cache_Request_Data[0] = @Env_FSG_PP_TP;
    Cache_Request_Data[1] = @Env_FSG_PP_TPT;
    Cache_Request_Data[2] = @Env_FSG_PP_A;
    Cache_Request_Data[3] = @Env_FSG_PP_BL;
    Cache_Request_Data[4] = 0;
    Cache_Request_Data[5] = 0;

    Fct_initSendBuf( "PlayPosition", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ ) Cache_Request_Data[i] = 0;

    /***SDS_RecognizerState ***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_SDS_RecognizerState;//Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 6;                        //length
    Cache_Request_Header[5] = 0;                        //ignored

    Cache_Request_Data[0] = @Env_FSG_SDS_IL;
    Cache_Request_Data[1] = @Env_FSG_SDS_IQ;

    Fct_initSendBuf( "SDS_RecognizerState", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ ) Cache_Request_Data[i] = 0;

    /***CurrentStateInfo2***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_CurrentStationInfo2;//Fct-ID
    Cache_Request_Header[2] = 0;                    //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 25;                   //length
    Cache_Request_Header[5] = 0;                        //ignored
//
//    Cache_Request_Data[0] = @Env_FSG_SDS_IL;
//    Cache_Request_Data[1] = @Env_FSG_SDS_IQ;

    Fct_initSendBuf( "CurrentStateInfo2", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ ) Cache_Request_Data[i] = 0;

    /***CurrentStation_Handle3***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_CurrentStation_Handle3;//Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 6;                        //length
    Cache_Request_Header[5] = 0;                        //ignored
//
//    Cache_Request_Data[0] = @Env_FSG_SDS_IL;
//    Cache_Request_Data[1] = @Env_FSG_SDS_IQ;

    Fct_initSendBuf( "CurrentStation_Handle3", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ ) Cache_Request_Data[i] = 0;

    /***SiriusAlertInfo***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_SiriusAlertInfo;//Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 10;                        //length
    Cache_Request_Header[5] = 0;                        //ignored
//

    Fct_initSendBuf( "SiriusAlertInfo", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ ) Cache_Request_Data[i] = 0;

    /***Station_Track_Switch***/
    //header
    Cache_Request_Header[0] = LSG_AudioSD;          //LSG-ID
    Cache_Request_Header[1] = FctID_Station_Track_Switch;//Fct-ID
    Cache_Request_Header[2] = 0;                        //ignored
    Cache_Request_Header[3] = Bap_ByteSequence;     //data-type
    Cache_Request_Header[4] = 6;                        //length
    Cache_Request_Header[5] = 0;                        //ignored
//

    Fct_initSendBuf( "Station_Track_Switch", Cache_Request_Header, Cache_Request_Data );

    for( i = 0; i < 255; i++ ) Cache_Request_Data[i] = 0;
}

void set_status_requestbuffer( dword Request_array [], int length, byte BAPDataType )
{
    int bufferline = 0, i;

    bufferline = get_requestbuffer_line();

    for( i = 0; i < length; i++ )
        gBAP_Request[bufferline][i] = Request_array[i];

    gBAP_Requestbuffer_status[bufferline] = length;
    gBAP_Requestbuffer_BAPDataTyp[bufferline] = BAPDataType;
}

byte get_requestbuffer_line()    //function to reserve memory in request-ring-buffer
{
    int line;

    //init lokal variables
    line = 0;
    //********************

    line = gwrite_requestbuffer_line;                           //next free element in ring-buffer
    if( gwrite_requestbuffer_line < ( REQUESTBUFFER_LINES - 1 ) )  //last element of ring-buffer is not reached
        gwrite_requestbuffer_line++;
    else                                                    //last element of ring-buffer is reached
        gwrite_requestbuffer_line = 0;

    return ( line );                                            //return position of free ring-buffer element
}

on envVar ENV_AudioSD_PowerOnOff
{
    char BAPVersion [200];
    char Path [255];
    int length, error;
    byte temp;

    if( TRUE == getvalue( this ) )
    {
	    putValue(ON_OFF_FSG49_0, 0);
		
        if( boTraceStatus_ON ) writelineEx( gError_Trace, 0, "Audio: FSG -> ON" );
        getAbsFilePath( dbc_path, Path, 255 ); //**** Loading of CAN database *****
        if( Bap180_LoadDBC( NODE_INDEX, 1, Path ) != 0 )
        {
            { if( boTraceStatus_ON ) writelineEx( gError_Trace, 0, "Audio: Error on loading: %s !", Path ); }
        }
        else
            if( boTraceStatus_ON ) writelineEx( gError_Trace, 0, "Audio: BAP-DBC-File loaded: %s !", Path );
        /**** Laden des BAP XML Files ****/
        getAbsFilePath( xml_path, Path, 255 );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Audio: AWV: Load BAP-XML-File: %s", Path );
        if( BAP160_LoadConfig( NODE_INDEX, Path ) != 0 )
        {        //load XML-File
            if( boTraceStatus_ON ) writelineEx( gError_Trace, 0, "Audio: Fehler beim Laden: %s !", Path );
        }
        else
            if( boTraceStatus_ON ) writelineEx( gError_Trace, 0, "Audio: BAP-XML-File loaded: %s !", Path );

        if( BAP160_AddCanMap( NODE_INDEX, 1, 1 ) != 0 )
        {        // Mapping
            if( boTraceStatus_ON ) writelineEx( gError_Trace, 0, "Audio: Error at Mapping!" );
        }
        // soll der BAP Stack wieder initlialisiert werden?
 //       if( gBAP_Init == 0 ) allways !!!
        {
            temp = BAP160_Init( NODE_INDEX, LSGID );
   //         Init_Arrays();
            if( temp == 0 )
                { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Audio: BAP_Init for %s succesful ( LSG %d, NODE_INDEX %d )", NODE_NAME, LSGID, NODE_INDEX); }
            else
                if( boTraceStatus_ON ) writelineEx( gError_Trace, 0, "Audio: BAP_Init error 0x%X for %s ( LSG %d, NODE_INDEX %d )", temp, NODE_NAME, LSGID, NODE_INDEX);
        }

        //initialize variables
        init_variables();

        //BAP-Shutdown
        temp = BAP160_Shutdown( NODE_INDEX, LSGID );
        if( temp == 0 )
            { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Audio: BAP_Shutdown for %s succesful ( LSG %d, NODE_INDEX %d )", NODE_NAME, LSGID, NODE_INDEX); }
        else
            if( boTraceStatus_ON ) writelineEx( gError_Trace, 0, "Audio: BAP_Shutdown error 0x%X for %s ( LSG %d, NODE_INDEX %d )", temp, NODE_NAME, LSGID, NODE_INDEX);

        // init data for bapconfig message.
        initBapConfig();

        //initialize arrays
        /***IssueList #80 - loading of short lists ***/
        //ReceptionList
        //ReceptionList_init_static();
        putValue( env_AudioSD_ReceptionList_Short,1 );

        //SourceList_init_static();
        putValue( env_AudioSD_SourceList_Short,1 );

        //RadioTVPresetList
        //RadioTVPresetList_init_static();
        putValue( env_AudioSD_RadioTVPreList_Short,1 );

        TpMemoList_init_static();

        //MediaBrowser
        //MediaBrowser_init_static();
        putValue( env_AudioSD_MBList_Short,1 );

        CommonList_initStatic();
        LastStationList_init_static();
        SiriusAlertList_init_static();
        FavoriteList_init_static();
        Picture_init_static();

        //initialize Cache
        BAP_Set_Cache();

        temp = BAP160_Start( NODE_INDEX, LSGID );
        if( temp == 0 )
            { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Audio: BAP_Start for %s succesful ( LSG %d, NODE_INDEX %d )", NODE_NAME, LSGID, NODE_INDEX); }
        else
            if( boTraceStatus_ON ) writelineEx( gError_Trace, 0, "Audio: BAP_Start error 0x%X for %s ( LSG %d, NODE_INDEX %d )", temp, NODE_NAME, LSGID, NODE_INDEX);

        // setze den Timer fuer den zyklischen Aufruf des CANoe -"Tasks"
        // setTimer( TaskTimer, 10 );

        //  BAPFsg_ProcessDebug( NODE_INDEX, DEBUG_CAN_CHANNEL, DEBUG_ID, LSGID, DEBUG_SWITCH_ON );

        settimer( Powerontimer, 20 );
        settimer( StartFSG_Timer,1000 );
    }
    else
    {
        Bap180_Shutdown( NODE_INDEX, LSG_AudioSD );

        gAudioSD_PowerOnOff = getvalue( ENV_AudioSD_PowerOnOff );

        Shutdown_AudioSD();
    }
}

Shutdown_AudioSD()
{
    canceltimer( TaskTimer );

    putvalue( env_AudioSD_Config_SWConfig, empty_string );
    putvalue( env_AudioSD_Config_DBC, empty_string );

    //activate FctList-Elements
    enableControl( "FSG_AudioSD_MainPanel", "FSG_0x03_FctList", TRUE );

    //Properties
    //FSG-Setup
    putvalue( env_AudioSD_FSGSetup_MaxVol, 0 );

    putvalue( env_AudioSD_FSGSetup_entertainm, 0 );
    putvalue( env_AudioSD_FSGSetup_Nav, 0 );
    putvalue( env_AudioSD_FSGSetup_TA, 0 );
    putvalue( env_AudioSD_FSGSetup_Phone, 0 );
    putvalue( env_AudioSD_FSGSetup_SDS, 0 );

    putvalue( env_AudioSD_FSGSetup_FM, 0 );
    putvalue( env_AudioSD_FSGSetup_AM, 0 );
    putvalue( env_AudioSD_FSGSetup_DAB, 0 );
    putvalue( env_AudioSD_FSGSetup_SDARS, 0 );
    putvalue( env_AudioSD_FSGSetup_AMLW, 0 );
    putvalue( env_AudioSD_FSGSetup_AMSW, 0 );
    putvalue( env_AudioSD_FSGSetup_TV, 0 );

    putvalue( env_AudioSD_FSGSetup_Ext_DAB, 0 );

    //FSG-OperationState
    putvalue( env_AudioSD_FSGOpState_OpState, FSGOPERATIONSTATE_OFF );
    putvalue( env_AudioSD_FSGOpState_HMIState, NO_ANIMATION_RUNNING_ON_FSG);

    //activeSource
    putvalue( env_AudioSD_activeSrc_Type, 0 );
    putvalue( env_AudioSD_activeSrc_SLRef, 0 );
    putvalue( env_AudioSD_activeSrc_TypeOfNum, 0 );
    putvalue( env_AudioSD_activeSrc_ReceptList, 0 );
    putvalue( env_AudioSD_activeSrc_PresetList, 0 );
    putvalue( env_AudioSD_activeSrc_MedBrList, 0 );
    putvalue( env_AudioSD_activeSrc_ListState, 0 );
    putvalue( env_AudioSD_activeSrc_number, 0 );

    //activeSourceName
    putvalue( env_AudioSD_activeSourceName, empty_string );

    //currentVolume
    putvalue( env_AudioSD_currentVolume_EntVol, 0 );
    putvalue( env_AudioSD_currentVolume_NavVol, 0 );
    putvalue( env_AudioSD_currentVolume_TaVol, 0 );
    putvalue( env_AudioSD_currentVolume_PhoVol, 0 );
    putvalue( env_AudioSD_currentVolume_SdsVol, 0 );
    putvalue( env_AudioSD_currentVolume_Change, 0 );

    //Mute
    putvalue( env_AudioSD_Mute_Mute, 0 );
    putvalue( env_AudioSD_Mute_DAB, 0 );
    putvalue( env_AudioSD_Mute_DVB, 0 );
    putvalue( env_AudioSD_Mute_SDARS, 0 );
    putvalue( env_AudioSD_Mute_IBOC, 0 );
    //IssueList #33
    //putvalue( env_AudioSD_Mute_sync_IBOC, 0 );
    putvalue( env_AudioSD_Mute_PhoneCall, 0 );

    //SourceState
    putvalue( env_AudioSD_SourceState_StInfo, 0 );
    putvalue( env_AudioSD_SourceState_Scope, 0 );
    putvalue( env_AudioSD_SourceState_Scope_s, empty_string );
    putvalue( env_AudioSD_SourceState_StInfo_s, empty_string );

    //CurrentStationInfo
    putvalue( env_AudioSD_CSI_PI_s, empty_string );
    putvalue( env_AudioSD_CSI_PIType, 0 );
    putvalue( env_AudioSD_CSI_SI_s, empty_string );
    putvalue( env_AudioSD_CSI_SIType, 0 );
    putvalue( env_AudioSD_CSI_TI_s, empty_string );
    putvalue( env_AudioSD_CSI_TIType, 0 );
    putvalue( env_AudioSD_CSI_QI_s, empty_string );
    putvalue( env_AudioSD_CSI_QIType, 0 );
    putvalue( env_AudioSD_CSI_PIID, 0 );
    putvalue( env_AudioSD_CSI_ChannelID, 0 );
    putvalue( env_AudioSD_CSI_StProp_linked, 0 );
    putvalue( env_AudioSD_CSI_StProp_IBOC, 0 );
    putvalue( env_AudioSD_CSI_TATP, 0 );
    putvalue( env_AudioSD_CSI_TMC, 0 );
    putvalue( env_AudioSD_CSI_VICS, 0 );
    putvalue( env_AudioSD_CSI_IBOC, 0 );
    //IssueList #189
    putvalue( env_AudioSD_CSI_StProp_AuSignal, 0 );

    //CurrentStation_Handle
    putvalue( env_AudioSD_CSH_FSGhandle, 0 );
    putvalue( env_AudioSD_CSH_FSGAbsPos, 0 );
    putvalue( env_AudioSD_CSH_PresetListRef, 0 );
    putvalue( env_AudioSD_CSH_PresetListAbsPos, 0 );
    putvalue( env_AudioSD_CSH_DABEnsHandle, 0 );
    putvalue( env_AudioSD_CSH_DABEnsAbsPos, 0 );

    //GeneralInfoSwitches
    putvalue( env_AudioSD_GIS_OnOff_TPTA, 0 );
    putvalue( env_AudioSD_GIS_OnOff_RDS, 0 );
    putvalue( env_AudioSD_GIS_OnOff_JPtraffic, 0 );
    putvalue( env_AudioSD_GIS_OnOff_TMC, 0 );
    putvalue( env_AudioSD_GIS_OnOff_VICS, 0 );

    putvalue( env_AudioSD_GIS_Mod_TPTA, 0 );
    putvalue( env_AudioSD_GIS_Mod_RDS, 0 );
    putvalue( env_AudioSD_GIS_Mod_JPtraffic, 0 );
    putvalue( env_AudioSD_GIS_Mod_TMC, 0 );
    putvalue( env_AudioSD_GIS_Mod_VICS, 0 );

    //TPMemoInfo
    putvalue( env_AudioSD_TPMemInfo_CMN, 0 );
    putvalue( env_AudioSD_TPMemInfo_TMN, 0 );
    putvalue( env_AudioSD_TPMemInfo_hour, 0 );
    putvalue( env_AudioSD_TPMemInfo_min, 0 );
    putvalue( env_AudioSD_TPMemInfo_station_s, empty_string );

    //AnnouncementInfo
    putvalue( env_AudioSD_AnInfo_Type, 0 );
    putvalue( env_AudioSD_AnInfo_StationName, empty_string );

    //InfoStates
    putvalue( env_AudioSD_InfoStates_states, 0 );

    //ReceptionListType
    putvalue( env_AudioSD_RecListType_Type, 0 );

    putvalue( env_AudioSD_DAC_Res, AUDIO_DAC_SUCCESSFUL);
    putvalue( env_AudioSD_DAC_Abort, AUDIO_DAC_ABORTSUCCESSFUL);

    putvalue( env_AudioSD_DAC_CT_s, empty_string );
    putvalue( env_AudioSD_DAC_FSGHandle, 0 );
    putvalue( env_AudioSD_DAC_LT_s, empty_string );

    //MediaBrowser_FolderLevel
    putvalue( env_AudioSD_MedBrFoLev_FolLev, 0 );
    putvalue( env_AudioSD_MedBrFoLev_Ref, 0 );
    putvalue( env_AudioSD_MedBrFoLev_Ref_abs, 0 );

    //MediaPath
    putvalue( env_AudioSD_MedPath_Type, 0 );
    putvalue( env_AudioSD_MedPath_Path_s, empty_string );

    //PreferredList
    putvalue( env_AudioSD_PreferredList_List, 0 );

    //SDS_State
    putvalue( env_AudioSD_SDSState_State, 0 );

    //FunctionSynchronisation
    putvalue( env_AudioSD_FctSync_Bit16_aS, 0 );
    putvalue( env_AudioSD_FctSync_Bit17_aSn, 0 );
    putvalue( env_AudioSD_FctSync_Bit18_cV, 0 );
    putvalue( env_AudioSD_FctSync_Bit19_Mute, 0 );
    putvalue( env_AudioSD_FctSync_Bit20_SrcS, 0 );
    putvalue( env_AudioSD_FctSync_Bit21_CSI, 0 );
    putvalue( env_AudioSD_FctSync_Bit22_CSH, 0 );
    putvalue( env_AudioSD_FctSync_Bit23_RL, 0 );
    putvalue( env_AudioSD_FctSync_Bit24_DAC, 0 );
    putvalue( env_AudioSD_FctSync_Bit25_GIS, 0 );
    putvalue( env_AudioSD_FctSync_Bit26_TPm, 0 );
    putvalue( env_AudioSD_FctSync_Bit27_TPmL, 0 );
    putvalue( env_AudioSD_FctSync_Bit28_AnIn, 0 );
    putvalue( env_AudioSD_FctSync_Bit29_AnEs, 0 );
    putvalue( env_AudioSD_FctSync_Bit30_InfS, 0 );
    putvalue( env_AudioSD_FctSync_Bit31_RLT, 0 );
    putvalue( env_AudioSD_FctSync_Bit32_SL, 0 );
    putvalue( env_AudioSD_FctSync_Bit33_RTPL, 0 );
    putvalue( env_AudioSD_FctSync_Bit34_SwS, 0 );
    putvalue( env_AudioSD_FctSync_Bit35_MBFL, 0 );
    putvalue( env_AudioSD_FctSync_Bit36_MB, 0 );
    putvalue( env_AudioSD_FctSync_Bit37_MPa, 0 );
    putvalue( env_AudioSD_FctSync_Bit38_MBCt, 0 );
    putvalue( env_AudioSD_FctSync_Bit39_MFIn, 0 );
    putvalue( env_AudioSD_FctSync_Bit40_PrfL, 0 );
    putvalue( env_AudioSD_FctSync_Bit41_SDS, 0 );
    putvalue( env_AudioSD_FctSync_Bit42_FctS, 0 );
    putvalue( env_AudioSD_FctSync_Bit43_ASGC, 0 );
    putvalue( env_AudioSD_FctSync_Bit44_GNLP, 0 );

    //ASG_Capabilities
    putvalue( env_AudioSD_ASGCapa_PresCa_DAB, 0 );
    putvalue( env_AudioSD_ASGCapa_PresCa_DAB_s, empty_string );

    //methods
    //DedicatedAudioControl
    gAudioSD_DAC_status = FALSE;
    canceltimer( DAC_Timer );

    putvalue( env_AudioSD_DAC_Res, AUDIO_DAC_SUCCESSFUL);
    putvalue( env_AudioSD_DAC_Abort, AUDIO_DAC_ABORTSUCCESSFUL);

    putvalue( env_AudioSD_DAC_CT_s, empty_string );
    putvalue( env_AudioSD_DAC_FSGHandle, 0 );
    putvalue( env_AudioSD_DAC_LT_s, empty_string );

    //AnnouncementEscape
    gAudioSD_AnnouncementEscape_status = FALSE;
    canceltimer( AnnouncementEscape_Timer );

    putvalue( env_AudioSD_AnE_Res, AUDIO_ANNOUNCEMENTESCAPE_SUCCESSFUL);
    putvalue( env_AudioSD_AnE_Abort, AUDIO_ANNOUNCEMENTESCAPE_ABORTSUCCESSFUL);
    putvalue( env_AudioSD_AnE_NotActive, FALSE );

    //SwitchSource
    gAudioSD_SwitchSource_status = FALSE;
    canceltimer( SwitchSource_Timer );

    putvalue( env_AudioSD_SwitchSource_Ref, 0 );
    putvalue( env_AudioSD_SwitchSource_Result, AUDIO_SWITCHSOURCERESULT_SUCCESSFUL);
    putvalue( env_AudioSD_SwitchSource_Abort, AUDIO_SWITCHSOURCERESULT_ABORT_SUCCESSFUL);

    //MediaBrowserControl
    gAudioSD_MediaBrowserControl_status = FALSE;
    canceltimer(MediaBrowserControl_Timer );

    putvalue( env_AudioSD_MBrC_Ref, 0 );
    putvalue( env_AudioSD_MBrC_Control_s, empty_string );
    putvalue( env_AudioSD_MBrC_Res, AUDIO_MEDIABROWSERCONTROL_SUCCESSFUL);
    putvalue( env_AudioSD_MBrC_Abort, AUDIO_MEDIABROWSERCONTROL_ABORT_SUCCESSFUL);

    //MediaFileInfo
    gAudioSD_MediaFileInfo_status = FALSE;
    canceltimer(MediaFileInfo_Timer );

    putvalue( env_AudioSD_MFI_Ref, 0 );
    putvalue( env_AudioSD_MFI_Artist_s, empty_string );
    putvalue( env_AudioSD_MFI_Title_s, empty_string );
    putvalue( env_AudioSD_MFI_Album_s, empty_string );
    putvalue( env_AudioSD_MFI_Result, AUDIO_MEDIAFILEINFO_SUCCESSFUL);
    putvalue( env_AudioSD_MFI_Abort, AUDIO_MEDIAFILEINFO_ABORT_SUCCESSFUL);

    //GetNextListPos
    gAudioSD_GetNextListPos_status = FALSE;
    canceltimer(GetNextListPos_Timer );

    putvalue( env_AudioSD_GNLP_LT_s, empty_string );
    putvalue( env_AudioSD_GNLP_Offset, 0 );
    putvalue( env_AudioSD_GNLP_CurrPos, 0 );
    putvalue( env_AudioSD_GNLP_nextPos, 0 );
    putvalue( env_AudioSD_GNLP_absPos, 0 );
    putvalue( env_AudioSD_GNLP_Result, AUDIO_MEDIAFILEINFO_SUCCESSFUL);
    putvalue( env_AudioSD_GNLP_Abort, AUDIO_MEDIAFILEINFO_ABORT_SUCCESSFUL);
    putvalue( env_AudioSD_GNLP_Offset_VZ_s, empty_string );

    //array's
    //ReceptionList
    putvalue( env_AudioSD_RL_ASGID, 0 );
    putvalue( env_AudioSD_RL_TAID, 0 );
    putvalue( env_AudioSD_RL_ParentID, 0 );
    putvalue( env_AudioSD_RL_TotalNumLE, 0 );
    putvalue( env_AudioSD_RL_ElementType, AUDIO_RECEPTIONLISTTYPE_ELEMENTTYPE_ENSEMBLES);
    putvalue( env_AudioSD_RL_AH_shift, FALSE );
    putvalue( env_AudioSD_RL_AH_dir, FORWARD);
    putvalue( env_AudioSD_RL_AH_POS, FALSE );
    putvalue( env_AudioSD_RL_AH_IS, FALSE );
    putvalue( env_AudioSD_RL_AH_RA, 0 );
    putvalue( env_AudioSD_RL_AH_start, 0 );
    putvalue( env_AudioSD_RL_AH_elements, 0 );
    putvalue( env_AudioSD_RL_DataSource, 0 );
    putvalue( env_AudioSD_RL_CSVPath, empty_string );
    putvalue( env_AudioSD_RL_DataSource_result, empty_string );
    putvalue( env_AudioSD_RL_DataSource_file, empty_string );
    putvalue( env_AudioSD_RL_CA_switch, FALSE );

    putvalue( env_AudioSD_RL_Error_on, FALSE );
    putvalue( env_AudioSD_RL_ErrorCode, 0 );

    //SourceList
    putvalue( env_AudioSD_SL_ASGID, 0 );
    putvalue( env_AudioSD_SL_TAID, 0 );
    putvalue( env_AudioSD_SL_TotalNumLE, 0 );
    putvalue( env_AudioSD_SL_AH_shift, FALSE );
    putvalue( env_AudioSD_SL_AH_dir, FORWARD);
    putvalue( env_AudioSD_SL_AH_POS, FALSE );
    putvalue( env_AudioSD_SL_AH_IS, FALSE );
    putvalue( env_AudioSD_SL_AH_RA, 0 );
    putvalue( env_AudioSD_SL_AH_start, 0 );
    putvalue( env_AudioSD_SL_AH_elements, 0 );
    putvalue( env_AudioSD_SL_DataSource, 0 );
    putvalue( env_AudioSD_SL_CSVPath, empty_string );
    putvalue( env_AudioSD_SL_DataSource_result, empty_string );
    putvalue( env_AudioSD_SL_DataSource_file, empty_string );
    putvalue( env_AudioSD_SL_CA_switch, FALSE );

    putvalue( env_AudioSD_SL_Error_on, FALSE );
    putvalue( env_AudioSD_SL_ErrorCode, 0 );

    //RadioTVPresetList
    putvalue( env_AudioSD_RTPL_ASGID, 0 );
    putvalue( env_AudioSD_RTPL_TAID, 0 );
    putvalue( env_AudioSD_RTPL_TotalNumLE, 0 );
    putvalue( env_AudioSD_RTPL_AH_shift, FALSE );
    putvalue( env_AudioSD_RTPL_AH_dir, FORWARD);
    putvalue( env_AudioSD_RTPL_AH_POS, FALSE );
    putvalue( env_AudioSD_RTPL_AH_RA, 0 );
    putvalue( env_AudioSD_RTPL_AH_start, 0 );
    putvalue( env_AudioSD_RTPL_AH_elements, 0 );
    putvalue( env_AudioSD_RTPL_DataSource, 0 );
    putvalue( env_AudioSD_RTPL_CSVPath, empty_string );
    putvalue( env_AudioSD_RTPL_DataSource_res, empty_string );
    putvalue( env_AudioSD_RTPL_DataSource_file, empty_string );
    putvalue( env_AudioSD_RTPL_CA_switch, FALSE );

    putvalue( env_AudioSD_RTPL_Error_on, FALSE );
    putvalue( env_AudioSD_RTPL_ErrorCode, 0 );

    //TpMemoList
    putvalue( env_AudioSD_TML_ASGID, 0 );
    putvalue( env_AudioSD_TML_TAID, 0 );
    putvalue( env_AudioSD_TML_TotalNumLE, 0 );
    putvalue( env_AudioSD_TML_AH_shift, FALSE );
    putvalue( env_AudioSD_TML_AH_dir, FORWARD);
    putvalue( env_AudioSD_TML_AH_POS, FALSE );
    putvalue( env_AudioSD_TML_AH_RA, 0 );
    putvalue( env_AudioSD_TML_AH_start, 0 );
    putvalue( env_AudioSD_TML_AH_elements, 0 );
    putvalue( env_AudioSD_TML_DataSource, 0 );
    putvalue( env_AudioSD_TML_CSVPath, empty_string );
    putvalue( env_AudioSD_TML_DataSource_res, empty_string );
    putvalue( env_AudioSD_TML_DataSource_file, empty_string );
    putvalue( env_AudioSD_TML_CA_switch, FALSE );

    putvalue( env_AudioSD_TML_Error_on, FALSE );
    putvalue( env_AudioSD_TML_ErrorCode, 0 );

    //MediaBrowser
    putvalue( env_AudioSD_MB_ASGID, 0 );
    putvalue( env_AudioSD_MB_TAID, 0 );
    putvalue( env_AudioSD_MB_ActiveListPos, 0 );
    putvalue( env_AudioSD_MB_TotalNumLE, 0 );
    putvalue( env_AudioSD_MB_AH_shift, FALSE );
    putvalue( env_AudioSD_MB_AH_dir, FORWARD);
    putvalue( env_AudioSD_MB_AH_POS, FALSE );
    putvalue( env_AudioSD_MB_AH_IS, FALSE );
    putvalue( env_AudioSD_MB_AH_RA, 0 );
    putvalue( env_AudioSD_MB_AH_start, 0 );
    putvalue( env_AudioSD_MB_AH_elements, 0 );
    putvalue( env_AudioSD_MB_DataSource, 0 );
    putvalue( env_AudioSD_MB_CSVPath, empty_string );
    putvalue( env_AudioSD_MB_DataSource_result, empty_string );
    putvalue( env_AudioSD_MB_DataSource_file, empty_string );
    putvalue( env_AudioSD_MB_CA_switch, FALSE );

    putvalue( env_AudioSD_MB_Error_on, FALSE );
    putvalue( env_AudioSD_MB_ErrorCode, 0 );

    //IssueList #62
    putValue( env_AudioSD_FctList_0x0E_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x0F_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x10_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x11_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x12_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x13_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x14_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x15_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x16_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x17_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x18_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x19_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x1A_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x1B_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x1C_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x1D_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x1E_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x1F_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x20_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x21_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x22_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x23_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x24_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x25_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x26_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x27_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x28_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x29_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x2A_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x2B_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x2C_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x2D_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x2E_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x2F_TimeOut, 0 );
    putValue( env_AudioSD_FctList_0x30_TimeOut, 0 );


   //IssueList #74
   gAudioFctList_0x18_TimeOut_flg= 0;
   gAudioFctList_0x1D_TimeOut_flg= 0;
   gAudioFctList_0x22_TimeOut_flg= 0;
   gAudioFctList_0x27_TimeOut_flg= 0;
   gAudioFctList_0x2C_TimeOut_flg= 0;
   gAudioFctList_0x26_TimeOut_flg= 0;

   //IssueList #68
   putValue( env_AudioSD_FctList_0x18_3min_TO, 0 );
   putValue( env_AudioSD_FctList_0x1D_3min_TO, 0 );
   putValue( env_AudioSD_FctList_0x22_3min_TO, 0 );
   putValue( env_AudioSD_FctList_0x27_3min_TO, 0 );
   putValue( env_AudioSD_FctList_0x2C_3min_TO, 0 );
   putValue( env_AudioSD_FctList_0x26_3min_TO, 0 );
}

on timer Powerontimer
{
    gAudioSD_PowerOnOff = 1;
    settimer( TaskTimer, 10 ); //start BAP-DLL-Timer
}

void FSG_Setup_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            FSG_Setup_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD FSG_Setup_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

void FSG_Setup_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;      //LSG-ID
    requestarray[1] = FctID_FSG_Setup;   //Fct.-ID
    requestarray[2] = request;           //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x0E_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_FSGSetup_maxVolume;
            requestarray[4] = gAudioSD_FSGSetup_supportedVolumeTypes;
            requestarray[5] = gAudioSD_FSGSetup_ReceptionList_AutoUpdate;
            requestarray[6] = gAudioSD_FSGSetup_Setup_Extensions;

            set_status_requestbuffer( requestarray, 7, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD FSG_Setup_Request: invalid request %d", request );
            break;
    }
}

on envVar env_AudioSD_FSGSetup_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_FSGSetup_maxVolume             = getvalue( env_AudioSD_FSGSetup_MaxVol);

        gAudioSD_FSGSetup_entertainmentVolume   = getvalue( env_AudioSD_FSGSetup_entertainm);
        gAudioSD_FSGSetup_navigationVolume      = getvalue( env_AudioSD_FSGSetup_Nav);
        gAudioSD_FSGSetup_announcementVolume    = getvalue( env_AudioSD_FSGSetup_TA);
        gAudioSD_FSGSetup_phoneVolume           = getvalue( env_AudioSD_FSGSetup_Phone );
        gAudioSD_FSGSetup_SDSVolume             = getvalue( env_AudioSD_FSGSetup_SDS);
        gAudioSD_FSGSetup_phoneRingVolume       = getvalue( env_AudioSD_FSGSetup_PRVol);
        gAudioSD_FSGSetup_carParkingFader       = getvalue( env_AudioSD_FSGSetup_CarPF );
        gAudioSD_FSGSetup_readMessageVolume     = getvalue( env_AudioSD_FSGSetup_RMVol);

        gAudioSD_FSGSetup_FMReceptionList      = getvalue( env_AudioSD_FSGSetup_FM);
        gAudioSD_FSGSetup_AMReceptionList      = getvalue( env_AudioSD_FSGSetup_AM);
        gAudioSD_FSGSetup_DABReceptionList     = getvalue( env_AudioSD_FSGSetup_DAB);
        gAudioSD_FSGSetup_SDARSReceptionList   = getvalue( env_AudioSD_FSGSetup_SDARS);
        gAudioSD_FSGSetup_AMLWReceptionList    = getvalue( env_AudioSD_FSGSetup_AMLW);
        gAudioSD_FSGSetup_AMSWReceptionList    = getvalue( env_AudioSD_FSGSetup_AMSW);
        gAudioSD_FSGSetup_TVDVBReceptionList   = getvalue( env_AudioSD_FSGSetup_TV);
        gAudioSD_FSGSetup_ORReceptionList      = getvalue( env_AudioSD_FSGSetup_OR);

        gAudioSD_FSGSetup_Setup_Extensions_DAB = getvalue( env_AudioSD_FSGSetup_Ext_DAB);
        gAudioSD_FSGSetup_Setup_Extensions_CL  = getvalue( env_AudioSD_FSGSetup_Ext_CL);
        gAudioSD_FSGSetup_Setup_Extensions_CA  = getvalue( env_AudioSD_FSGSetup_Ext_CA);
        gAudioSD_FSGSetup_Setup_Extensions_SA  = getvalue( env_AudioSD_FSGSetup_Ext_SA);
        gAudioSD_FSGSetup_Setup_Extensions_SAas  = getvalue( env_AudioSD_FSGSetup_Ext_SAas );


        gAudioSD_FSGSetup_supportedVolumeTypes = gAudioSD_FSGSetup_entertainmentVolume + gAudioSD_FSGSetup_navigationVolume * 0x02 + gAudioSD_FSGSetup_announcementVolume * 0x04 + gAudioSD_FSGSetup_phoneVolume * 0x08 + gAudioSD_FSGSetup_SDSVolume * 0x10+ gAudioSD_FSGSetup_phoneRingVolume * 0x20+ gAudioSD_FSGSetup_carParkingFader* 0x40+ gAudioSD_FSGSetup_readMessageVolume * 0x80;

        gAudioSD_FSGSetup_ReceptionList_AutoUpdate = gAudioSD_FSGSetup_FMReceptionList + gAudioSD_FSGSetup_AMReceptionList* 0x02 + gAudioSD_FSGSetup_DABReceptionList* 0x04 + gAudioSD_FSGSetup_SDARSReceptionList* 0x08 + gAudioSD_FSGSetup_AMLWReceptionList* 0x10 + gAudioSD_FSGSetup_AMSWReceptionList* 0x20 + gAudioSD_FSGSetup_TVDVBReceptionList* 0x40 + gAudioSD_FSGSetup_ORReceptionList* 0x80;

        gAudioSD_FSGSetup_Setup_Extensions = gAudioSD_FSGSetup_Setup_Extensions_DAB + gAudioSD_FSGSetup_Setup_Extensions_CL* 0x02 + gAudioSD_FSGSetup_Setup_Extensions_CA* 0x04 + gAudioSD_FSGSetup_Setup_Extensions_SA* 0x08 + gAudioSD_FSGSetup_Setup_Extensions_SAas * 0x10;

        FSG_Setup_Request( Data_REQ, 0 );
    }
}

void FSG_OperationState_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            FSG_OperationState_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD FSG_OperationState_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

FSG_OperationState_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_FSG_OperationState; //Fct.-ID
    requestarray[2] = request;                   //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x0F_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_FSG_OperationState_OpState;
            requestarray[4] = gAudioSD_FSG_OperationState_HMI_State;

            set_status_requestbuffer( requestarray, 5, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD FSG_OperationState_Request: invalid request %d", request );
            break;
    }
}

on envVar env_AudioSD_FSGOpState_update
{
    if( gAudioSD_PowerOnOff == gAudioSD_PowerOnOff && getvalue( this ) )
    {
        gAudioSD_FSG_OperationState_OpState     = getvalue( env_AudioSD_FSGOpState_OpState );
    gAudioSD_FSG_OperationState_HMI_State   = getvalue( env_AudioSD_FSGOpState_HMIState );

    FSG_OperationState_Request( Data_REQ, 0 );
  }
}

activeSource_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;         //LSG-ID
    requestarray[1] = FctID_ActiveSource;   //Fct.-ID
    requestarray[2] = request;              //request type
    write( "AS: Request..." );
    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x10_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_activeSource_SourceType;
            requestarray[4] = gAudioSD_activeSource_SourceList_Reference & 0x00ff;
            requestarray[5] = ( gAudioSD_activeSource_SourceList_Reference & 0xff00 ) / 0x100;
            requestarray[6] = ( gAudioSD_activeSource_TypeOfNumber * 0x10 ) + gAudioSD_activeSource_ListAvailable;
            requestarray[7] = ( gAudioSD_activeSource_ListState * 0x10 ) + gAudioSD_activeSource_ListAvailable2;
            requestarray[8] = gAudioSD_activeSource_Number;
            write( "AS: %X %X %X %X %X %X",requestarray[3],requestarray[4],requestarray[5],requestarray[6],requestarray[7],requestarray[8] );
            set_status_requestbuffer( requestarray, 9, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD activeSource_Request: invalid request %d", request );
            break;
    }
}

activeSource_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            activeSource_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD activeSource_Indication: invalid indication %d", Indication_array[2] );
            break;
    }

}

on envVar env_AudioSD_activeSrc_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_activeSource_SourceType            = getvalue( env_AudioSD_activeSrc_Type );
        gAudioSD_activeSource_SourceList_Reference   = getvalue( env_AudioSD_activeSrc_SLRef );
        gAudioSD_activeSource_TypeOfNumber           = getvalue( env_AudioSD_activeSrc_TypeOfNum);
        gAudioSD_activeSource_ReceptionList          = getvalue( env_AudioSD_activeSrc_ReceptList );
        gAudioSD_activeSource_PresetList             = getvalue( env_AudioSD_activeSrc_PresetList );
        gAudioSD_activeSource_MediaBrowserList       = getvalue( env_AudioSD_activeSrc_MedBrList );
        gAudioSD_activeSource_SiriusAlertList        = getvalue( env_AudioSD_activeSrc_SAList );
        gAudioSD_activeSource_LastStationList        = getvalue( env_AudioSD_activeSrc_LSList );
        gAudioSD_activeSource_FavoriteList           = getvalue( env_AudioSD_activeSrc_FList );
        gAudioSD_activeSource_ListState              = getvalue( env_AudioSD_activeSrc_ListState );
        gAudioSD_activeSource_Number                 = getvalue( env_AudioSD_activeSrc_number );

        gAudioSD_activeSource_ListAvailable          = gAudioSD_activeSource_ReceptionList + gAudioSD_activeSource_PresetList* 0x02 + gAudioSD_activeSource_MediaBrowserList* 0x04 + gAudioSD_activeSource_SiriusAlertList* 0x08;
        gAudioSD_activeSource_ListAvailable2         = gAudioSD_activeSource_LastStationList + gAudioSD_activeSource_FavoriteList* 0x02;

        activeSource_Request( Data_REQ, 0 );
        //IssueList #32
        putValue( env_AudioSD_activeSrc_update, 0x0 );
    }
}

void activeSourceName_Request( byte request, byte errorcode )
{
    int i, Offset = 0;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_ActiveSourceName;    //Fct.-ID
    requestarray[2] = request;                   //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x11_TimeOut ) != TRUE )
            {
            requestarray[3] = strlen( gAudioSD_activeSourceName );
            Offset = 4;

            for( i = 0; i < strlen( gAudioSD_activeSourceName ); i++ )
            {
                requestarray[Offset] = gAudioSD_activeSourceName[i];
                Offset++;
            }

            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD activeSourceName_Request: invalid request %d", request );
            break;
    }
}

void activeSourceName_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            activeSourceName_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD activeSourceName_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

on envVar env_AudioSD_activeSourceName_up
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        getvalue( env_AudioSD_activeSourceName, gAudioSD_activeSourceName );


        activeSourceName_Request( Data_REQ, 0 );
    }
}

currentVolume_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;          //LSG-ID
    requestarray[1] = FctID_CurrentVolume;   //Fct.-ID
    requestarray[2] = request;               //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x12_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_currentVolume_EntertainmentVolume;
            requestarray[4] = gAudioSD_currentVolume_NavigationVolume;
            requestarray[5] = gAudioSD_currentVolume_TaVolume;
            requestarray[6] = gAudioSD_currentVolume_PhoneVolume;
            requestarray[7] = gAudioSD_currentVolume_SDSVolume;
            requestarray[8] = gAudioSD_currentVolume_ChangingVolumeType;

            set_status_requestbuffer( requestarray, 9, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD currentVolume_Request: invalid request %d", request );
            break;
    }
}

currentVolume_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            currentVolume_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD currentVolume_Indication: invalid indication %d", Indication_array[2] );
            break;
    }

}

on envVar env_AudioSD_currentVolume_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_currentVolume_EntertainmentVolume  = getvalue( env_AudioSD_currentVolume_EntVol);
        gAudioSD_currentVolume_NavigationVolume     = getvalue( env_AudioSD_currentVolume_NavVol);
        gAudioSD_currentVolume_TaVolume             = getvalue( env_AudioSD_currentVolume_TaVol);
        gAudioSD_currentVolume_PhoneVolume          = getvalue( env_AudioSD_currentVolume_PhoVol);
        gAudioSD_currentVolume_SDSVolume            = getvalue( env_AudioSD_currentVolume_SdsVol);
        gAudioSD_currentVolume_ChangingVolumeType   = getvalue( env_AudioSD_currentVolume_Change );

        currentVolume_Request( Data_REQ, 0 );
    }
}

Mute_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;  //LSG-ID
    requestarray[1] = FctID_Mute;   //Fct.-ID
    requestarray[2] = request;       //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x13_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_Mute_MuteState;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD Mute_Request: invalid request %d", request );
            break;
    }
}

void Mute_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataSetGet_IND:
            //get data
            gAudioSD_Mute_MuteState = Indication_array[3];

            gAudioSD_Mute_Entertainment = gAudioSD_Mute_MuteState & 0x01;
            gAudioSD_Mute_DAB = ( gAudioSD_Mute_MuteState & 0x02 ) / 0x02;
            gAudioSD_Mute_DVB = ( gAudioSD_Mute_MuteState & 0x04 ) / 0x04;
            gAudioSD_Mute_SDARS = ( gAudioSD_Mute_MuteState & 0x08 ) / 0x08;
            gAudioSD_Mute_sync_IBOC = ( gAudioSD_Mute_MuteState & 0x10 ) / 0x10;
            gAudioSD_Mute_Phone = ( gAudioSD_Mute_MuteState & 0x20 ) / 0x20;
            gAudioSD_Mute_IBOC = ( gAudioSD_Mute_MuteState & 0x40 ) / 0x40;
            gAudioSD_Mute_OnlineRadio = ( gAudioSD_Mute_MuteState & 0x80 ) / 0x80;

            //Panel
            putvalue( env_AudioSD_Mute_Mute, gAudioSD_Mute_Entertainment );
            putvalue( env_AudioSD_Mute_DAB, gAudioSD_Mute_DAB);
            putvalue( env_AudioSD_Mute_DVB, gAudioSD_Mute_DVB);
            putvalue( env_AudioSD_Mute_SDARS, gAudioSD_Mute_SDARS);
            putvalue( env_AudioSD_Mute_IBOC, gAudioSD_Mute_IBOC);
            putvalue( env_AudioSD_Mute_PhoneCall, gAudioSD_Mute_Phone );
            putvalue( env_AudioSD_Mute_sync_IBOC, gAudioSD_Mute_sync_IBOC);
            putvalue( env_AudioSD_Mute_OnRad, gAudioSD_Mute_OnlineRadio);

            if( getvalue( env_AudioSD_Mute_Error_on ) )
                Mute_Request(Error_REQ, getvalue( env_AudioSD_Mute_ErrorCode ) );

            else
                Mute_Request( Data_REQ, 0 );
            break;

        case DataGet_IND:
            if( gBAP_Indication[5] != 3)  //datalength error
                Mute_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE );  //send error-message
            else
                Mute_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD Mute_Indication: invalid indication %d", Indication_array[2] );
            break;
    }

}

on envVar env_AudioSD_Mute_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_Mute_MuteState = 0;

        gAudioSD_Mute_Entertainment = getvalue( env_AudioSD_Mute_Mute );
        gAudioSD_Mute_DAB           = getvalue( env_AudioSD_Mute_DAB);
        gAudioSD_Mute_DVB           = getvalue( env_AudioSD_Mute_DVB);
        gAudioSD_Mute_SDARS         = getvalue( env_AudioSD_Mute_SDARS);
        gAudioSD_Mute_sync_IBOC     = getvalue( env_AudioSD_Mute_sync_IBOC);
        gAudioSD_Mute_IBOC          = getvalue( env_AudioSD_Mute_IBOC);
        gAudioSD_Mute_Phone         = getvalue( env_AudioSD_Mute_PhoneCall);
        gAudioSD_Mute_OnlineRadio   = getvalue( env_AudioSD_Mute_OnRad );
        gAudioSD_Mute_MuteState= gAudioSD_Mute_Entertainment + ( gAudioSD_Mute_DAB* 0x02 ) + ( gAudioSD_Mute_DVB* 0x04 ) + ( gAudioSD_Mute_SDARS* 0x08 ) + ( gAudioSD_Mute_sync_IBOC* 0x10 ) + ( gAudioSD_Mute_Phone * 0x20 ) + ( gAudioSD_Mute_IBOC* 0x40 )+ ( gAudioSD_Mute_OnlineRadio* 0x80 );

        Mute_Request( Data_REQ, 0 );
    }
}

SourceState_Indication( dword Indication_array [], int datalength )
{
    byte errorcode = 0;

    errorcode = 0;

    switch( Indication_array[2] ) // indication
    {
        case DataSetGet_IND:
            //get data
            gAudioSD_SourceState_StateInfo = Indication_array[3];
            gAudioSD_SourceState_Scope = Indication_array[4];

            //Panel
            if( gAudioSD_SourceState_StateInfo < 0x08 )
            {
                putvalue( env_AudioSD_SourceState_StInfo, gAudioSD_SourceState_StateInfo);
                putvalue( env_AudioSD_SourceState_StInfo_s, gAudioSD_SourceState_StateInfo_string[gAudioSD_SourceState_StateInfo] );
            }
            else
            {
                putvalue( env_AudioSD_SourceState_StInfo_s, gstring_reserved );
                errorcode = BAP_BAL_OUT_OF_RANGE;
            }

            if( gAudioSD_SourceState_Scope < 0x09)
            {
                putvalue( env_AudioSD_SourceState_Scope, gAudioSD_SourceState_Scope );
                putvalue( env_AudioSD_SourceState_Scope_s, gAudioSD_SourceState_Scope_string[gAudioSD_SourceState_Scope] );
            }
            else
            {
                putvalue( env_AudioSD_SourceState_Scope_s, gstring_reserved );
                errorcode = BAP_BAL_OUT_OF_RANGE;
            }


            if( getvalue( env_AudioSD_SourceState_Error_on ) )
                SourceState_Request(Error_REQ, getvalue( env_AudioSD_SourceState_ErrorC) );

            else if( errorcode != 0 )
                SourceState_Request(Error_REQ, errorcode );

            else
                SourceState_Request( Data_REQ, 0 );

            break;

        case DataGet_IND:
            if( gBAP_Indication[5] != 3)  //datalength error
                SourceState_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE );   //send error-message
            else
                SourceState_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD SourceState_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

SourceState_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;      //LSG-ID
    requestarray[1] = FctID_SourceState;    //Fct.-ID
    requestarray[2] = request;           //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x14_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_SourceState_StateInfo;
            requestarray[4] = gAudioSD_SourceState_Scope;

            set_status_requestbuffer( requestarray, 5, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD SourceState_Request: invalid request %d", request );
            break;
    }
}

on envVar env_AudioSD_SourceState_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_SourceState_StateInfo  = getvalue( env_AudioSD_SourceState_StInfo);
gAudioSD_SourceState_Scope      = getvalue( env_AudioSD_SourceState_Scope );

        if( gAudioSD_SourceState_StateInfo< 0x08 )
            putvalue( env_AudioSD_SourceState_StInfo_s, gAudioSD_SourceState_StateInfo_string[gAudioSD_SourceState_StateInfo] );
        else
            putvalue( env_AudioSD_SourceState_StInfo_s, gstring_reserved );

        if( gAudioSD_SourceState_Scope < 0x09)
            putvalue( env_AudioSD_SourceState_Scope_s, gAudioSD_SourceState_Scope_string[gAudioSD_SourceState_Scope] );
        else
            putvalue( env_AudioSD_SourceState_Scope_s, gstring_reserved );


        SourceState_Request( Data_REQ, 0 );
    }
}

GeneralInfoSwitches_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataSetGet_IND:
            //get data
            gAudioSD_GeneralInfoSwitches_OnOffSwitches = Indication_array[3];
            gAudioSD_GeneralInfoSwitches_Reserve = Indication_array[4];

            gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA = gAudioSD_GeneralInfoSwitches_OnOffSwitches & 0x01;
            gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS = ( gAudioSD_GeneralInfoSwitches_OnOffSwitches & 0x02 ) / 0x02;
            gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic = ( gAudioSD_GeneralInfoSwitches_OnOffSwitches & 0x04 ) / 0x04;
            gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC = ( gAudioSD_GeneralInfoSwitches_OnOffSwitches & 0x08 ) / 0x08;
            gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS = ( gAudioSD_GeneralInfoSwitches_OnOffSwitches & 0x10 ) / 0x10;
            gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online = ( gAudioSD_GeneralInfoSwitches_OnOffSwitches & 0x20 ) / 0x20;
            gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB = ( gAudioSD_GeneralInfoSwitches_OnOffSwitches & 0x40 ) / 0x40;

            if( getvalue( env_AudioSD_GIS_Error_on ) )
                GeneralInfoSwitches_Request(Error_REQ, getvalue( env_AudioSD_GIS_ErrorCode ) );
            else
                GeneralInfoSwitches_Request( Data_REQ, 0 );

            //Panel
            putvalue( env_AudioSD_GIS_OnOff_TPTA, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA);
            putvalue( env_AudioSD_GIS_OnOff_RDS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS);
            putvalue( env_AudioSD_GIS_OnOff_JPtraffic, gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic);
            putvalue( env_AudioSD_GIS_OnOff_TMC, gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC);
            putvalue( env_AudioSD_GIS_OnOff_VICS, gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS);
            putvalue( env_AudioSD_GIS_OnOff_ON, gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online );
            putvalue( env_AudioSD_GIS_OnOff_DAB, gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB);
        break;
        case DataGet_IND:
            if( gBAP_Indication[5] != 3)  //datalength error
                GeneralInfoSwitches_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE );   //send error-message
            else
                GeneralInfoSwitches_Request( Data_REQ, 0 );    //send status
        break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD GeneralInfoSwitches_Indication: invalid indication %d", Indication_array[2] );
        break;
    }
}

GeneralInfoSwitches_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_GeneralInfoSwitches;    //Fct.-ID
    requestarray[2] = request;                   //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x19_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_GeneralInfoSwitches_OnOffSwitches;
            requestarray[4] = gAudioSD_GeneralInfoSwitches_Modification;

            set_status_requestbuffer( requestarray, 5, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD GeneralInfoSwitches_Request: invalid request %d", request );
            break;
    }
}

on envVar env_AudioSD_GIS_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA         = getvalue( env_AudioSD_GIS_OnOff_TPTA);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS          = getvalue( env_AudioSD_GIS_OnOff_RDS);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic    = getvalue( env_AudioSD_GIS_OnOff_JPtraffic);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC          = getvalue( env_AudioSD_GIS_OnOff_TMC);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS         = getvalue( env_AudioSD_GIS_OnOff_VICS);
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online       = getvalue( env_AudioSD_GIS_OnOff_ON );
    gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB          = getvalue( env_AudioSD_GIS_OnOff_DAB);

    gAudioSD_GeneralInfoSwitches_Modification_TPTA          = getvalue( env_AudioSD_GIS_Mod_TPTA);
    gAudioSD_GeneralInfoSwitches_Modification_RDS           = getvalue( env_AudioSD_GIS_Mod_RDS);
    gAudioSD_GeneralInfoSwitches_Modification_JPtraffic     = getvalue( env_AudioSD_GIS_Mod_JPtraffic);
    gAudioSD_GeneralInfoSwitches_Modification_TMC           = getvalue( env_AudioSD_GIS_Mod_TMC);
    gAudioSD_GeneralInfoSwitches_Modification_VICS          = getvalue( env_AudioSD_GIS_Mod_VICS);
    gAudioSD_GeneralInfoSwitches_Modification_Online        = getvalue( env_AudioSD_GIS_Mod_ON );
    gAudioSD_GeneralInfoSwitches_Modification_DAB           = getvalue( env_AudioSD_GIS_Mod_DAB);

    gAudioSD_GeneralInfoSwitches_OnOffSwitches  = gAudioSD_GeneralInfoSwitches_OnOffSwitches_TPTA + gAudioSD_GeneralInfoSwitches_OnOffSwitches_RDS* 0x02 + gAudioSD_GeneralInfoSwitches_OnOffSwitches_JPtraffic* 0x04 + gAudioSD_GeneralInfoSwitches_OnOffSwitches_TMC* 0x08 + gAudioSD_GeneralInfoSwitches_OnOffSwitches_VICS* 0x10+ gAudioSD_GeneralInfoSwitches_OnOffSwitches_Online * 0x20+ gAudioSD_GeneralInfoSwitches_OnOffSwitches_DAB* 0x40;
        gAudioSD_GeneralInfoSwitches_Modification   = gAudioSD_GeneralInfoSwitches_Modification_TPTA + gAudioSD_GeneralInfoSwitches_Modification_RDS* 0x02 + gAudioSD_GeneralInfoSwitches_Modification_JPtraffic* 0x04 + gAudioSD_GeneralInfoSwitches_Modification_TMC* 0x08 + gAudioSD_GeneralInfoSwitches_Modification_VICS* 0x10 + gAudioSD_GeneralInfoSwitches_Modification_Online * 0x20 + gAudioSD_GeneralInfoSwitches_Modification_DAB* 0x40;

    GeneralInfoSwitches_Request( Data_REQ, 0 );
    }
}

CurrentStationInfo_Request( byte request, byte errorcode )
{
    int i, Offset;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_CurrentStationInfo; //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;

    switch( request )
    {
        case Data_REQ:
          //IssueList #62
          if( getValue( env_AudioSD_FctList_0x15_TimeOut ) != TRUE )
          {
                //PrimaryInformation
        //Updates from J.Karl 07.11.2013
                if( getvalue( env_AudioSD_CSI_NULL) != FALSE )
                {
                    requestarray[Offset] = 1;
                    Offset++;
                    requestarray[Offset] = 0;
                    Offset++;
                }
                else
                {
                    //PrimaryInformation
                    requestarray[Offset] = strlen( gAudioSD_CSI_PrimaryInformation );
                    Offset++;

                    for( i = 0; i < strlen( gAudioSD_CSI_PrimaryInformation ); i++ )
                    {
                    requestarray[Offset] = gAudioSD_CSI_PrimaryInformation[i];
                    Offset++;
                    }
                }

                //PI_Type
                requestarray[Offset] = gAudioSD_CSI_PI_Type;
                Offset++;

                //PI_ID
                requestarray[Offset] = gAudioSD_CSI_PIID & 0xff;
                Offset++;
                requestarray[Offset] = ( gAudioSD_CSI_PIID & 0xff00 ) / 0x100;
                Offset++;

                //SecondaryInformation
                //Updates from J.Karl 07.11.2013
                if( getvalue( env_AudioSD_CSI_NULL) != FALSE )
                {
                    requestarray[Offset] = 1;
                    Offset++;
                    requestarray[Offset] = 0;
                    Offset++;
                }
                else
                {
                    requestarray[Offset] = strlen( gAudioSD_CSI_SecondaryInformation );
                    Offset++;

                    for( i = 0; i < strlen( gAudioSD_CSI_SecondaryInformation ); i++ )
                    {
                        requestarray[Offset] = gAudioSD_CSI_SecondaryInformation[i];
                        Offset++;
                    }
        }

        //SI_Type
        requestarray[Offset] = gAudioSD_CSI_SI_Type;
        Offset++;

                //TertiaryInformation
        //Updates from J.Karl 07.11.2013
                if( getvalue( env_AudioSD_CSI_NULL) != FALSE )
                {
                    requestarray[Offset] = 1;
                    Offset++;
                    requestarray[Offset] = 0;
                    Offset++;
                }
                else
                {
            requestarray[Offset] = strlen( gAudioSD_CSI_TertiaryInformation );
            Offset++;

            for( i = 0; i < strlen( gAudioSD_CSI_TertiaryInformation ); i++ )
            {
                requestarray[Offset] = gAudioSD_CSI_TertiaryInformation[i];
                Offset++;
            }
        }

        //TI_Type
        requestarray[Offset] = gAudioSD_CSI_TI_Type;
        Offset++;

                //QuaternaryInformation
        //Updates from J.Karl 07.11.2013
                if( getvalue( env_AudioSD_CSI_NULL) != FALSE )
                {
                    requestarray[Offset] = 1;
                    Offset++;
                    requestarray[Offset] = 0;
                    Offset++;
                }
                else
                {
                    requestarray[Offset] = strlen( gAudioSD_CSI_QuarternaryInformation );
                    Offset++;

                    for( i = 0; i < strlen( gAudioSD_CSI_QuarternaryInformation ); i++ )
                    {
                requestarray[Offset] = gAudioSD_CSI_QuarternaryInformation[i];
                Offset++;
                    }
        }

        //QI_Type
        requestarray[Offset] = gAudioSD_CSI_QI_Type;
        Offset++;

        //StationInfoSwitches
        requestarray[Offset] = gAudioSD_CSI_StationInfoSwitches;
        Offset++;

        //StationProperties
        requestarray[Offset] = gAudioSD_CSI_StationProperties;
        Offset++;

        //Channel_ID
        requestarray[Offset] = gAudioSD_CSI_ChannelID & 0xff;
        Offset++;
        requestarray[Offset] = ( gAudioSD_CSI_ChannelID & 0xff00 ) / 0x100;
        Offset++;

                //MR 60227
                //Send the BAP request as normal/expected if MOST is not active
                if( getValue( env_PIC_bapMOST_active_flag ) == 0x00 )
                set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                //BAP_MOST sync
                else if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
                {
                      //BAP FIRST before MOST
                        if( getValue( env_AudioTel_bapMost_delayTimer ) <= 0 ) //delay timer
                        {
                        //send BAP first
                        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                        //call MOST function after the delay
                        setTimer( _tBapFirst_delayTime, (-1 ) * getValue( env_AudioTel_bapMost_delayTimer ) );
                        }
                        ////MOST FIRST before BAP
                        else if( getValue( env_AudioTel_bapMost_delayTimer ) > 0 ) //delay timer
                        {
                           //prepare the data
                           //clear
                           for( i = 0; i < BAP_BUFFER_SIZE; i++ )
                           gAudio_Requestarray[i] = 0;
                           for( i = 0; i <Offset; i++ )
                           gAudio_Requestarray[i] = requestarray[i];
                           gAudio_BuffSize = Offset;
                           gAudio_BAPdataType = Bap_ByteSequence;
                           //call MOST
                           //BAP2MOSTSync();
                           //call BAP after the delay
                           setTimer( _tMostFirst_delayTime, getValue( env_AudioTel_bapMost_delayTimer ) );
                       }
                } //MOST_active_fla
      }
          break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentStationInfo_Request: invalid request %d", request );
            break;
    }
}

CurrentStationInfo_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            CurrentStationInfo_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentStationInfo_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

on envVar env_AudioSD_CSI_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        getvalue( env_AudioSD_CSI_PI_s, gAudioSD_CSI_PrimaryInformation );
        getvalue( env_AudioSD_CSI_SI_s, gAudioSD_CSI_SecondaryInformation );
        getvalue( env_AudioSD_CSI_TI_s, gAudioSD_CSI_TertiaryInformation );
        getvalue( env_AudioSD_CSI_QI_s, gAudioSD_CSI_QuarternaryInformation );
        gAudioSD_CSI_PI_Type                        = getvalue( env_AudioSD_CSI_PIType );
        gAudioSD_CSI_SI_Type                        = getvalue( env_AudioSD_CSI_SIType );
        gAudioSD_CSI_TI_Type                        = getvalue( env_AudioSD_CSI_TIType );
        gAudioSD_CSI_QI_Type                        = getvalue( env_AudioSD_CSI_QIType );
        gAudioSD_CSI_PIID                           = getvalue( env_AudioSD_CSI_PIID);
        gAudioSD_CSI_ChannelID                      = getvalue( env_AudioSD_CSI_ChannelID);
        gAudioSD_CSI_StationProperties_DABlinked    = getvalue( env_AudioSD_CSI_StProp_linked );
        gAudioSD_CSI_StationProperties_IBOC         = getvalue( env_AudioSD_CSI_StProp_IBOC);
        gAudioSD_CSI_StationProperties_DABservice   = getvalue( env_AudioSD_CSI_StProp_DABserv);
        gAudioSD_CSI_StationProperties_OnlineServ   = getvalue( env_AudioSD_CSI_StProp_OR);
        gAudioSD_CSI_TATP                           = getvalue( env_AudioSD_CSI_TATP );
        gAudioSD_CSI_TMC                            = getvalue( env_AudioSD_CSI_TMC);
        gAudioSD_CSI_VICS                           = getvalue( env_AudioSD_CSI_VICS);
        gAudioSD_CSI_IBOC                           = getvalue( env_AudioSD_CSI_IBOC);


        gAudioSD_CSI_StationInfoSwitches = gAudioSD_CSI_TATP + ( gAudioSD_CSI_TMC* 0x02 ) + ( gAudioSD_CSI_VICS* 0x04 ) + ( gAudioSD_CSI_IBOC* 0x08 );
        gAudioSD_CSI_StationProperties = gAudioSD_CSI_StationProperties_DABlinked + ( gAudioSD_CSI_StationProperties_IBOC* 0x02 )+ ( gAudioSD_CSI_StationProperties_DABservice * 0x04 )+ ( gAudioSD_CSI_StationProperties_OnlineServ* 0x08 );


        CurrentStationInfo_Request( Data_REQ, 0 );
    }
}

ReceptionList_Indication ( dword Indication_array [], int datalength )
{
    byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements;
    //IssueList #76 - MR49870 : ReceptionList
    int i = 0,j = 0;
    byte audioListDelFlg;
    word validStartElem_plusElem;

    //IssueList #193
    byte rl_InValidStartElemFlg;

    // Init local variables.
    mode                    = 0;
    direction               = 0;
    shift                   = 0;
    transmitpos             = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    indexsize               = 0;
    valid_startelement      = 0xff;
    valid_elements          = 0;

    //IssueList #76 - MR49870 : ReceptionList
    validStartElem_plusElem = 0;

        switch( Indication_array[2] ) // indication
        {
            case DataGet_IND:

                if( getvalue( env_AudioSD_RL_Error_on ) )
                {
                    //MR 63667 11.07.2014 -TNLE with SA-button
                    //ReceptionList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue( env_AudioSD_RL_ErrorCode ) );
                    ReceptionList_Request(Error_REQ, 0, 0, 0, 0, 0, 0, getvalue( env_AudioSD_RL_ErrorCode ) );
                }
                //MR 63336    02.07.2014
                else if( getvalue( env_AudioSD_RL_Timeout ) == TRUE )
                {
                /* NOP */
                }
                else
                {
                    //get Data
                    gReceptionList_ASGID                = ( gBAP_Indication[3] & 0xF0 ) / 0x10;
                    gReceptionList_TAID                 = gBAP_Indication[3] & 0x0F;
                    gReceptionList_ElementType          = gBAP_Indication[4];
                    gReceptionList_ParentID             = gBAP_Indication[5] + ( gBAP_Indication[6]* 0x100 );

                    //decode BAP-ArrayHeader
                    mode                = ( gBAP_Indication[7] & 0xF0 ) / 0x10;

                    // decode "mode -byte"
                    shift       = mode & 0x01;
                    direction   = ( mode & 0x02 ) / 0x02;
                    transmitpos = ( mode & 0x04 ) / 0x04;
                    indexsize   = ( mode & 0x08 ) / 0x08;


                    recordaddress       = gBAP_Indication[7] & 0x0F;
                    if( indexsize )
                    {
                        startelement        = gBAP_Indication[8];
                        startelement        += gBAP_Indication[9] * 0x100;
                        elements            = gBAP_Indication[10];
                        elements            += gBAP_Indication[11]* 0x100;
                    }
                    else
                    {
                        startelement        = gBAP_Indication[8];
                        elements            = gBAP_Indication[9];
                    }

                    requested_startelement = startelement;

                    transmitpos     = TRUE; //Position must always be sent in the case of *.GetArray.

                    /***Startelement = 0***/
                    if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
                    {
                        if( FORWARD==direction )  //forward-start
                        {
                            valid_startelement = 0;

                             //IssueList #76 - MR49870 : ReceptionList
                            //change the AUDIO_RECEPTIONLIST_ENTRIES --> gRL_CSVtotalElem --> gReceptionList_TotalNumListElements
                            if( gReceptionList_TotalNumListElements <= elements )         //1. more elements requested, than in array
                            {
                                if( shift == FALSE )
                                {
                                    //IssueList #76 - MR49870 : ReceptionList
                                    for( i = 0; i < gReceptionList_TotalNumListElements; i++ )
                                    {
                                        if( 0 != gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                        {
                                            if( gReceptionList_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i = gRL_CSVtotalElem;
                                    }
                                }
                                else if( shift == TRUE )
                                {
                                    valid_startelement  = startelement;
                                    valid_elements      = 0;
                                }
                            }
                            else    //2. number of requested elements < elements in array
                            {
                                if( shift == FALSE )
                                {
                                    for( i = 0; i < elements; i++ )
                                    {
                                        if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                        {
                                            if( gReceptionList_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i = gRL_CSVtotalElem;
                                    }
                                }
                                else if( shift == TRUE )
                                {
                                    valid_startelement  = startelement;
                                    valid_elements      = 0;
                                }
                            }
                        }                                                               //forward ends

                        else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                        {
                            //searching for valid startelement
                            for( i = ( gRL_CSVtotalElem-1 ); i>= 0; i--)
                            {
                                if( 0!= gReceptionList_ListEntryValidInformation[i] )        //found valid startelement
                                {
                                    valid_startelement = i;
                                    i = 0;
                                }
                            }

                            //searching for valid elements
                            if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                            {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                            }
                            else if( 0 ==valid_startelement )
                                valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                            else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                            {
                                for( i =valid_startelement; i>= 0; i--)
                                {
                                    if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                    {
                                        if( gReceptionList_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                        valid_elements++;                                //increment elements
                                    }
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                                {
                                    if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                    {
                                        if( gReceptionList_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                        valid_elements++;                                //increment elements
                                    }
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }

                            }
                        }                                                               //backward-end
                    }                                                                   //startelement == 0 -end

                    /***Startelement!= 0***/
                    else                                                                //searching for Startelement-ID
                    {
                        //IssueList #193 - start
                        rl_InValidStartElemFlg = 0;
                        for( i = 0; i < gRL_CSVtotalElem; i++ )
                        {
                            if( startelement == gReceptionList_Pos_insDel[i][0] )
                            {
                                //check if Start is deleted then reply with 0 elements
                                if( gReceptionList_Pos_insDel[i][1] == 0x01 )
                                {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                                rl_InValidStartElemFlg = 1;
                                }
                            }
                        }
                        //IssueList #193 - end

                        //IssueList #193 - if condition
                        if( rl_InValidStartElemFlg == 0x00 )
                        {
                            //searching for valid startelement
                            for( i = 0; i < gRL_CSVtotalElem; i++ )
                            {
                                if( gReceptionList_Pos[i] == startelement )                        //found a valid element
                                {
                                    if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                                    {
                                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                            valid_startelement = i + 1-2*direction;

                                        else if( i == 0 && BACKWARD==direction )
                                            valid_startelement = gReceptionList_sum;     //valid element is last element in Array


                                        else if( i == 0 && FORWARD==direction )
                                            valid_startelement = 0;                          //valid element is first element in Array
                                    }

                                    else
                                        valid_startelement = i;                              //found element is valid_startelement

                                    i = gRL_CSVtotalElem;
                                }
                            }

                            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
                            {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                            }
                            else                                                                //found valid entry for startelement in array
                            {
                                //verify number of valid elements
                                if( BACKWARD==direction )                                            //backward-start
                                {
                                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                                        {
                                        //IssueList #76 - MR49870 : ReceptionList
                                       audioListDelFlg = 0x00;
                                       audioListDelFlg = audioList_deleteCheck( gReceptionList_Pos[0], gReceptionList_Pos_insDel, gRL_CSVtotalElem );

                                            if( audioListDelFlg == 0x00 )
                                            valid_elements= 1;
                                        }

                                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                                    {
                                        for( i =valid_startelement; i>= 0; i--)
                                        {
                                            if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                            {
                                                if( gReceptionList_Pos[i] > 0xFF ) //check indexsize
                                                    indexsize = TRUE;

                                                valid_elements++;                                //increment elements
                                            }
                                            else                                                //no valid element, loop finished
                                                i = 0;
                                        }
                                    }
                                    else                                                        //enougth array-elements available
                                    {
                                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                                        {
                                            if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                            {
                                                if( gReceptionList_Pos[i] > 0xFF ) //check indexsize
                                                    indexsize = TRUE;

                                                valid_elements++;
                                            }
                                            else                                                //no valid element, loop finished
                                                i = 0;
                                        }
                                    }
                                }                                                                //backward-end
                                else                                                            //forward-start
                                {   //IssueList #76 - MR49870 : ReceptionList 07MAY
                                    //if((valid_startelement+elements )>= gRL_CSVtotalElem)
                                    if((valid_startelement+elements )>= gReceptionList_TotalNumListElements )
                                    {
                                        for( i =valid_startelement; i < gRL_CSVtotalElem; i++ )
                                        {
                                            if( 0!= gReceptionList_Pos[i] )                        //if there is an valid element
                                            {
                                                if( gReceptionList_Pos[i] > 0xFF ) //check indexsize
                                                    indexsize = TRUE;

                                                //IssueList #76 - MR49870 : ReceptionList
                                                audioListDelFlg = 0x00;
                                                audioListDelFlg = audioList_deleteCheck( gReceptionList_Pos[i], gReceptionList_Pos_insDel, gRL_CSVtotalElem );

                                                //ReceptionList 15MAY
                                                //if( audioListDelFlg == 0x00 )
                                                if( audioListDelFlg == 0x00 && valid_elements < elements )
                                                valid_elements++;                                //increment elements
                                            }
                                            else                                                //no valid element, loop finished
                                                i = gRL_CSVtotalElem;

                                        }
                                    }
                                    else
                                    {   //IssueList #76 - MR49870 : ReceptionList 15MAY
                                        // adjustment of boundary if there's deleted element
                                        validStartElem_plusElem =valid_startelement+elements;
                                        //for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                                        for( i =valid_startelement; i <validStartElem_plusElem; i++ )
                                        {
                                            if( 0!= gReceptionList_Pos[i] )                            //if there is an valid element
                                            {
                                                if( gReceptionList_Pos[i] > 0xFF ) //check indexsize
                                                    indexsize = TRUE;

                                                //IssueList #76 - MR49870 : ReceptionList
                                               audioListDelFlg = 0x00;
                                               audioListDelFlg = audioList_deleteCheck( gReceptionList_Pos[i], gReceptionList_Pos_insDel, gRL_CSVtotalElem);

                                                if( audioListDelFlg == 0x00 )
                                                {
                                                    //ReceptionList 15MAY
                                                    if( valid_elements < elements )      //guard check if valid elements < elements
                                                    valid_elements++;                                //increment elements

                                                 }
                                                 //ReceptionList 15MAY
                                                 else
                                                 {
                                                    if( valid_elements < elements )
                                                    validStartElem_plusElem++;      //adjust the loop boundary based on number of deleted elements
                                                 }

                                            }
                                            else                                    //no valid element, loop finished
                                                i = gRL_CSVtotalElem;
                                        }
                                    }
                                }
                            }
                        }//rl_InValidStartElemFlg
                    } //else Startelement!= 0

                    if((valid_startelement > 0xFF ) || ( requested_startelement > 0xFF ) ) //check indexsize
                        indexsize = TRUE;

                    mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                    //send StatusArray
                    //MR 63667 11.07.2014 -TNLE with SA-button
                    //ReceptionList_Request( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
            //VAGH-10511
            if( !getvalue( env_AudioSD_RL_noStatusArray ) )
                ReceptionList_Request( Data_REQ, gReceptionList_TotalNumListElements, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );

                    //Panel
                    putvalue( env_AudioSD_RL_ASGID, gReceptionList_ASGID);
                    putvalue( env_AudioSD_RL_TAID, gReceptionList_TAID);
                    //IssueList #109 - set gReceptionList_ElementType manually
                    //if( gReceptionList_ElementType < 0x06 )
                    //  putvalue( env_AudioSD_RL_ElementType, gReceptionList_ElementType );

                    putvalue( env_AudioSD_RL_ParentID, gReceptionList_ParentID);
                }
             break;

            case Error_IND:
                writelineEx( gError_Trace, 0, "FSG_AudioSD ReceptionList_Indication: received error, errorcode:0x%x", Indication_array[3] );
            break;

            default:
                writelineEx( gError_Trace, 0, "FSG_AudioSD ReceptionList_Indication: invalid indication %d", Indication_array[2] );
             break;
    }
}

ReceptionList_Request ( byte request, word tnle, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode )
{
    int  i;
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word ReceptionListLine;
    dword requestarray [BAP_BUFFER_SIZE];
    //IssueList #76 - MR49870 : ReceptionList
    byte audioListDelFlg;

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray [i] = 0;

    shift               = 0;
    direction           = 0;
    transmitpos         = 0;
    indexsize           = 0;
    ReceptionListLine   = 0;
    current_element     = 0;
    Offset              = 0;

    // decode "mode -byte"
    shift       = mode & 0x01;
    direction   = ( mode & 0x02 ) / 0x02;
    transmitpos = ( mode & 0x04 ) / 0x04;
    indexsize   = ( mode & 0x08 ) / 0x08;

    // Handle request.
    requestarray[0] = LSG_AudioSD;                //LSG-ID
    requestarray[1] = FctID_ReceptionList;        //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;

    switch( request )
    {
        case Changed_REQ:
            requestarray[Offset] = gReceptionList_ElementType;
            Offset++;
            requestarray[Offset] = gReceptionList_ParentID & 0xff;
            Offset++;
            requestarray[Offset] = ( gReceptionList_ParentID & 0xff00 ) / 0x100;
            Offset++;

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            ReceptionListLine = startelement;

            if( getvalue( env_AudioSD_RL_CA_switch ) ) //ArrayData
            {
                //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                        while( current_element < elements )
                        {
                            if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }

                                //Type
                                requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                Offset++;

                                //Attributes
                                requestarray[Offset] = ( gReceptionList_Attributes[ReceptionListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gReceptionList_Attributes[ReceptionListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //PresetID
                                requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                                Offset++;

                                //FmREG_Code
                                requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                                Offset++;

                                //Category
                                requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gReceptionList_Name[ReceptionListLine] );
                                Offset++;

                                for( i = 0; i < strlen( gReceptionList_Name[ReceptionListLine] ); i++ )
                                {
                                    requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                    Offset++;
                                }

                                //Frequency
                                requestarray[Offset] = strlen( gReceptionList_Frequency[ReceptionListLine] );
                                Offset++;

                                for( i = 0; i < strlen( gReceptionList_Frequency[ReceptionListLine] ); i++ )
                                {
                                    requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                        }//end while

                        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                    break;

                    case 1: //Type, Attributes, PresetID, FmREG_Code, Category, Name
                        while( current_element < elements )
                        {
                            if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                        Offset++;
                                        requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }

                                //Type
                                requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                Offset++;

                                //Attributes
                                requestarray[Offset] = gReceptionList_Attributes[ReceptionListLine];
                                Offset++;

                                //PresetID
                                requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                                Offset++;

                                //FmREG_Code
                                requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                                Offset++;

                                //Category
                                requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gReceptionList_Name[ReceptionListLine] );
                                Offset++;

                                for( i = 0; i < strlen( gReceptionList_Name[ReceptionListLine] ); i++ )
                                {
                                    requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                        }//end while

                        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                    break;

                    case 2: //Type, Attributes
                        while( current_element < elements )
                        {
                            if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                        Offset++;
                                        requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }

                                //Type
                                requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                Offset++;

                                //Attributes
                                requestarray[Offset] = gReceptionList_Attributes[ReceptionListLine];
                                Offset++;
                            }
                            current_element++;
                            ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                        }//end while

                        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                    break;

                    case 3: //PresetID, FmREG_Code, Category, Name
                        while( current_element < elements )
                        {
                            if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                        Offset++;
                                        requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }

                                //PresetID
                                requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                                Offset++;

                                //FmREG_Code
                                requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                                Offset++;

                                //Category
                                requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gReceptionList_Name[ReceptionListLine] );
                                Offset++;

                                for( i = 0; i < strlen( gReceptionList_Name[ReceptionListLine] ); i++ )
                                {
                                    requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                        }//end while

                        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                    break;

                    case 4: //Name
                        while( current_element < elements )
                        {
                            if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                        Offset++;
                                        requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }

                                //Name
                                requestarray[Offset] = strlen( gReceptionList_Name[ReceptionListLine] );
                                Offset++;

                                for( i = 0; i < strlen( gReceptionList_Name[ReceptionListLine] ); i++ )
                                {
                                    requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                        }//end while

                        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                    break;

                    case 5: //Frequency
                        while( current_element < elements )
                        {
                            if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                        Offset++;
                                        requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }

                                //Frequency
                                requestarray[Offset] = strlen( gReceptionList_Frequency[ReceptionListLine] );
                                Offset++;

                                for( i = 0; i < strlen( gReceptionList_Frequency[ReceptionListLine] ); i++ )
                                {
                                    requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );
                        }//end while
                        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                        break;

                    case 6: //Type, Attributes, Category, Name
                        while ( current_element < elements )
                        {
                            if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                        Offset++;
                                        requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                                //Type
                                requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                Offset++;
                                //Attributes
                                requestarray[Offset] = gReceptionList_Attributes[ReceptionListLine];
                                Offset++;
                                //Category
                                requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                Offset++;
                                //Name
                                requestarray[Offset] = strlen( gReceptionList_Name[ReceptionListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gReceptionList_Name[ReceptionListLine] ); i++ )
                                {
                                    requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            ReceptionListLine = ReceptionList_nextvalidLine( ReceptionListLine, direction );
                        }//end while

                        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                    break;

                    case 15: //Pos
                        while( current_element < elements )
                        {
                            if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                        Offset++;
                                        requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                        }//end while

                    break;

                    default:
                        write( "AudioSD ReceptionList_Request: invalid recordaddress %d", recordaddress );
                    break;
                } //end switch "recordaddress"
            }//end ArrayData

            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        break; //end Changed_REQ

        case Data_REQ:
    //changes from Jran Karl (28.03.2012 )
            //MR 63336    02.07.2014
            //if( getvalue( env_AudioSD_RL_Timeout ) != TRUE )
            if(/*getvalue( env_AudioSD_RL_Timeout ) !=*/ TRUE )
            {
            //VAGH-10511
            ASGID = gReceptionList_ASGID;
            TAID = gReceptionList_TAID;
                if( getvalue( env_AudioSD_RL_ASGID_error ) != FALSE )
                {
                    ASGID += 0x02;
                }
                if( getvalue( env_AudioSD_RL_TAID_error ) != FALSE )
                {
                    TAID += 0x02;
                }

                requestarray[Offset] = (( ASGID * 0x10 ) & 0xF0 ) + ( TAID & 0x0F );
                Offset++;
                requestarray[Offset] = gReceptionList_ElementType;
                Offset++;
                requestarray[Offset] = gReceptionList_ParentID & 0xff;
                Offset++;
                requestarray[Offset] = ( gReceptionList_ParentID & 0xff00 ) / 0x100;
                Offset++;
                //MR 63667 11.07.2014 -TNLE with SA-button
                //requestarray[Offset] = gReceptionList_TotalNumListElements & 0xff;
                requestarray[Offset] =tnle /*gReceptionList_TotalNumListElements */ & 0xff;
                Offset++;

                //requestarray[Offset] = ( gReceptionList_TotalNumListElements & 0xff00 ) / 0x100;
                requestarray[Offset] = ( tnle /*gReceptionList_TotalNumListElements */ & 0xff00 ) / 0x100;
                Offset++;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;
                if( indexsize )
                {
                    requestarray[Offset] = requested_startelement & 0xff;
                    Offset++;
                    requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                    Offset++;

                    requestarray[Offset] = elements & 0xff;
                    Offset++;
                    requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                    Offset++;
                }
                else
                {
                    requestarray[Offset] = requested_startelement;
                    Offset++;
                    requestarray[Offset] = elements;
                    Offset++;
                }

                ReceptionListLine = startelement;

                //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                            while( current_element < elements )
                            {
                                if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                            //IssueList #76 - MR49870 : ReceptionList
                                            //Updating the status array excluding the deleted elements
                                           audioListDelFlg = 0x00;
                                           audioListDelFlg = audioList_deleteCheck( gReceptionList_Pos[ReceptionListLine], gReceptionList_Pos_insDel, gRL_CSVtotalElem);

                                        if( audioListDelFlg == 0x00 )
                                        {
                                            if( indexsize )
                                            {

                                                requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0xFF );
                                                Offset++;
                                                requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                                Offset++;

                                            }
                                            else
                                            {
                                                requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                                Offset++;
                                            }
                                        }// if audioListDelFlg
                                   }
                                    //IssueList #76 - MR49870 : ReceptionList
                                   if( audioListDelFlg == 0x00 )
                                   {
                                    //Type
                                    requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                    Offset++;

                                    //Attributes
                                    requestarray[Offset] = ( gReceptionList_Attributes[ReceptionListLine] & 0x00ff );
                                    Offset++;
                                    requestarray[Offset] = ( gReceptionList_Attributes[ReceptionListLine] & 0xFF00 ) / 0x100;
                                    Offset++;

                                    //PresetID
                                    requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                                    Offset++;

                                    //FmREG_Code
                                    requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                                    Offset++;

                                    //Category
                                    requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                    Offset++;

                                    //Name
                                    requestarray[Offset] = strlen( gReceptionList_Name[ReceptionListLine] );
                                    Offset++;

                                    for( i = 0; i < strlen( gReceptionList_Name[ReceptionListLine] ); i++ )
                                    {
                                        requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                        Offset++;
                                    }

                                    //Frequency
                                    requestarray[Offset] = strlen( gReceptionList_Frequency[ReceptionListLine] );
                                    Offset++;

                                    for( i = 0; i < strlen( gReceptionList_Frequency[ReceptionListLine] ); i++ )
                                    {
                                        requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                        Offset++;
                                    }
                                   }//  gReceptionList_InvalidFlg
                                }
                                //IssueList #76 - MR49870 : ReceptionList
                                if( audioListDelFlg == 0x00 )
                                current_element++;
                                ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 1: //Type, Attributes, PresetID, FmREG_Code, Category, Name
                            while( current_element < elements )
                            {
                                if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                            Offset++;
                                            requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                            Offset++;
                                        }
                                    }

                                    //Type
                                    requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                    Offset++;

                                    //Attributes
                                    requestarray[Offset] = gReceptionList_Attributes[ReceptionListLine];
                                    Offset++;

                                    //PresetID
                                    requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                                    Offset++;

                                    //FmREG_Code
                                    requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                                    Offset++;

                                    //Category
                                    requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                    Offset++;

                                    //Name
                                    requestarray[Offset] = strlen( gReceptionList_Name[ReceptionListLine] );
                                    Offset++;

                                    for( i = 0; i < strlen( gReceptionList_Name[ReceptionListLine] ); i++ )
                                    {
                                        requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                        Offset++;
                                    }
                                }
                                current_element++;
                                ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 2: //Type, Attributes
                            while( current_element < elements )
                            {
                                if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                            Offset++;
                                            requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                            Offset++;
                                        }
                                    }

                                    //Type
                                    requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                                    Offset++;

                                    //Attributes
                                    requestarray[Offset] = gReceptionList_Attributes[ReceptionListLine];
                                    Offset++;
                                }
                                current_element++;
                                ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 3: //PresetID, FmREG_Code, Category, Name
                            while( current_element < elements )
                            {
                                if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                            Offset++;
                                            requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                            Offset++;
                                        }
                                    }

                                    //PresetID
                                    requestarray[Offset] = gReceptionList_PresetID[ReceptionListLine];
                                    Offset++;

                                    //FmREG_Code
                                    requestarray[Offset] = gReceptionList_FmRegCode[ReceptionListLine];
                                    Offset++;

                                    //Category
                                    requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                                    Offset++;

                                    //Name
                                    requestarray[Offset] = strlen( gReceptionList_Name[ReceptionListLine] );
                                    Offset++;

                                    for( i = 0; i < strlen( gReceptionList_Name[ReceptionListLine] ); i++ )
                                    {
                                        requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                        Offset++;
                                    }
                                }
                                current_element++;
                                ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                     case 4: //Name
                            while( current_element < elements )
                            {
                                if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                            Offset++;
                                            requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                            Offset++;
                                        }
                                    }

                                    //Name
                                    requestarray[Offset] = strlen( gReceptionList_Name[ReceptionListLine] );
                                    Offset++;

                                    for( i = 0; i < strlen( gReceptionList_Name[ReceptionListLine] ); i++ )
                                    {
                                        requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                        Offset++;
                                    }
                                }
                                current_element++;
                                ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                     case 5: //Frequency
                            while( current_element < elements )
                            {
                                if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                            Offset++;
                                            requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                            Offset++;
                                        }
                                    }

                                    //Frequency
                                    requestarray[Offset] = strlen( gReceptionList_Frequency[ReceptionListLine] );
                                    Offset++;

                                    for( i = 0; i < strlen( gReceptionList_Frequency[ReceptionListLine] ); i++ )
                                    {
                                        requestarray[Offset] = gReceptionList_Frequency[ReceptionListLine][i];
                                        Offset++;
                                    }
                                }
                                current_element++;
                                ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );
                    }//end while
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                    break;

                case 6: //Type, Attributes, Category, Name
                    while ( current_element < elements )
                    {
                        if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if( transmitpos ) // Pos  ->Array position transmitted
                            {
                                if( indexsize )
                                {
                                    requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                    Offset++;
                                    requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine] & 0xFF00 ) / 0x100 );
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                    Offset++;
                                }
                            }
                            //Type
                            requestarray[Offset] = gReceptionList_Type[ReceptionListLine];
                            Offset++;
                            //Attributes
                            requestarray[Offset] = gReceptionList_Attributes[ReceptionListLine];
                            Offset++;
                            //Category
                            requestarray[Offset] = gReceptionList_Category[ReceptionListLine];
                            Offset++;
                            //Name
                            requestarray[Offset] = strlen( gReceptionList_Name[ReceptionListLine] );
                            Offset++;
                            for( i = 0; i < strlen( gReceptionList_Name[ReceptionListLine] ); i++ )
                            {
                                requestarray[Offset] = gReceptionList_Name[ReceptionListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        ReceptionListLine = ReceptionList_nextvalidLine( ReceptionListLine, direction );
                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 15: //Pos
                            while( current_element < elements )
                            {
                                if( ReceptionListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD ReceptionList_Request: invalid ReceptionListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                           //IssueList #76 - MR49870 : ReceptionList
                                            // Check if element is deleted
                                            audioListDelFlg = 0x00;
                                            audioListDelFlg = audioList_deleteCheck( gReceptionList_Pos[ReceptionListLine], gReceptionList_Pos_insDel, gRL_CSVtotalElem);

                                        if( audioListDelFlg == 0x00 )
                                        {
                                            if( indexsize )
                                            {

                                                requestarray[Offset] = ( gReceptionList_Pos[ReceptionListLine] & 0x00FF );
                                                Offset++;
                                                requestarray[Offset] = (( gReceptionList_Pos[ReceptionListLine]& 0xFF00 ) / 0x100 );
                                                Offset++;
                                            }
                                            else
                                            {

                                                requestarray[Offset] = gReceptionList_Pos[ReceptionListLine];
                                                Offset++;
                                            }
                                        }
                                    }
                                }
                                //IssueList #76 - MR49870 : ReceptionList
                                if( audioListDelFlg == 0x00 )
                                current_element++;
                                ReceptionListLine =ReceptionList_nextvalidLine( ReceptionListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    default:
                        write( "AudioSD ReceptionList_Request: invalid recordaddress %d", recordaddress );
                     break;
                } //end switch "recordaddress"
            //changes from Jran Karl (28.03.2012 )
        }
            else
            {
                write( "AudioSD ReceptionList_Request: Simulate timeout of Status-Array!" );
            }
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
         break; //end Error_REQ

    } //end switch "request"
}

AnnouncementInfo_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            AnnouncementInfo_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD AnnouncementInfo_Indication: invalid indication %d", Indication_array[2] );
            break;
    }

}

AnnouncementInfo_Request( byte request, byte errorcode )
{
    int i, Offset = 0;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_AnnouncementInfo;   //Fct.-ID
    requestarray[2] = request;                   //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x1C_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_AnnouncementInfo_Type;
            requestarray[4] = strlen( gAudioSD_AnnouncementInfo_StationName );
            Offset = 5;

            for( i = 0; i < strlen( gAudioSD_AnnouncementInfo_StationName ); i++ )
            {
                requestarray[Offset] = gAudioSD_AnnouncementInfo_StationName[i];
                Offset++;
            }

            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD AnnouncementInfo_Request: invalid request %d", request );
            break;
    }
}

on envVar env_AudioSD_AnInfo_update
{
    int i;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_AnnouncementInfo_Type = getvalue( env_AudioSD_AnInfo_Type );
        getvalue( env_AudioSD_AnInfo_StationName, gAudioSD_AnnouncementInfo_StationName );


        AnnouncementInfo_Request( Data_REQ, 0 );
    }
    else if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_AnnouncementInfo_Type = 0;

        for( i = 0; i < ANNOUNCEMENT_STATIONNAME_TEXTLENGTH; i++ )
            gAudioSD_AnnouncementInfo_StationName[i] = 0;


        putvalue( env_AudioSD_AnInfo_Type, gAudioSD_AnnouncementInfo_Type );
        putvalue( env_AudioSD_AnInfo_StationName, empty_string );

        AnnouncementInfo_Request( Data_REQ, 0 );
    }

}

InfoStates_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            InfoStates_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD InfoStates_Indication: invalid indication %d", Indication_array[2] );
            break;
    }

}

InfoStates_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_InfoStates; //Fct.-ID
    requestarray[2] = request;                   //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x1E_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_InfoStates_States;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD InfoStates_Request: invalid request %d", request );
            break;
    }
}

AnnouncementEscape_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] )
    {
        case Processing_CNF:
            //IssueList #57  and #74
            if( (( getValue( env_AudioSD_AnE_ErrorCode ) == 0x00 )||( getValue( env_AudioSD_AnE_ErrorCode ) > 0x3F ) ) && ( gAudioFctList_0x1D_TimeOut_flg == 0x00 ) )
             {
             AnnouncementEscape_Request( Processing_REQ, 0 );          //send Processing

                 //IssueList #68
                if( gAudioFctList_0x1D_Processing_flg== 0x01 )
                {
                  if( isTimerActive( gAudioFctList_0x1D_ProcessingTimer ) == 0x00 )
                  setTimer( gAudioFctList_0x1D_ProcessingTimer,AUDIOMAXPROCESSINGTIME );

                AnnouncementEscape_Request( Processing_REQ, 0 );
                }
             }
            break;

        case StartResult_IND:
              //IssueList #74
              if( getValue( env_AudioSD_FctList_0x1D_TimeOut ) != TRUE )
              {
                  gAudioFctList_0x1D_TimeOut_flg = 0x00;

                  //IssueList #57
                  if( getValue( env_AudioSD_AnE_Error_on )== 0x00 )
                  putValue( env_AudioSD_AnE_ErrorCode, 0 );
                  if( getvalue( env_AudioSD_AnE_Error_on ) )
                      AnnouncementEscape_Request(Error_REQ, getvalue( env_AudioSD_AnE_ErrorCode ) );

                  else if( FALSE == gAudioSD_AnnouncementEscape_status )
                  {
                      if( getvalue( env_AudioSD_AnE_NotActive ) == 0x04 )
                      {
                          gAudioSD_AnnouncementEscape_Result = getvalue( env_AudioSD_AnE_NotActive );
                          AnnouncementEscape_Request( Result_REQ, 0 );
                      }
                      else
                      {
                          gAudioSD_AnnouncementEscape_status = TRUE;                          //method active
                          settimer( AnnouncementEscape_Timer, AnnouncementEscape_TimerTime );
                      }
                  }
                }// IssueList #74
                else
                  gAudioFctList_0x1D_TimeOut_flg = 0x01;
            break;

        case Abort_IND:
            if( getvalue( env_AudioSD_AnE_Error_on ) )
                AnnouncementEscape_Request(Error_REQ, getvalue( env_AudioSD_AnE_ErrorCode ) );

            else
            {
                if( TRUE != gAudioSD_AnnouncementEscape_status )                             //method not active
                    AnnouncementEscape_Request(Error_REQ, 0x50 );                            //send error-message

                else if( TRUE == gAudioSD_AnnouncementEscape_status )                            //method still active
                {
                    gAudioSD_AnnouncementEscape_Result = getvalue( env_AudioSD_AnE_Abort );

                    if( AUDIO_ANNOUNCEMENTESCAPE_ABORTSUCCESSFUL == gAudioSD_AnnouncementEscape_Result )     //only, if abort is successful
                    {
                        canceltimer( AnnouncementEscape_Timer );                              //abort method
                        gAudioSD_AnnouncementEscape_status = FALSE;                         //method finished
                    }

                    AnnouncementEscape_Request( Result_REQ, 0 );  //send result-message
                }
            }
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD AnnouncementEscape_Indication: unknown indication %d", Indication_array[2] );
            break;
    }
}

AnnouncementEscape_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;                  //LSG-ID
    requestarray[1] = FctID_AnnouncementEscape;   //Fct.-ID
    requestarray[2] = request;

    switch( request )
    {
        case Processing_REQ:
            requestarray[3] = gAudioSD_AnnouncementEscape_Reserve;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            break;
        case Result_REQ:
            //IssueList #68
            if( gAudioFctList_0x1D_Processing_flg == 0x00 )
            {
            requestarray[3] = gAudioSD_AnnouncementEscape_Result;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            }
            break;
        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            //IssueList #68
            cancelTimer( gAudioFctList_0x1D_ProcessingTimer );
            break;
        default:    //error
            writelineEx( gError_Trace, 0, "AudioSD AnnouncementEscape_Request: unknown request %d", request );
            break;
    }
}

DedicatedAudioControl_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;                  //LSG-ID
    requestarray[1] = FctID_DedicatedAudioControl;   //Fct.-ID
    requestarray[2] = request;

    switch( request )
    {
        case Processing_REQ:
            requestarray[3] = gAudioSD_DAC_Reserve;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            break;
        case Result_REQ:
            //IssueList #68
            if( gAudioFctList_0x18_Processing_flg == 0x00 )
            {
            requestarray[3] = gAudioSD_DAC_Result;
            //MR 60227
            //Send the BAP request as normal/expected if MOST is not active
            if( getValue( env_PIC_bapMOST_active_flag ) == 0x00 )
            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
             //BAP_MOST sync
            else if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
                {
                      //BAP FIRST before MOST
                      if( getValue( env_AudioTel_bapMost_delayTimer ) <= 0 ) //delay timer
                      {
                          set_status_requestbuffer( requestarray, 4, Bap_UInt8 ); //send BAP first
                          setTimer( _tBapFirst_delayTime, (-1 ) * getValue( env_AudioTel_bapMost_delayTimer ) ); //call MOST function after the delay
                      }
                      ////MOST FIRST before BAP
                      else if( getValue( env_AudioTel_bapMost_delayTimer ) > 0 ) //delay timer
                      {
                          //prepare the data
                          for( i = 0; i < BAP_BUFFER_SIZE; i++ ) //clear
                             gAudio_Requestarray[i] = 0;
                          for( i = 0; i < 4; i++ ) //prepare the data
                             gAudio_Requestarray[i] = requestarray[i];
                          gAudio_BuffSize = 4;
                          gAudio_BAPdataType = Bap_UInt8;
                          BAP2MOSTSync(); //call MOST
                          setTimer( _tMostFirst_delayTime, getValue( env_AudioTel_bapMost_delayTimer ) ); //call BAP after the delay
                      }
                } //MOST_active_flag
            }
            break;
        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            cancelTimer( gAudioFctList_0x18_ProcessingTimer );
            break;
        default:    //error
            writelineEx( gError_Trace, 0, "AudioSD DedicatedAudioControl_Request: unknown request %d", request );
            break;
    }
}

DedicatedAudioControl_Indication ( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] )
    {
        case Processing_CNF:
           if( (( getValue( env_AudioSD_DAC_ErrorCode ) == 0x00 )||( getValue( env_AudioSD_DAC_ErrorCode ) > 0x3F ) ) &&  ( gAudioFctList_0x18_TimeOut_flg == 0x00 ) )
             {
             DedicatedAudioControl_Request( Processing_REQ, 0 );          //send Processing

                if( gAudioFctList_0x18_Processing_flg== 0x01 )
                {
                  if( isTimerActive( gAudioFctList_0x18_ProcessingTimer ) == 0x00 )
                  setTimer( gAudioFctList_0x18_ProcessingTimer,AUDIOMAXPROCESSINGTIME );

                DedicatedAudioControl_Request( Processing_REQ, 0 );
                }

             }
        break;

        case StartResult_IND:
              if( getValue( env_AudioSD_FctList_0x18_TimeOut ) != TRUE )
              {
              gAudioFctList_0x18_TimeOut_flg = 0x00;

                if( getValue( env_AudioSD_DAC_Error_on )== 0x00 )
                putValue( env_AudioSD_DAC_ErrorCode, 0 );

                    if( getvalue( env_AudioSD_DAC_Error_on ) )
                    {
                        DedicatedAudioControl_Request(Error_REQ, getvalue( env_AudioSD_DAC_ErrorCode ) );
                    }
                    else
                    {
                        if( FALSE == gAudioSD_DAC_status )
                        {
                            gAudioSD_DAC_status = TRUE;                            //method active

                            //get data
                            gAudioSD_DAC_ControlType  =Indication_array[3];
                            gAudioSD_DAC_FSGHandle    =Indication_array[4] + ( Indication_array[5] * 0x100 );
                            gAudioSD_DAC_ListType     =Indication_array[6];

                            if( gAudioSD_DAC_ControlType> 0x07)
                            {
                                DedicatedAudioControl_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE );
                                gAudioSD_DAC_status = FALSE;
                            }
                            else if( gAudioSD_DAC_ListType> 0x05)
                            {
                                DedicatedAudioControl_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE );
                                gAudioSD_DAC_status = FALSE;
                            }
                            else //received data valid
                            {
                                if( getvalue( env_AudioSD_DAC_Res ) == AUDIO_DAC_SUCCESSFUL)
                                {
                                    switch(  gAudioSD_DAC_ControlType )
                                    {
                                        case AUDIO_DAC_FASTFORWARD:
                                                    gAudioSD_DAC_MethodHandling = 3;
                                                    settimer( DAC_MethodHandling_Timer, 20 );
                                        break;

                                        case AUDIO_DAC_FASTBACKWARD:
                                                    gAudioSD_DAC_MethodHandling = 3;
                                                    settimer( DAC_MethodHandling_Timer, 20 );
                                        break;

                                        case AUDIO_DAC_SELECT_LIST_ENTRY:
                                                    if( getValue( env_Audio_Update_Mode ) )
                                                    {
                                //write( "\n Station Handle SELECT CHOSEN" );
                                                        Audio_Current_Station_Handle_Update();
                                                    }
                                                    gAudioSD_DAC_MethodHandling = 1;
                                                    settimer( DAC_MethodHandling_Timer, 20 );
                                                    settimer( DAC_Timer, gAudioSD_DAC_TimerTime );
                                        break;

                                        case AUDIO_DAC_NEXT:
                                                    if( getValue( env_Audio_Update_Mode ) )
                                                    {
                                //write( "\n Station Handle NEXT CHOSEN" );
                                                        Audio_Next_Station_Handle_Update();
                                                    }
                                                    gAudioSD_DAC_MethodHandling = 1;
                                                    settimer( DAC_MethodHandling_Timer, 20 );
                                                    settimer( DAC_Timer, gAudioSD_DAC_TimerTime );
                                        break;

                                        case AUDIO_DAC_PREVIOUS:
                                                    if( getValue( env_Audio_Update_Mode ) )
                                                    {
                                //write( "\n Station Handle PREVIOUS CHOSEN" );
                                                        Audio_Previous_Station_Handle_Update();
                                                    }
                                                    gAudioSD_DAC_MethodHandling = 1;
                                                    settimer( DAC_MethodHandling_Timer, 20 );
                                                    settimer( DAC_Timer, gAudioSD_DAC_TimerTime );
                                        break;

                                        //changes from Jran Karl (28.03.2012 )
                        case AUDIO_DAC_UPDATESTATION:
                                            putValue( env_AudioSD_activeSrc_ListState, 0x04 );
                                            putValue( env_AudioSD_activeSrc_update, 0x01 );

                                            settimer( DAC_Timer, 1000*5); // 5 sekunden

                                        break;

                        case AUDIO_DAC_CANCELSTATIONLISTUPDATE:
                                            putValue( env_AudioSD_activeSrc_ListState, 0x03);
                                            putValue( env_AudioSD_activeSrc_update, 0x01 );
                                            settimer( DAC_Timer, 1000*5); // 5 sekunden

                                        break;

                                        default:
                                                    settimer( DAC_Timer, gAudioSD_DAC_TimerTime );
                                        break;
                                    }
                                }
                                else
                                    settimer( DAC_Timer, gAudioSD_DAC_TimerTime );
                            }
                        }
                    }
                }
                else
                gAudioFctList_0x18_TimeOut_flg = 0x01;
        break;

        case Abort_IND:
            if( getvalue( env_AudioSD_DAC_Error_on ) )
            {
                    DedicatedAudioControl_Request(Error_REQ, getvalue( env_AudioSD_DAC_ErrorCode ) );
            }
            else
            {
                if( TRUE != gAudioSD_DAC_status )                                //method not active
                {
                    DedicatedAudioControl_Request(Error_REQ, 0x50 );            //send error-message
                }
                else if( TRUE == gAudioSD_DAC_status )                            //method still active
                {
                    gAudioSD_DAC_Result = getvalue( env_AudioSD_DAC_Abort );

                    if( AUDIO_DAC_ABORTSUCCESSFUL == gAudioSD_DAC_Result )        //only, if abort is successful
                    {
                        canceltimer( DAC_Timer );                                //abort method
                        canceltimer( DAC_MethodHandling_Timer );
                        gAudioSD_DAC_status = FALSE;                            //method finished
                        gAudioSD_DAC_MethodHandling = 0;
                    }

                    DedicatedAudioControl_Request( Result_REQ, 0 );    //send result-message
                }
            }
        break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD DedicatedAudioControl_Indication: unknown indication %d", Indication_array[2] );
        break;
        }
}

on timer DAC_Timer
{
    gAudioSD_DAC_Result = getvalue( env_AudioSD_DAC_Res );
    if( gAudioSD_DAC_Result != AUDIO_DAC_NOTSUCCESSFUL && gAudioSD_DAC_status == TRUE )
    {
      //Panel
      if( gAudioSD_DAC_ControlType < 0x08 )
          putvalue( env_AudioSD_DAC_CT_s, gAudioSD_DAC_ControlType_s[gAudioSD_DAC_ControlType] );
      else
          putvalue( env_AudioSD_DAC_CT_s, gstring_reserved );

      putvalue( env_AudioSD_DAC_FSGHandle, gAudioSD_DAC_FSGHandle );

      if( gAudioSD_DAC_ListType < 0x08 )
          putvalue( env_AudioSD_DAC_LT_s, gAudioSD_DAC_ListType_s[gAudioSD_DAC_ListType] );
      else
          putvalue( env_AudioSD_DAC_LT_s, gstring_reserved );
    }
    DedicatedAudioControl_Request( Result_REQ, 0 ); //send Result

    // Update Station Info
    switch(  gAudioSD_DAC_ControlType )
    {
        case AUDIO_DAC_SELECT_LIST_ENTRY:
            if( getValue( env_Audio_Update_Mode ) )
            {
                //write( "\n Station Info SELECT CHOSEN" );
                Audio_Current_Station_Info_Update();
            }
        break;

        case AUDIO_DAC_NEXT:
            if( getValue( env_Audio_Update_Mode ) )
            {
                //write( "\n Station Info NEXT CHOSEN" );
                Audio_Next_Station_Info_Update();
            }
        break;

        case AUDIO_DAC_PREVIOUS:
            if( getValue( env_Audio_Update_Mode ) )
            {
                //write( "\n Station Info PREVIOUS CHOSEN" );
                Audio_Previous_Station_Info_Update();
            }
        break;
    }

    gAudioSD_DAC_status = FALSE; //method not active

    if( gAudioSD_DAC_Result == AUDIO_DAC_SUCCESSFUL)
    {
        gAudioSD_DAC_MethodHandling = 2;
        settimer( DAC_MethodHandling_Timer,100 );
    }
}

on envVar env_AudioSD_RecListType_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_ReceptionListType_Type = getvalue( env_AudioSD_RecListType_Type );


        ReceptionListType_Request( Data_REQ, 0 );
    }
    //changes from J.Karl 30.11.2012
    putValue( env_AudioSD_RecListType_update, 0x0 );
}

ReceptionListType_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_ReceptionListType;  //Fct.-ID
    requestarray[2] = request;                   //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x1F_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_ReceptionListType_Type;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD ReceptionListType_Request: invalid request %d", request );
            break;
    }
}

SourceList_Request( byte request, word tnle, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode )
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word SourceListLine;
    //IssueList #76 - MR49870 : SourceList
    byte audioListDelFlg;

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray [i] = 0;

    shift               = 0;
    direction           = 0;
    transmitpos         = 0;
    indexsize           = 0;
    SourceListLine      = 0;
    current_element     = 0;
    Offset              = 0;
    audioListDelFlg = 0;

    // decode "mode -byte"
    shift       = mode & 0x01;
    direction   = ( mode & 0x02 ) / 0x02;
    transmitpos = ( mode & 0x04 ) / 0x04;
    indexsize   = ( mode & 0x08 ) / 0x08;

    // Handle request.
    requestarray[0] = LSG_AudioSD;                //LSG-ID
    requestarray[1] = FctID_SourceList;            //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;

    switch( request )
    {
        case Changed_REQ:

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            SourceListLine = startelement;

            if( getvalue( env_AudioSD_SL_CA_switch ) ) //ArrayData
            {
            //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                        while( current_element < elements )
                        {
                            if( SourceListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SourceList_Request: invalid SourceListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0xFF ); Offset++;
                                        requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 ); Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine]; Offset++;
                                    }
                                }
                                requestarray[Offset] = gSourceList_SourceType[SourceListLine]; Offset++; //SourceType
                                requestarray[Offset] = gSourceList_InstanceID[SourceListLine]; Offset++; //InstanceID
                                requestarray[Offset] = gSourceList_MediaType[SourceListLine]; Offset++; //MediaType
                                requestarray[Offset] = gSourceList_Attributes[SourceListLine]; Offset++; //Attributes
                                requestarray[Offset] = strlen( gSourceList_Name[SourceListLine] ); Offset++; //Name
                                for( i = 0; i < strlen( gSourceList_Name[SourceListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSourceList_Name[SourceListLine][i]; Offset++;
                                }
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );
                        }//end while
                    break;

                    case 1: //SourceType, Instance_ID, MediaType, Attributes
                        while( current_element < elements )
                        {
                            if( SourceListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SourceList_Request: invalid SourceListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }

                                //SourceType
                                requestarray[Offset] = gSourceList_SourceType[SourceListLine];
                                Offset++;

                                //InstanceID
                                requestarray[Offset] = gSourceList_InstanceID[SourceListLine];
                                Offset++;

                                //MediaType
                                requestarray[Offset] = gSourceList_MediaType[SourceListLine];
                                Offset++;

                                //Attributes
                                requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                                Offset++;
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );

                        }//end while
                    break;

                    case 2: //Name
                        while( current_element < elements )
                        {
                            if( SourceListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SourceList_Request: invalid SourceListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }

                                //Name
                                requestarray[Offset] = strlen( gSourceList_Name[SourceListLine] );
                                Offset++;

                                for( i = 0; i < strlen( gSourceList_Name[SourceListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSourceList_Name[SourceListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );

                        }//end while
                    break;

                    case 3: //Attributes
                        while( current_element < elements )
                        {
                            if( SourceListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SourceList_Request: invalid SourceListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }

                                //Attributes
                                requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                                Offset++;
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );

                        }//end while
                    break;

                    case 4: //MediaType
                        while( current_element < elements )
                        {
                            if( SourceListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SourceList_Request: invalid SourceListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }

                                //MediaType
                                requestarray[Offset] = gSourceList_MediaType[SourceListLine];
                                Offset++;
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );

                        }//end while
                    break;

                    case 15: //Pos
                        while( current_element < elements )
                        {
                            if( SourceListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SourceList_Request: invalid SourceListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0x00FF );
                                        Offset++;
                                        requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );

                        }//end while

                    break;

                    default:
                        write( "AudioSD SourceList_Request: invalid recordaddress %d", recordaddress );
                    break;
                } //end switch "recordaddress"
            }//end 'ArrayData'

            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            break; //end Changed_REQ

        case Data_REQ:
            //changes from Jran Karl (28.03.2012 )
            //MR 63336    02.07.2014
            //if( getvalue( env_AudioSD_SL_Timeout ) != TRUE )
            if(/*getvalue( env_AudioSD_SL_Timeout ) != */ TRUE )
            {
            //VAGH-10511
            ASGID = gSourceList_ASGID;
            TAID = gSourceList_TAID;
                if( getvalue( env_AudioSD_SL_ASGID_error ) != FALSE )
                {
                    ASGID += 0x02;
                }
                //MR 63332 #1
                //if( getvalue( env_AudioSD_RTPL_TAID_error ) != FALSE )
                if( getvalue( env_AudioSD_SL_TAID_error ) != FALSE )
                {
                    TAID += 0x02;
                }

                requestarray[Offset] = (( ASGID * 0x10 ) & 0xF0 ) + ( TAID & 0x0F );
                Offset++;
                //MR 63667 11.07.2014 -TNLE with SA-button
                requestarray[Offset] =tnle /*gSourceList_TotalNumListElements */ & 0xff;
                Offset++;
                requestarray[Offset] = ( tnle /*gSourceList_TotalNumListElements */ & 0xff00 ) / 0x100;
                Offset++;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;
                if( indexsize )
                {
                    requestarray[Offset] = requested_startelement & 0xff;
                    Offset++;
                    requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                    Offset++;

                    requestarray[Offset] = elements & 0xff;
                    Offset++;
                    requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                    Offset++;
                }
                else
                {
                    requestarray[Offset] = requested_startelement;
                    Offset++;
                    requestarray[Offset] = elements;
                    Offset++;
                }

                SourceListLine = startelement;

                //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                            while( current_element < elements )
                            {

                                if( SourceListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD SourceList_Request: invalid SourceListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        //IssueList #76 - MR49870 : SourceList
                                            //Updating the status array excluding the deleted elements
                                           audioListDelFlg = 0x00;
                                           audioListDelFlg = audioList_deleteCheck( gSourceList_Pos[SourceListLine], gSourceList_Pos_insDel, gSL_CSVtotalElem);

                                        if( audioListDelFlg == 0x00 )
                                        {
                                            if( indexsize )
                                            {
                                                requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0xFF );
                                                Offset++;
                                                requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 );
                                                Offset++;
                                            }
                                            else
                                            {

                                                requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                                Offset++;
                                            }
                                        } // audioListDelFlg
                                    }

                                     //IssueList #76 - MR49870 : SourceList
                                   if( audioListDelFlg == 0x00 )
                                   {
                                        //SourceType
                                        requestarray[Offset] = gSourceList_SourceType[SourceListLine];
                                        Offset++;

                                        //InstanceID
                                        requestarray[Offset] = gSourceList_InstanceID[SourceListLine];
                                        Offset++;

                                        //MediaType
                                        requestarray[Offset] = gSourceList_MediaType[SourceListLine];
                                        Offset++;

                                        //Attributes
                                        requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                                        Offset++;

                                        //Name
                                        requestarray[Offset] = strlen( gSourceList_Name[SourceListLine] );
                                        Offset++;

                                        for( i = 0; i < strlen( gSourceList_Name[SourceListLine] ); i++ )
                                        {
                                            requestarray[Offset] = gSourceList_Name[SourceListLine][i];
                                            Offset++;
                                        }
                                    }
                                }
                                 //IssueList #76 - MR49870 : SourceList
                                if( audioListDelFlg == 0x00 )
                                current_element++;

                                SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 1: //SourceType, Instance_ID, MediaType, Attributes

                            while( current_element < elements )
                            {

                                if( SourceListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD SourceList_Request: invalid SourceListLine" );

                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                            //IssueList #76 - MR49870 : SourceList
                                            //Updating the status array excluding the deleted elements
                                           audioListDelFlg = 0x00;
                                           audioListDelFlg = audioList_deleteCheck( gSourceList_Pos[SourceListLine], gSourceList_Pos_insDel, gSL_CSVtotalElem);

                                        if( audioListDelFlg == 0x00 )
                                        {
                                            if( indexsize )
                                            {
                                                requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0xFF ); Offset++;
                                                requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 ); Offset++;
                                            }
                                            else
                                            {
                                                requestarray[Offset] = gSourceList_Pos[SourceListLine]; Offset++;
                                            }
                                        } //audioListDelFlg
                                    }

                                    if( audioListDelFlg == 0x00 )
                                    {
                                        requestarray[Offset] = gSourceList_SourceType[SourceListLine]; Offset++; //SourceType
                                        requestarray[Offset] = gSourceList_InstanceID[SourceListLine]; Offset++; //InstanceID
                                        requestarray[Offset] = gSourceList_MediaType[SourceListLine]; Offset++; //MediaType
                                        requestarray[Offset] = gSourceList_Attributes[SourceListLine]; Offset++; //Attributes
                                    }
                                }
                                if( audioListDelFlg == 0x00 )
                                current_element++;

                                SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 2: //Name
                            while( current_element < elements )
                            {
                                if( SourceListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD SourceList_Request: invalid SourceListLine" );

                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0xFF );
                                            Offset++;
                                            requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gSourceList_Pos[SourceListLine]; Offset++;
                                        }
                                    }

                                    requestarray[Offset] = strlen( gSourceList_Name[SourceListLine] ); Offset++; //Name
                                    for( i = 0; i < strlen( gSourceList_Name[SourceListLine] ); i++ )
                                    {
                                        requestarray[Offset] = gSourceList_Name[SourceListLine][i]; Offset++;
                                    }
                                }

                                current_element++;
                                SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 3: //Attributes
                            while( current_element < elements )
                            {
                                if( SourceListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD SourceList_Request: invalid SourceListLine" );

                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0xFF );
                                            Offset++;
                                            requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                            Offset++;
                                        }
                                    }

                                    //Attributes
                                    requestarray[Offset] = gSourceList_Attributes[SourceListLine];
                                    Offset++;
                                }
                                current_element++;
                                SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                     case 4: //MediaType
                            while( current_element < elements )
                            {
                                if( SourceListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD SourceList_Request: invalid SourceListLine" );

                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0xFF );
                                            Offset++;
                                            requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                            Offset++;
                                        }
                                    }

                                    //MediaType
                                    requestarray[Offset] = gSourceList_MediaType[SourceListLine];
                                    Offset++;
                                }
                                current_element++;
                                SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 15: //Pos
                            while( current_element < elements )
                            {
                                if( SourceListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD SourceList_Request: invalid SourceListLine" );

                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {

                                         //IssueList #76 - MR49870 : SourceList
                                            // Check if element is deleted
                                            audioListDelFlg = 0x00;
                                            audioListDelFlg = audioList_deleteCheck( gSourceList_Pos[SourceListLine], gSourceList_Pos_insDel, gSL_CSVtotalElem);

                                        if( audioListDelFlg == 0x00 )
                                        {

                                            if( indexsize )
                                            {
                                                requestarray[Offset] = ( gSourceList_Pos[SourceListLine] & 0x00FF );
                                                Offset++;
                                                requestarray[Offset] = (( gSourceList_Pos[SourceListLine]& 0xFF00 ) / 0x100 );
                                                Offset++;
                                            }
                                            else
                                            {

                                                requestarray[Offset] = gSourceList_Pos[SourceListLine];
                                                Offset++;
                                            }
                                        }
                                    }
                                }

                                //IssueList #76 - MR49870 : SourceList
                                if( audioListDelFlg == 0x00 )
                                current_element++;

                                SourceListLine = SourceList_nextvalidLine( SourceListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    default:
                        write( "AudioSD SourceList_Request: invalid recordaddress %d", recordaddress );
                     break;
                } //end switch "recordaddress"
            //changes from Jran Karl (28.03.2012 )
        }
            else
            {
                write( "AudioSD SourceList_Request: Simulate timeout of Status-Array!" );
            }
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
         break; //end Error_REQ

    } //end switch "request"
}

SourceList_Indication ( dword Indication_array [], int datalength )
{
    byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements;
    //IssueList #76 - MR49870 : SourceList
    int i = 0,j = 0;
    byte audioListDelFlg;
    word validStartElem_plusElem;

    //IssueList #193
    byte sl_InValidStartElemFlg;

    // Init local variables.
    mode                    = 0;
    direction               = 0;
    shift                   = 0;
    transmitpos             = 0;
    recordaddress           = 0;
    requested_startelement  = 0x0000;
    startelement            = 0x0000;
    elements                = 0;
    indexsize               = 0;
    valid_startelement      = 0xff;
    valid_elements          = 0;

    //IssueList #76 - MR49870 : SourceList 15MAY
    validStartElem_plusElem = 0;

        switch( Indication_array[2] ) // indication
        {
            case DataGet_IND:
                if( getvalue( env_AudioSD_SL_Error_on ) )
                {
                    //MR 63667 11.07.2014 -TNLE with SA-button
                    //SourceList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue( env_AudioSD_SL_ErrorCode ) );
                    SourceList_Request(Error_REQ, 0, 0, 0, 0, 0, 0, getvalue( env_AudioSD_SL_ErrorCode ) );
                }
                //MR 63336    02.07.2014
                else if( getvalue( env_AudioSD_SL_Timeout ) == TRUE )
                {
                /* NOP */
                }
                else
                {
                    //getData
                    gSourceList_ASGID                = ( gBAP_Indication[3] & 0xF0 ) / 0x10;
                    gSourceList_TAID                 = gBAP_Indication[3] & 0x0F;

                    //decode BAP-ArrayHeader
                    mode                = ( gBAP_Indication[4] & 0xF0 ) / 0x10;

                    // decode "mode -byte"
                    shift       = mode & 0x01;
                    direction   = ( mode & 0x02 ) / 0x02;
                    transmitpos = ( mode & 0x04 ) / 0x04;
                    indexsize   = ( mode & 0x08 ) / 0x08;

                    recordaddress       = gBAP_Indication[4] & 0x0F;
                    if( indexsize )
                    {
                        startelement        = gBAP_Indication[5];
                        startelement        += gBAP_Indication[6] * 0x100;
                        elements            = gBAP_Indication[7];
                        elements            += gBAP_Indication[8]* 0x100;
                    }
                    else
                    {
                        startelement        = gBAP_Indication[5];
                        elements            = gBAP_Indication[6];
                    }

                    requested_startelement = startelement;

                    transmitpos     = TRUE; //Position must always be sent in the case of *.GetArray.
                    mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***Startelement = 0***/
                if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
                {
                    if( FORWARD==direction )  //forward-start
                    {
                        valid_startelement = 0;

                             //IssueList #76 - MR49870 : SourceList
                 //change the AUDIO_SOURCELIST_ENTRIES --> gSL_CSVtotalElem --> gSourceList_TotalNumListElements
                if( gSourceList_TotalNumListElements <= elements )         //1. more elements requested, than in array
                    {
                                if( shift == FALSE )
                                {
                                    //IssueList #76 - MR49870 : SourceList
                                    for( i = 0; i < gSourceList_TotalNumListElements; i++ )
                                    {
                                        if( 0 != gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                        {
                                            if( gSourceList_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                            valid_elements++;                                //increment elements
                                            //write( "1 valid_elements = %d", valid_elements );

                                        }
                                        else                                                //no valid element, loop finished
                                            i = gSL_CSVtotalElem;
                                    }
                                }
                                else if( shift == TRUE )
                                {
                                    valid_startelement  = startelement;
                                    valid_elements      = 0;
                                }
                            }
                            else    //2. number of requested elements < elements in array
                            {
                                if( shift == FALSE )
                                {
                                    for( i = 0; i < elements; i++ )
                                    {
                                        if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                        {
                                            if( gSourceList_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                            valid_elements++;      //increment elements

                                        }
                                        else                                                //no valid element, loop finished
                                            i = gSL_CSVtotalElem;
                                    }
                                }
                                else if( shift == TRUE )
                                {
                                    valid_startelement  = startelement;
                                    valid_elements      = 0;
                                }
                            }
                        }                                                               //forward ends

                        else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                        {
                            //searching for valid startelement
                            for( i = ( gSL_CSVtotalElem-1 ); i>= 0; i--)
                            {
                                if( 0!= gSourceList_ListEntryValidInformation[i] )        //found valid startelement
                                {
                                    valid_startelement = i;
                                    i = 0;
                                }
                            }

                        //searching for valid elements
                        if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                        else if( 0 ==valid_startelement )
                            valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                            else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                            {
                                for( i =valid_startelement; i>= 0; i--)
                                {
                                    if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                    {
                                        if( gSourceList_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                        valid_elements++;  //increment elements

                                    }
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                                {
                                    if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                    {
                                        if( gSourceList_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                        valid_elements++;        //increment elements

                                    }
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }

                        }
                    }                                                               //backward-end
                }                                                                   //startelement == 0 -end

                    /***Startelement!= 0***/
                    else                                                                //searching for Startelement-ID
                    {
                        //IssueList #193 - start
                        sl_InValidStartElemFlg = 0;
                        for( i = 0; i < gSL_CSVtotalElem; i++ )
                        {
                            if( startelement == gSourceList_Pos_insDel[i][0] )
                            {
                                //check if Start is deleted then reply with 0 elements
                                if( gSourceList_Pos_insDel[i][1] == 0x01 )
                                {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                                sl_InValidStartElemFlg = 1;
                                }
                            }
                        }
                        //IssueList #193 - end

                        //IssueList #193 - if condition
                        if( sl_InValidStartElemFlg == 0x00 )
                        {
                            //searching for valid startelement

                            for( i = 0; i < gSL_CSVtotalElem; i++ )
                            {
                                if( gSourceList_Pos[i] == startelement )                        //found a valid element
                                {
                                    if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                                    {
                                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                            valid_startelement = i + 1-2*direction;

                                        else if( i == 0 && BACKWARD==direction )
                                            valid_startelement = gSourceList_sum;     //valid element is last element in Array

                                    else if( i == 0 && FORWARD==direction )
                                        valid_startelement = 0;                          //valid element is first element in Array
                                }

                                else
                                    valid_startelement = i;                              //found element is valid_startelement

                                    i = gSL_CSVtotalElem;
                                }
                            }

                            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
                            {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                            }
                            else                                                                //found valid entry for startelement in array
                            {
                                //verify number of valid elements
                                if( BACKWARD==direction )                                            //backward-start
                                {
                                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                                        {
                                        //IssueList #76 - MR49870 : SourceList
                                       audioListDelFlg = 0x00;
                                       audioListDelFlg = audioList_deleteCheck( gSourceList_Pos[0], gSourceList_Pos_insDel, gSL_CSVtotalElem );

                                            if( audioListDelFlg == 0x00 )
                                            valid_elements= 1;
                                        }

                                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                                    {
                                        for( i =valid_startelement; i>= 0; i--)
                                        {
                                            if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                            {
                                                if( gSourceList_Pos[i] > 0xFF ) //check indexsize
                                                    indexsize = TRUE;

                                                valid_elements++;    //increment elements

                                            }
                                            else                                                //no valid element, loop finished
                                                i = 0;
                                        }
                                    }
                                    else                                                        //enougth array-elements available
                                    {
                                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                                        {
                                            if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                            {
                                                if( gSourceList_Pos[i] > 0xFF ) //check indexsize
                                                    indexsize = TRUE;

                                                valid_elements++;                                //increment elements
                                                 //write( "6 valid_elements = %d", valid_elements );
                                            }
                                            else                                                //no valid element, loop finished
                                                i = 0;
                                        }
                                    }
                                }                                                                //backward-end
                                else                                                            //forward-start
                                {
                                    //IssueList #76 - MR49870 : SourceList
                                    //if((valid_startelement+elements )>= gSL_CSVtotalElem)
                                    if((valid_startelement+elements )>= gSourceList_TotalNumListElements )
                                    {
                                        for( i =valid_startelement; i < gSL_CSVtotalElem; i++ )
                                        {
                                            if( 0!= gSourceList_Pos[i] )                        //if there is an valid element
                                            {
                                                if( gSourceList_Pos[i] > 0xFF ) //check indexsize
                                                    indexsize = TRUE;

                                                //IssueList #76 - MR49870 : SourceList
                                                audioListDelFlg = 0x00;
                                                audioListDelFlg = audioList_deleteCheck( gSourceList_Pos[i], gSourceList_Pos_insDel, gSL_CSVtotalElem );

                                              //SourceList 15MAY
                                              //if( audioListDelFlg == 0x00 )
                                              if( audioListDelFlg == 0x00 && valid_elements < elements )
                                                valid_elements++;                                //increment elements

                                            }
                                            else                                                //no valid element, loop finished
                                                i = gSL_CSVtotalElem;
                                        }
                                    }
                                    else
                                    {
                                         //IssueList #76 - MR49870 : SourceList 15MAY
                                         validStartElem_plusElem =valid_startelement+elements;
                                        //for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                                        for( i =valid_startelement; i <validStartElem_plusElem ; i++ )
                                        {
                                            if( 0!= gSourceList_Pos[i] )                            //if there is an valid element
                                            {
                                                if( gSourceList_Pos[i] > 0xFF ) //check indexsize
                                                    indexsize = TRUE;

                                                //IssueList #76 - MR49870 : SourceList
                                               audioListDelFlg = 0x00;
                                               audioListDelFlg = audioList_deleteCheck( gSourceList_Pos[i], gSourceList_Pos_insDel, gSL_CSVtotalElem);

                                                if( audioListDelFlg == 0x00 )
                                                {
                                                    //SourceList 15MAY
                                                    if( valid_elements < elements )      //guard check if valid elements < elements
                                                    valid_elements++;                    //increment elements


                                                 }

                                                 //SourceList 15MAY
                                                 else
                                                 {
                                                    if( valid_elements < elements )
                                                    validStartElem_plusElem++;          //adjust the loop boundary based on number of deleted elements
                                                 }

                                            }
                                            else                                                    //no valid element, loop finished
                                                i = gSL_CSVtotalElem;
                                        }
                                    }
                                }
                            }
                        }//sl_InValidStartElemFlg
                    } //else Startelement!= 0

                    if((valid_startelement > 0xFF ) || ( requested_startelement > 0xFF ) ) //check indexsize
                        indexsize = TRUE;

                mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                //send StatusArray
                //MR 63667 11.07.2014 -TNLE with SA-button
                //SourceList_Request( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
        //VAGH-10511
        if(!getvalue( env_AudioSD_SL_noStatusArray ) )
            SourceList_Request( Data_REQ, gSourceList_TotalNumListElements, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
                }
                //Panel
                putvalue( env_AudioSD_SL_ASGID, gSourceList_ASGID);
                putvalue( env_AudioSD_SL_TAID, gSourceList_TAID);
             break;

            case Error_IND:
                writelineEx( gError_Trace, 0, "FSG_AudioSD SourceList_Indication: received error, errorcode:0x%x", Indication_array[3] );
            break;

            default:
                writelineEx( gError_Trace, 0, "FSG_AudioSD SourceList_Indication: invalid indication %d", Indication_array[2] );
             break;
    }
}

SwitchSource_Indication ( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] )
    {
        case Processing_CNF:
            //IssueList #57  and #74
           if( (( getValue( env_AudioSD_SwitchSource_ErrorC) == 0x00 )||( getValue( env_AudioSD_SwitchSource_ErrorC) > 0x3F ) ) &&  ( gAudioFctList_0x22_TimeOut_flg == 0x00 ) )
             {
             SwitchSource_Request( Processing_REQ, 0 );          //send Processing

                //IssueList #68
                if( gAudioFctList_0x22_Processing_flg== 0x01 )
                {
                  if( isTimerActive( gAudioFctList_0x22_ProcessingTimer ) == 0x00 )
                  setTimer( gAudioFctList_0x22_ProcessingTimer,AUDIOMAXPROCESSINGTIME );

                SwitchSource_Request( Processing_REQ, 0 );
                }
             }
        break;

        case StartResult_IND:
              //IssueList #74
              if( getValue( env_AudioSD_FctList_0x22_TimeOut ) != TRUE )
              {
                  gAudioFctList_0x22_TimeOut_flg = 0x00;

                    //IssueList #57
                if( getValue( env_AudioSD_SwitchSource_ErrorON )== 0x00 )
                putValue( env_AudioSD_SwitchSource_ErrorC, 0 );

                    if( getvalue( env_AudioSD_SwitchSource_ErrorON ) )
                        SwitchSource_Request(Error_REQ, getvalue( env_AudioSD_SwitchSource_ErrorC) );

                    else
                    {
                        if( FALSE == gAudioSD_SwitchSource_status )
                        {
                            gAudioSD_SwitchSource_status = TRUE;                            //method active

                            //get data
                            //IssueList #146 -added if condition
                            if( getValue( env_AudioSD_FctList_0x22_3min_TO) == 0x00 )
                            gAudioSD_SwitchSource_Reference    =Indication_array[3];

                 //changes from J.Karl 30.11.2012 -s
                            gAudioSD_SwitchSource_Result = getvalue( env_AudioSD_SwitchSource_Result );

                            //Panel
                            if( gAudioSD_SwitchSource_Result != AUDIO_SWITCHSOURCERESULT_NOT_SUCCESSFUL && gAudioSD_SwitchSource_status == TRUE )
                            {
                                putvalue( env_AudioSD_SwitchSource_Ref, gAudioSD_SwitchSource_Reference );
                                //IssueList #32
                                putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_SwitchSource_Reference );

                                //IssueList #86
                                getSourceListRef();
                                sourceListType();

                                putvalue( env_AudioSD_RecListType_update, 0x1 );

                //IssueList #146
                       if( getValue( env_AudioSD_FctList_0x22_3min_TO) == 0x00 )
                                putValue( env_AudioSD_activeSrc_update, 0x1 );
                            }  //changes from J.Karl 30.11.2012 -e

                            settimer( SwitchSource_Timer, SwitchSource_TimerTime );
                        }
                    }
               } //IssueList #74
               else
               gAudioFctList_0x22_TimeOut_flg = 0x01;

        break;

        case Abort_IND:
            if( getvalue( env_AudioSD_SwitchSource_ErrorON ) )
                    SwitchSource_Request(Error_REQ, getvalue( env_AudioSD_SwitchSource_ErrorC) );

            else
            {
                if( TRUE != gAudioSD_SwitchSource_status )                                //method not active
                    SwitchSource_Request(Error_REQ, 0x50 );            //send error-message

                else if( TRUE == gAudioSD_SwitchSource_status )                            //method still active
                {
                    gAudioSD_SwitchSource_Result = getvalue( env_AudioSD_SwitchSource_Abort );

                    if( AUDIO_SWITCHSOURCERESULT_ABORT_SUCCESSFUL == gAudioSD_SwitchSource_Result )        //only, if abort is successful
                    {
                        canceltimer( SwitchSource_Timer );                                //abort method
                        gAudioSD_SwitchSource_status = FALSE;                            //method finished
                    }

                    SwitchSource_Request( Result_REQ, 0 );    //send result-message
                }
            }
        break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD SwitchSource_Indication: unknown indication %d", Indication_array[2] );
        break;
        }
}

SwitchSource_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;         //LSG-ID
    requestarray[1] = FctID_SwitchSource;   //Fct.-ID
    requestarray[2] = request;

    switch( request )
    {
        case Processing_REQ:
            requestarray[3] = gAudioSD_SwitchSource_Reserve;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            break;
        case Result_REQ:
            //IssueList #68
            if( gAudioFctList_0x22_Processing_flg == 0x00 )
            {
            requestarray[3] = gAudioSD_SwitchSource_Result;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            }
            break;
        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );

            //IssueList #68
            cancelTimer( gAudioFctList_0x22_ProcessingTimer );
            break;
        default:    //error
            writelineEx( gError_Trace, 0, "AudioSD SwitchSource_Request: unknown request %d", request );
            break;
    }
}

ReceptionListType_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
      case DataGet_IND:
          ReceptionListType_Request( Data_REQ, 0 );    //send status
          break;
      default:
          writelineEx( gError_Trace, 0, "FSG_AudioSD ReceptionListType_Indication: invalid indication %d", Indication_array[2] );
          break;
    }
}

on timer InfoStates_Start_Timer
{/*
    gAudioSD_InfoStates = NO_ERROR;

    putvalue( env_AudioSD_InfoStates, gAudioSD_InfoStates );

    InfoStates_Request( Data_REQ, 0 );

    gFSG_OperationState=NORMAL_OPERATION;

    putvalue( env_AudioSD_FSGOpState, gFSG_OperationState );

    FSG_OperationState_Request( Data_REQ, 0 );
    */
}

on message BAP_Audio_ASG_02 //BAP-message
{
  int i, error;
  byte RX_Data[8];        //received CAN-DATA
  dword RX_Header[3];     //received CAN-Header

  RX_Header[0] =this.CAN;

  RX_Header[1] = this.ID;

  RX_Header[2] = this.DLC; // received length

    // extract CAN data
    for( i = 0; i <this.DLC; i++ )
  {
    RX_Data [i] =this.byte( i);
  }

         //send recieved CAN-data with CAN-header to BAP-DLL
         //IssueList #159 - start
         // error =Bap180_CAN_SetRxDat( NODE_INDEX,RX_Header,RX_Data );

         switch( ( RX_Data[1] & 0x0F ) )
        {
         //getAll
        case 1: //error
                if( getValue( env_FSG_AudioSD_GetAll_ErrEn )== 0x01 )
                Request_error( FctID_GetAll, getValue( env_FSG_AudioSD_GetAll_ErrCode ) );

                else if( getValue( env_FSG_AudioSD_GetAll_FctEn ) == 0x01 )
                error =Bap180_CAN_SetRxDat( NODE_INDEX,RX_Header,RX_Data );//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 2: //error
                if( getValue( env_BAPCFG_FSG_AudioSD_ErrEn )== 0x01 )
                Request_error( FctID_BAP_Config, getValue( env_BAPCFG_FSG_AudioSD_ErrCode ) );

                else if( getValue( env_BAPCFG_FSG_AudioSD_FctEn ) == 0x01 )
                error =Bap180_CAN_SetRxDat( NODE_INDEX,RX_Header,RX_Data );//send recieved CAN-data with CAN-header to BAP-DLL
                break;

        case 3: //error
                if( getValue( env_FSG_AudioSD_FctList_ErrEn )== 0x01 )
                Request_error( FctID_FunctionList, getValue( env_FSG_AudioSD_FctList_ErrCode ) );

                else if( getValue( env_FSG_AudioSD_FctList_FctEn ) == 0x01 )
                error =Bap180_CAN_SetRxDat( NODE_INDEX,RX_Header,RX_Data );
                break;


        default: error =Bap180_CAN_SetRxDat( NODE_INDEX,RX_Header,RX_Data );    //send recieved CAN-data with CAN-header to BAP-DLL
                break;
        }
        //IssueList #159 - end


  if( error != 0 )
  {
    write( "FSG-AudioSD: BAP_CAN_SetRxData: %d", error );
  }
}

void Fct_initSendBuf( char description[], dword Cache_Request_Header[], byte Cache_Request_Data[] )
{
    byte error = BAP_ERR_OK;

    error = Bap180_InitSendBuf( NODE_INDEX, Cache_Request_Header, Cache_Request_Data );

    if( error != BAP_ERR_OK)
    {
      write( "Fct_initSendBuf %s errorcode: 0x%x", description, error );
    }
}

void CurrentStationHandle_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            CurrentStationHandle_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentStationHandle_Indication: invalid indication %d", Indication_array[2] );
            break;
    }

}

void CurrentStationHandle_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;                  //LSG-ID
    requestarray[1] = FctID_CurrentStation_Handle;  //Fct.-ID
    requestarray[2] = request;                       //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x16_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_CSIhandle_FSGhandle & 0xff;
            requestarray[4] = ( gAudioSD_CSIhandle_FSGhandle & 0xff00 ) / 0x100;
            requestarray[5] = gAudioSD_CSIhandle_FSGhandle_absolutePos & 0xff;
            requestarray[6] = ( gAudioSD_CSIhandle_FSGhandle_absolutePos & 0xff00 ) / 0x100;
            requestarray[7] = gAudioSD_CSIhandle_PresetListRef;
            requestarray[8] = gAudioSD_CSIhandle_PresetListabsolutePos;
            requestarray[9] = gAudioSD_CSIhandle_DABEnsembleHandle & 0xff;
            requestarray[10] = ( gAudioSD_CSIhandle_DABEnsembleHandle & 0xff00 ) / 0x100;
            requestarray[11] = gAudioSD_CSIhandle_DABEnsembleAbsPos & 0xff;
            requestarray[12] = ( gAudioSD_CSIhandle_DABEnsembleAbsPos & 0xff00 ) / 0x100;

            //MR 60227
            //Send the BAP request as normal/expected if MOST is not active
            if( getValue( env_PIC_bapMOST_active_flag ) == 0x00 )
            set_status_requestbuffer( requestarray, 13, Bap_ByteSequence );

            //BAP_MOST sync
            else if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
                {
                      //BAP FIRST before MOST
                      if( getValue( env_AudioTel_bapMost_delayTimer ) <= 0 ) //delay timer
                      {
                      //send BAP first
                      set_status_requestbuffer( requestarray, 13, Bap_ByteSequence );
                      //call MOST function after the delay
                      setTimer( _tBapFirst_delayTime, (-1 ) * getValue( env_AudioTel_bapMost_delayTimer ) );
                      }
                      ////MOST FIRST before BAP
                      else if( getValue( env_AudioTel_bapMost_delayTimer ) > 0 ) //delay timer
                      {
                        //prepare the data
                        //clear
                       for( i = 0; i < BAP_BUFFER_SIZE; i++ )
                       gAudio_Requestarray[i] = 0;
                       for( i = 0; i <13; i++ )
                       gAudio_Requestarray[i] = requestarray[i];
                       gAudio_BuffSize = 13;
                       gAudio_BAPdataType = Bap_ByteSequence;
                       //call MOST
                       BAP2MOSTSync();
                       //call BAP after the delay
                       setTimer( _tMostFirst_delayTime, getValue( env_AudioTel_bapMost_delayTimer ) );
                    }
                  } //MOST_active_flag
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentStationHandle_Request: invalid request %d", request );
            break;
    }
}

void BAP2MOSTSync()
{
    int  i;

    //CoverArt & StationArt
    if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
    {
        if( gAudioSD_CSIhandle_FSGhandle!= gMemFSGhandle )
        {
            for( i = 0; i < gMediaBrowser_TotalNumListElements; i++ )
            {
                if( gAudioSD_CSIhandle_FSGhandle == gMediaBrowser_PictureFileIndex[i][0] )
                {
                    if( ( gAudioSD_activeSource_SourceType == 0x01 ) || ( gAudioSD_activeSource_SourceType == 0x02 ) || ( gAudioSD_activeSource_SourceType == 0x03) ||
                        ( gAudioSD_activeSource_SourceType == 0x04 ) || ( gAudioSD_activeSource_SourceType == 0x05) || ( gAudioSD_activeSource_SourceType == 0x11 ) ||
                        ( gAudioSD_activeSource_SourceType == 0x19) || ( gAudioSD_activeSource_SourceType == 0x1A) )
                    {
                        //Broadcast sources
                        if( (strncmp( gMediaBrowser_PictureFile[gMediaBrowser_PictureFileIndex[i][1]],empty_string,3) != 0 ) )
                        {
                            //sending  PictureFilename, POS value, SourceType,StatationArtType
                            PicServTrigStationArt( gMediaBrowser_PictureFile[gMediaBrowser_PictureFileIndex[i][1]], gAudioSD_CSIhandle_PresetListRef, gMediaBrowserSourceType[i], gMediaBrowserStationArtType[i] );
                        }
                        else
                        {
                            write( "MOST warning: No PictureFilename for MediaBrowser POS %x", gAudioSD_CSIhandle_FSGhandle );
                        }
                    }
                    else
                    {
                        //Media sources
                        if( (strncmp( gMediaBrowser_PictureFile[gMediaBrowser_PictureFileIndex[i][1]],empty_string,3) != 0 ) )
                        {
                            //sending PictureFilename, POS value, SourceType, CoverArtType
                            PicServTrigCoverArt( gMediaBrowser_PictureFile[gMediaBrowser_PictureFileIndex[i][1]], gMediaBrowser_PictureFileIndex[i][0], gMediaBrowserSourceType[i], gMediaBrowserStationArtType[i] );
                        }
                        else
                        {
                            write( "MOST warning: No PictureFilename for MediaBrowser POS %x", gAudioSD_CSIhandle_FSGhandle );
                        }
                    }
                }
            }
            gMemFSGhandle = gAudioSD_CSIhandle_FSGhandle;
        }
    } //MOST_active_flag
}

TPMemoInfo_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            TPMemoInfo_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD TPMemoInfo_Indication: invalid indication %d", Indication_array[2] );
            break;
    }

}

TPMemoInfo_Request( byte request, byte errorcode )
{
    int i, Offset = 0;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;      //LSG-ID
    requestarray[1] = FctID_TPMemoInfo; //Fct.-ID
    requestarray[2] = request;           //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x1A_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_TPMemoInfo_CurrentMsgNumber;
            requestarray[4] = gAudioSD_TPMemoInfo_TotalMsgNumber;
            requestarray[5] = gAudioSD_TPMemoInfo_hour;
            requestarray[6] = gAudioSD_TPMemoInfo_minute;
            requestarray[7] = strlen( gAudioSD_TPMemoInfo_StationName );
            Offset = 8;

            for( i = 0; i < strlen( gAudioSD_TPMemoInfo_StationName ); i++ )
            {
                requestarray[Offset] = gAudioSD_TPMemoInfo_StationName[i];
                Offset++;
            }

            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: TPMemoInfo_Request: invalid request %d", request );
            break;
    }
}

MediaBrowserFolderLevel_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            MediaBrowserFolderLevel_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: MediaBrowserFolderLevel_Indication: invalid indication %d", Indication_array[2] );
            break;
    }

}

MediaBrowserFolderLevel_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;                      //LSG-ID
    requestarray[1] = FctID_MediaBrowser_FolderLevel;   //Fct.-ID
    requestarray[2] = request;                           //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x23_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_MediaBrowser_FL_FolderLevel;
            requestarray[4] = gAudioSD_MediaBrowser_FL_RefMediaBrowser & 0xff;
            requestarray[5] = ( gAudioSD_MediaBrowser_FL_RefMediaBrowser & 0xff00 ) / 0x100;
            requestarray[6] = gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos & 0xff;
            requestarray[7] = ( gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos & 0xff00 ) / 0x100;

            set_status_requestbuffer( requestarray, 8, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: MediaBrowserFolderLevel_Request: invalid request %d", request );
            break;
    }
}

MediaBrowser_Indication ( dword Indication_array [], int datalength )
{
    byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements;
    //24.02.2015 update from Jochen
    int i = 0,transSuppression;
    //IssueList #193
    byte mb_InValidStartElemFlg;
    //IssueList #76 - MR49870 : MediaBrowser
    int j = 0;
    byte audioListDelFlg;
    word validStartElem_plusElem;

    // Init local variables.
    mode                    = 0;
    direction               = 0;
    shift                   = 0;
    transmitpos             = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    indexsize               = 0;
    valid_startelement      = 0xff;
    valid_elements          = 0;

    //IssueList #76 - MR49870 : MediaBrowser
    validStartElem_plusElem = 0;

        switch( Indication_array[2] ) // indication
        {
            case DataGet_IND:
                //MR 63336    02.07.2014 -s
                if( getvalue( env_AudioSD_MB_Timeout ) == TRUE )
                {
                /* NOP */
                }
                else if( getvalue( env_AudioSD_MB_Error_on ) )
                {
                    MediaBrowser_Request(Error_REQ, 0, 0, 0, 0, 0, 0, getvalue( env_AudioSD_MB_ErrorCode ) );
                }
                else
                {
                //MR 63336    02.07.2014 -e
                //getData
                gMediaBrowser_ASGID                = ( gBAP_Indication[3] & 0xF0 ) / 0x10;
                gMediaBrowser_TAID                 = gBAP_Indication[3] & 0x0F;
                //changes from Jran Karl (28.03.2012 )
                gMediaBrowser_ActiveListPos        = getvalue( env_AudioSD_MB_ActiveListPos );

                //decode BAP-ArrayHeader
                mode                = ( gBAP_Indication[4] & 0xF0 ) / 0x10;

                // decode "mode -byte"
                shift       = mode & 0x01;
                direction   = ( mode & 0x02 ) / 0x02;
                transmitpos = ( mode & 0x04 ) / 0x04;
                indexsize   = ( mode & 0x08 ) / 0x08;

                recordaddress       = gBAP_Indication[4] & 0x0F;
                if( indexsize )
                {
                    startelement        = gBAP_Indication[5];
                    startelement        += gBAP_Indication[6] * 0x100;
                    elements            = gBAP_Indication[7];
                    elements            += gBAP_Indication[8]* 0x100;
                }
                else
                {
                    startelement        = gBAP_Indication[5];
                    elements            = gBAP_Indication[6];
                }

                requested_startelement = startelement;

                transmitpos     = TRUE; //Position must always be sent in the case of *.GetArray.


                /***Startelement = 0***/
                if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
                {
                    if( FORWARD==direction )  //forward-start
                    {
                        valid_startelement = 0;

                        //IssueList #76 - MR49870 : MediaBrowser
                        //change the AUDIO_MEDIABROWSER_ENTRIES --> gMB_CSVtotalElem --> gMediaBrowser_TotalNumListElements
                        //if( gMB_CSVtotalElem <= elements ) //1. more elements requested, than in array
                        if( gMediaBrowser_TotalNumListElements <= elements ) //1. more elements requested, than in array
                        {
                            if( shift == FALSE )
                            {
                                //IssueList #76 - MR49870 : MediaBrowser
                                //for( i = 0; i < gMB_CSVtotalElem; i++ )
                                for( i = 0; i < gMediaBrowser_TotalNumListElements; i++ )
                                {
                                    if( 0 != gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                    {
                                        if( gMediaBrowser_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                        valid_elements++;                                //increment elements
                                    }
                                    else                                                //no valid element, loop finished
                                        i = gMB_CSVtotalElem;
                                }
                            }
                            else if( shift == TRUE )
                            {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                            }
                        }
                        else    //2. number of requested elements < elements in array
                        {
                            if( shift == FALSE )
                            {
                                for( i = 0; i < elements; i++ )
                                {
                                    if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                    {
                                        if( gMediaBrowser_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                        valid_elements++;                                //increment elements
                                    }
                                    else                                                //no valid element, loop finished
                                        i = gMB_CSVtotalElem;
                                }
                            }
                            else if( shift == TRUE )
                            {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                            }
                        }
                    }                                                               //forward ends

                    else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                    {
                        //searching for valid startelement
                        for( i = ( gMB_CSVtotalElem-1 ); i>= 0; i--)
                        {
                            if( 0!= gMediaBrowser_ListEntryValidInformation[i] )        //found valid startelement
                            {
                                valid_startelement = i;
                                i = 0;
                            }
                        }

                        //searching for valid elements
                        if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                        else if( 0 ==valid_startelement )
                            valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                        else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                        {
                            for( i =valid_startelement; i>= 0; i--)
                            {
                                if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                {
                                    if( gMediaBrowser_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                    valid_elements++;                                //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                        else                                                        //enougth array-elements available
                        {
                            for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                            {
                                if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                {
                                    if( gMediaBrowser_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                    valid_elements++;                                //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }

                        }
                    }                                                               //backward-end
                }                                                                   //startelement == 0 -end

                /***Startelement!= 0***/
                else                                                                //searching for Startelement-ID
                {
                    //IssueList #193 - start
                    mb_InValidStartElemFlg = 0;
                    for( i = 0; i < gMB_CSVtotalElem; i++ )
                    {
                        if( startelement == gMediaBrowser_Pos_insDel[i][0] )
                        {
                            //check if Start is deleted then reply with 0 elements
                            if( gMediaBrowser_Pos_insDel[i][1] == 0x01 )
                            {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                            mb_InValidStartElemFlg = 1;
                            }
                        }
                    }
                    //IssueList #193 - end

                    //IssueList #193 - if condition
                    if( mb_InValidStartElemFlg == 0x00 )
                    {
                        //searching for valid startelement
                        for( i = 0; i < gMB_CSVtotalElem; i++ )
                        {
                            if( gMediaBrowser_Pos[i] == startelement )                        //found a valid element
                            {
                                if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                                {
                                    if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                        valid_startelement = i + 1-2*direction;

                                    else if( i == 0 && BACKWARD==direction )
                                        valid_startelement = gMediaBrowser_sum;     //valid element is last element in Array

                                    else if( i == 0 && FORWARD==direction )
                                        valid_startelement = 0;                          //valid element is first element in Array
                                }

                                else
                                    valid_startelement = i;                              //found element is valid_startelement

                                i = gMB_CSVtotalElem;
                            }
                        }

                        if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                        else                                                                //found valid entry for startelement in array
                        {
                            //verify number of valid elements
                            if( BACKWARD==direction )                                            //backward-start
                            {
                                if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                                    {
                                    //IssueList #76 - MR49870 : MediaBrowser
                                    audioListDelFlg = 0x00;
                                    audioListDelFlg = audioList_deleteCheck( gMediaBrowser_Pos[0], gMediaBrowser_Pos_insDel, gMB_CSVtotalElem );

                                    if( audioListDelFlg == 0x00 )
                                    valid_elements= 1;
                                    }

                                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                                {
                                    for( i =valid_startelement; i>= 0; i--)
                                    {
                                        if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                        {
                                            if( gMediaBrowser_Pos[i] > 0xFF ) //check indexsize
                                                    indexsize = TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i = 0;
                                    }
                                }
                                else                                                        //enougth array-elements available
                                {
                                    for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                                    {
                                        if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                        {
                                            if( gMediaBrowser_Pos[i] > 0xFF ) //check indexsize
                                                    indexsize = TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i = 0;
                                    }
                                }
                            }                                                                //backward-end
                            else                                                            //forward-start
                            {
                                //IssueList #76 - MR49870 : MediaBrowser 07MAY
                                //if((valid_startelement+elements )>= gMB_CSVtotalElem)
                                if((valid_startelement+elements )>= gMediaBrowser_TotalNumListElements )
                                {
                                    for( i =valid_startelement; i < gMB_CSVtotalElem; i++ )
                                    {
                                        if( 0!= gMediaBrowser_Pos[i] )                        //if there is an valid element
                                        {
                                            if( gMediaBrowser_Pos[i] > 0xFF ) //check indexsize
                                                    indexsize = TRUE;

                                            //IssueList #76 - MR49870 : MediaBrowser
                                            audioListDelFlg = 0x00;
                                            audioListDelFlg = audioList_deleteCheck( gMediaBrowser_Pos[i], gMediaBrowser_Pos_insDel, gMB_CSVtotalElem );

                                            //MediaBrowser 15MAY
                                            //if( audioListDelFlg == 0x00 )
                                            if( audioListDelFlg == 0x00 && valid_elements < elements )
                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i = gMB_CSVtotalElem;
                                    }
                                }
                                else
                                {
                                        //IssueList #76 - MR49870 : MediaBrowser 15MAY
                                         validStartElem_plusElem =valid_startelement+elements;
                                        //for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                                        for( i =valid_startelement; i <validStartElem_plusElem ; i++ )
                                        {
                                        if( 0!= gMediaBrowser_Pos[i] )                            //if there is an valid element
                                        {
                                            if( gMediaBrowser_Pos[i] > 0xFF ) //check indexsize
                                                indexsize = TRUE;

                                             //IssueList #76 - MR49870 : MediaBrowser
                                            audioListDelFlg = 0x00;
                                            audioListDelFlg = audioList_deleteCheck( gMediaBrowser_Pos[i], gMediaBrowser_Pos_insDel, gMB_CSVtotalElem );

                                            if( audioListDelFlg == 0x00 )
                                            {
                                                //MediaBrowser 15MAY
                                                if( valid_elements < elements )      //guard check if valid elements < elements
                                                valid_elements++;                                //increment elements
                                            }
                                            //MediaBrowser 15MAY
                                            else
                                            {
                                                 if( valid_elements < elements )
                                                 validStartElem_plusElem++;         //adjust the loop boundary based on number of deleted elements
                                            }

                                        }
                                        else                                                //no valid element, loop finished
                                            i = gMB_CSVtotalElem;
                                    }
                                }
                            }
                        }
                    }//mb_InValidStartElemFlg
                } //else Startelement!= 0

                if((valid_startelement > 0xFF ) || ( requested_startelement > 0xFF ) ) //check indexsize
                        indexsize = TRUE;

                mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                //send StatusArray
                //MR 63667 11.07.2014 -TNLE with SA-button
        //24.02.2015 update from Jochen
                //MediaBrowser_Request( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
        //VAGH-10511
                if(!getvalue( env_AudioSD_MB_noStatusArray ) )
            MediaBrowser_Request( Data_REQ, gMediaBrowser_TotalNumListElements, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );

                //Panel
                putvalue( env_AudioSD_MB_ASGID, gMediaBrowser_ASGID);
                putvalue( env_AudioSD_MB_TAID, gMediaBrowser_TAID);
                }
             break;

            case Error_IND:
                writelineEx( gError_Trace, 0, "AudioSD: MediaBrowser_Indication: received error, errorcode:0x%x", Indication_array[3] );
            break;

            default:
                writelineEx( gError_Trace, 0, "AudioSD: MediaBrowser_Indication: invalid indication %d", Indication_array[2] );
             break;
    }
}

void MediaBrowser_Request ( byte request, word tnle, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode )
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word MediaBrowserLine;
    //IssueList #76 - MR49870 : MediaBrowser
    byte audioListDelFlg;

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray [i] = 0;

    shift               = 0;
    direction           = 0;
    transmitpos         = 0;
    indexsize           = 0;
    MediaBrowserLine   = 0;
    current_element     = 0;
    Offset              = 0;

    // decode "mode -byte"
    shift       = mode & 0x01;
    direction   = ( mode & 0x02 ) / 0x02;
    transmitpos = ( mode & 0x04 ) / 0x04;
    indexsize   = ( mode & 0x08 ) / 0x08;

    // Handle request.
    requestarray[0] = LSG_AudioSD;                //LSG-ID
    requestarray[1] = FctID_MediaBrowser;        //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;

    switch( request )
    {
        case Changed_REQ:
            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            MediaBrowserLine = startelement;

            if( getvalue( env_AudioSD_MB_CA_switch ) ) //ArrayData
            {
                //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                        while( current_element < elements )
                        {
                            if(MediaBrowserLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD MediaBrowser_Request: invalid MediaBrowserLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gMediaBrowser_Pos[MediaBrowserLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gMediaBrowser_Pos[MediaBrowserLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }

                                //FileType
                                requestarray[Offset] = gMediaBrowser_FileType[MediaBrowserLine];
                                Offset++;

                                //FileState
                                requestarray[Offset] = ( gMediaBrowser_FileState[MediaBrowserLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gMediaBrowser_FileState[MediaBrowserLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //FileName
                                requestarray[Offset] = strlen( gMediaBrowser_FileName[MediaBrowserLine] );
                                Offset++;

                                for( i = 0; i < strlen( gMediaBrowser_FileName[MediaBrowserLine] ); i++ )
                                {
                                    requestarray[Offset] = gMediaBrowser_FileName[MediaBrowserLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            MediaBrowserLine =MediaBrowser_nextvalidLine(MediaBrowserLine, direction );

                        }//end while
                    break;

                    case 1: //FileType, FileState
                        while( current_element < elements )
                        {
                            if(MediaBrowserLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD MediaBrowser_Request: invalid MediaBrowserLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gMediaBrowser_Pos[MediaBrowserLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gMediaBrowser_Pos[MediaBrowserLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }

                                //FileType
                                requestarray[Offset] = gMediaBrowser_FileType[MediaBrowserLine];
                                Offset++;

                                //FileState
                                requestarray[Offset] = ( gMediaBrowser_FileState[MediaBrowserLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gMediaBrowser_FileState[MediaBrowserLine] & 0xFF00 ) / 0x100;
                                Offset++;
                            }
                            current_element++;
                            MediaBrowserLine =MediaBrowser_nextvalidLine(MediaBrowserLine, direction );

                        }//end while
                    break;

                    case 2: //FileName
                        while( current_element < elements )
                        {
                            if(MediaBrowserLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD MediaBrowser_Request: invalid MediaBrowserLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gMediaBrowser_Pos[MediaBrowserLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gMediaBrowser_Pos[MediaBrowserLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }

                                //FileName
                                requestarray[Offset] = strlen( gMediaBrowser_FileName[MediaBrowserLine] );
                                Offset++;

                                for( i = 0; i < strlen( gMediaBrowser_FileName[MediaBrowserLine] ); i++ )
                                {
                                    requestarray[Offset] = gMediaBrowser_FileName[MediaBrowserLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            MediaBrowserLine =MediaBrowser_nextvalidLine(MediaBrowserLine, direction );

                        }//end while
                    break;

                    case 15: //Pos
                        while( current_element < elements )
                        {
                            if(MediaBrowserLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD MediaBrowser_Request: invalid MediaBrowserLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gMediaBrowser_Pos[MediaBrowserLine] & 0x00FF );
                                        Offset++;
                                        requestarray[Offset] = (( gMediaBrowser_Pos[MediaBrowserLine]& 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            MediaBrowserLine =MediaBrowser_nextvalidLine(MediaBrowserLine, direction );

                        }//end while
                    break;

                    default:
                        write( "AudioSD MediaBrowser_Request: invalid recordaddress %d", recordaddress );
                    break;
                } //end switch "recordaddress"
            }// end 'ArrayData'

            //set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                            //MR 60227
                            //Send the BAP request as normal/expected if MOST is not active
                            if( getValue( env_PIC_bapMOST_active_flag ) == 0x00 )
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                            //BAP_MOST sync
                            else if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
                             {
                                //BAP FIRST before MOST
                                if( getValue( env_AudioTel_bapMost_delayTimer ) <= 0 ) //delay timer
                                {
                                //send BAP first
                                set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                                //call MOST function after the delay
                                setTimer( _tBapFirst_delayTime, (-1 ) * getValue( env_AudioTel_bapMost_delayTimer ) );
                                }
                                ////MOST FIRST before BAP
                                else if( getValue( env_AudioTel_bapMost_delayTimer ) > 0 ) //delay timer
                                {
                                  if( isTimerActive( _tMostFirst_delayTime )== 0 )
                                  {
                                  //prepare the data
                                      //clear
                                     for( i = 0; i < BAP_BUFFER_SIZE; i++ )
                                     gAudio_Requestarray[i] = 0;
                                     for( i = 0; i <Offset; i++ )
                                     gAudio_Requestarray[i] = requestarray[i];
                                     gAudio_BuffSize = Offset;
                                     gAudio_BAPdataType = Bap_ByteSequence;
                                     //call MOST
                                    // BAP2MOSTSync();
                                     //call BAP after the delay
                                     setTimer( _tMostFirst_delayTime, getValue( env_AudioTel_bapMost_delayTimer ) );
                                  }
                                  else
                                  {
                                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                                  }
                                }
                            } //MOST_active_flag

         break; //end Changed_REQ

        case Data_REQ:
    //changes from Jran Karl (28.03.2012 )
            //MR 63336    02.07.2014
            //if( getvalue( env_AudioSD_MB_Timeout ) != TRUE )
            if(/*getvalue( env_AudioSD_MB_Timeout ) != */ TRUE )
            {
            //VAGH-10511
            ASGID = gMediaBrowser_ASGID;
            TAID = gMediaBrowser_TAID;
                if( getvalue( env_AudioSD_MB_ASGID_error ) != FALSE )
                {
                    ASGID += 0x02;
                }
                if( getvalue( env_AudioSD_MB_TAID_error ) != FALSE )
                {
                    TAID += 0x02;
                }

                requestarray[Offset] = (( ASGID * 0x10 ) & 0xF0 ) + ( TAID & 0x0F );
                Offset++;
                //MR 63667 11.07.2014 -TNLE with SA-button
                requestarray[Offset] = tnle /*gMediaBrowser_TotalNumListElements */ & 0xff;
                Offset++;
                requestarray[Offset] = ( tnle /*gMediaBrowser_TotalNumListElements */ & 0xff00 ) / 0x100;
                Offset++;
                requestarray[Offset] = gMediaBrowser_ActiveListPos & 0xff;
                Offset++;
                requestarray[Offset] = ( gMediaBrowser_ActiveListPos & 0xff00 ) / 0x100;
                Offset++;


                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;
                if( indexsize )
                {
                    requestarray[Offset] = requested_startelement & 0xff;
                    Offset++;
                    requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                    Offset++;

                    requestarray[Offset] = elements & 0xff;
                    Offset++;
                    requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                    Offset++;
                }
                else
                {
                    requestarray[Offset] = requested_startelement;
                    Offset++;
                    requestarray[Offset] = elements;
                    Offset++;
                }

                MediaBrowserLine = startelement;

                //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                            while( current_element < elements )
                            {
                                if(MediaBrowserLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD MediaBrowser_Request: invalid MediaBrowserLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                            //IssueList #76 - MR49870 : MediaBrowser
                                            //Updating the status array excluding the deleted elements
                                           audioListDelFlg = 0x00;
                                           audioListDelFlg = audioList_deleteCheck( gMediaBrowser_Pos[MediaBrowserLine], gMediaBrowser_Pos_insDel, gMB_CSVtotalElem);

                                        if( audioListDelFlg == 0x00 )
                                        {
                                            if( indexsize )
                                            {
                                                requestarray[Offset] = ( gMediaBrowser_Pos[MediaBrowserLine] & 0xFF );
                                                Offset++;
                                                requestarray[Offset] = (( gMediaBrowser_Pos[MediaBrowserLine]& 0xFF00 ) / 0x100 );
                                                Offset++;
                                            }
                                            else
                                            {
                                                requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                                Offset++;
                                            }
                                         }//audioListDelFlg
                                    }

                                    if( audioListDelFlg == 0x00 )
                                    {
                                    //FileType
                                    requestarray[Offset] = gMediaBrowser_FileType[MediaBrowserLine];
                                    Offset++;

                                    //FileState
                                    requestarray[Offset] = ( gMediaBrowser_FileState[MediaBrowserLine] & 0x00ff );
                                    Offset++;
                                    requestarray[Offset] = ( gMediaBrowser_FileState[MediaBrowserLine] & 0xFF00 ) / 0x100;
                                    Offset++;

                                    //FileName
                                    requestarray[Offset] = strlen( gMediaBrowser_FileName[MediaBrowserLine] );
                                    Offset++;

                                        for( i = 0; i < strlen( gMediaBrowser_FileName[MediaBrowserLine] ); i++ )
                                        {
                                            requestarray[Offset] = gMediaBrowser_FileName[MediaBrowserLine][i];
                                            Offset++;
                                        }
                                    } //audioListDelFlg
                                }
                                if( audioListDelFlg == 0x00 )
                                current_element++;

                                MediaBrowserLine =MediaBrowser_nextvalidLine(MediaBrowserLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 1: //FileType, FileState
                            while( current_element < elements )
                            {
                                if(MediaBrowserLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD MediaBrowser_Request: invalid MediaBrowserLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gMediaBrowser_Pos[MediaBrowserLine] & 0xFF );
                                            Offset++;
                                            requestarray[Offset] = (( gMediaBrowser_Pos[MediaBrowserLine]& 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                            Offset++;
                                        }
                                    }

                                    //FileType
                                    requestarray[Offset] = gMediaBrowser_FileType[MediaBrowserLine];
                                    Offset++;

                                    //FileState
                                    requestarray[Offset] = ( gMediaBrowser_FileState[MediaBrowserLine] & 0x00ff );
                                    Offset++;
                                    requestarray[Offset] = ( gMediaBrowser_FileState[MediaBrowserLine] & 0xFF00 ) / 0x100;
                                    Offset++;
                                }
                                current_element++;
                                MediaBrowserLine =MediaBrowser_nextvalidLine(MediaBrowserLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 2: //FileName
                            while( current_element < elements )
                            {
                                if(MediaBrowserLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD MediaBrowser_Request: invalid MediaBrowserLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gMediaBrowser_Pos[MediaBrowserLine] & 0xFF );
                                            Offset++;
                                            requestarray[Offset] = (( gMediaBrowser_Pos[MediaBrowserLine]& 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                            Offset++;
                                        }
                                    }

                                    //FileName
                                    requestarray[Offset] = strlen( gMediaBrowser_FileName[MediaBrowserLine] );
                                    Offset++;

                                    for( i = 0; i < strlen( gMediaBrowser_FileName[MediaBrowserLine] ); i++ )
                                    {
                                        requestarray[Offset] = gMediaBrowser_FileName[MediaBrowserLine][i];
                                        Offset++;
                                    }
                                }
                                current_element++;
                                MediaBrowserLine =MediaBrowser_nextvalidLine(MediaBrowserLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 15: //Pos
                            while( current_element < elements )
                            {
                                if(MediaBrowserLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD MediaBrowser_Request: invalid MediaBrowserLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        //IssueList #76 - MR49870 : MediaBrowser
                                            //Updating the status array excluding the deleted elements
                                           audioListDelFlg = 0x00;
                                           audioListDelFlg = audioList_deleteCheck( gMediaBrowser_Pos[MediaBrowserLine], gMediaBrowser_Pos_insDel, gMB_CSVtotalElem);

                                        if( audioListDelFlg == 0x00 )
                                        {
                                            if( indexsize )
                                            {
                                                requestarray[Offset] = ( gMediaBrowser_Pos[MediaBrowserLine] & 0x00FF );
                                                Offset++;
                                                requestarray[Offset] = (( gMediaBrowser_Pos[MediaBrowserLine]& 0xFF00 ) / 0x100 );
                                                Offset++;
                                            }
                                            else
                                            {
                                                requestarray[Offset] = gMediaBrowser_Pos[MediaBrowserLine];
                                                Offset++;
                                            }
                                        }//audioListDelFlg
                                    }
                                }
                                //IssueList #76 - MR49870 : MediaBrowser
                                if( audioListDelFlg == 0x00 )
                                current_element++;
                                MediaBrowserLine =MediaBrowser_nextvalidLine(MediaBrowserLine, direction );

                            }//end while

                            //MR 60227
                            //Send the BAP request as normal/expected if MOST is not active
                            if( getValue( env_PIC_bapMOST_active_flag ) == 0x00 )
                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

                            //BAP_MOST sync
                            else if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
                             {
                                //BAP FIRST before MOST
                                if( getValue( env_AudioTel_bapMost_delayTimer ) <= 0 ) //delay timer
                                {
                                //send BAP first
                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                                //call MOST function after the delay
                                setTimer( _tBapFirst_delayTime, (-1 ) * getValue( env_AudioTel_bapMost_delayTimer ) );
                                }
                                ////MOST FIRST before BAP
                                else if( getValue( env_AudioTel_bapMost_delayTimer ) > 0 ) //delay timer
                                {
                                  if( isTimerActive( _tMostFirst_delayTime )== 0 )
                                  {
                                  //prepare the data
                                      //clear
                                     for( i = 0; i < BAP_BUFFER_SIZE; i++ )
                                     gAudio_Requestarray[i] = 0;
                                     for( i = 0; i <Offset; i++ )
                                     gAudio_Requestarray[i] = requestarray[i];
                                     gAudio_BuffSize = Offset;
                                     gAudio_BAPdataType = Bap_ByteSequence;
                                     //call MOST
                                    // BAP2MOSTSync();
                                     //call BAP after the delay
                                     setTimer( _tMostFirst_delayTime, getValue( env_AudioTel_bapMost_delayTimer ) );
                                  }
                                  else
                                  {
                                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                                  }
                                }
                            } //MOST_active_flag
                     break;

                    default:
                        write( "AudioSD MediaBrowser_Request: invalid recordaddress %d", recordaddress );
                     break;
                } //end switch "recordaddress"
            //changes from Jran Karl (28.03.2012 )
        }
            else
            {
                write( "AudioSD MediaBrowser_Request: Simulate timeout of Status-Array!" );
            }
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
         break; //end Error_REQ

    } //end switch "request"
}

void LastStationList_Indication( dword Indication_array [], int datalength )
{
    byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements;
    int i = 0, transSuppression;
	byte audioListDelFlg;
	byte lsl_InValidStartElemFlg;
	word validStartElem_plusElem;

    // Init local variables.
    mode = 0;
    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    recordaddress = 0;
    requested_startelement = 0;
    startelement = 0;
    elements = 0;
    valid_startelement = 0xff;
    i = 0;
    valid_elements = 0;
    transSuppression = getvalue(Env_FSG_LSL_E_TS_stop);

    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
        //MR 63336
        if( getvalue( env_AudioSD_LSL_Error_Status ) )
        {
          LastStationList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue( env_AudioSD_LSL_ErrorCode ) );
        }
        else if( getvalue( env_AudioSD_LSL_Timeout ) == TRUE )
        {
        /* NOP */
        }
        else
        {
            //getData
            gLSL_ASGID = ( gBAP_Indication[3] & 0xF0 ) / 0x10;
            gLSL_TAID = gBAP_Indication[3] & 0x0F;

            //decode BAP-ArrayHeader
            mode = ( gBAP_Indication[4] & 0xF0 ) / 0x10;

            // decode "mode -byte"
            shift = mode & 0x01;
            direction = ( mode & 0x02 ) / 0x02;
            transmitpos = ( mode & 0x04 ) / 0x04;
            indexsize = ( mode & 0x08 ) / 0x08;
			
		
            recordaddress = gBAP_Indication[4] & 0x0F;
            if( indexsize )
            {
                startelement = gBAP_Indication[5];
                startelement += gBAP_Indication[6] * 0x100;
                elements = gBAP_Indication[7];
                elements += gBAP_Indication[8] * 0x100;
            }
            else
            {
                startelement = gBAP_Indication[5];
                elements = gBAP_Indication[6];
            }
			

            requested_startelement = startelement;

            transmitpos = TRUE; //Position must always be sent in the case of *.GetArray.


            /***Startelement = 0***/
            if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
            {
                if( FORWARD == direction )  //forward-start
                {
                    valid_startelement = 0;

                    if( AUDIO_LASTSTATIONLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
                            {
                                if( 0 != gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                                {
                                    if( gLSL_Pos[i] > 0xFF ) //check indexsize
                                        indexsize = TRUE;

                                    valid_elements++;                               //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = AUDIO_LASTSTATIONLIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement = startelement;
                            valid_elements = 0;
                        }
                    }
                    else    //2. number of requested elements < elements in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < elements; i++ )
                            {
                                if( 0 != gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                                {
                                    if( gLSL_Pos[i] > 0xFF ) //check indexsize
                                        indexsize = TRUE;

                                    valid_elements++;                               //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = AUDIO_LASTSTATIONLIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement = startelement;
                            valid_elements = 0;
                        }
                    }
                }                                                               //forward ends

                else if( BACKWARD == direction && TRUE == shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                {
                    //searching for valid startelement
                    for( i = ( AUDIO_LASTSTATIONLIST_ENTRIES - 1 ); i >= 0; i--)
                    {
                        if( 0 != gLSL_ListEntryValidInformation[i] )        //found valid startelement
                        {
                            valid_startelement = i;
                            i = 0;
                        }
                    }

                    //searching for valid elements
                    if( 0xFF == valid_startelement )                             //Startelement-ID doesn't exist in SMSReceived-array
                    {
                        valid_startelement = startelement;
                        valid_elements = 0;
                    }
                    else if( 0 == valid_startelement )
                        valid_elements = 1;                                       //only 1 element because valid startelement is on position 0

                    else if( elements > (valid_startelement + 1 ) )                   //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i = valid_startelement; i >= 0; i--)
                        {
                            if( 0 != gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                            {
                                if( gLSL_Pos[i] > 0xFF ) //check indexsize
                                    indexsize = TRUE;

                                valid_elements++;                               //increment elements
                            }
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i = valid_startelement; i > (valid_startelement - elements ); i--)
                        {
                            if( 0 != gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                            {
                                if( gLSL_Pos[i] > 0xFF ) //check indexsize
                                    indexsize = TRUE;

                                valid_elements++;                               //increment elements
                            }
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                               //backward-end
            }                                                                   //startelement == 0 -end

            /***Startelement!= 0***/
            else                                                                //searching for Startelement-ID
            {
			    //IssueList #193 - start
                        lsl_InValidStartElemFlg = 0;
                        for( i = 0; i < gLSL_CSVtotalElem; i++ )
                        {
                            if( startelement == gLastStationList_Pos_insDel[i][0] )
                            {
                                //check if Start is deleted then reply with 0 elements
                                if( gLastStationList_Pos_insDel[i][1] == 0x01 )
                                {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                                lsl_InValidStartElemFlg = 1;
                                }
                            }
                        }
                        //IssueList #193 - end
				if(lsl_InValidStartElemFlg == 0x0)
                {				
                //searching for valid startelement
                for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
                {
                    if( gLSL_Pos[i] == startelement )                       //found a valid element
                    {
                        if( shift == TRUE )                                          //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                        {
                            if( i != 0 || BACKWARD != direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                {valid_startelement = i + 1 - 2 * direction;
                                  }
                            else if( i == 0 && BACKWARD == direction )
							{
                                valid_startelement = gLSL_sum - 1;     //valid element is last element in Array
								}

                            else if( i == 0 && FORWARD == direction )
                                valid_startelement = 0;                          //valid element is first element in Array
                        }

                        else
						{
							valid_startelement = i;                              //found element is valid_startelement
						}
                        i = AUDIO_LASTSTATIONLIST_ENTRIES;
                    }
                }

                if( 0xFF == valid_startelement )                                     //Startelement-ID doesn't exist in array
                {
                    valid_startelement = startelement;
                    valid_elements = 0;
                }
                else                                                                //found valid entry for startelement in array
                {
                    //verify number of valid elements
                    if( BACKWARD == direction )                                          //backward-start
                    {
                        if( valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                        { 
						    audioListDelFlg = 0x00;
						    audioListDelFlg = audioList_deleteCheck( gLSL_Pos[0], gLastStationList_Pos_insDel, gLSL_CSVtotalElem );

							if( audioListDelFlg == 0x00 )                     
								valid_elements = 1;
                        }
                        else if( elements > (valid_startelement + 1 ) )                   //not enougth array-elements available, because array endet at array-position 0
                        {
                            for( i = valid_startelement; i >= 0; i--)
                            {
                                if( 0 != gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                                {
                                    if( gLSL_Pos[i] > 0xFF ) //check indexsize
                                        indexsize = TRUE;

                                    valid_elements++;                               //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                        else                                                        //enougth array-elements available
                        {
                            for( i = valid_startelement; i > (valid_startelement - elements ); i--)
                            {
                                if( 0 != gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                                {
                                    if( gLSL_Pos[i] > 0xFF ) //check indexsize
                                        indexsize = TRUE;
                                    
                                    valid_elements++;                               //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                    }                                                               //backward-end
                    else                                                            //forward-start
                    {
                        if( (valid_startelement + elements ) >= AUDIO_LASTSTATIONLIST_ENTRIES)
                        {
                            for( i = valid_startelement; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
                            {
                                if( 0 != gLSL_Pos[i] )                      //if there is an valid element
                                {
                                    if( gLSL_Pos[i] > 0xFF ) //check indexsize
                                        indexsize = TRUE;
                                    
									audioListDelFlg = 0x00;
									audioListDelFlg = audioList_deleteCheck( gLSL_Pos[i], gLastStationList_Pos_insDel, gLSL_CSVtotalElem );

                                    if( audioListDelFlg == 0x00 && valid_elements < elements )            
										valid_elements++;                               //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = AUDIO_LASTSTATIONLIST_ENTRIES;
                            }
                        }
                        else
                        {
						    validStartElem_plusElem =valid_startelement+elements;
                            for( i = valid_startelement; i < validStartElem_plusElem; i++ )
                            {
                                if( 0 != gLSL_Pos[i] )                          //if there is an valid element
                                {
                                    if( gLSL_Pos[i] > 0xFF ) //check indexsize
                                        indexsize = TRUE;

								    audioListDelFlg = 0x00;
								    audioListDelFlg = audioList_deleteCheck( gLSL_Pos[i], gLastStationList_Pos_insDel, gLSL_CSVtotalElem);

                                    if( audioListDelFlg == 0x00 )
									{   
										if( valid_elements < elements ) 												
											valid_elements++;                               //increment elements
                                    }
									else
									{
										if( valid_elements < elements )
											validStartElem_plusElem++;  
									}
								}
                                else                                                //no valid element, loop finished
                                    i = AUDIO_LASTSTATIONLIST_ENTRIES;
                            }
                        }
                    }
					}
                }
            }

            if( (valid_startelement > 0xFF ) || ( requested_startelement > 0xFF ) ) //check indexsize
                indexsize = TRUE;
		    
			//indexsize = FALSE;

            mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + indexsize * 0x08;

            //send StatusArray
            if( !transSuppression )
                LastStationList_Request( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );

            //Panel
            putvalue(Env_FSG_LSL_ASGID, gLSL_ASGID);
            putvalue(Env_FSG_LSL_TAID, gLSL_TAID);
            }
            break;

        case Error_IND:
            writelineEx( gError_Trace, 0, "AudioSD: LastStationList_Indication: received error, errorcode:0x%x", Indication_array[3] );
            break;

        default:
            writelineEx( gError_Trace, 0, "AudioSD: LastStationList_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

void LastStationList_Request( byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word LastStationListLine;
	
	byte audioListDelFlg;

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    LastStationListLine = 0;
    current_element = 0;
    Offset = 0;

    // decode "mode -byte"
    shift = mode & 0x01;
    direction = ( mode & 0x02 ) / 0x02;
    transmitpos = ( mode & 0x04 ) / 0x04;
    indexsize = ( mode & 0x08 ) / 0x08;
	
	if( elements == 0 )
	{
	    transmitpos = 0;
		mode &= 0xFB;
	}

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_LastStationList;    //Fct.-ID
    requestarray[2] = request;                  //request type
	//requestarray[3] = transmitpos;
    Offset = 3;

    switch( request )
    {
        case Changed_REQ:
            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            LastStationListLine = startelement;
            if( getvalue( env_AudioSD_MB_CA_switch ) ) //ArrayData
            {
                //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                        while ( current_element < elements )
                        {
                            if( LastStationListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD LastStationList_Request: invalid LastStationListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gLSL_Pos[LastStationListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gLSL_Pos[LastStationListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gLSL_Pos[LastStationListLine];
                                        Offset++;
                                    }
                                }

                                //PresentIndex
                                requestarray[Offset] = gLSL_PresentIndex[LastStationListLine];
                                Offset++;

                                //Waveband
                                requestarray[Offset] = gLSL_Waveband[LastStationListLine];
                                Offset++;

                                //Attributes
                                requestarray[Offset] = ( gLSL_Attributes[LastStationListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gLSL_Attributes[LastStationListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gLSL_Name[LastStationListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gLSL_Name[LastStationListLine] ); i++ )
                                {
                                    requestarray[Offset] = gLSL_Name[LastStationListLine][i];
                                    Offset++;
                                }

                                //Frequenz
                                requestarray[Offset] = strlen( gLSL_Frequenz[LastStationListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gLSL_Frequenz[LastStationListLine] ); i++ )
                                {
                                    requestarray[Offset] = gLSL_Frequenz[LastStationListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            LastStationListLine = LastStationList_nextvalidLine(LastStationListLine, direction );

                        }//end while
                        break;

                    case 1: //Presentindex, Waveband,Attributes,Name,Frequency
                        while ( current_element < elements )
                        {
                            if( LastStationListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD LastStationList_Request: invalid LastStationListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                //PresentIndex
                                requestarray[Offset] = gLSL_PresentIndex[LastStationListLine];
                                Offset++;

                                //Waveband
                                requestarray[Offset] = gLSL_Waveband[LastStationListLine];
                                Offset++;

                                //Attributes
                                requestarray[Offset] = ( gLSL_Attributes[LastStationListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gLSL_Attributes[LastStationListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gLSL_Name[LastStationListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gLSL_Name[LastStationListLine] ); i++ )
                                {
                                    requestarray[Offset] = gLSL_Name[LastStationListLine][i];
                                    Offset++;
                                }

                                //Frequenz
                                requestarray[Offset] = strlen( gLSL_Frequenz[LastStationListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gLSL_Frequenz[LastStationListLine] ); i++ )
                                {
                                    requestarray[Offset] = gLSL_Frequenz[LastStationListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            LastStationListLine = LastStationList_nextvalidLine(LastStationListLine, direction );

                        }//end while
                        break;

                    case 2: //PresentIndex,Waveband,Name
                        while ( current_element < elements )
                        {
                            if( LastStationListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD LastStationList_Request: invalid LastStationListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                //PresentIndex
                                requestarray[Offset] = gLSL_PresentIndex[LastStationListLine];
                                Offset++;

                                //Waveband
                                requestarray[Offset] = gLSL_Waveband[LastStationListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gLSL_Name[LastStationListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gLSL_Name[LastStationListLine] ); i++ )
                                {
                                    requestarray[Offset] = gLSL_Name[LastStationListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            LastStationListLine = LastStationList_nextvalidLine(LastStationListLine, direction );

                        }//end while
                        break;
                    case 3://PresentIndex,Name,Frequency
                        while ( current_element < elements )
                        {
                            if( LastStationListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD LastStationList_Request: invalid LastStationListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                //PresentIndex
                                requestarray[Offset] = gLSL_PresentIndex[LastStationListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gLSL_Name[LastStationListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gLSL_Name[LastStationListLine] ); i++ )
                                {
                                    requestarray[Offset] = gLSL_Name[LastStationListLine][i];
                                    Offset++;
                                }

                                //Frequenz
                                requestarray[Offset] = strlen( gLSL_Frequenz[LastStationListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gLSL_Frequenz[LastStationListLine] ); i++ )
                                {
                                    requestarray[Offset] = gLSL_Frequenz[LastStationListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            LastStationListLine = LastStationList_nextvalidLine(LastStationListLine, direction );

                        }//end while
                        break;
                    case 15: //Pos
                        while ( current_element < elements )
                        {
                            if( LastStationListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD LastStationList_Request: invalid LastStationListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gLSL_Pos[LastStationListLine] & 0x00FF );
                                        Offset++;
                                        requestarray[Offset] = (( gLSL_Pos[LastStationListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gLSL_Pos[LastStationListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            LastStationListLine = LastStationList_nextvalidLine(LastStationListLine, direction );

                        }//end while
                        break;
                    default:
                        write( "AudioSD LastStationList_Request: invalid recordaddress %d", recordaddress );
                        break;
                } //end switch "recordaddress"
            // end 'ArrayData'
            }
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

            break; //end Changed_REQ

        case Data_REQ:
            //VAGH-10511
            ASGID = gLSL_ASGID;
            TAID = gLSL_TAID;
            if( getvalue( env_AudioSD_LSL_ASGID_Error ) != FALSE )
            {
                ASGID += 0x02;
            }
            if( getvalue( env_AudioSD_LSL_TAID_Error ) != FALSE )
            {
                TAID += 0x02;
            }
            requestarray[Offset] = (( ASGID * 0x10 ) & 0xF0 ) + ( TAID & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = gLSL_TNLE & 0xff;
                Offset++;
                requestarray[Offset] = ( gLSL_TNLE & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = gLSL_TNLE & 0xff;
                Offset++;
            }
            //requestarray[Offset] = gLSL_ALP & 0xff;
            //Offset++;
            //requestarray[Offset] = ( gLSL_ALP & 0xff00 ) / 0x100;
            //Offset++;


            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            LastStationListLine = startelement;
			

            //copy data
            switch( recordaddress )
            {
                case 0: //complete record
                    while ( current_element < elements )
                    {
                        if( LastStationListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD LastStationList_Request: invalid LastStationListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if( transmitpos ) // Pos  ->Array position transmitted
                            {
							//IssueList #76 - MR49870 : RTPL
                                            //Updating the status array excluding the deleted elements
								audioListDelFlg = 0x00;
							    audioListDelFlg = audioList_deleteCheck( gLSL_Pos[LastStationListLine], gLastStationList_Pos_insDel, gLSL_CSVtotalElem);
										
								if(audioListDelFlg == 0x0)
								{							
									if( indexsize )
									{
										requestarray[Offset] = ( gLSL_Pos[LastStationListLine] & 0xFF );
										Offset++;
										requestarray[Offset] = (( gLSL_Pos[LastStationListLine] & 0xFF00 ) / 0x100 );
										Offset++;
									}
									else
									{
										requestarray[Offset] = gLSL_Pos[LastStationListLine];
										Offset++;
									}
								}
							}
                            
							if(audioListDelFlg == 0x0)
							{
								//PresentIndex
								requestarray[Offset] = gLSL_PresentIndex[LastStationListLine];
								Offset++;

								//Waveband
								requestarray[Offset] = gLSL_Waveband[LastStationListLine];
								Offset++;

								//Attributes
								requestarray[Offset] = ( gLSL_Attributes[LastStationListLine] & 0x00ff );
								Offset++;
								requestarray[Offset] = ( gLSL_Attributes[LastStationListLine] & 0xFF00 ) / 0x100;
								Offset++;

								//Name
								requestarray[Offset] = strlen( gLSL_Name[LastStationListLine] );
								Offset++;
								for( i = 0; i < strlen( gLSL_Name[LastStationListLine] ); i++ )
								{
									requestarray[Offset] = gLSL_Name[LastStationListLine][i];
									Offset++;
								}

								//Frequenz
								requestarray[Offset] = strlen( gLSL_Frequenz[LastStationListLine] );
								Offset++;
								for( i = 0; i < strlen( gLSL_Frequenz[LastStationListLine] ); i++ )
								{
									requestarray[Offset] = gLSL_Frequenz[LastStationListLine][i];
									Offset++;
								}
							}
                        }
						if(audioListDelFlg == 0x0)
							current_element++;
                        LastStationListLine = LastStationList_nextvalidLine(LastStationListLine, direction );

                    }//end while
                    break;

                case 1: //Presentindex, Waveband,Attributes,Name,Frequency
				    
                    while ( current_element < elements )
                    {
                        if( LastStationListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD LastStationList_Request: invalid LastStationListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
						
						if( transmitpos ) // Pos  ->Array position transmitted
							{
								if( indexsize )
								{
									requestarray[Offset] = ( gLSL_Pos[LastStationListLine] & 0xFF );
									Offset++;
									requestarray[Offset] = (( gLSL_Pos[LastStationListLine] & 0xFF00 ) / 0x100 );
									Offset++;
								}
								else
								{
									requestarray[Offset] = gLSL_Pos[LastStationListLine];
									Offset++;
								}
							}
                            /***Array Data***/
                            //PresentIndex
                            requestarray[Offset] = gLSL_PresentIndex[LastStationListLine];
                            Offset++;

                            //Waveband
                            requestarray[Offset] = gLSL_Waveband[LastStationListLine];
                            Offset++;

                            //Attributes
                            requestarray[Offset] = ( gLSL_Attributes[LastStationListLine] & 0x00ff );
                            Offset++;
                            requestarray[Offset] = ( gLSL_Attributes[LastStationListLine] & 0xFF00 ) / 0x100;
                            Offset++;

                            //Name
                            requestarray[Offset] = strlen( gLSL_Name[LastStationListLine] );
                            Offset++;
                            for( i = 0; i < strlen( gLSL_Name[LastStationListLine] ); i++ )
                            {
                                requestarray[Offset] = gLSL_Name[LastStationListLine][i];
                                Offset++;
                            }

                            //Frequenz
                            requestarray[Offset] = strlen( gLSL_Frequenz[LastStationListLine] );
                            Offset++;
                            for( i = 0; i < strlen( gLSL_Frequenz[LastStationListLine] ); i++ )
                            {
                                requestarray[Offset] = gLSL_Frequenz[LastStationListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        LastStationListLine = LastStationList_nextvalidLine(LastStationListLine, direction );

                    }//end while
                    break;

                case 2: //PresentIndex,Waveband,Name
                    while ( current_element < elements )
                    {
                        if( LastStationListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD LastStationList_Request: invalid LastStationListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            //PresentIndex
                            requestarray[Offset] = gLSL_PresentIndex[LastStationListLine];
                            Offset++;

                            //Waveband
                            requestarray[Offset] = gLSL_Waveband[LastStationListLine];
                            Offset++;

                            //Name
                            requestarray[Offset] = strlen( gLSL_Name[LastStationListLine] );
                            Offset++;
                            for( i = 0; i < strlen( gLSL_Name[LastStationListLine] ); i++ )
                            {
                                requestarray[Offset] = gLSL_Name[LastStationListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        LastStationListLine = LastStationList_nextvalidLine(LastStationListLine, direction );

                    }//end while
                    break;
                case 3://PresentIndex,Name,Frequency
                    while ( current_element < elements )
                    {
                        if( LastStationListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD LastStationList_Request: invalid LastStationListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            //PresentIndex
                            requestarray[Offset] = gLSL_PresentIndex[LastStationListLine];
                            Offset++;

                            //Name
                            requestarray[Offset] = strlen( gLSL_Name[LastStationListLine] );
                            Offset++;
                            for( i = 0; i < strlen( gLSL_Name[LastStationListLine] ); i++ )
                            {
                                requestarray[Offset] = gLSL_Name[LastStationListLine][i];
                                Offset++;
                            }

                            //Frequenz
                            requestarray[Offset] = strlen( gLSL_Frequenz[LastStationListLine] );
                            Offset++;
                            for( i = 0; i < strlen( gLSL_Frequenz[LastStationListLine] ); i++ )
                            {
                                requestarray[Offset] = gLSL_Frequenz[LastStationListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        LastStationListLine = LastStationList_nextvalidLine(LastStationListLine, direction );

                    }//end while
                    break;
                case 15: //Pos
                    while ( current_element < elements )
                    {
                        if( LastStationListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD LastStationList_Request: invalid LastStationListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if( transmitpos ) // Pos  ->Array position transmitted
                            {
								//Updating the status array excluding the deleted elements
							    audioListDelFlg = 0x00;
							    audioListDelFlg = audioList_deleteCheck( gLSL_Pos[LastStationListLine], gLastStationList_Pos_insDel, gLSL_CSVtotalElem);
								if(audioListDelFlg == 0x0)
								{
								  
									if( indexsize )
									{
										requestarray[Offset] = ( gLSL_Pos[LastStationListLine] & 0x00FF );
										Offset++;
										requestarray[Offset] = (( gLSL_Pos[LastStationListLine] & 0xFF00 ) / 0x100 );
										Offset++;
									}
									else
									{
										requestarray[Offset] = gLSL_Pos[LastStationListLine];
										Offset++;
									}
								}
                            }
                        }
						if(audioListDelFlg == 0x0)
							current_element++;
                        LastStationListLine = LastStationList_nextvalidLine(LastStationListLine, direction );

                    }//end while
                    break;
                default:
                    write( "AudioSD LastStationList_Request: invalid recordaddress %d", recordaddress );
                    break;
            } //end switch "recordaddress"
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            break; //end Data_REQ

          case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break; //end Error_REQ

    } //end switch "request"
}

void MediaPath_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            MediaPath_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: MediaPath_Indication: invalid indication %d", Indication_array[2] );
            break;
    }

}

MediaPath_Request( byte request, byte errorcode )
{
    int i, Offset = 0;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;      //LSG-ID
    requestarray[1] = FctID_MediaPath;  //Fct.-ID
    requestarray[2] = request;           //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x25_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_MediaPath_FolderType;
            requestarray[4] = strlen( gAudioSD_MediaPath_Path );
            Offset = 5;

            for( i = 0; i < strlen( gAudioSD_MediaPath_Path ); i++ )
            {
                requestarray[Offset] = gAudioSD_MediaPath_Path[i];
                Offset++;
            }

            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: MediaPath_Request: invalid request %d", request );
            break;
    }
}

MediaBrowserControl_Indication ( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] )
    {
        case Processing_CNF:
            //IssueList #57  and #74
           if( (( getValue( env_AudioSD_MBrC_ErrorCode ) == 0x00 )||( getValue( env_AudioSD_MBrC_ErrorCode ) > 0x3F ) ) && ( gAudioFctList_0x26_TimeOut_flg == 0x00 ) )
             {
             MediaBrowserControl_Request( Processing_REQ, 0 );          //send Processing

                //IssueList #68
                if( gAudioFctList_0x26_Processing_flg== 0x01 )
                {
                  if( isTimerActive( gAudioFctList_0x26_ProcessingTimer ) == 0x00 )
                  setTimer( gAudioFctList_0x26_ProcessingTimer,AUDIOMAXPROCESSINGTIME );

                MediaBrowserControl_Request( Processing_REQ, 0 );
                }
             }
        break;

        case StartResult_IND:
              //IssueList #74
              if( getValue( env_AudioSD_FctList_0x26_TimeOut ) != TRUE )
              {
              gAudioFctList_0x26_TimeOut_flg = 0x00;

                    //IssueList #57
                if( getValue( env_AudioSD_MBrC_Error_on )== 0x00 )
                putValue( env_AudioSD_MBrC_ErrorCode, 0 );

                    if( getvalue( env_AudioSD_MBrC_Error_on ) )
                        MediaBrowserControl_Request(Error_REQ, getvalue( env_AudioSD_MBrC_ErrorCode ) );

                    else
                    {
                        if( FALSE == gAudioSD_MediaBrowserControl_status )
                        {
                            gAudioSD_MediaBrowserControl_status = TRUE;                            //method active

                            //get data
                            gAudioSD_MediaBrowserControl_Control    =Indication_array[3];
                            gAudioSD_MediaBrowserControl_Reference  =Indication_array[4] + ( Indication_array[5] * 0x100 );

                            if( gAudioSD_MediaBrowserControl_Control> 0x04 )
                            {
                                MediaBrowserControl_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE );
                                gAudioSD_MediaBrowserControl_status = FALSE;
                            }
                            else //received data valid
                            {
                                settimer(MediaBrowserControl_Timer, MediaBrowserControl_TimerTime );
                                //changes from J.Karl 19.11.2013
                if( gAudioSD_MediaBrowserControl_Control == 0x03 /*go to source */)
                                {
                                    gAudioSD_SwitchSource_Reference = gAudioSD_MediaBrowserControl_Reference;
                                    getSourceListRef();
                                    sourceListType();
                                    putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_SwitchSource_Reference );
                                    putvalue( env_AudioSD_activeSrc_update, 0x1 );
                                    putvalue( env_AudioSD_RecListType_update, 0x1 );
                                }
                            }
                        }
                    }
                } //IssueList #74
                else
                gAudioFctList_0x26_TimeOut_flg = 0x01;
        break;

        case Abort_IND:
            if( getvalue( env_AudioSD_MBrC_Error_on ) )
                MediaBrowserControl_Request(Error_REQ, getvalue( env_AudioSD_MBrC_ErrorCode ) );

            else
            {
                if( TRUE != gAudioSD_MediaBrowserControl_status )                                //method not active
                    MediaBrowserControl_Request(Error_REQ, 0x50 );            //send error-message

                else if( TRUE == gAudioSD_MediaBrowserControl_status )        //method still active
                {
                    gAudioSD_MediaBrowserControl_Result = getvalue( env_AudioSD_MBrC_Abort );

                    if( AUDIO_MEDIABROWSERCONTROL_ABORT_SUCCESSFUL == gAudioSD_MediaBrowserControl_Result )        //only, if abort is successful
                    {
                        canceltimer(MediaBrowserControl_Timer );                                //abort method
                        gAudioSD_MediaBrowserControl_status = FALSE;                            //method finished
                    }

                    MediaBrowserControl_Request( Result_REQ, 0 );    //send result-message
                }
            }
        break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: MediaBrowserControl_Indication: unknown indication %d", Indication_array[2] );
        break;
        }
}

MediaBrowserControl_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;                //LSG-ID
    requestarray[1] = FctID_MediaBrowserControl;   //Fct.-ID
    requestarray[2] = request;

    switch( request )
    {
        case Processing_REQ:
            requestarray[3] = gAudioSD_MediaBrowserControl_Reserve;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            break;
        case Result_REQ:
            //IssueList #68
            if( gAudioFctList_0x26_Processing_flg == 0x00 )
            {
            requestarray[3] = gAudioSD_MediaBrowserControl_Result;

              //MR 60227
             //Send the BAP request as normal/expected if MOST is not active
             if( getValue( env_PIC_bapMOST_active_flag ) == 0x00 )
                     set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
                            //BAP_MOST sync
                            else if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
                             {
                                //BAP FIRST before MOST
                                  if( getValue( env_AudioTel_bapMost_delayTimer ) <= 0 ) //delay timer
                                  {
                                  //send BAP first
                                  set_status_requestbuffer( requestarray, 4, Bap_UInt8 );

                                  //call MOST function after the delay
                                  setTimer( _tBapFirst_delayTime, (-1 ) * getValue( env_AudioTel_bapMost_delayTimer ) );
                                  }
                                  ////MOST FIRST before BAP
                                    else if( getValue( env_AudioTel_bapMost_delayTimer ) > 0 ) //delay timer
                                    {
                                      if( isTimerActive( _tMostFirst_delayTime_MedBrwCtrl)== 0 )
                                      {
                                      //prepare the data
                                       //clear
                                       for( i = 0; i < BAP_BUFFER_SIZE; i++ )
                                       gAudio_Requestarray_mbCtrl[i] = 0;
                                       for( i = 0; i <4; i++ )
                                       gAudio_Requestarray_mbCtrl[i] = requestarray[i];
                                       gAudio_BuffSize_mbCtrl = 4;
                                       gAudio_BAPdataType_mbCtrl = Bap_UInt8;
                                       //call MOST
                                       BAP2MOSTSync();
                                       //call BAP after the delay
                                       setTimer( _tMostFirst_delayTime_MedBrwCtrl, getValue( env_AudioTel_bapMost_delayTimer ) );
                                      }
                                      else
                                      {
            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
                                      }
                                    }
                            } //MOST_active_flag
            }
            break;
        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            //IssueList #68
            cancelTimer( gAudioFctList_0x26_ProcessingTimer );
            break;
        default:    //error
            writelineEx( gError_Trace, 0, "AudioSD: MediaBrowserControl_Request: unknown request %d", request );
            break;
    }
}

MediaFileInfo_Indication ( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] )
    {
        case Processing_CNF:
            //IssueList #57  and #74
           if( (( getValue( env_AudioSD_MFI_ErrorCode ) == 0x00 )||( getValue( env_AudioSD_MFI_ErrorCode ) > 0x3F ) ) &&   ( gAudioFctList_0x27_TimeOut_flg == 0x00 ) )
             {
             MediaFileInfo_Request( Processing_REQ, 0 );          //send Processing

                //IssueList #68
                if( gAudioFctList_0x27_Processing_flg== 0x01 )
                {
                  if( isTimerActive( gAudioFctList_0x27_ProcessingTimer ) == 0x00 )
                  setTimer( gAudioFctList_0x27_ProcessingTimer,AUDIOMAXPROCESSINGTIME );

                MediaFileInfo_Request( Processing_REQ, 0 );
                }
             }
        break;

        case StartResult_IND:
              //IssueList #74
              if( getValue( env_AudioSD_FctList_0x27_TimeOut ) != TRUE )
              {
              gAudioFctList_0x27_TimeOut_flg = 0x00;
                    //IssueList #57
                if( getValue( env_AudioSD_MFI_Error_on )== 0x00 )
                putValue( env_AudioSD_MFI_ErrorCode, 0 );


                    if( getvalue( env_AudioSD_MFI_Error_on ) )
                        MediaFileInfo_Request(Error_REQ, getvalue( env_AudioSD_MFI_ErrorCode ) );

                    else
                    {
                        if( FALSE == gAudioSD_MediaFileInfo_status )
                        {
                            gAudioSD_MediaFileInfo_status = TRUE;                            //method active

                            //get data
                            gAudioSD_MediaFileInfo_Reference    =Indication_array[3];

                            settimer(MediaFileInfo_Timer, MediaFileInfo_TimerTime );
                        }
                    }
               } //IssueList #74
               else
               gAudioFctList_0x27_TimeOut_flg = 0x01;

        break;

        case Abort_IND:
            if( getvalue( env_AudioSD_MFI_Error_on ) )
                MediaFileInfo_Request(Error_REQ, getvalue( env_AudioSD_MFI_ErrorCode ) );

            else
            {
                if( TRUE != gAudioSD_MediaFileInfo_status )                                //method not active
                    MediaFileInfo_Request(Error_REQ, 0x50 );            //send error-message

                else if( TRUE == gAudioSD_MediaFileInfo_status )                            //method still active
                {
                    gAudioSD_MediaFileInfo_Result = getvalue( env_AudioSD_MFI_Abort );

                    if( AUDIO_MEDIAFILEINFO_ABORT_SUCCESSFUL == gAudioSD_MediaFileInfo_Result )        //only, if abort is successful
                    {
                        canceltimer(MediaFileInfo_Timer );                                //abort method
                        gAudioSD_MediaFileInfo_status = FALSE;                             //method finished
                    }

                    MediaFileInfo_Request( Result_REQ, 0 );    //send result-message
                }
            }
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: MediaFileInfo_Indication: unknown indication %d", Indication_array[2] );
            break;
        }
}

MediaFileInfo_Request( byte request, byte errorcode )
{
    int i = 0, Offset = 0;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;          //LSG-ID
    requestarray[1] = FctID_MediaFileInfo;   //Fct.-ID
    requestarray[2] = request;

    switch( request )
    {
        case Processing_REQ:
            requestarray[3] = gAudioSD_MediaFileInfo_Reserve;

            set_status_requestbuffer( requestarray, 4, Bap_ByteSequence );
            break;
        case Result_REQ:
            if( gAudioFctList_0x27_Processing_flg == 0x00 )
            {
            requestarray[3] = gAudioSD_MediaFileInfo_Result;
            Offset = 4;

            //Artist
            requestarray[Offset] = strlen( gAudioSD_MediaFileInfo_Artist_s );
            Offset++;

            for( i = 0; i < strlen( gAudioSD_MediaFileInfo_Artist_s ); i++ )
            {
                requestarray[Offset] = gAudioSD_MediaFileInfo_Artist_s[i];
                Offset++;
            }

            //Title
            requestarray[Offset] = strlen( gAudioSD_MediaFileInfo_Title_s );
            Offset++;

            for( i = 0; i < strlen( gAudioSD_MediaFileInfo_Title_s ); i++ )
            {
                requestarray[Offset] = gAudioSD_MediaFileInfo_Title_s[i];
                Offset++;
            }

            //Album
            requestarray[Offset] = strlen( gAudioSD_MediaFileInfo_Album_s );
            Offset++;

            for( i = 0; i < strlen( gAudioSD_MediaFileInfo_Album_s ); i++ )
            {
                requestarray[Offset] = gAudioSD_MediaFileInfo_Album_s[i];
                Offset++;
            }
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }
            break;
        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );

            //IssueList #68
            cancelTimer( gAudioFctList_0x27_ProcessingTimer );
            break;
        default:    //error
            writelineEx( gError_Trace, 0, "AudioSD: MediaFileInfo_Request: unknown request %d", request );
            break;
    }
}

PreferredList_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            PreferredList_Request( Data_REQ, 0 );    //send status
            break;
        case DataSetGet_IND:

            putvalue( env_AudioSD_PreferredList_List, Indication_array[3] );

            PreferredList_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: PreferredList_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

PreferredList_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;          //LSG-ID
    requestarray[1] = FctID_PreferredList;  //Fct.-ID
    requestarray[2] = request;               //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x28_TimeOut ) != TRUE )
            {
            gAudioSD_PreferredList_List = getValue( env_AudioSD_PreferredList_List );
            requestarray[3] = gAudioSD_PreferredList_List;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: PreferredList_Request: invalid request %d", request );
            break;
    }
}

SDS_State_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:

            putvalue( env_AudioSD_SDSState_State, Indication_array[3] );

            SDS_State_Request( Data_REQ, 0 );    //send status
            break;
        case DataSetGet_IND:

            putvalue( env_AudioSD_SDSState_State, Indication_array[3] );

            SDS_State_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: SDS_State_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

SDS_State_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;      //LSG-ID
    requestarray[1] = FctID_SDS_State;  //Fct.-ID
    requestarray[2] = request;           //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x29_TimeOut ) != TRUE )
            {
            gAudioSD_SDSState_State = getvalue( env_AudioSD_SDSState_State );
            requestarray[3] = gAudioSD_SDSState_State;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: SDS_State_Request: invalid request %d", request );
            break;
    }
}

FunctionSynchronisation_Request( byte request, byte errorcode )
{
    int i, Offset = 0;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;                  //LSG-ID
    requestarray[1] = FctID_FunctionSynchronisation;    //Fct.-ID
    requestarray[2] = request;                       //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x2A_TimeOut ) != TRUE )
            {
            Offset = 3;

            for( i = 0; i < 8; i++ )
            {
                requestarray[Offset] = gAudioSD_FunctionSynchronisation_FctList[i];
                Offset++;
            }

            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: FunctionSynchronisation_Request: invalid request %d", request );
            break;
    }
}

FunctionSynchronisation_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            FunctionSynchronisation_Request( Data_REQ, 0 );    //send status
        break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: FunctionSynchronisation_Indication: invalid indication %d", Indication_array[2] );
        break;
    }
}

ASGCapabilities_Indication( dword Indication_array [], int datalength )
{
    int i = 0;
    switch( Indication_array[2] ) // indication
    {
        case DataSetGet_IND:
            //get data
            gAudioSD_ASGCapabilities_PresentationCapabilities = Indication_array[3];
            gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 = gAudioSD_ASGCapabilities_PresentationCapabilities & 0x01;
            gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 = ( gAudioSD_ASGCapabilities_PresentationCapabilities & 0x02 )>>1;

            if( getvalue( env_AudioSD_ASGCapa_Error_on ) )
                ASGCapabilities_Request(Error_REQ, getvalue( env_AudioSD_ASGCapa_ErrorCode ) );

            else
                ASGCapabilities_Request( Data_REQ, 0 );

            //Panel
            putvalue( env_AudioSD_ASGCapa_PresCa_DAB_s, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0_string[gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0] );

            putvalue( env_AudioSD_ASGCapa_PresCa_SDA_s, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1_string[gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1] );
            putvalue( env_AudioSD_ASGCapa_PresCa_DAB, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 );
        putvalue( env_AudioSD_ASGCapa_PresCa_SDARS, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 );

            break;

        case DataGet_IND:
            if( gBAP_Indication[5] != 3)  //datalength error
                Mute_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE );  //send error-message
            else
                Mute_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: ASGCapabilities_Indication: invalid indication %d", Indication_array[2] );
            break;
    }

}

ASGCapabilities_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_ASG_Capabilities;   //Fct.-ID
    requestarray[2] = request;                   //request type

    switch( request )
    {
        case Data_REQ:
            //IssueList #62
            if( getValue( env_AudioSD_FctList_0x2B_TimeOut ) != TRUE )
            {
            requestarray[3] = gAudioSD_ASGCapabilities_PresentationCapabilities;

            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            }
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: ASGCapabilities_Request: invalid request %d", request );
            break;
    }
}

GetNextListPos_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] )
    {
        case Processing_CNF:
            //IssueList #57  and #74
           if( (( getValue( env_AudioSD_GNLP_ErrorCode ) == 0x00 )||( getValue( env_AudioSD_GNLP_ErrorCode ) > 0x3F ) ) &&  ( gAudioFctList_0x2C_TimeOut_flg == 0x00 ) )
             GetNextListPos_Request( Processing_REQ, 0 );          //send Processing

            //IssueList #68
                if( gAudioFctList_0x2C_Processing_flg== 0x01 )
                {
                  if( isTimerActive( gAudioFctList_0x2C_ProcessingTimer ) == 0x00 )
                  setTimer( gAudioFctList_0x2C_ProcessingTimer,AUDIOMAXPROCESSINGTIME );

                GetNextListPos_Request( Processing_REQ, 0 );
                }
        break;

        case StartResult_IND:
               //IssueList #74
              if( getValue( env_AudioSD_FctList_0x2C_TimeOut ) != TRUE )
              {
              gAudioFctList_0x2C_TimeOut_flg = 0x00;
                  //IssueList #57
                if( getValue( env_AudioSD_GNLP_Error_on )== 0x00 )
                putValue( env_AudioSD_GNLP_ErrorCode, 0 );


                    if( getvalue( env_AudioSD_GNLP_Error_on ) )
                        GetNextListPos_Request(Error_REQ, getvalue( env_AudioSD_GNLP_ErrorCode ) );

                     //IssueList #96
             //IssueList 197
                    //else if( gAudioSD_GetNextListPos_Result ==  AUDIO_GETNEXTLISTPOS_NOT_SUCCESSFUL)
            else if( getValue( env_AudioSD_GNLP_Result ) !=  AUDIO_GETNEXTLISTPOS_SUCCESSFUL)
                    {
                    cancelTimer(GetNextListPos_Timer );
                    gAudioSD_GetNextListPos_status = FALSE;

                    GetNextListPos_Request( Result_REQ, 0 ); //send Result
                    }

                    else
                    {
                        if( FALSE == gAudioSD_GetNextListPos_status )
                        {
                            gAudioSD_GetNextListPos_status = TRUE;                            //method active

                            //get data
                            gAudioSD_GetNextListPos_CurrentPos  =Indication_array[3] + ( Indication_array[4] * 0x100 );
                            gAudioSD_GetNextListPos_Offset      =Indication_array[5] + ( Indication_array[6] * 0x100 );
                            //changes from Jran Karl (28.03.2012 )
                            if( gAudioSD_GetNextListPos_Offset >= 0x8000 )
                            {
                                gAudioSD_GetNextListPos_Offset = -( 0x10000 - gAudioSD_GetNextListPos_Offset );
                            }
                            gAudioSD_GetNextListPos_ListType    =Indication_array[7];

                if( gAudioSD_GetNextListPos_ListType> 0x07)
                            {
                                GetNextListPos_Request(Error_REQ, BAP_BAL_OUT_OF_RANGE );
                                gAudioSD_GetNextListPos_status = FALSE;
                            }
                            else //received data valid
                                settimer(GetNextListPos_Timer, GetNextListPos_TimerTime );
                        }
                    }
               } //IssueList #74
               else
               gAudioFctList_0x2C_TimeOut_flg = 0x01;

            break;

        case Abort_IND:
            if( TRUE != gAudioSD_GetNextListPos_status )                             //method not active
                GetNextListPos_Request(Error_REQ, 0x50 );            //send error-message

            else if( TRUE == gAudioSD_GetNextListPos_status )                            //method still active
            {
                gAudioSD_GetNextListPos_Result = getvalue( env_AudioSD_GNLP_Abort );

                if( AUDIO_GETNEXTLISTPOS_ABORT_SUCCESSFUL == gAudioSD_GetNextListPos_Result )        //only, if abort is successful
                {
                    canceltimer(GetNextListPos_Timer );                              //abort method
                    gAudioSD_GetNextListPos_status = FALSE;                         //method finished
                }

                GetNextListPos_Request( Result_REQ, 0 );  //send result-message
            }
            break;
        default:
            writelineEx( gError_Trace, 0, "AudioSD: GetNextListPos_Indication: unknown indication %d", Indication_array[2] );
            break;
    }
}

GetNextListPos_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;           //LSG-ID
    requestarray[1] = FctID_GetNextListPos;   //Fct.-ID
    requestarray[2] = request;

    switch( request )
    {
        case Processing_REQ:
            requestarray[3] = gAudioSD_GetNextListPos_Reserve;

            set_status_requestbuffer( requestarray, 4, Bap_ByteSequence );
            break;
        case Result_REQ:
            //IssueList #68
            if( gAudioFctList_0x2C_Processing_flg == 0x00 )
            {
            requestarray[3] = gAudioSD_GetNextListPos_Result;
            requestarray[4] = gAudioSD_GetNextListPos_CurrentPos & 0xff;
            requestarray[5] = ( gAudioSD_GetNextListPos_CurrentPos & 0xff00 ) / 0x100;
            requestarray[6] = gAudioSD_GetNextListPos_nextPos & 0xff;
            requestarray[7] = ( gAudioSD_GetNextListPos_nextPos & 0xff00 ) / 0x100;
            requestarray[8] = gAudioSD_GetNextListPos_absoluteListPos & 0xff;
            requestarray[9] = ( gAudioSD_GetNextListPos_absoluteListPos & 0xff00 ) / 0x100;

            set_status_requestbuffer( requestarray, 10, Bap_ByteSequence );
            }

            break;
        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );

            //IssueList #68
            cancelTimer( gAudioFctList_0x2C_ProcessingTimer );
            break;
        default:    //error
            writelineEx( gError_Trace, 0, "AudioSD: GetNextListPos_Request: unknown request %d", request );
            break;
    }
}

on envVar env_AudioSD_CSH_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_CSIhandle_FSGhandle                = getvalue( env_AudioSD_CSH_FSGhandle );
        gAudioSD_CSIhandle_FSGhandle_absolutePos    = getvalue( env_AudioSD_CSH_FSGAbsPos );
        gAudioSD_CSIhandle_PresetListRef            = getvalue( env_AudioSD_CSH_PresetListRef );
        gAudioSD_CSIhandle_PresetListabsolutePos    = getvalue( env_AudioSD_CSH_PresetListAbsPos );
        gAudioSD_CSIhandle_DABEnsembleHandle        = getvalue( env_AudioSD_CSH_DABEnsHandle );
        gAudioSD_CSIhandle_DABEnsembleAbsPos        = getvalue( env_AudioSD_CSH_DABEnsAbsPos );

        CurrentStationHandle_Request( Data_REQ, 0 );
    }
}

on envVar env_AudioSD_TPMemInfo_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_TPMemoInfo_CurrentMsgNumber    = getvalue( env_AudioSD_TPMemInfo_CMN );
        gAudioSD_TPMemoInfo_TotalMsgNumber      = getvalue( env_AudioSD_TPMemInfo_TMN );
        gAudioSD_TPMemoInfo_hour                = getvalue( env_AudioSD_TPMemInfo_hour );
        gAudioSD_TPMemoInfo_minute              = getvalue( env_AudioSD_TPMemInfo_min );
        getvalue( env_AudioSD_TPMemInfo_station_s, gAudioSD_TPMemoInfo_StationName );

        TPMemoInfo_Request( Data_REQ, 0 );
    }
}

on envVar env_AudioSD_MedBrFoLev_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_MediaBrowser_FL_FolderLevel            = getvalue( env_AudioSD_MedBrFoLev_FolLev);
gAudioSD_MediaBrowser_FL_RefMediaBrowser        = getvalue( env_AudioSD_MedBrFoLev_Ref );
gAudioSD_MediaBrowser_FL_RefMediaBrowser_AbsPos = getvalue( env_AudioSD_MedBrFoLev_Ref_abs );


        MediaBrowserFolderLevel_Request( Data_REQ, 0 );
    }
}

on envVar env_AudioSD_MedPath_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_MediaPath_FolderType = getvalue( env_AudioSD_MedPath_Type );
        getvalue( env_AudioSD_MedPath_Path_s, gAudioSD_MediaPath_Path );

        MediaPath_Request( Data_REQ, 0 );
    }
}

on envVar env_AudioSD_PreferredList_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_PreferredList_List = getvalue( env_AudioSD_PreferredList_List );

        PreferredList_Request( Data_REQ, 0 );
    }
}

on envVar env_AudioSD_SDSState_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_SDSState_State = getvalue( env_AudioSD_SDSState_State );


        SDS_State_Request( Data_REQ, 0 );
    }
}

on envVar env_AudioSD_ASGCapa_update
{
    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0 = getvalue( env_AudioSD_ASGCapa_PresCa_DAB);
        gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1 = getvalue( env_AudioSD_ASGCapa_PresCa_SDARS);

        gAudioSD_ASGCapabilities_PresentationCapabilities = 0;

        //IssueList #189 - SDARS
        gAudioSD_ASGCapabilities_PresentationCapabilities = ( gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0* 0x01 )+ ( gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1* 0x02 );


        putvalue( env_AudioSD_ASGCapa_PresCa_DAB_s, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0_string[gAudioSD_ASGCapabilities_PresentationCapabilities_Bit0] );
        putvalue( env_AudioSD_ASGCapa_PresCa_SDA_s, gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1_string[gAudioSD_ASGCapabilities_PresentationCapabilities_Bit1] );


        ASGCapabilities_Request( Data_REQ, 0 );
    }
}

on envVar env_AudioSD_FctSync_update
{
    int i = 0;

    //get data
    gAudioSD_FunctionSynchronisation_FctList_Bit16  = getvalue( env_AudioSD_FctSync_Bit16_aS);
    gAudioSD_FunctionSynchronisation_FctList_Bit17  = getvalue( env_AudioSD_FctSync_Bit17_aSn );
    gAudioSD_FunctionSynchronisation_FctList_Bit18  = getvalue( env_AudioSD_FctSync_Bit18_cV);
    gAudioSD_FunctionSynchronisation_FctList_Bit19  = getvalue( env_AudioSD_FctSync_Bit19_Mute );
    gAudioSD_FunctionSynchronisation_FctList_Bit20  = getvalue( env_AudioSD_FctSync_Bit20_SrcS);
    gAudioSD_FunctionSynchronisation_FctList_Bit21  = getvalue( env_AudioSD_FctSync_Bit21_CSI);
    gAudioSD_FunctionSynchronisation_FctList_Bit22  = getvalue( env_AudioSD_FctSync_Bit22_CSH);
    gAudioSD_FunctionSynchronisation_FctList_Bit23  = getvalue( env_AudioSD_FctSync_Bit23_RL);
    gAudioSD_FunctionSynchronisation_FctList_Bit24  = getvalue( env_AudioSD_FctSync_Bit24_DAC);
    gAudioSD_FunctionSynchronisation_FctList_Bit25  = getvalue( env_AudioSD_FctSync_Bit25_GIS);
    gAudioSD_FunctionSynchronisation_FctList_Bit26  = getvalue( env_AudioSD_FctSync_Bit26_TPm);
    gAudioSD_FunctionSynchronisation_FctList_Bit27  = getvalue( env_AudioSD_FctSync_Bit27_TPmL);
    gAudioSD_FunctionSynchronisation_FctList_Bit28  = getvalue( env_AudioSD_FctSync_Bit28_AnIn );
    gAudioSD_FunctionSynchronisation_FctList_Bit29  = getvalue( env_AudioSD_FctSync_Bit29_AnEs );
    gAudioSD_FunctionSynchronisation_FctList_Bit30  = getvalue( env_AudioSD_FctSync_Bit30_InfS);
    gAudioSD_FunctionSynchronisation_FctList_Bit31  = getvalue( env_AudioSD_FctSync_Bit31_RLT );
    gAudioSD_FunctionSynchronisation_FctList_Bit32  = getvalue( env_AudioSD_FctSync_Bit32_SL);
    gAudioSD_FunctionSynchronisation_FctList_Bit33  = getvalue( env_AudioSD_FctSync_Bit33_RTPL);
    gAudioSD_FunctionSynchronisation_FctList_Bit34  = getvalue( env_AudioSD_FctSync_Bit34_SwS);
    gAudioSD_FunctionSynchronisation_FctList_Bit35  = getvalue( env_AudioSD_FctSync_Bit35_MBFL);
    gAudioSD_FunctionSynchronisation_FctList_Bit36  = getvalue( env_AudioSD_FctSync_Bit36_MB);
    gAudioSD_FunctionSynchronisation_FctList_Bit37  = getvalue( env_AudioSD_FctSync_Bit37_MPa );
    gAudioSD_FunctionSynchronisation_FctList_Bit38  = getvalue( env_AudioSD_FctSync_Bit38_MBCt );
    gAudioSD_FunctionSynchronisation_FctList_Bit39  = getvalue( env_AudioSD_FctSync_Bit39_MFIn );
    gAudioSD_FunctionSynchronisation_FctList_Bit40  = getvalue( env_AudioSD_FctSync_Bit40_PrfL);
    gAudioSD_FunctionSynchronisation_FctList_Bit41  = getvalue( env_AudioSD_FctSync_Bit41_SDS);
    gAudioSD_FunctionSynchronisation_FctList_Bit42  = getvalue( env_AudioSD_FctSync_Bit42_FctS);
    gAudioSD_FunctionSynchronisation_FctList_Bit43  = getvalue( env_AudioSD_FctSync_Bit43_ASGC);
    gAudioSD_FunctionSynchronisation_FctList_Bit44  = getvalue( env_AudioSD_FctSync_Bit44_GNLP );
    gAudioSD_FunctionSynchronisation_FctList_Bit45  = getvalue( env_AudioSD_FctSync_Bit45_SwRdMd );
    gAudioSD_FunctionSynchronisation_FctList_Bit46  = getvalue( env_AudioSD_FctSync_Bit46_MedImp);
    gAudioSD_FunctionSynchronisation_FctList_Bit47  = getvalue( env_AudioSD_FctSync_Bit47_CurVol);
    gAudioSD_FunctionSynchronisation_FctList_2_Bit00 = getvalue( env_AudioSD_FctSync_2_Bit00_CurD);
    gAudioSD_FunctionSynchronisation_FctList_2_Bit01 = getvalue( env_AudioSD_FctSync_2_Bit01_ONRA);
    gAudioSD_FunctionSynchronisation_FctList_2_Bit02 = getvalue( env_AudioSD_FctSync_2_Bit02_ComL);
    gAudioSD_FunctionSynchronisation_FctList_2_Bit03 = getvalue( env_AudioSD_FctSync_2_Bit03_CurS);
    gAudioSD_FunctionSynchronisation_FctList_2_Bit04 = getvalue( env_AudioSD_FctSync_2_Bit04_PPos );
    gAudioSD_FunctionSynchronisation_FctList_2_Bit05 = getvalue( env_AudioSD_FctSync_2_Bit05_SRS);
    gAudioSD_FunctionSynchronisation_FctList_2_Bit06 = getvalue( env_AudioSD_FctSync_2_Bit06_CSI2 );
    gAudioSD_FunctionSynchronisation_FctList_2_Bit07 = getvalue( env_AudioSD_FctSync_2_Bit07_CSH3);
    gAudioSD_FunctionSynchronisation_FctList_3_Bit00 = getvalue( env_AudioSD_FctSync3_Bit00_LSL);
    gAudioSD_FunctionSynchronisation_FctList_3_Bit01 = getvalue( env_AudioSD_FctSync3_Bit01_SAI);
    gAudioSD_FunctionSynchronisation_FctList_3_Bit02 = getvalue( env_AudioSD_FctSync3_Bit02_Pic);
    gAudioSD_FunctionSynchronisation_FctList_3_Bit03 = getvalue( env_AudioSD_FctSync3_Bit03_FL);
    gAudioSD_FunctionSynchronisation_FctList_3_Bit04 = getvalue( env_AudioSD_FctSync3_Bit04_STS);

    //clear
    for( i = 0; i <8; i++ )
        gAudioSD_FunctionSynchronisation_FctList[i] = 0;

    //Byte 2
    gAudioSD_FunctionSynchronisation_FctList[2] = gAudioSD_FunctionSynchronisation_FctList_Bit23;
    gAudioSD_FunctionSynchronisation_FctList[2] += gAudioSD_FunctionSynchronisation_FctList_Bit22* 0x02;
    gAudioSD_FunctionSynchronisation_FctList[2] += gAudioSD_FunctionSynchronisation_FctList_Bit21* 0x04;
    gAudioSD_FunctionSynchronisation_FctList[2] += gAudioSD_FunctionSynchronisation_FctList_Bit20* 0x08;
    gAudioSD_FunctionSynchronisation_FctList[2] += gAudioSD_FunctionSynchronisation_FctList_Bit19* 0x10;
    gAudioSD_FunctionSynchronisation_FctList[2] += gAudioSD_FunctionSynchronisation_FctList_Bit18* 0x20;
    gAudioSD_FunctionSynchronisation_FctList[2] += gAudioSD_FunctionSynchronisation_FctList_Bit17* 0x40;
    gAudioSD_FunctionSynchronisation_FctList[2] += gAudioSD_FunctionSynchronisation_FctList_Bit16* 0x80;

    //Byte 3
    gAudioSD_FunctionSynchronisation_FctList[3] = gAudioSD_FunctionSynchronisation_FctList_Bit31;
    gAudioSD_FunctionSynchronisation_FctList[3] += gAudioSD_FunctionSynchronisation_FctList_Bit30* 0x02;
    gAudioSD_FunctionSynchronisation_FctList[3] += gAudioSD_FunctionSynchronisation_FctList_Bit29* 0x04;
    gAudioSD_FunctionSynchronisation_FctList[3] += gAudioSD_FunctionSynchronisation_FctList_Bit28* 0x08;
    gAudioSD_FunctionSynchronisation_FctList[3] += gAudioSD_FunctionSynchronisation_FctList_Bit27* 0x10;
    gAudioSD_FunctionSynchronisation_FctList[3] += gAudioSD_FunctionSynchronisation_FctList_Bit26* 0x20;
    gAudioSD_FunctionSynchronisation_FctList[3] += gAudioSD_FunctionSynchronisation_FctList_Bit25* 0x40;
    gAudioSD_FunctionSynchronisation_FctList[3] += gAudioSD_FunctionSynchronisation_FctList_Bit24* 0x80;

    //Byte 4
    gAudioSD_FunctionSynchronisation_FctList[4] = gAudioSD_FunctionSynchronisation_FctList_Bit39;
    gAudioSD_FunctionSynchronisation_FctList[4] += gAudioSD_FunctionSynchronisation_FctList_Bit38* 0x02;
    gAudioSD_FunctionSynchronisation_FctList[4] += gAudioSD_FunctionSynchronisation_FctList_Bit37* 0x04;
    gAudioSD_FunctionSynchronisation_FctList[4] += gAudioSD_FunctionSynchronisation_FctList_Bit36* 0x08;
    gAudioSD_FunctionSynchronisation_FctList[4] += gAudioSD_FunctionSynchronisation_FctList_Bit35* 0x10;
    gAudioSD_FunctionSynchronisation_FctList[4] += gAudioSD_FunctionSynchronisation_FctList_Bit34* 0x20;
    gAudioSD_FunctionSynchronisation_FctList[4] += gAudioSD_FunctionSynchronisation_FctList_Bit33* 0x40;
    gAudioSD_FunctionSynchronisation_FctList[4] += gAudioSD_FunctionSynchronisation_FctList_Bit32* 0x80;

    //Byte 5
    gAudioSD_FunctionSynchronisation_FctList[5] = gAudioSD_FunctionSynchronisation_FctList_Bit47;
    gAudioSD_FunctionSynchronisation_FctList[5] += gAudioSD_FunctionSynchronisation_FctList_Bit46* 0x02;
    gAudioSD_FunctionSynchronisation_FctList[5] += gAudioSD_FunctionSynchronisation_FctList_Bit45* 0x04;
    gAudioSD_FunctionSynchronisation_FctList[5] += gAudioSD_FunctionSynchronisation_FctList_Bit44* 0x08;
    gAudioSD_FunctionSynchronisation_FctList[5] += gAudioSD_FunctionSynchronisation_FctList_Bit43* 0x10;
    gAudioSD_FunctionSynchronisation_FctList[5] += gAudioSD_FunctionSynchronisation_FctList_Bit42* 0x20;
    gAudioSD_FunctionSynchronisation_FctList[5] += gAudioSD_FunctionSynchronisation_FctList_Bit41* 0x40;
    gAudioSD_FunctionSynchronisation_FctList[5] += gAudioSD_FunctionSynchronisation_FctList_Bit40* 0x80;

    //Byte 6
    gAudioSD_FunctionSynchronisation_FctList[6] = gAudioSD_FunctionSynchronisation_FctList_2_Bit07;
    gAudioSD_FunctionSynchronisation_FctList[6] += gAudioSD_FunctionSynchronisation_FctList_2_Bit06* 0x02;
    gAudioSD_FunctionSynchronisation_FctList[6] += gAudioSD_FunctionSynchronisation_FctList_2_Bit05* 0x04;
    gAudioSD_FunctionSynchronisation_FctList[6] += gAudioSD_FunctionSynchronisation_FctList_2_Bit04* 0x08;
    gAudioSD_FunctionSynchronisation_FctList[6] += gAudioSD_FunctionSynchronisation_FctList_2_Bit03* 0x10;
    gAudioSD_FunctionSynchronisation_FctList[6] += gAudioSD_FunctionSynchronisation_FctList_2_Bit02* 0x20;
    gAudioSD_FunctionSynchronisation_FctList[6] += gAudioSD_FunctionSynchronisation_FctList_2_Bit01* 0x40;
    gAudioSD_FunctionSynchronisation_FctList[6] += gAudioSD_FunctionSynchronisation_FctList_2_Bit00* 0x80;

    //Byte 7
    gAudioSD_FunctionSynchronisation_FctList[7] = gAudioSD_FunctionSynchronisation_FctList_3_Bit04* 0x08;
    gAudioSD_FunctionSynchronisation_FctList[7] += gAudioSD_FunctionSynchronisation_FctList_3_Bit03* 0x10;
    gAudioSD_FunctionSynchronisation_FctList[7] += gAudioSD_FunctionSynchronisation_FctList_3_Bit02* 0x20;
    gAudioSD_FunctionSynchronisation_FctList[7] += gAudioSD_FunctionSynchronisation_FctList_3_Bit01* 0x40;
    gAudioSD_FunctionSynchronisation_FctList[7] += gAudioSD_FunctionSynchronisation_FctList_3_Bit00* 0x80;

    FunctionSynchronisation_Request( Data_REQ, 0 );
}

on timer AnnouncementEscape_Timer
{
    if( getvalue( env_AudioSD_AnE_NotActive ) == 0x04 )
        gAudioSD_AnnouncementEscape_Result = getvalue( env_AudioSD_AnE_NotActive );

    else
        gAudioSD_AnnouncementEscape_Result = getvalue( env_AudioSD_AnE_Res );

    AnnouncementEscape_Request( Result_REQ, 0 ); //send Result

gAudioSD_AnnouncementEscape_status = FALSE; //method not active

    //if( gAudioSD_AnnouncementEscape_Result == AUDIO_DAC_SUCCESSFUL)
    if( gAudioSD_AnnouncementEscape_Result == AUDIO_ANNOUNCEMENTESCAPE_SUCCESSFUL)
    {
        gAudioSD_AnnouncementEscape_MethodHandling = 1;
        settimer( AnnouncementEscape_MethodHandling_Timer,100 );
    }
}

on timer SwitchSource_Timer
{
 //changes from J.Karl 30.11.2012 - s
//    gAudioSD_SwitchSource_Result = getvalue( env_AudioSD_SwitchSource_Result );

    //Panel
//    if( gAudioSD_SwitchSource_Result != AUDIO_SWITCHSOURCERESULT_NOT_SUCCESSFUL && gAudioSD_SwitchSource_status == TRUE )
//    {
//        putvalue( env_AudioSD_SwitchSource_Ref, gAudioSD_SwitchSource_Reference );
        //IssueList #32
//        putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_SwitchSource_Reference );

        //IssueList #86
//        getSourceListRef();
//        receptionListType();

//        putvalue( env_AudioSD_RecListType_update, 0x1 );
//        putValue( env_AudioSD_activeSrc_update, 0x1 );
//    }    //changes from J.Karl 30.11.2012 - e
    SwitchSource_Request( Result_REQ, 0 ); //send Result

    gAudioSD_SwitchSource_status = FALSE; //method not active
 //changes from J.Karl 30.11.2012
    putValue( env_AudioSD_RL_FRU, 0x1 );
}

on timer MediaBrowserControl_Timer
{
    gAudioSD_MediaBrowserControl_Result = getvalue( env_AudioSD_MBrC_Res );

    if( gAudioSD_MediaBrowserControl_Result != AUDIO_MEDIABROWSERCONTROL_NOT_SUCCESSFUL && gAudioSD_MediaBrowserControl_status == TRUE )
    {
        //Panel
        if( gAudioSD_MediaBrowserControl_Control< 0x05)
            putvalue( env_AudioSD_MBrC_Control_s, gAudioSD_MediaBrowserControl_Control_s[gAudioSD_MediaBrowserControl_Control] );
        else
            putvalue( env_AudioSD_MBrC_Control_s, gstring_reserved );

        putvalue( env_AudioSD_MBrC_Ref, gAudioSD_MediaBrowserControl_Reference );
    }


    MediaBrowserControl_Request( Result_REQ, 0 ); //send Result

    //changes from J.Karl 19.11.2013
    if( gAudioSD_MediaBrowserControl_Control == 0x03 /*go to source */)
    {
        putValue( env_AudioSD_RL_FRU, 0x1 );
        putValue( env_AudioSD_MB_FRU, 0x1 );
    }

gAudioSD_MediaBrowserControl_status = FALSE; //method not active
}

on timer MediaFileInfo_Timer
{
    gAudioSD_MediaFileInfo_Result = getvalue( env_AudioSD_MFI_Result );

    if( gAudioSD_MediaFileInfo_Result != AUDIO_MEDIAFILEINFO_NOT_SUCCESSFUL && gAudioSD_MediaFileInfo_status == TRUE )
    {
        //Panel
        putvalue( env_AudioSD_MFI_Ref, gAudioSD_MediaFileInfo_Reference );
        getvalue( env_AudioSD_MFI_Artist_s, gAudioSD_MediaFileInfo_Artist_s );
        getvalue( env_AudioSD_MFI_Title_s, gAudioSD_MediaFileInfo_Title_s );
        getvalue( env_AudioSD_MFI_Album_s, gAudioSD_MediaFileInfo_Album_s );
    }


    MediaFileInfo_Request( Result_REQ, 0 ); //send Result

gAudioSD_MediaFileInfo_status = FALSE; //method not active
}

on timer GetNextListPos_Timer
{
//changes from Jran Karl (28.03.2012 )
    int i = 0;
    int absPos = -1;
    int newPos = 0;
    int maxPos = 0;

    //IssueList #96
    //gAudioSD_GetNextListPos_Result = AUDIO_GETNEXTLISTPOS_SUCCESSFUL;
    gAudioSD_GetNextListPos_Result = getValue( env_AudioSD_GNLP_Result );


    if( gAudioSD_GetNextListPos_status == TRUE )
    {
        if( gAudioSD_GetNextListPos_ListType == 0x00 ) //ReceptionList
        {
            maxPos = gReceptionList_TotalNumListElements;
            for( i = 0; i < gReceptionList_TotalNumListElements; i++ )
                if( gReceptionList_Pos[i] == gAudioSD_GetNextListPos_CurrentPos )
                {
                    absPos = i;
                    break;
                }
        }
        else if( gAudioSD_GetNextListPos_ListType == 0x03) //RadioTVPresetList
        {

            maxPos = gRadioTVPresetList_TotalNumListElements;
            for( i = 0; i < gRadioTVPresetList_TotalNumListElements; i++ )
                if( gRadioTVPresetList_Pos[i] == gAudioSD_GetNextListPos_CurrentPos )
                {
                    absPos = i;
                    break;
                }
        }
        else if( gAudioSD_GetNextListPos_ListType == 0x04 ) //MediaBrowser
        {
            maxPos = gMediaBrowser_TotalNumListElements;
            for( i = 0; i < gMediaBrowser_TotalNumListElements; i++ )
                if( gMediaBrowser_Pos[i] == gAudioSD_GetNextListPos_CurrentPos )
                {
                    absPos = i;
                    break;
                }
        }

        newPos = absPos + gAudioSD_GetNextListPos_Offset;
        if( gAudioSD_GetNextListPos_ListType > 0x04 || absPos == -1 || newPos >= maxPos || newPos < 0 )
        {
            gAudioSD_GetNextListPos_nextPos = 0xFFFF;
            gAudioSD_GetNextListPos_absoluteListPos = 0xFFFF;
        //IssueList #197
            //putvalue( env_AudioSD_GNLP_Result, 0x1 );
        gAudioSD_GetNextListPos_Result = AUDIO_GETNEXTLISTPOS_NOT_SUCCESSFUL;
        }
        else
        {
            if( gAudioSD_GetNextListPos_ListType == 0x00 ) //ReceptionList
                gAudioSD_GetNextListPos_nextPos = gReceptionList_Pos[newPos];
            else if( gAudioSD_GetNextListPos_ListType == 0x03) //RadioTVPresetList
                gAudioSD_GetNextListPos_nextPos = gRadioTVPresetList_Pos[newPos];
            else if( gAudioSD_GetNextListPos_ListType == 0x04 ) //MediaBrowser
                gAudioSD_GetNextListPos_nextPos = gMediaBrowser_Pos[newPos];
            gAudioSD_GetNextListPos_absoluteListPos = newPos + 1;
    //IssueList #197
    gAudioSD_GetNextListPos_Result = AUDIO_GETNEXTLISTPOS_SUCCESSFUL;
        }
    //end of changes from Jran Karl (28.03.2012 )


        //Panel
        putvalue( env_AudioSD_GNLP_CurrPos, gAudioSD_GetNextListPos_CurrentPos );
        putvalue( env_AudioSD_GNLP_Offset, gAudioSD_GetNextListPos_Offset );
    //changes from Jran Karl (28.03.2012 )
        putvalue( env_AudioSD_GNLP_nextPos, gAudioSD_GetNextListPos_nextPos );
        putvalue( env_AudioSD_GNLP_absPos, gAudioSD_GetNextListPos_absoluteListPos );

    if( gAudioSD_GetNextListPos_ListType < 0x08 )
            putvalue( env_AudioSD_GNLP_LT_s, gAudioSD_GetNextListPos_ListType_s[gAudioSD_GetNextListPos_ListType] );
        else
            putvalue( env_AudioSD_GNLP_LT_s, gstring_reserved );

    }


    GetNextListPos_Request( Result_REQ, 0 ); //send Result

    gAudioSD_GetNextListPos_status = FALSE; //method not active

}

byte ReceptionList_nextvalidLine( byte current_ReceptionListLine, byte direction )
{
    byte next_ReceptionListLine;
    int i;

    //init lokal variables
    next_ReceptionListLine = 0;
    i = 0;

    //search next "list entry"
    if( (( gReceptionList_sum - 1 ) == current_ReceptionListLine && FORWARD == direction ) || ( 0 == current_ReceptionListLine && BACKWARD == direction ) )   //last-/fist-element of array reached
        next_ReceptionListLine = 0xFF;
    else
    {
        next_ReceptionListLine = current_ReceptionListLine + 1 - 2 * direction;       //increment or decrement array-line ( depends on direction );

        if( 0 == gReceptionList_ListEntryValidInformation[next_ReceptionListLine] )  // check if next element is "valid"
            next_ReceptionListLine = 0xff;
    }

    return (next_ReceptionListLine );
}

ReceptionList_init_static()
{
    byte j, i, ReceptionListLine;

    //clear
    ReceptionListLine = 0;
    gReceptionList_sum = 0;

    for( j = 0; j < AUDIO_RECEPTIONLIST_ENTRIES; j++ )
    {
        gReceptionList_Pos[j] = 0;
        gReceptionList_Type[j] = 0;

        gReceptionList_Attributes_available_Bit0[j] = 0;
        gReceptionList_Attributes_DVB_Bit1[j] = 0;
        gReceptionList_Attributes_DAB_Bit2[j] = 0;
        gReceptionList_Attributes_DAB_Bit3[j] = 0;
        gReceptionList_Attributes_DAB_Bit4[j] = 0;
        gReceptionList_Attributes_TP_Bit5[j] = 0;
        gReceptionList_Attributes_TMC_Bit6[j] = 0;
        gReceptionList_Attributes_SDARS_Bit7[j] = 0;
        gReceptionList_Attributes_DABServ_Bit8[j] = 0;
        gReceptionList_Attributes_FMOnlineRadio_Bit9[j] = 0;
        gReceptionList_Attributes[j] = 0;

        gReceptionList_PresetID[j] = 0;
        gReceptionList_FmRegCode[j] = 0;
        gReceptionList_Category[j] = 0;

        gReceptionList_ListEntryValidInformation[j] = 0;

        for( i = 0; i < AUDIO_RECEPTIONLIST_NAME_LENGTH; i++ )
            gReceptionList_Name[j][i] = 0;

        for( i = 0; i < AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH; i++ )
            gReceptionList_Frequency[j][i] = 0;
    }

    //entry 0
    gReceptionList_ListEntryValidInformation[ReceptionListLine] = TRUE;
    gReceptionList_Pos[ReceptionListLine] = 0x10;
    gReceptionList_Type[ReceptionListLine] = AUDIO_RECEPTIONLIST_SECONDARYANDPRIMARYSERVICE;

    gReceptionList_Attributes_available_Bit0[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_TP_Bit5[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] = TRUE;
    gReceptionList_Attributes[ReceptionListLine] = gReceptionList_Attributes_available_Bit0[ReceptionListLine] + ( gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] * 0x02 ) + ( gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] * 0x04 ) + ( gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] * 0x08 ) + ( gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] * 0x10 ) + ( gReceptionList_Attributes_TP_Bit5[ReceptionListLine] * 0x20 ) + ( gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] * 0x40 ) + ( gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] * 0x80 + ( gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] * 0x100 ) + ( gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] * 0x200 ) );

    gReceptionList_PresetID[ReceptionListLine] = 0x32;
    gReceptionList_FmRegCode[ReceptionListLine] = 0x74;
    gReceptionList_Category[ReceptionListLine] = AUDIO_RECEPTIONLIST_SCIENCE;
    strncpy( gReceptionList_Name[ReceptionListLine], "Name_0", AUDIO_RECEPTIONLIST_NAME_LENGTH);
    strncpy( gReceptionList_Frequency[ReceptionListLine], "Frequency_0", AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH);
    ReceptionListLine++;

    //entry 1
    gReceptionList_ListEntryValidInformation[ReceptionListLine] = TRUE;
    gReceptionList_Pos[ReceptionListLine] = 0x74;
    gReceptionList_Type[ReceptionListLine] = AUDIO_RECEPTIONLIST_FLATSLIST_0x04;

    gReceptionList_Attributes_available_Bit0[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_TP_Bit5[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] = FALSE;
    gReceptionList_Attributes[ReceptionListLine] = gReceptionList_Attributes_available_Bit0[ReceptionListLine] + ( gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] * 0x02 ) + ( gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] * 0x04 ) + ( gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] * 0x08 ) + ( gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] * 0x10 ) + ( gReceptionList_Attributes_TP_Bit5[ReceptionListLine] * 0x20 ) + ( gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] * 0x40 ) + ( gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] * 0x80 + ( gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] * 0x100 ) + ( gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] * 0x200 ) );

    gReceptionList_PresetID[ReceptionListLine] = 0x71;
    gReceptionList_FmRegCode[ReceptionListLine] = 0x62;
    gReceptionList_Category[ReceptionListLine] = AUDIO_RECEPTIONLIST_TALK;
    strncpy( gReceptionList_Name[ReceptionListLine], "Name_1", AUDIO_RECEPTIONLIST_NAME_LENGTH);
    strncpy( gReceptionList_Frequency[ReceptionListLine], "Frequency_1", AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH);
    ReceptionListLine++;

    //entry 2
    gReceptionList_ListEntryValidInformation[ReceptionListLine] = TRUE;
    gReceptionList_Pos[ReceptionListLine] = 0x20;
    gReceptionList_Type[ReceptionListLine] = AUDIO_RECEPTIONLIST_SECONDARYANDPRIMARYSERVICE;

    gReceptionList_Attributes_available_Bit0[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_TP_Bit5[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] = FALSE;
    gReceptionList_Attributes[ReceptionListLine] = gReceptionList_Attributes_available_Bit0[ReceptionListLine] + ( gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] * 0x02 ) + ( gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] * 0x04 ) + ( gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] * 0x08 ) + ( gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] * 0x10 ) + ( gReceptionList_Attributes_TP_Bit5[ReceptionListLine] * 0x20 ) + ( gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] * 0x40 ) + ( gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] * 0x80 + ( gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] * 0x100 ) + ( gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] * 0x200 ) );

    gReceptionList_PresetID[ReceptionListLine] = 0x54;
    gReceptionList_FmRegCode[ReceptionListLine] = 0x97;
    gReceptionList_Category[ReceptionListLine] = AUDIO_RECEPTIONLIST_OLDIES;
    strncpy( gReceptionList_Name[ReceptionListLine], "Name_2", AUDIO_RECEPTIONLIST_NAME_LENGTH);
    strncpy( gReceptionList_Frequency[ReceptionListLine], "Frequency_2", AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH);
    ReceptionListLine++;

    //entry 3
    gReceptionList_ListEntryValidInformation[ReceptionListLine] = TRUE;
    gReceptionList_Pos[ReceptionListLine] = 0x84;
    gReceptionList_Type[ReceptionListLine] = AUDIO_RECEPTIONLIST_PRIMARYSERVICEONLY;

    gReceptionList_Attributes_available_Bit0[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_TP_Bit5[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] = TRUE;
    gReceptionList_Attributes[ReceptionListLine] = gReceptionList_Attributes_available_Bit0[ReceptionListLine] + ( gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] * 0x02 ) + ( gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] * 0x04 ) + ( gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] * 0x08 ) + ( gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] * 0x10 ) + ( gReceptionList_Attributes_TP_Bit5[ReceptionListLine] * 0x20 ) + ( gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] * 0x40 ) + ( gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] * 0x80 + ( gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] * 0x100 ) + ( gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] * 0x200 ) );

    gReceptionList_PresetID[ReceptionListLine] = 0x64;
    gReceptionList_FmRegCode[ReceptionListLine] = 0x28;
    gReceptionList_Category[ReceptionListLine] = AUDIO_RECEPTIONLIST_PERSONALITY;
    strncpy( gReceptionList_Name[ReceptionListLine], "Name_3", AUDIO_RECEPTIONLIST_NAME_LENGTH);
    strncpy( gReceptionList_Frequency[ReceptionListLine], "Frequency_3", AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH);
    ReceptionListLine++;

    //entry 4
    gReceptionList_ListEntryValidInformation[ReceptionListLine] = TRUE;
    gReceptionList_Pos[ReceptionListLine] = 0x777;
    gReceptionList_Type[ReceptionListLine] = AUDIO_RECEPTIONLIST_FLATSLIST_0x03;

    gReceptionList_Attributes_available_Bit0[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_TP_Bit5[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] = TRUE;
    gReceptionList_Attributes[ReceptionListLine] = gReceptionList_Attributes_available_Bit0[ReceptionListLine] + ( gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] * 0x02 ) + ( gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] * 0x04 ) + ( gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] * 0x08 ) + ( gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] * 0x10 ) + ( gReceptionList_Attributes_TP_Bit5[ReceptionListLine] * 0x20 ) + ( gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] * 0x40 ) + ( gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] * 0x80 + ( gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] * 0x100 ) + ( gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] * 0x200 ) );

    gReceptionList_PresetID[ReceptionListLine] = 0x21;
    gReceptionList_FmRegCode[ReceptionListLine] = 0x49;
    gReceptionList_Category[ReceptionListLine] = AUDIO_RECEPTIONLIST_COLLEGE;
    strncpy( gReceptionList_Name[ReceptionListLine], "Name_4", AUDIO_RECEPTIONLIST_NAME_LENGTH);
    strncpy( gReceptionList_Frequency[ReceptionListLine], "Frequency_4", AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH);
    ReceptionListLine++;

    //entry 5
    gReceptionList_ListEntryValidInformation[ReceptionListLine] = TRUE;
    gReceptionList_Pos[ReceptionListLine] = 0x3664;
    gReceptionList_Type[ReceptionListLine] = AUDIO_RECEPTIONLIST_FLATSLIST_0x04;

    gReceptionList_Attributes_available_Bit0[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_TP_Bit5[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] = TRUE;
    gReceptionList_Attributes[ReceptionListLine] = gReceptionList_Attributes_available_Bit0[ReceptionListLine] + ( gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] * 0x02 ) + ( gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] * 0x04 ) + ( gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] * 0x08 ) + ( gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] * 0x10 ) + ( gReceptionList_Attributes_TP_Bit5[ReceptionListLine] * 0x20 ) + ( gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] * 0x40 ) + ( gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] * 0x80 + ( gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] * 0x100 ) + ( gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] * 0x200 ) );

    gReceptionList_PresetID[ReceptionListLine] = 0x16;
    gReceptionList_FmRegCode[ReceptionListLine] = 0x69;
    gReceptionList_Category[ReceptionListLine] = AUDIO_RECEPTIONLIST_TRAVEL;
    strncpy( gReceptionList_Name[ReceptionListLine], "Name_5", AUDIO_RECEPTIONLIST_NAME_LENGTH);
    strncpy( gReceptionList_Frequency[ReceptionListLine], "Frequency_5", AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH);
    ReceptionListLine++;

    //entry 6
    gReceptionList_ListEntryValidInformation[ReceptionListLine] = TRUE;
    gReceptionList_Pos[ReceptionListLine] = 0x32;
    gReceptionList_Type[ReceptionListLine] = AUDIO_RECEPTIONLIST_SECONDARYANDPRIMARYSERVICE;

    gReceptionList_Attributes_available_Bit0[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_TP_Bit5[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] = FALSE;
    gReceptionList_Attributes[ReceptionListLine] = gReceptionList_Attributes_available_Bit0[ReceptionListLine] + ( gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] * 0x02 ) + ( gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] * 0x04 ) + ( gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] * 0x08 ) + ( gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] * 0x10 ) + ( gReceptionList_Attributes_TP_Bit5[ReceptionListLine] * 0x20 ) + ( gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] * 0x40 ) + ( gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] * 0x80 + ( gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] * 0x100 ) + ( gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] * 0x200 ) );

    gReceptionList_PresetID[ReceptionListLine] = 0x59;
    gReceptionList_FmRegCode[ReceptionListLine] = 0x21;
    gReceptionList_Category[ReceptionListLine] = AUDIO_RECEPTIONLIST_SERIOUSCLASSICAL;
    strncpy( gReceptionList_Name[ReceptionListLine], "Name_6", AUDIO_RECEPTIONLIST_NAME_LENGTH);
    strncpy( gReceptionList_Frequency[ReceptionListLine], "Frequency_6", AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH);
    ReceptionListLine++;

    //entry 7
    gReceptionList_ListEntryValidInformation[ReceptionListLine] = TRUE;
    gReceptionList_Pos[ReceptionListLine] = 0x91;
    gReceptionList_Type[ReceptionListLine] = AUDIO_RECEPTIONLIST_ENSEMBLES;

    gReceptionList_Attributes_available_Bit0[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_TP_Bit5[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] = TRUE;
    gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] = FALSE;
    gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] = TRUE;
    gReceptionList_Attributes[ReceptionListLine] = gReceptionList_Attributes_available_Bit0[ReceptionListLine] + ( gReceptionList_Attributes_DVB_Bit1[ReceptionListLine] * 0x02 ) + ( gReceptionList_Attributes_DAB_Bit2[ReceptionListLine] * 0x04 ) + ( gReceptionList_Attributes_DAB_Bit3[ReceptionListLine] * 0x08 ) + ( gReceptionList_Attributes_DAB_Bit4[ReceptionListLine] * 0x10 ) + ( gReceptionList_Attributes_TP_Bit5[ReceptionListLine] * 0x20 ) + ( gReceptionList_Attributes_TMC_Bit6[ReceptionListLine] * 0x40 ) + ( gReceptionList_Attributes_SDARS_Bit7[ReceptionListLine] * 0x80 + ( gReceptionList_Attributes_DABServ_Bit8[ReceptionListLine] * 0x100 ) + ( gReceptionList_Attributes_FMOnlineRadio_Bit9[ReceptionListLine] * 0x200 ) );

    gReceptionList_PresetID[ReceptionListLine] = 0x48;
    gReceptionList_FmRegCode[ReceptionListLine] = 0x82;
    gReceptionList_Category[ReceptionListLine] = AUDIO_RECEPTIONLIST_FINANCE;
    strncpy( gReceptionList_Name[ReceptionListLine], "Name_7", AUDIO_RECEPTIONLIST_NAME_LENGTH);
    strncpy( gReceptionList_Frequency[ReceptionListLine], "Frequency_7", AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH);
    ReceptionListLine++;

    gReceptionList_sum = ReceptionListLine;
    gReceptionList_TotalNumListElements = gReceptionList_sum;

    if( boTraceStatus_ON )
    {
        writelineEx( gBAP_Trace, 0, "Reception: " );
        writelineEx( gBAP_Trace, 0, "Reception: *******Default ReceptionList_Array*******" );
        writelineEx( gBAP_Trace, 0, "Reception: " );

        for( i = 0; i < gReceptionList_sum; i++ )
        {
            writelineEx( gBAP_Trace, 0, "Reception: *******Element %d*******", i);

            writelineEx( gBAP_Trace, 0, "Reception: Pos[%d]: 0x%x", i, gReceptionList_Pos[i] );

            writelineEx( gBAP_Trace, 0, "Reception: Type[%d]: 0x%x", i, gReceptionList_Type[i] );
            if( gReceptionList_Type[i] < 0x0B)
                writeEx( gBAP_Trace, 0, "Reception:  -> '%s'", gReceptionList_Type_s[gReceptionList_Type[i]] );
            else
                writeEx( gBAP_Trace, 0, "Reception:  -> '%s'", gstring_reserved );

            if( gReceptionList_Attributes[i] & 0x01 )
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit0[%d]: 'available'", i);
            else
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit0[%d]: 'not available'", i);

            if( gReceptionList_Attributes[i] & 0x02 )
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit1[%d]: 'DVB service corrupted'", i);
            else
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit1[%d]: 'service OK'", i);

            if( gReceptionList_Attributes[i] & 0x04 )
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit2[%d]: 'DAB primary service contains secondary service(s )'", i);
            else
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit2[%d]: 'DAB primary service contains no secondary service(s )'", i);

            if( gReceptionList_Attributes[i] & 0x08 )
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit3[%d]: 'DAB primary service corrupted'", i);
            else
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit3[%d]: 'service OK'", i);

            if( gReceptionList_Attributes[i] & 0x10 )
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit4[%d]: 'DAB service FM linked'", i);
            else
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit4[%d]: 'DAB service not linked to FM'", i);

            if( gReceptionList_Attributes[i] & 0x20 )
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit5[%d]: 'TP available/supported by station'", i);
            else
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit5[%d]: 'TP not available/not supported by station'", i);

            if( gReceptionList_Attributes[i] & 0x40 )
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit6[%d]: 'TMC available/supported by station'", i);
            else
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit6[%d]: 'TMC not supported/not available by station'", i);

            if( gReceptionList_Attributes[i] & 0x80 )
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit7[%d]: 'SDARS station not subscribed'", i);
            else
                writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit7[%d]: 'SDARS station subscribed or not an SDARS station'", i);

            writelineEx( gBAP_Trace, 0, "Reception: PresetID[%d]: 0x%x", i, gReceptionList_PresetID[i] );
            writelineEx( gBAP_Trace, 0, "Reception: FmREG_Code[%d]: 0x%x", i, gReceptionList_FmRegCode[i] );

            writelineEx( gBAP_Trace, 0, "Reception: Category[%d]: 0x%x", i, gReceptionList_Category[i] );
            if( gReceptionList_Category[i] < 0x38 )
                writeEx( gBAP_Trace, 0, "Reception:  -> '%s'", gReceptionList_Category_s[gReceptionList_Category[i]] );
            else
                writeEx( gBAP_Trace, 0, "Reception:  -> '%s'", gstring_reserved );

            writelineEx( gBAP_Trace, 0, "Reception: Name[%d]: '%s'", i, gReceptionList_Name[i] );
            writelineEx( gBAP_Trace, 0, "Reception: Frequency[%d]: '%s'", i, gReceptionList_Frequency[i] );
            writelineEx( gBAP_Trace, 0, "Reception: " );
        }
        writelineEx( gBAP_Trace, 0, "Reception: Anzahl der Listenelemente: %d", gReceptionList_sum);
    }
    putvalue( env_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements );

    gAudioSD_CSIhandle_FSGhandle = gReceptionList_Pos[0];
    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
     //IssueList #72
    gAudioSD_CSIhandle_FSGhandle_absolutePos = 0x01;
    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
}

ReceptionList_init_CSV() //Byte & file selection
{
    dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, current_CSV_line = 0, count1 = 0, count2 = 0;
    char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
    byte ReceptionListLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
    char ReceptionList_Pos_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8 ) code in the *.csv
    char ReceptionList_Type_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];       //help value ->"Type" is stored in the ASCII(UTF-8 ) code in the *.csv
    char ReceptionList_Attributes_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Attributes" is stored in the ASCII(UTF-8 ) code in the *.csv
    char ReceptionList_PresetID_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"PresetID" is stored in the ASCII(UTF-8 ) code in the *.csv
    char ReceptionList_FmRegCode_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];  //help value ->"FmREGCode" is stored in the ASCII(UTF-8 ) code in the *.csv
    char ReceptionList_Category_string[AUDIO_RECEPTIONLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Category" is stored in the ASCII(UTF-8 ) code in the *.csv

    if( getvalue( env_AudioSD_RL_DataSource ) == AUDIO_EXTERNAL_LIST ) //output data in write window "FSGReceptionList"
    {
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: *******External ReceptionList*******" );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: " );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: **********************Start load new ReceptionList**********************" );

        //clear
        for( j = 0; j < AUDIO_RECEPTIONLIST_ENTRIES; j++ )
        {
            gReceptionList_Pos[j]                       = 0;
            gReceptionList_Type[j]                      = 0;

            gReceptionList_Attributes_available_Bit0[j]     = 0;
            gReceptionList_Attributes_DVB_Bit1[j]           = 0;
            gReceptionList_Attributes_DAB_Bit2[j]           = 0;
            gReceptionList_Attributes_DAB_Bit3[j]           = 0;
            gReceptionList_Attributes_DAB_Bit4[j]           = 0;
            gReceptionList_Attributes_TP_Bit5[j]            = 0;
            gReceptionList_Attributes_TMC_Bit6[j]           = 0;
            gReceptionList_Attributes_SDARS_Bit7[j]         = 0;
            gReceptionList_Attributes_DABServ_Bit8[j]       = 0;
            gReceptionList_Attributes_FMOnlineRadio_Bit9[j] = 0;
            gReceptionList_Attributes[j]                    = 0;

            gReceptionList_PresetID[j]                      = 0;
            gReceptionList_FmRegCode[j]                     = 0;
            gReceptionList_Category[j]                      = 0;

            gReceptionList_ListEntryValidInformation[j]     = 0;

            for( i = 0; i < AUDIO_RECEPTIONLIST_NAME_LENGTH; i++ )
                gReceptionList_Name[j][i] = 0;

            for( i = 0; i < AUDIO_RECEPTIONLIST_FREQUENCY_LENGTH; i++ )
                gReceptionList_Frequency[j][i] = 0;
        }

        for( i = 0; i < AUDIO_FILENAME_SIZE; i++ ) //clear "filename"
            gReceptionList_CSV_filename[i] = 0;

        for( j = 0; j < AUDIO_RECEPTIONLIST_ENTRIES; j++ ) //clear "buffer"
        {
            buffer_string[j]    = 0;
            buffer_byte[j]      = 0;

            for( i = 0; i < AUDIO_TEXTLENGTH; i++ ) //clear help value
            {
                ReceptionList_Pos_string[j][i]          = 0;
                ReceptionList_Type_string[j][i]         = 0;
                ReceptionList_Attributes_string[j][i]   = 0;
                ReceptionList_PresetID_string[j][i]     = 0;
                ReceptionList_FmRegCode_string[j][i]    = 0;
                ReceptionList_Category_string[j][i]     = 0;
            }
        }

        i = 0; j = 0; ReceptionListLine = 0; current_CSV_line = 0; //reset values


        getvalue( env_AudioSD_RL_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel

//write( "complete path *.csv: %s", Path_CSV); //debug

i = 0;

        while ( Path_CSV[i] != 0 ) //scan "path"
        {
            if( Path_CSV[i] == 0x5C) //count "/" to seperate later "path" & "filename"
                count1++;

            //write( "Path[%d] of *.csv: %x",i, Path_CSV[i] ); //debug
            i++;
        }

        i = 0; j = 0; //reset values

        while ( Path_CSV[i] != 0 ) //seperate "path" and "filename"
        {
            if( count2==count1 ) //get filename after last "\"
            {
                gReceptionList_CSV_filename[j] = Path_CSV[i];
                j++;

                Path_CSV[i] = 0;
            }

            if( Path_CSV[i] == 0x5C) //count "\" to get filename after last "\"
                count2++;

            i++;
        }

        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: path of *.csv: %s", Path_CSV);        //output file path

        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: filename of *.csv: '%s'", gReceptionList_CSV_filename );  //output filename

        putvalue( env_AudioSD_RL_DataSource_file, gReceptionList_CSV_filename ); //output current loaded *.csv-file on panel

        setFilePath( Path_CSV, 0 ); //set path for *.csv file

        CSVfileHandle =openFileRead( gReceptionList_CSV_filename,1 ); //open *.csv ( binary-mode ->get the ASCII/UTF-8 code )

        if( CSVfileHandle != 0 ) //*.csv file access successful
        {
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: Dateizugriff auf '%s' erfolgreich", gReceptionList_CSV_filename );    //output result


            putvalue( env_AudioSD_RL_DataSource_result, "successful" );   //output result on panel

            Num_of_csv_byte = fileGetBinaryBlock( buffer_byte, elcount( buffer_byte ), CSVfileHandle );//get data from *.csv and store the total number of byte in *.csv-file

            for( i = 0; i <Num_of_csv_byte; i++ ) //copy data into "ReceptionList"
            {
                if( buffer_byte[i] != 0x3B) //read data if no ";" is detected
                {
                    if( buffer_byte[i] == 0x0D && buffer_byte[i + 1] == 0x0A) //nextline in *.csv (next "record element" in ReceptionList ) -> "LF" and "CR" detected -> copy ( transform string -> long ) data from help values in global values
                    {
                        if( current_CSV_line > 0 && ReceptionListLine < AUDIO_RECEPTIONLIST_ENTRIES ) // ignore first line in *.csv file
                        {
                            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: " );
                            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: *******Element %d*******", ReceptionListLine );

                            //transform 'string' to 'long' for "POS", "Type", "Attributes", "PresetID", "FmREG_CODE" and Category
                            gReceptionList_Pos[ReceptionListLine]           =atol( ReceptionList_Pos_string[ReceptionListLine] );
                            gReceptionList_Type[ReceptionListLine]          =atol( ReceptionList_Type_string[ReceptionListLine] );
                            gReceptionList_Attributes[ReceptionListLine]    =atol( ReceptionList_Attributes_string[ReceptionListLine] );
                            gReceptionList_PresetID[ReceptionListLine]      =atol( ReceptionList_PresetID_string[ReceptionListLine] );
                            gReceptionList_FmRegCode[ReceptionListLine]     =atol( ReceptionList_FmRegCode_string[ReceptionListLine] );
                            gReceptionList_Category[ReceptionListLine]      =atol( ReceptionList_Category_string[ReceptionListLine] );

                            if( boTraceStatus_ON )
                            {
                                writelineEx( gBAP_Trace, 0, "Reception: Pos[%d]: 0x%x", ReceptionListLine, gReceptionList_Pos[ReceptionListLine] );

                                writelineEx( gBAP_Trace, 0, "Reception: Type[%d]: 0x%x", ReceptionListLine, gReceptionList_Type[ReceptionListLine] );
                                if( gReceptionList_Type[ReceptionListLine] < 0x0B)
                                    writeEx( gBAP_Trace, 0, "Reception:  -> '%s'", gReceptionList_Type_s[gReceptionList_Type[ReceptionListLine]] );
                                else
                                    writeEx( gBAP_Trace, 0, "Reception:  -> '%s'", gstring_reserved );

                                writelineEx( gBAP_Trace, 0, "Reception: Attributes[%d]: 0x%x", ReceptionListLine, gReceptionList_Attributes[ReceptionListLine] );

                                if( gReceptionList_Attributes[ReceptionListLine] & 0x01 )
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit0[%d]: 'available'", ReceptionListLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit0[%d]: 'not available'", ReceptionListLine );

                                if( gReceptionList_Attributes[ReceptionListLine] & 0x02 )
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit1[%d]: 'DVB service corrupted'", ReceptionListLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit1[%d]: 'service OK'", ReceptionListLine );

                                if( gReceptionList_Attributes[ReceptionListLine] & 0x04 )
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit2[%d]: 'DAB primary service contains secondary service(s )'", ReceptionListLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit2[%d]: 'DAB primary service contains no secondary service(s )'", ReceptionListLine );

                                if( gReceptionList_Attributes[ReceptionListLine] & 0x08 )
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit3[%d]: 'DAB primary service corrupted'", ReceptionListLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit3[%d]: 'service OK'", ReceptionListLine );

                                if( gReceptionList_Attributes[ReceptionListLine] & 0x10 )
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit4[%d]: 'DAB service FM linked'", ReceptionListLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit4[%d]: 'DAB service not linked to FM'", ReceptionListLine );

                                if( gReceptionList_Attributes[ReceptionListLine] & 0x20 )
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit5[%d]: 'TP available/supported by station'", ReceptionListLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit5[%d]: 'TP not available/not supported by station'", ReceptionListLine );

                                if( gReceptionList_Attributes[ReceptionListLine] & 0x40 )
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit6[%d]: 'TMC available/supported by station'", ReceptionListLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit6[%d]: 'TMC not supported/not available by station'", ReceptionListLine );

                                if( gReceptionList_Attributes[ReceptionListLine] & 0x80 )
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit7[%d]: 'SDARS station not subscribed'", ReceptionListLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "Reception: Attribues_Bit7[%d]: 'SDARS station subscribed or not an SDARS station'", ReceptionListLine );
                                writelineEx( gBAP_Trace, 0, "Reception: PresetID[%d]: 0x%x", ReceptionListLine, gReceptionList_PresetID[ReceptionListLine] );
                                writelineEx( gBAP_Trace, 0, "Reception: FmREG_Code[%d]: 0x%x", ReceptionListLine, gReceptionList_FmRegCode[ReceptionListLine] );
                                writelineEx( gBAP_Trace, 0, "Reception: Category[%d]: 0x%x", ReceptionListLine, gReceptionList_Category[ReceptionListLine] );
                                if( gReceptionList_Category[ReceptionListLine] < 0x38 )
                                    writeEx( gBAP_Trace, 0, "Reception:  -> '%s'", gReceptionList_Category_s[gReceptionList_Category[ReceptionListLine]] );
                                else
                                    writeEx( gBAP_Trace, 0, "Reception:  -> '%s'", gstring_reserved );
                                writelineEx( gBAP_Trace, 0, "Reception: Name[%d]: %s", ReceptionListLine, gReceptionList_Name[ReceptionListLine] );
                                writelineEx( gBAP_Trace, 0, "Reception: Frequency[%d]: %s", ReceptionListLine, gReceptionList_Frequency[ReceptionListLine] );
                            }
                            gReceptionList_ListEntryValidInformation[ReceptionListLine]  = TRUE;

                            ReceptionListLine++; // -> next line in *.csv (next record element )
                        }

                        current_CSV_line++; //next line in *.csv file
                        element = 0; //start at 'POS' ( first record element of "array data" )
                        j = 0; //reset value
                    }

                    else if( current_CSV_line> 0 && ReceptionListLine < AUDIO_RECEPTIONLIST_ENTRIES) //copy data from "buffer_byte" ( data from *.csv file ) in help values and "name" until end of line is not detected
                    {
                        switch(  element )
                        {
                            case 0: //POS
                                    ReceptionList_Pos_string[ReceptionListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //Type
                                    ReceptionList_Type_string[ReceptionListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 2: //Attributes
                                    ReceptionList_Attributes_string[ReceptionListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 3: //PresetID
                                    ReceptionList_PresetID_string[ReceptionListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 4: //FmREG_Code
                                    ReceptionList_FmRegCode_string[ReceptionListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 5: //Category
                                    ReceptionList_Category_string[ReceptionListLine][j] =buffer_byte[i];
                                    j++;
                             break;
                            case 6: //Name
                                    gReceptionList_Name[ReceptionListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 7: //Frequency
                                    gReceptionList_Frequency[ReceptionListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            default:
                             break;
                        }
                    }
                }

                else  // ";" is detected ->next record element of "array data"
                {
                    element++;
                    j = 0; //reset value
                }

            }
            // - if condition
            if( getValue( env_AudioSD_RL_insert_UPD_button ) == 0x00 )
            gReceptionList_TotalNumListElements = gReceptionList_sum =ReceptionListLine; //get "total number of list elements"

            putvalue( env_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements );

            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: " );
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: Anzahl der Listenelemente: %d", gReceptionList_sum); //output total number of list elements
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: " );
            if( fileClose( CSVfileHandle ) != 0 ) //close *.csv file
                { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: Datei '%s' geschlossen", gReceptionList_CSV_filename ); } //output result 
            else
                { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: Fehler beim Schlieen der Datei '%s'", gReceptionList_CSV_filename ); }//output result
        }
        else //*.csv file access not successful
        {
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Reception: Fehler beim Dateizugriff auf '%s'", gReceptionList_CSV_filename ); //output result
            putvalue( env_AudioSD_RL_DataSource_result, "not successful" ); //output result
        }

        gAudioSD_CSIhandle_FSGhandle = gReceptionList_Pos[0];
        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );

        gAudioSD_CSIhandle_FSGhandle_absolutePos = 0x01;
       putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );

         for( i = 0; i < gReceptionList_TotalNumListElements; i++ )
        gReceptionList_Pos_insDel[i] [0] = gReceptionList_Pos[i];

        if( getValue( env_AudioSD_RL_insert_UPD_button ) == 0x00 )
        {
        for( i = 0; i < gReceptionList_TotalNumListElements; i++ )
        gReceptionList_Pos_insDel[i] [2] = i + 1;

        gRL_totalDELctr = 0;
        }
    }
}

on envVar env_AudioSD_RL_CA
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        if( getvalue( env_AudioSD_RL_AH_start ) >255 && getvalue( env_AudioSD_RL_AH_IS) == 0 ) // check if 8 or 16 bit
            putvalue( env_AudioSD_RL_AH_IS,1 );

        //get data from Panel
        gReceptionList_ElementType  = getvalue( env_AudioSD_RL_ElementType );
        gReceptionList_ParentID     = getvalue( env_AudioSD_RL_ParentID);

        recordaddress   = getvalue( env_AudioSD_RL_AH_RA);
        shift           = getvalue( env_AudioSD_RL_AH_shift );
        direction       = getvalue( env_AudioSD_RL_AH_dir );
        transmitpos     = getvalue( env_AudioSD_RL_AH_POS);
        indexsize       = getvalue( env_AudioSD_RL_AH_IS);
        startelement    = getvalue( env_AudioSD_RL_AH_start );
        elements        = getvalue( env_AudioSD_RL_AH_elements );

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;


        /***Startelement = 0***/
        if( getvalue( env_AudioSD_RL_CA_switch ) ) //ArrayData
        {
            if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
            {
                if( FORWARD==direction )  //forward-start
                {
                    valid_startelement = 0;

                    if( AUDIO_RECEPTIONLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
                            {
                                if( 0 != gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_RECEPTIONLIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                    }
                    else    //2. number of requested elements < elements in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < elements; i++ )
                            {
                                if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                i = AUDIO_RECEPTIONLIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }

                    }
                }                                                               //forward ends

                else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                {
                    //searching for valid startelement
                    for( i = ( AUDIO_RECEPTIONLIST_ENTRIES-1 ); i>= 0; i--)
                    {
                        if( 0!= gReceptionList_ListEntryValidInformation[i] )        //found valid startelement
                        {
                            valid_startelement = i;
                            i = 0;
                        }
                    }

                    //searching for valid elements
                    if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                    else if( 0 ==valid_startelement )
                        valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                        {
                            if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                            if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                               //backward-end
            }                                                                   //startelement == 0 -end

            /***Startelement!= 0***/
            else                                                                //searching for Startelement-ID
            {
                //searching for valid startelement
                for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
                {
                    if( gReceptionList_Pos[i] == startelement )                        //found a valid element
                    {
                        if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                        {
                            if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                valid_startelement = i + 1-2* direction;

                            else if( i == 0 && BACKWARD==direction )
                                valid_startelement = gReceptionList_sum;     //valid element is last element in Array

                            else if( i == 0 && FORWARD==direction )
                                valid_startelement = 0;                          //valid element is first element in Array
                        }

                        else
                            valid_startelement = i;                              //found element is valid_startelement

                        i = AUDIO_RECEPTIONLIST_ENTRIES;
                    }
                    else
                        valid_startelement = 0xff;
                }

                if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else                                                                //found valid entry for startelement in array
                {
                    //verify number of valid elements
                    if( BACKWARD==direction )                                            //backward-start
                    {
                        if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                            valid_elements= 1;

                        else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                        {
                            for( i =valid_startelement; i>= 0; i--)
                            {
                                if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                        else                                                        //enougth array-elements available
                        {
                            for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                            {
                                if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                    }                                                                //backward-end
                    else                                                            //forward-start
                    {
                        if((valid_startelement+elements )>= AUDIO_RECEPTIONLIST_ENTRIES)
                        {
                            for( i =valid_startelement; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
                            {
                                if( 0!= gReceptionList_Pos[i] )                            //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_RECEPTIONLIST_ENTRIES;
                            }
                        }
                        else
                        {
                            for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                            {
                                if( 0!= gReceptionList_Pos[i] )                            //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_RECEPTIONLIST_ENTRIES;
                            }
                        }
                    }
                }
            }
            putvalue( env_AudioSD_RL_AH_elements, valid_elements );

            //send ChangedArray
        //MR 63667 11.07.2014 -TNLE with SA-button
            ReceptionList_Request( Changed_REQ, 0, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
        }
        else
        {
            //send ChangedArray
        //MR 63667 11.07.2014 -TNLE with SA-button
            ReceptionList_Request( Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0 );
        }
    }
}

on envVar env_AudioSD_RL_DataSource
{
    if( getvalue( this ) == AUDIO_DEFAULT_LIST )
    {
        ReceptionList_init_static();
        putvalue( env_AudioSD_RL_DataSource_file, empty_string );
        putvalue( env_AudioSD_RL_DataSource_result, empty_string );
    }
}

on envVar env_AudioSD_RL_reload //load external ReceptionList from *.csv
{
//IssueList #76 - MR49870 : ReceptionList
byte i;


    if( getvalue( this ) && getvalue( env_AudioSD_RL_DataSource ) == AUDIO_EXTERNAL_LIST )

        {
         if( getValue( env_AudioSD_RL_insert_UPD_button )== 0x00 )
         {
             for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
             {
              gReceptionList_Pos_insDel[i] [0] = 0x00;   //POS value
              gReceptionList_Pos_insDel[i] [1] = 0x00;   //tagging of deleted elements
              gReceptionList_Pos_insDel[i] [2] = 0x00;   //index
              }
        }

        ReceptionList_init_CSV();
            //IssueList #76 - MR49870 : ReceptionList
             if( gAudioSD_PowerOnOff == POWER_ON )
            {
                gRL_loadReloadFlg = 0x00;
                if( getValue( env_AudioSD_RL_insert_UPD_button )== 0x00 )
                {
                    //MR 63332 #3   02.07.2014
                    //gReceptionList_TotalNumListElements = getValue( env_AudioSD_RL_TotalNumLE );

                    gRL_CSVtotalElem = gReceptionList_TotalNumListElements;
                    //Clear insert/delete panel
                    putValue( env_AudioSD_RL_delete_start, 0 );
                    putValue( env_AudioSD_RL_insert_start, 0 );
                    putValue( env_AudioSD_RL_insert_start, 0 );
                    putValue( env_AudioSD_RL_insert_successor, 0 );
                    putValue( env_AudioSD_RL_delete_ErrHandler, 1 );
                    putValue( env_AudioSD_RL_delete_Message, empty_string );

                    putValue( env_AudioSD_RL_insert_ErrHandler, 1 );
                    putValue( env_AudioSD_RL_Insert_Message, empty_string );

                    gRL_loadReloadFlg = 0x01;           //for Indexing after Insert

                    gAudioSD_CSIhandle_FSGhandle               = 0x1;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos   = 0x1;


                 }
            //Clearing send buffer
            for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
            {
            gReceptionList_Send[i][0] = 0;   //POS value
            gReceptionList_Send[i][1] = 0;   //index
            }
          }// POWER ON

        }// if External list


    else if( getvalue( env_AudioSD_RL_DataSource ) != AUDIO_EXTERNAL_LIST )
        putvalue( env_AudioSD_RL_DataSource_result, "not successful, select 'external *.csv'" );
}

on envVar env_AudioSD_RL_StatusArray
{
    word tnle, requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i, transSuppression;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;
    transSuppression        = getvalue( env_AudioSD_RL_noStatusArray );

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        if( getvalue( env_AudioSD_RL_AH_start ) >255 && getvalue( env_AudioSD_RL_AH_IS) == 0 ) // check if 8 or 16 bit
            putvalue( env_AudioSD_RL_AH_IS,1 );

        //get data from Panel
        gReceptionList_ASGID                = getvalue( env_AudioSD_RL_ASGID);
        gReceptionList_TAID                 = getvalue( env_AudioSD_RL_TAID);
        gReceptionList_ElementType          = getvalue( env_AudioSD_RL_ElementType );
        gReceptionList_ParentID             = getvalue( env_AudioSD_RL_ParentID);

        //MR 63332 #3   02.07.2014
        //gReceptionList_TotalNumListElements  = getvalue( env_AudioSD_RL_TotalNumLE );

        //MR 63667 11.07.2014 -TNLE with SA-button
        tnle = getvalue( env_AudioSD_RL_TotalNumLE );

        recordaddress   = getvalue( env_AudioSD_RL_AH_RA);
        shift           = getvalue( env_AudioSD_RL_AH_shift );
        direction       = getvalue( env_AudioSD_RL_AH_dir );
        transmitpos     = getvalue( env_AudioSD_RL_AH_POS);
        indexsize       = getvalue( env_AudioSD_RL_AH_IS);
        startelement    = getvalue( env_AudioSD_RL_AH_start );
        elements        = getvalue( env_AudioSD_RL_AH_elements );

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;


        /***Startelement = 0***/
        if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
        {
            if( FORWARD==direction )  //forward-start
            {
                valid_startelement = 0;

                if( AUDIO_RECEPTIONLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                {
                    if( shift == FALSE )
                    {
                        for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
                        {
                            if( 0 != gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_RECEPTIONLIST_ENTRIES;
                        }
                    }
                    else if( shift == TRUE )
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if( shift == FALSE )
                    {
                        for( i = 0; i < elements; i++ )
                        {
                            if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i = AUDIO_RECEPTIONLIST_ENTRIES;
                        }
                    }
                    else if( shift == TRUE )
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }

                }
            }                                                               //forward ends

            else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
            {
                //searching for valid startelement
                for( i = ( AUDIO_RECEPTIONLIST_ENTRIES-1 ); i>= 0; i--)
                {
                    if( 0!= gReceptionList_ListEntryValidInformation[i] )        //found valid startelement
                    {
                        valid_startelement = i;
                        i = 0;
                    }
                }

                //searching for valid elements
                if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else if( 0 ==valid_startelement )
                    valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for( i =valid_startelement; i>= 0; i--)
                    {
                        if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                    {
                        if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
            }                                                               //backward-end
        }                                                                   //startelement == 0 -end

        /***Startelement!= 0***/
        else                                                                //searching for Startelement-ID
        {
            //searching for valid startelement
            for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
            {
                if( gReceptionList_Pos[i] == startelement )                        //found a valid element
                {
                    if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                    {
                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement = i + 1-2* direction;

                        else if( i == 0 && BACKWARD==direction )
                            valid_startelement = gReceptionList_sum;     //valid element is last element in Array

                        else if( i == 0 && FORWARD==direction )
                            valid_startelement = 0;                          //valid element is first element in Array
                    }

                    else
                        valid_startelement = i;                              //found element is valid_startelement

                    i = AUDIO_RECEPTIONLIST_ENTRIES;
                }
                else
                    valid_startelement = 0xff;
            }

            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
            {
                valid_startelement  = startelement;
                valid_elements      = 0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if( BACKWARD==direction )                                            //backward-start
                {
                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                        valid_elements= 1;

                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                        {
                            if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                            if( 0!= gReceptionList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements )>= AUDIO_RECEPTIONLIST_ENTRIES)
                    {
                        for( i =valid_startelement; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
                        {
                            if( 0!= gReceptionList_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_RECEPTIONLIST_ENTRIES;
                        }
                    }
                    else
                    {
                        for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                        {
                            if( 0!= gReceptionList_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_RECEPTIONLIST_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue( env_AudioSD_RL_AH_elements, valid_elements );

        //send StatusArray
    //MR 63667
        if(!transSuppression )
            ReceptionList_Request( Data_REQ, tnle, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
    }
}

SourceList_init_static()
{
    byte j, i, SourceListLine;

    //clear
    SourceListLine = 0;
    gSourceList_sum = 0;

    for( j = 0; j < AUDIO_SOURCELIST_ENTRIES; j++ )
    {
        gSourceList_Pos[j] = 0;
        gSourceList_SourceType[j] = 0;
        gSourceList_InstanceID[j] = 0;
        gSourceList_MediaType[j] = 0;

        gSourceList_Attributes_BuiltIn_Bit0[j] = 0;
        gSourceList_Attributes_MediaError_Bit1[j] = 0;
        gSourceList_Attributes_MediaPlay_Bit2[j] = 0;
        gSourceList_Attributes_MediaRead_Bit3[j] = 0;
        gSourceList_Attributes_MediaLoad_Bit4[j] = 0;
        gSourceList_Attributes_ImportRun_Bit5[j] = 0;
        gSourceList_Attributes_MediaSupp_Bit6[j] = 0;
        gSourceList_Attributes[j] = 0;

        gSourceList_ListEntryValidInformation[j] = 0;

        for( i = 0; i < AUDIO_SOURCELIST_NAME_LENGTH; i++ )
            gSourceList_Name[j][i] = 0;
    }

    //entry 0
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0x7214;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_FLASH;
    gSourceList_InstanceID[SourceListLine] = 5;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_RAW;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = TRUE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = TRUE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_0", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    //entry 1
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0x01;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_BLUERAY;
    gSourceList_InstanceID[SourceListLine] = 0;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_DVDVIDEO;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = FALSE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = FALSE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_1", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    //entry 2
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0x7513;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_BTRCP;
    gSourceList_InstanceID[SourceListLine] = 254;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_CDAUDIO;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = TRUE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = FALSE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_2", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    //entry 3
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0x67;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_JUKEBOX;
    gSourceList_InstanceID[SourceListLine] = 7;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_VIDEOBROADCAST;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = TRUE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = TRUE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_3", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    //entry 4
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0x9674;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_AMTI;
    gSourceList_InstanceID[SourceListLine] = 96;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_FILESYSTEM;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = FALSE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = TRUE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_4", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    //entry 5
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0x71;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_SDARSXM;
    gSourceList_InstanceID[SourceListLine] = 3;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_VIDEOBROADCAST;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = TRUE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = TRUE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_5", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    //entry 6
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0x40;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_SD;
    gSourceList_InstanceID[SourceListLine] = 41;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_DVDAUDIO;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = TRUE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = TRUE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_6", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    //entry 7
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0x5719;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_TV;
    gSourceList_InstanceID[SourceListLine] = 21;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_SOUNDBROADCAST;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = FALSE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = TRUE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_7", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    //entry 8
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0x6540;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_AMSW;
    gSourceList_InstanceID[SourceListLine] = 75;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_DVDVIDEO;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = TRUE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = TRUE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_8", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    //entry 9
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0x83;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_WLANMASSSTOR;
    gSourceList_InstanceID[SourceListLine] = 9;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_IPOD;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = FALSE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = TRUE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_9", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    //entry 10
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0xDAC3;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_CDC;
    gSourceList_InstanceID[SourceListLine] = 21;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_RCP;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = TRUE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = TRUE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_10", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    //entry 11
    gSourceList_ListEntryValidInformation[SourceListLine] = TRUE;
    gSourceList_Pos[SourceListLine] = 0xaffe;
    gSourceList_SourceType[SourceListLine] = AUDIO_SOURCELIST_ST_AUXIN_VIDEO_TV;
    gSourceList_InstanceID[SourceListLine] = 1;
    gSourceList_MediaType[SourceListLine] = AUDIO_SOURCELIST_MT_UNKNOWN;

    gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaError_Bit1[SourceListLine] = TRUE;
    gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaRead_Bit3[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] = FALSE;
    gSourceList_Attributes_ImportRun_Bit5[SourceListLine] = FALSE;
    gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] = TRUE;
    gSourceList_Attributes[SourceListLine] = gSourceList_Attributes_BuiltIn_Bit0[SourceListLine] + ( gSourceList_Attributes_MediaError_Bit1[SourceListLine] * 0x02 ) + ( gSourceList_Attributes_MediaPlay_Bit2[SourceListLine] * 0x04 ) + ( gSourceList_Attributes_MediaRead_Bit3[SourceListLine] * 0x08 ) + ( gSourceList_Attributes_MediaLoad_Bit4[SourceListLine] * 0x10 ) + ( gSourceList_Attributes_ImportRun_Bit5[SourceListLine] * 0x20 ) + ( gSourceList_Attributes_MediaSupp_Bit6[SourceListLine] * 0x40 );

    strncpy( gSourceList_Name[SourceListLine], "Name_11", AUDIO_SOURCELIST_NAME_LENGTH);
    SourceListLine++;

    gSourceList_sum = SourceListLine;
    gSourceList_TotalNumListElements = gSourceList_sum;
    if( boTraceStatus_ON ) 
    {
        //write Array in "write -window"
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: " );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: *******Default SourceList_Array*******" );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: " );

        for( i = 0; i < gSourceList_sum; i++ )
        {
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: *******Element %d*******", i);

            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Pos[%d]: 0x%x", i, gSourceList_Pos[i] );

            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: SourceType[%d]: 0x%x", i, gSourceList_SourceType[i] );
            if( gSourceList_SourceType[i] < 0x28 )
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gSourceList_SourceType_s[gSourceList_SourceType[i]] );
            else if( gSourceList_SourceType[i] == AUDIO_SOURCELIST_ST_UNKNOWN )
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gstring_unknown );
            else
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gstring_reserved );

            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: InstanceID[%d]: 0x%x", i, gSourceList_InstanceID[i] );

            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: MediaType[%d]: 0x%x", i, gSourceList_MediaType[i] );
            if( gSourceList_MediaType[i] < 0x0E )
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gSourceList_MediaType_s[gSourceList_MediaType[i]] );
            else if( gSourceList_MediaType[i] == AUDIO_SOURCELIST_MT_UNKNOWN )
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gstring_unknown );
            else
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gstring_reserved );

            if( gSourceList_Attributes[i] & 0x01 )
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit0[%d]: 'built-in and ready'", i);
            else
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit0[%d]: 'built-in but not ready'", i);

            if( gSourceList_Attributes[i] & 0x02 )
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit1[%d]: 'media/audio no error'", i);
            else
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit1[%d]: 'media/audio source error'", i);

            if( gSourceList_Attributes[i] & 0x04 )
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit2[%d]: 'media is playable'", i);
            else
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit2[%d]: 'media is not playable (no playable files )'", i);

            if( gSourceList_Attributes[i] & 0x08 )
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit3[%d]: 'media is readable'", i);
            else
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit3[%d]: 'media is not readable'", i);

            if( gSourceList_Attributes[i] & 0x10 )
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit4[%d]: 'media is not being loaded'", i);
            else
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit4[%d]: 'media is being loaded'", i);

            if( gSourceList_Attributes[i] & 0x20 )
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit5[%d]: 'no import running'", i);
            else
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit5[%d]: 'import running'", i);

            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Name[%d]: '%s'", i, gSourceList_Name[i] );
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: " );
        }

        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Anzahl der Listenelemente: %d", gSourceList_sum);
    }

    putvalue( env_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements );
}

byte SourceList_nextvalidLine( byte current_SourceListLine, byte direction )
{
    byte next_SourceListLine;
    int i;

    //init lokal variables
    next_SourceListLine = 0;
    i = 0;

    //search next "list entry"
    if( (( gSourceList_sum - 1 ) == current_SourceListLine && FORWARD == direction ) || ( 0 == current_SourceListLine && BACKWARD == direction ) )    //last-/fist-element of array reached
        next_SourceListLine = 0xFF;
    else
    {
        next_SourceListLine = current_SourceListLine + 1 - 2 * direction;       //increment or decrement array-line ( depends on direction );

        if( 0 == gSourceList_ListEntryValidInformation[next_SourceListLine] )    // check if next element is "valid"
            next_SourceListLine = 0xff;
    }

    return (next_SourceListLine );
}

on envVar env_AudioSD_SL_DataSource
{
    if( getvalue( this ) == AUDIO_DEFAULT_LIST )
    {
        SourceList_init_static();
        putvalue( env_AudioSD_SL_DataSource_file, empty_string );
        putvalue( env_AudioSD_SL_DataSource_result, empty_string );
    }
}

on envVar env_AudioSD_SL_reload //load external SourceList from *.csv
{
byte i;

    if( getvalue( this ) && getvalue( env_AudioSD_SL_DataSource ) == AUDIO_EXTERNAL_LIST )
        //IssueList #60
        {
         if( getValue( env_AudioSD_SL_insert_UPD_button )== 0x00 )
         {
             for( i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++ )
             {
              gSourceList_Pos_insDel[i] [0] = 0x00; //pos
              gSourceList_Pos_insDel[i] [1] = 0x00;  //insDel tag
              gSourceList_Pos_insDel[i] [2] = 0x00;  //sourceType
              }
        }

        SourceList_init_CSV();
            //IssueList #76 - MR49870 : SourceList
             if( gAudioSD_PowerOnOff == POWER_ON )
            {
                 if( getValue( env_AudioSD_SL_insert_UPD_button )== 0x00 )
                {
                //MR 63332 #3   02.07.2014
                //gSourceList_TotalNumListElements = getValue( env_AudioSD_SL_TotalNumLE );

                gSL_CSVtotalElem = gSourceList_TotalNumListElements;
                //Clear insert/delete panel
                putValue( env_AudioSD_SL_delete_start, 0 );
                putValue( env_AudioSD_SL_insert_start, 0 );
                putValue( env_AudioSD_SL_insert_start, 0 );
                putValue( env_AudioSD_SL_insert_successor, 0 );
                putValue( env_AudioSD_SL_delete_ErrHandler, 1 );
                putValue( env_AudioSD_SL_delete_Message, empty_string );

                putValue( env_AudioSD_SL_insert_ErrHandler, 1 );
                putValue( env_AudioSD_SL_Insert_Message, empty_string );

                gAudioSD_activeSource_SourceType            = ACTIVESOURCE_SOURCETYPE_FM;
                gAudioSD_activeSource_SourceList_Reference   = 1;
                putValue( env_AudioSD_activeSrc_SLRef, gAudioSD_activeSource_SourceList_Reference );
                }


                for( i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++ )
                {
                gSourceList_Send[i][0] = 0; //pos
                gSourceList_Send[i][1] = 0; //sourceType
                }

            }

           //IssueList #86
            putValue( env_AudioSD_activeSrc_SLRef, 0x1 );
            putValue( env_AudioSD_activeSrc_Type, gSourceList_SourceType[0] );
            putValue( env_AudioSD_activeSrc_number, gSourceList_InstanceID[0] );
            sourceListType();

        }

    else if( getvalue( env_AudioSD_SL_DataSource ) != AUDIO_EXTERNAL_LIST )
        putvalue( env_AudioSD_SL_DataSource_result, "not successful, select 'external *.csv'" );
}

on envVar env_AudioSD_SL_CA
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
byte mode, shift, direction, transmitpos, indexsize, recordaddress;
int i;

// Init local variables.
mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        if( getvalue( env_AudioSD_SL_AH_start ) >255 && getvalue( env_AudioSD_SL_AH_IS) == 0 ) // check if 8 or 16 bit
            putvalue( env_AudioSD_SL_AH_IS,1 );

        recordaddress   = getvalue( env_AudioSD_SL_AH_RA);
        shift           = getvalue( env_AudioSD_SL_AH_shift );
        direction       = getvalue( env_AudioSD_SL_AH_dir );
        transmitpos     = getvalue( env_AudioSD_SL_AH_POS);
        indexsize       = getvalue( env_AudioSD_SL_AH_IS);
        startelement    = getvalue( env_AudioSD_SL_AH_start );
        elements        = getvalue( env_AudioSD_SL_AH_elements );

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;


        /***Startelement = 0***/
        if( getvalue( env_AudioSD_SL_CA_switch ) ) //ArrayData
        {
            if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
            {
                if( FORWARD==direction )  //forward-start
                {
                    valid_startelement = 0;

                    if( AUDIO_SOURCELIST_ENTRIES <= elements ) //1. more elements requested, than in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++ )
                            {
                                if( 0 != gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_SOURCELIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                    }
                    else    //2. number of requested elements < elements in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < elements; i++ )
                            {
                                if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_SOURCELIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                    }
                }                                                               //forward ends

                else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                {
                    //searching for valid startelement
                    for( i = ( AUDIO_SOURCELIST_ENTRIES-1 ); i>= 0; i--)
                    {
                        if( 0!= gSourceList_ListEntryValidInformation[i] )        //found valid startelement
                        {
                            valid_startelement = i;
                            i = 0;
                        }
                    }

                    //searching for valid elements
                    if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                    else if( 0 ==valid_startelement )
                        valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                        {
                            if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                            if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                               //backward-end
            }                                                                   //startelement == 0 -end

            /***Startelement!= 0***/
            else                                                                //searching for Startelement-ID
            {
                //searching for valid startelement
                for( i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++ )
                {
                    if( gSourceList_Pos[i] == startelement )                        //found a valid element
                    {
                        if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                        {
                            if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                valid_startelement = i + 1-2* direction;

                            else if( i == 0 && BACKWARD==direction )
                                valid_startelement = gSourceList_sum;     //valid element is last element in Array

                            else if( i == 0 && FORWARD==direction )
                                valid_startelement = 0;                          //valid element is first element in Array
                        }

                        else
                            valid_startelement = i;                              //found element is valid_startelement

                        i = AUDIO_SOURCELIST_ENTRIES;
                    }
                    else
                        valid_startelement = 0xff;
                }

                if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else                                                                //found valid entry for startelement in array
                {
                    //verify number of valid elements
                    if( BACKWARD==direction )                                            //backward-start
                    {
                        if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                            valid_elements= 1;

                        else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                        {
                            for( i =valid_startelement; i>= 0; i--)
                            {
                                if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                        else                                                        //enougth array-elements available
                        {
                            for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                            {
                                if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                    }                                                                //backward-end
                    else                                                            //forward-start
                    {
                        if((valid_startelement+elements )>= AUDIO_SOURCELIST_ENTRIES)
                        {
                            for( i =valid_startelement; i < AUDIO_SOURCELIST_ENTRIES; i++ )
                            {
                                if( 0!= gSourceList_Pos[i] )                            //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_SOURCELIST_ENTRIES;
                            }
                        }
                        else
                        {
                            for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                            {
                                if( 0!= gSourceList_Pos[i] )                            //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_SOURCELIST_ENTRIES;
                            }
                        }
                    }
                }
            }
            putvalue( env_AudioSD_SL_AH_elements, valid_elements );

            //send ChangedArray
            SourceList_Request( Changed_REQ, 0, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
        }
        else
        {
            //send ChangedArray
            SourceList_Request( Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0 );
        }
    }
}

on envVar env_AudioSD_SL_StatusArray
{
    word tnle, requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i, transSuppression;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;
    transSuppression        = getvalue( env_AudioSD_SL_noStatusArray );

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        if( getvalue( env_AudioSD_SL_AH_start ) >255 && getvalue( env_AudioSD_SL_AH_IS) == 0 ) // check if 8 or 16 bit
            putvalue( env_AudioSD_SL_AH_IS,1 );

        //get data from Panel
        gSourceList_ASGID                = getvalue( env_AudioSD_SL_ASGID);
        gSourceList_TAID                 = getvalue( env_AudioSD_SL_TAID);

        //MR 63332 #3   02.07.2014
        //gSourceList_TotalNumListElements  = getvalue( env_AudioSD_SL_TotalNumLE );

        //MR 63667 11.07.2014 -TNLE with SA-button
        tnle = getvalue( env_AudioSD_SL_TotalNumLE );

        recordaddress   = getvalue( env_AudioSD_SL_AH_RA);
        shift           = getvalue( env_AudioSD_SL_AH_shift );
        direction       = getvalue( env_AudioSD_SL_AH_dir );
        transmitpos     = getvalue( env_AudioSD_SL_AH_POS);
        indexsize       = getvalue( env_AudioSD_SL_AH_IS);
        startelement    = getvalue( env_AudioSD_SL_AH_start );
        elements        = getvalue( env_AudioSD_SL_AH_elements );

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;


        /***Startelement = 0***/
        if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
        {
            if( FORWARD==direction )  //forward-start
            {
                valid_startelement = 0;

                if( AUDIO_SOURCELIST_ENTRIES <= elements ) //1. more elements requested, than in array
                {
                    if( shift == FALSE )
                    {
                        for( i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++ )
                        {
                            if( 0 != gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_SOURCELIST_ENTRIES;
                        }
                    }
                    else if( shift == TRUE )
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if( shift == FALSE )
                    {
                        for( i = 0; i < elements; i++ )
                        {
                            if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i = AUDIO_SOURCELIST_ENTRIES;
                        }
                    }
                    else if( shift == TRUE )
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }

                }
            }                                                               //forward ends

            else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
            {
                //searching for valid startelement
                for( i = ( AUDIO_SOURCELIST_ENTRIES-1 ); i>= 0; i--)
                {
                    if( 0!= gSourceList_ListEntryValidInformation[i] )        //found valid startelement
                    {
                        valid_startelement = i;
                        i = 0;
                    }
                }

                //searching for valid elements
                if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else if( 0 ==valid_startelement )
                    valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for( i =valid_startelement; i>= 0; i--)
                    {
                        if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                    {
                        if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
            }                                                               //backward-end
        }                                                                   //startelement == 0 -end

        /***Startelement!= 0***/
        else                                                                //searching for Startelement-ID
        {
            //searching for valid startelement
            for( i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++ )
            {
                if( gSourceList_Pos[i] == startelement )                        //found a valid element
                {
                    if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                    {
                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement = i + 1-2* direction;

                        else if( i == 0 && BACKWARD==direction )
                            valid_startelement = gSourceList_sum;     //valid element is last element in Array

                        else if( i == 0 && FORWARD==direction )
                            valid_startelement = 0;                          //valid element is first element in Array
                    }

                    else
                        valid_startelement = i;                              //found element is valid_startelement

                    i = AUDIO_SOURCELIST_ENTRIES;
                }
                else
                    valid_startelement = 0xff;
            }

            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
            {
                valid_startelement  = startelement;
                valid_elements      = 0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if( BACKWARD==direction )                                            //backward-start
                {
                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                        valid_elements= 1;

                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                        {
                            if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                            if( 0!= gSourceList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements )>= AUDIO_SOURCELIST_ENTRIES)
                    {
                        for( i =valid_startelement; i < AUDIO_SOURCELIST_ENTRIES; i++ )
                        {
                            if( 0!= gSourceList_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_SOURCELIST_ENTRIES;
                        }
                    }
                    else
                    {
                        for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                        {
                            if( 0!= gSourceList_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_SOURCELIST_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue( env_AudioSD_SL_AH_elements, valid_elements );

        //send StatusArray
    //MR 63667
        if(!transSuppression )
            SourceList_Request( Data_REQ, tnle, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
    }
}

SourceList_init_CSV() //Byte & file selection
{
    dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, current_CSV_line = 0, count1 = 0, count2 = 0;
    char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
    byte SourceListLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
    char SourceList_Pos_string[AUDIO_SOURCELIST_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8 ) code in the *.csv
    char SourceList_SourceType_string[AUDIO_SOURCELIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"SourceType" is stored in the ASCII(UTF-8 ) code in the *.csv
    char SourceList_InstanceID_string[AUDIO_SOURCELIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"InstanceID" is stored in the ASCII(UTF-8 ) code in the *.csv
    char SourceList_MediaType_string[AUDIO_SOURCELIST_ENTRIES][AUDIO_TEXTLENGTH];  //help value ->"MediaType" is stored in the ASCII(UTF-8 ) code in the *.csv
    char SourceList_Attributes_string[AUDIO_SOURCELIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Attributes" is stored in the ASCII(UTF-8 ) code in the *.csv

     //BAP_MOST sync CoverArt
    char gSourceList_CoverArtType_string [AUDIO_SOURCELIST_ENTRIES][AUDIO_TEXTLENGTH];

    if( getvalue( env_AudioSD_SL_DataSource ) == AUDIO_EXTERNAL_LIST ) //output data in write window "FSGSourceList"
    {
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: *******External SourceList*******" );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: " );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: **********************Start load new SourceList**********************" );

        //clear
        for( j = 0; j < AUDIO_SOURCELIST_ENTRIES; j++ )
        {
            gSourceList_Pos[j]                          = 0;
            gSourceList_SourceType[j]                   = 0;
            gSourceList_InstanceID[j]                   = 0;
            gSourceList_MediaType[j]                    = 0;

            gSourceList_Attributes_BuiltIn_Bit0[j]      = 0;
            gSourceList_Attributes_MediaError_Bit1[j]   = 0;
            gSourceList_Attributes_MediaPlay_Bit2[j]    = 0;
            gSourceList_Attributes_MediaRead_Bit3[j]    = 0;
            gSourceList_Attributes_MediaLoad_Bit4[j]    = 0;
            gSourceList_Attributes_ImportRun_Bit5[j]    = 0;
            gSourceList_Attributes_MediaSupp_Bit6[j]    = 0;
            gSourceList_Attributes[j]                   = 0;

            gSourceList_ListEntryValidInformation[j] = 0;
            //BAP_MOST sync CoverArt
            gSourceList_CoverArtType [j] = 0;

            for( i = 0; i < AUDIO_SOURCELIST_NAME_LENGTH; i++ )
                gSourceList_Name[j][i] = 0;

            //BAP_MOST sync CoverArt
             //tagging the POS and index per PictureFile
            gSourceList_PictureFileIndex[j] [0]        = 0;
            gSourceList_PictureFileIndex[j] [1]        = 0;

           //BAP_MOST sync CoverArt
             for( i = 0; i < AUDIO_SOURCE_PICFILE_LENGTH; i++ )
                gSourceList_PictureFile[j][i] = 0;
        }

        for( i = 0; i < AUDIO_FILENAME_SIZE; i++ ) //clear "filename"
            gSourceList_CSV_filename[i] = 0;

        for( j = 0; j < AUDIO_SOURCELIST_ENTRIES; j++ ) //clear "buffer"
        {
            buffer_string[j]    = 0;
            buffer_byte[j]      = 0;

            for( i = 0; i < AUDIO_TEXTLENGTH; i++ ) //clear help value
            {
                SourceList_Pos_string[j][i]          = 0;
                SourceList_SourceType_string[j][i]   = 0;
                SourceList_InstanceID_string[j][i]   = 0;
                SourceList_MediaType_string[j][i]    = 0;
                SourceList_Attributes_string[j][i]   = 0;
                //BAP_MOST sync CoverArt
                gSourceList_CoverArtType_string[j][i]   = 0;
            }
        }

        i = 0; j = 0; SourceListLine = 0; current_CSV_line = 0; //reset values


        getvalue( env_AudioSD_SL_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel

//write( "complete path *.csv: %s", Path_CSV); //debug

i = 0;

        while ( Path_CSV[i] != 0 ) //scan "path"
        {
            if( Path_CSV[i] == 0x5C) //count "/" to seperate later "path" & "filename"
                count1++;

            //write( "Path[%d] of *.csv: %x",i, Path_CSV[i] ); //debug
            i++;
        }

        i = 0; j = 0; //reset values

        while ( Path_CSV[i] != 0 ) //seperate "path" and "filename"
        {
            if( count2==count1 ) //get filename after last "\"
            {
                gSourceList_CSV_filename[j] = Path_CSV[i];
                j++;

                Path_CSV[i] = 0;
            }

            if( Path_CSV[i] == 0x5C) //count "\" to get filename after last "\"
                count2++;

            i++;
        }

        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: path of *.csv: %s", Path_CSV);        //output file path

        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: filename of *.csv: '%s'", gSourceList_CSV_filename );  //output filename

        putvalue( env_AudioSD_SL_DataSource_file, gSourceList_CSV_filename ); //output current loaded *.csv-file on panel

        setFilePath( Path_CSV, 0 ); //set path for *.csv file

        CSVfileHandle = openFileRead( gSourceList_CSV_filename,1 ); //open *.csv ( binary-mode ->get the ASCII/UTF-8 code )

        if( CSVfileHandle!= 0 ) //*.csv file access successful
        {
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Dateizugriff auf '%s' erfolgreich", gSourceList_CSV_filename );    //output result


            putvalue( env_AudioSD_SL_DataSource_result, "successful" );   //output result on panel

            Num_of_csv_byte = fileGetBinaryBlock( buffer_byte, elcount( buffer_byte ), CSVfileHandle );//get data from *.csv and store the total number of byte in *.csv-file

            for( i = 0; i <Num_of_csv_byte; i++ ) //copy data into "SourceList"
            {
                if( buffer_byte[i] != 0x3B) //read data if no ";" is detected
                {
                    if( buffer_byte[i] == 0x0D && buffer_byte[i + 1] == 0x0A) //nextline in *.csv (next "record element" in SourceList ) -> "LF" and "CR" detected -> copy ( transform string -> long ) data from help values in global values
                    {
                        if( current_CSV_line> 0 && SourceListLine < AUDIO_SOURCELIST_ENTRIES) //ignore first line in *.csv file
                        {
                            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: " );
                            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: *******Element %d*******", SourceListLine );

                            //transform 'string' to 'long' for "POS", "SourceType", "InstanceID", "MediaType" and "Attributes"
                            gSourceList_Pos[SourceListLine]           =atol( SourceList_Pos_string[SourceListLine] );
                            gSourceList_SourceType[SourceListLine]    =atol( SourceList_SourceType_string[SourceListLine] );
                            gSourceList_InstanceID[SourceListLine]    =atol( SourceList_InstanceID_string[SourceListLine] );
                            gSourceList_MediaType[SourceListLine]     =atol( SourceList_MediaType_string[SourceListLine] );
                            gSourceList_Attributes[SourceListLine]    =atol( SourceList_Attributes_string[SourceListLine] );

                            //BAP_MOST sync CoverArt
                            gSourceList_CoverArtType[SourceListLine]  =atol( gSourceList_CoverArtType_string[SourceListLine] );

                            //SourceType
                            gSourceList_PictureFileIndex[SourceListLine][0] = gSourceList_SourceType[SourceListLine];
                            //index
                            gSourceList_PictureFileIndex[SourceListLine][1] = SourceListLine;
                            //POS
                            gSourceList_PictureFileIndex[SourceListLine][2] = gSourceList_Pos[SourceListLine];

                            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Pos[%d]: 0x%x", SourceListLine, gSourceList_Pos[SourceListLine] );


                            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: SourceType[%d]: 0x%x", SourceListLine, gSourceList_SourceType[SourceListLine] );
                            if( gSourceList_SourceType[SourceListLine] < 0x2E )
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gSourceList_SourceType_s[gSourceList_SourceType[SourceListLine]] );
                            else if( gSourceList_SourceType[SourceListLine] == AUDIO_SOURCELIST_ST_UNKNOWN )
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gstring_unknown );
                            else
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gstring_reserved );

                            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: InstanceID[%d]: 0x%x", SourceListLine, gSourceList_InstanceID[SourceListLine] );


                            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: MediaType[%d]: 0x%x", SourceListLine, gSourceList_MediaType[SourceListLine] );
                            if( gSourceList_MediaType[SourceListLine] < 0x0E )
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gSourceList_MediaType_s[gSourceList_MediaType[SourceListLine]] );
                            else if( gSourceList_MediaType[SourceListLine] == AUDIO_SOURCELIST_MT_UNKNOWN )
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gstring_unknown );
                            else
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList:  -> '%s'", gstring_reserved );



                            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attributes[%d]: 0x%x", SourceListLine, gSourceList_Attributes[SourceListLine] );

                            if( gSourceList_Attributes[SourceListLine] & 0x01 )
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit0[%d]: 'built-in and ready'", SourceListLine );
                            else
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit0[%d]: 'built-in but not ready'", SourceListLine );

                            if( gSourceList_Attributes[SourceListLine] & 0x02 )
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit1[%d]: 'media/audio no error'", SourceListLine );
                            else
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit1[%d]: 'media/audio source error'", SourceListLine );

                            if( gSourceList_Attributes[SourceListLine] & 0x04 )
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit2[%d]: 'media is playable'", SourceListLine );
                            else
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit2[%d]: 'media is not playable (no playable files )'", SourceListLine );

                            if( gSourceList_Attributes[SourceListLine] & 0x08 )
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit3[%d]: 'media is readable'", SourceListLine );
                            else
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit3[%d]: 'media is not readable'", SourceListLine );

                            if( gSourceList_Attributes[SourceListLine] & 0x10 )
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit4[%d]: 'media is not being loaded'", SourceListLine );
                            else
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit4[%d]: 'media is being loaded'", SourceListLine );

                            if( gSourceList_Attributes[SourceListLine] & 0x20 )
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit5[%d]: 'no import running'", SourceListLine );
                            else
                                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Attribues_Bit5[%d]: 'import running'", SourceListLine );


                            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Name[%d]: %s", SourceListLine, gSourceList_Name[SourceListLine] );

                            gSourceList_ListEntryValidInformation[SourceListLine]  = TRUE;

                            SourceListLine++; // -> next line in *.csv (next record element )
                        }

                        current_CSV_line++; //next line in *.csv file
                        element = 0; //start at 'POS' ( first record element of "array data" )
                        j = 0; //reset value
                    }

                    else if( current_CSV_line> 0 && SourceListLine < AUDIO_SOURCELIST_ENTRIES) //copy data from "buffer_byte" ( data from *.csv file ) in help values and "name" until end of line is not detected
                    {
                        switch(  element )
                        {
                            case 0: //POS
                                    SourceList_Pos_string[SourceListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //SourceType
                                    SourceList_SourceType_string[SourceListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 2: //InstanceID
                                    SourceList_InstanceID_string[SourceListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 3: //MediaType
                                    SourceList_MediaType_string[SourceListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 4: //Attributes
                                    SourceList_Attributes_string[SourceListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 5: //Name
                                    gSourceList_Name[SourceListLine][j] =buffer_byte[i];
                                    j++;
                             break;
                             //BAP_MOST sync CoverArt
                             //coverArtType
                             case 6:gSourceList_CoverArtType_string[SourceListLine][j] =buffer_byte[i];
                             break;

                            case 7: //PictureFile
                                    gSourceList_PictureFile[SourceListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            default:
                             break;
                        }
                    }
                }

                else  // ";" is detected ->next record element of "array data"
                {
                    element++;
                    j = 0; //reset value
                }

            }
            //IssueList #76 - MR49870 : SourceList
            // - if condition
            if( getValue( env_AudioSD_SL_insert_UPD_button ) == 0x00 )
            gSourceList_TotalNumListElements = gSourceList_sum = SourceListLine; //get "total number of list elements"


            putvalue( env_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements );

            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: " );

            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Anzahl der Listenelemente: %d", gSourceList_sum); //output total number of list elements

            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: " );

            if( fileClose( CSVfileHandle ) != 0 ) //close *.csv file
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Datei '%s' geschlossen", gSourceList_CSV_filename ); //output result

            else
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Fehler beim Schlieen der Datei '%s'", gSourceList_CSV_filename );//output result
        }

        else //*.csv file access not successful
        {
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "SourceList: Fehler beim Dateizugriff auf '%s'", gSourceList_CSV_filename ); //output result


            putvalue( env_AudioSD_SL_DataSource_result, "not successful" ); //output result
        }
        gAudioSD_activeSource_SourceList_Reference  = gSourceList_Pos[0];
        putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_activeSource_SourceList_Reference );

        //IssueList #76 - MR49870 : SourceList
        for( i = 0; i < gSourceList_TotalNumListElements; i++ )
        {
            gSourceList_Pos_insDel[i] [0] = gSourceList_Pos[i];  //Pos Value
            gSourceList_Pos_insDel[i] [2] = gSourceList_SourceType[i]; // SourceType
        }


        if( getValue( env_AudioSD_SL_insert_UPD_button ) == 0x00 )
        gSL_totalDELctr = 0;
    }
}

RadioTVPresetList_Indication ( dword Indication_array [], int datalength )
{
    byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements;
    //24.02.2015 update from Jochen
    int transSuppression;

    //IssueList #76 - MR49870 : RTPL
    int i = 0,j = 0;
    byte audioListDelFlg;
    word validStartElem_plusElem;

     //IssueList #193
    byte rtpl_InValidStartElemFlg;

    // Init local variables.
    mode                    = 0;
    direction               = 0;
    shift                   = 0;
    transmitpos             = 0;
    recordaddress           = 0;
    requested_startelement  = 0x0000;
    startelement            = 0x0000;
    elements                = 0;
    indexsize               = 0;
    valid_startelement      = 0xff;
    valid_elements          = 0;
    //24.02.2015 update from Jochen
    transSuppression        = getvalue( env_AudioSD_PL_noStatusArray );

    //IssueList #76 - MR49870 : RTPL
    validStartElem_plusElem = 0;

        switch( Indication_array[2] ) // indication
        {
            case DataGet_IND:

                if( getvalue( env_AudioSD_RTPL_Error_on ) )
                {
                    //MR 63667 11.07.2014 -TNLE with SA-button
                    //RadioTVPresetList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue( env_AudioSD_RTPL_ErrorCode ) );
                    RadioTVPresetList_Request(Error_REQ, 0, 0, 0, 0, 0, 0, getvalue( env_AudioSD_RTPL_ErrorCode ) );
                }
                //MR 63336    02.07.2014
                else if( getvalue( env_AudioSD_RTPL_Timeout ) == TRUE )
                {
                /* NOP */
                }
                else
                {
                    //getData
                    gRadioTVPresetList_ASGID                = ( gBAP_Indication[3] & 0xF0 ) / 0x10;
                    gRadioTVPresetList_TAID                 = gBAP_Indication[3] & 0x0F;

                    //decode BAP-ArrayHeader
                    mode                = ( gBAP_Indication[4] & 0xF0 ) / 0x10;

                    // decode "mode -byte"
                    shift       = mode & 0x01;
                    direction   = ( mode & 0x02 ) / 0x02;
                    transmitpos = ( mode & 0x04 ) / 0x04;
                    indexsize   = ( mode & 0x08 ) / 0x08;

                    recordaddress       = gBAP_Indication[4] & 0x0F;
                    if( indexsize )
                    {
                        startelement        = gBAP_Indication[5];
                        startelement        += gBAP_Indication[6] * 0x100;
                        elements            = gBAP_Indication[7];
                        elements            += gBAP_Indication[8]* 0x100;
                    }
                    else
                    {
                        startelement        = gBAP_Indication[5];
                        elements            = gBAP_Indication[6];
                    }

                    requested_startelement = startelement;

                    transmitpos     = TRUE; //Position must always be sent in the case of *.GetArray.


                    /***Startelement = 0***/
                    if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
                    {
                        if( FORWARD==direction )  //forward-start
                        {
                            valid_startelement = 0;

                             //IssueList #76 - MR49870 : RTPL
                            //change the AUDIO_RTPL_ENTRIES --> gRTPL_CSVtotalElem --> gRadioTVPresetList_TotalNumListElements
                            if( gRadioTVPresetList_TotalNumListElements <= elements )         //1. more elements requested, than in array
                            {
                                if( shift == FALSE )
                                {
                                    for( i = 0; i < gRadioTVPresetList_TotalNumListElements; i++ )
                                    {
                                        if( 0 != gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i = gRTPL_CSVtotalElem;
                                    }
                                }
                                else if( shift == TRUE )
                                {
                                    valid_startelement  = startelement;
                                    valid_elements      = 0;
                                }
                            }
                            else    //2. number of requested elements < elements in array
                            {
                                if( shift == FALSE )
                                {
                                    for( i = 0; i < elements; i++ )
                                    {
                                        if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )        //if there is an valid element
                                            valid_elements++;                                //increment elements
                                        else                                                //no valid element, loop finished
                                            i = gRTPL_CSVtotalElem;
                                    }
                                }
                                else if( shift == TRUE )
                                {
                                    valid_startelement  = startelement;
                                    valid_elements      = 0;
                                }
                            }
                        }                                                               //forward ends
                        else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                        {
                            //searching for valid startelement
                            for( i = ( gRTPL_CSVtotalElem-1 ); i>= 0; i--)
                            {
                                if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )        //found valid startelement
                                {
                                    valid_startelement = i;
                                    i = 0;
                                }
                            }

                            //searching for valid elements
                            if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                            {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                            }
                            else if( 0 ==valid_startelement )
                                valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                            else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                            {
                                for( i =valid_startelement; i>= 0; i--)
                                {
                                    if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                        valid_elements++;                                //increment elements
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                                {
                                    if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                        valid_elements++;                                //increment elements
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }
                            }
                        }                                                               //backward-end
                    }                                                                   //startelement == 0 -end
                    /***Startelement!= 0***/
                    else                                                                //searching for Startelement-ID
                    {
                        rtpl_InValidStartElemFlg = 0;
                        for( i = 0; i < gRTPL_CSVtotalElem; i++ )
                        {
                            if( startelement == gRTPL_Pos_insDel[i][0] )
                            {
                                //check if Start is deleted then reply with 0 elements
                                if( gRTPL_Pos_insDel[i][1] == 0x01 )
                                {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                                rtpl_InValidStartElemFlg = 1;
                                }
                            }
                        }
                        if( rtpl_InValidStartElemFlg == 0x00 )
                        {
                            //searching for valid startelement
                            for( i = 0; i < gRTPL_CSVtotalElem; i++ )
                            {
                                if( gRadioTVPresetList_Pos[i] == startelement )                        //found a valid element
                                {
                                    if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                                    {
                                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                            valid_startelement = i + 1-2*direction;

                                        else if( i == 0 && BACKWARD==direction )
                                            valid_startelement = gRadioTVPresetList_sum;        //valid element is last element in Array

                                        else if( i == 0 && FORWARD==direction )
                                            valid_startelement = 0;                          //valid element is first element in Array
                                    }
                                    else
                                        valid_startelement = i;                              //found element is valid_startelement

                                    i = gRTPL_CSVtotalElem;
                                }
                            }
                            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
                            {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                            }
                            else                                                                //found valid entry for startelement in array
                            {
                                //verify number of valid elements
                                if( BACKWARD==direction )                                            //backward-start
                                {
                                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                                        {
                                        //IssueList #76 - MR49870 : RTPL
                                       audioListDelFlg = 0x00;
                                       audioListDelFlg = audioList_deleteCheck( gRadioTVPresetList_Pos[0], gRTPL_Pos_insDel, gRTPL_CSVtotalElem );

                                            if( audioListDelFlg == 0x00 )
                                            valid_elements= 1;
                                        }
                                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                                    {
                                        for( i =valid_startelement; i>= 0; i--)
                                        {
                                            if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                                valid_elements++;                                //increment elements
                                            else                                                //no valid element, loop finished
                                                i = 0;
                                        }
                                    }
                                    else                                                        //enougth array-elements available
                                    {
                                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                                        {
                                            if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                                valid_elements++;                                //increment elements
                                            else                                                //no valid element, loop finished
                                                i = 0;
                                        }
                                    }
                                }                                                                //backward-end
                                else                                                            //forward-start
                                {
                                    if((valid_startelement+elements )>= gRadioTVPresetList_TotalNumListElements )
                                    {
                                        for( i =valid_startelement; i < gRTPL_CSVtotalElem; i++ )
                                        {
                                            if( 0!= gRadioTVPresetList_Pos[i] )                        //if there is an valid element
                                            {
                                            //IssueList #76 - MR49870 : RTPL
                                             audioListDelFlg = 0x00;
                                             audioListDelFlg = audioList_deleteCheck( gRadioTVPresetList_Pos[i], gRTPL_Pos_insDel, gRTPL_CSVtotalElem );

                                              //RTPL 15MAY
                                              //if( audioListDelFlg == 0x00 )
                                              if( audioListDelFlg == 0x00 && valid_elements < elements )
                                              valid_elements++;                                    //increment elements
                                            }
                                            else                                                //no valid element, loop finished
                                                i = gRTPL_CSVtotalElem;
                                        }
                                    }
                                    else
                                    {
                                        //IssueList #76 - MR49870 : RTPL 15MAY
                                         validStartElem_plusElem =valid_startelement+elements;
                                        //for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                                        for( i =valid_startelement; i <validStartElem_plusElem ; i++ )
                                        {
                                            if( 0!= gRadioTVPresetList_Pos[i] )                            //if there is an valid element
                                            {
                                            //IssueList #76 - MR49870 : RTPL
                                               audioListDelFlg = 0x00;

                                               audioListDelFlg = audioList_deleteCheck( gRadioTVPresetList_Pos[i], gRTPL_Pos_insDel, gRTPL_CSVtotalElem);

                                                if( audioListDelFlg == 0x00 )
                                                {
                                                    //RTPL 15MAY
                                                    if( valid_elements < elements )      //guard check if valid elements < elements
                                                    valid_elements++;                   //increment elements
                                                 }
                                                 //RTPL 15MAY
                                                 else
                                                 {
                                                    if( valid_elements < elements )
                                                    validStartElem_plusElem++;      //adjust the loop boundary based on number of deleted elements
                                                 }
                                            }
                                            else                                                    //no valid element, loop finished
                                                i = gRTPL_CSVtotalElem;
                                        }
                                    }
                                }
                            }
                        }//rtplInValidStartElemFlg
                    }  //else Startelement!= 0

                    mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;
                    //send StatusArray
                    //MR 63667 11.07.2014 -TNLE with SA-button
                    //RadioTVPresetList_Request( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
                    //24.02.2015 update from Jochen
                    if( !transSuppression )
                        RadioTVPresetList_Request( Data_REQ, gRadioTVPresetList_TotalNumListElements, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
                    }
                    //Panel
                    putvalue( env_AudioSD_RTPL_ASGID, gRadioTVPresetList_ASGID);
                    putvalue( env_AudioSD_RTPL_TAID, gRadioTVPresetList_TAID);
            break;

            case Error_IND:
                    writelineEx( gError_Trace, 0, "RadioTVPreset: FSG_AudioSD RadioTVPresetList_Indication: received error, errorcode:0x%x", Indication_array[3] );
            break;

            default:
                writelineEx( gError_Trace, 0, "RadioTVPreset: FSG_AudioSD RadioTVPresetList_Indication: invalid indication %d", Indication_array[2] );
             break;
    }
}

RadioTVPresetList_Request ( byte request, word tnle, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode )
{
    int  i;
    dword requestarray [BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word RadioTVPresetListLine;
    //IssueList #76 - MR49870 : RTPL
    byte audioListDelFlg;

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray [i] = 0;

    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    RadioTVPresetListLine   = 0;
    current_element         = 0;
    Offset                  = 0;

    // decode "mode -byte"
    shift       = mode & 0x01;
    direction   = ( mode & 0x02 ) / 0x02;
    transmitpos = ( mode & 0x04 ) / 0x04;
    indexsize   = ( mode & 0x08 ) / 0x08;

    // Handle request.
    requestarray[0] = LSG_AudioSD;                //LSG-ID
    requestarray[1] = FctID_RadioTV_PresetList;    //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;

    switch( request )
    {
        case Changed_REQ:

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            RadioTVPresetListLine = startelement;

            if( getvalue( env_AudioSD_RTPL_CA_switch ) ) //ArrayData
            {
                //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                        while( current_element < elements )
                        {
                            if( RadioTVPresetListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                        Offset++;
                                    }
                                }

                                //PresetIndex
                                requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                                Offset++;

                                //Waveband
                                requestarray[Offset] = gRadioTVPresetList_Waveband[RadioTVPresetListLine];
                                Offset++;

                                //Attributes
                                requestarray[Offset] = ( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0xFF );
                                Offset++;
                                requestarray[Offset] = (( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0xFF00 ) / 0x100 );
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] );
                                Offset++;

                                for( i = 0; i < strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] ); i++ )
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            RadioTVPresetListLine =RadioTVPresetList_nextvalidLine( RadioTVPresetListLine, direction );

                        }//end while
                    break;

                    case 1: //PresetIndex, Waveband, Name
                        while( current_element < elements )
                        {
                            if( RadioTVPresetListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                        Offset++;
                                    }
                                }

                                //PresetIndex
                                requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                                Offset++;

                                //Waveband
                                requestarray[Offset] = gRadioTVPresetList_Waveband[RadioTVPresetListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] );
                                Offset++;

                                for( i = 0; i < strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] ); i++ )
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            RadioTVPresetListLine =RadioTVPresetList_nextvalidLine( RadioTVPresetListLine, direction );

                        }//end while
                    break;

                    case 2: //PresetIndex, Name
                        while( current_element < elements )
                        {
                            if( RadioTVPresetListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                        Offset++;
                                    }
                                }

                                //PresetIndex
                                requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] );
                                Offset++;

                                for( i = 0; i < strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] ); i++ )
                                {
                                    requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            RadioTVPresetListLine =RadioTVPresetList_nextvalidLine( RadioTVPresetListLine, direction );

                        }//end while
                    break;

                    case 15: //Pos
                        while( current_element < elements )
                        {
                            if( RadioTVPresetListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            RadioTVPresetListLine =RadioTVPresetList_nextvalidLine( RadioTVPresetListLine, direction );

                        }//end while
                    break;

                    default:
                        write( "AudioSD RadioTVPresetList_Request: invalid recordaddress %d", recordaddress );
                    break;
                } //end switch "recordaddress"
            }// end 'ArrayData'

            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

         break; //end Changed_REQ

        case Data_REQ:
            //changes from Jran Karl (28.03.2012 )
            //MR 63336    02.07.2014
            //if( getvalue( env_AudioSD_RTPL_Timeout ) != TRUE )
            if(/*getvalue( env_AudioSD_RTPL_Timeout ) != */ TRUE )
            {
            //VAGH-10511
            ASGID = gRadioTVPresetList_ASGID;
            TAID = gRadioTVPresetList_TAID;
                if( getvalue( env_AudioSD_RTPL_ASGID_error ) != FALSE )
                {
                    ASGID += 0x2;
                }
                if( getvalue( env_AudioSD_RTPL_TAID_error ) != FALSE )
                {
                    TAID += 0x02;
                }

                requestarray[Offset] = (( ASGID * 0x10 ) & 0xF0 ) + ( TAID & 0x0F );
                Offset++;

                //MR 63667 11.07.2014 -TNLE with SA-button
                //requestarray[Offset] = gRadioTVPresetList_TotalNumListElements;
                requestarray[Offset] =tnle;
                Offset++;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;
                if( indexsize )
                {
                    requestarray[Offset] = requested_startelement & 0xff;
                    Offset++;
                    requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                    Offset++;

                    requestarray[Offset] = elements & 0xff;
                    Offset++;
                    requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                    Offset++;
                }
                else
                {
                    requestarray[Offset] = requested_startelement;
                    Offset++;
                    requestarray[Offset] = elements;
                    Offset++;
                }

                RadioTVPresetListLine = startelement;

                //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                            while( current_element < elements )
                            {
                                if( RadioTVPresetListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {

                                            //IssueList #76 - MR49870 : RTPL
                                            //Updating the status array excluding the deleted elements
                                           audioListDelFlg = 0x00;
                                           audioListDelFlg = audioList_deleteCheck( gRadioTVPresetList_Pos[RadioTVPresetListLine], gRTPL_Pos_insDel, gRTPL_CSVtotalElem);

                                        if( audioListDelFlg == 0x00 )
                                        {
                                            if( indexsize )
                                            {
                                                requestarray[Offset] = ( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF );
                                                Offset++;
                                                requestarray[Offset] = (( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00 ) / 0x100 );
                                                Offset++;
                                            }
                                            else
                                            {
                                                requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                                Offset++;
                                            }
                                        }// audioListDelFlg
                                    }

                                   if( audioListDelFlg == 0x00 )
                                   {
                                    //PresetIndex
                                    requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                                    Offset++;

                                    //Waveband
                                    requestarray[Offset] = gRadioTVPresetList_Waveband[RadioTVPresetListLine];
                                    Offset++;

                                    //Attributes
                                    requestarray[Offset] = ( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0xFF );
                                    Offset++;
                                    requestarray[Offset] = (( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0xFF00 ) / 0x100 );
                                    Offset++;

                                    //Name
                                    requestarray[Offset] = strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] );
                                    Offset++;

                                    for( i = 0; i < strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] ); i++ )
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                        Offset++;
                                    }
                                   } // audioListDelFlg
                                }
                                //IssueList #76 - MR49870 : RTPL
                                if( audioListDelFlg == 0x00 )
                                current_element++;
                                RadioTVPresetListLine =RadioTVPresetList_nextvalidLine( RadioTVPresetListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 1: //PresetIndex, Waveband, Name
                        while( current_element < elements )
                            {
                                if( RadioTVPresetListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF );
                                            Offset++;
                                            requestarray[Offset] = (( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                            Offset++;
                                        }
                                    }

                                    //PresetIndex
                                    requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                                    Offset++;

                                    //Waveband
                                    requestarray[Offset] = gRadioTVPresetList_Waveband[RadioTVPresetListLine];
                                    Offset++;

                                    //Name
                                    requestarray[Offset] = strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] );
                                    Offset++;

                                    for( i = 0; i < strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] ); i++ )
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                        Offset++;
                                    }
                                }
                                current_element++;
                                RadioTVPresetListLine =RadioTVPresetList_nextvalidLine( RadioTVPresetListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 2: //PresetIndex, Name
                        while( current_element < elements )
                            {
                                if( RadioTVPresetListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                        if( indexsize )
                                        {
                                            requestarray[Offset] = ( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF );
                                            Offset++;
                                            requestarray[Offset] = (( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00 ) / 0x100 );
                                            Offset++;
                                        }
                                        else
                                        {
                                            requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                            Offset++;
                                        }
                                    }

                                    //PresetIndex
                                    requestarray[Offset] = gRadioTVPresetList_PresetIndex[RadioTVPresetListLine];
                                    Offset++;

                                    //Name
                                    requestarray[Offset] = strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] );
                                    Offset++;

                                    for( i = 0; i < strlen( gRadioTVPresetList_Name[RadioTVPresetListLine] ); i++ )
                                    {
                                        requestarray[Offset] = gRadioTVPresetList_Name[RadioTVPresetListLine][i];
                                        Offset++;
                                    }
                                }
                                current_element++;
                                RadioTVPresetListLine =RadioTVPresetList_nextvalidLine( RadioTVPresetListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    case 15: //Pos
                        while( current_element < elements )
                            {
                                if( RadioTVPresetListLine == 0xFF ) //Invalid "list entry"
                                {
                                    write( "AudioSD RadioTVPresetList_Request: invalid RadioTVPresetListLine" );
                                    current_element = elements;
                                }
                                else //"list entry" valid
                                {
                                    /***Array Data***/
                                    if( transmitpos ) // Pos  ->Array position transmitted
                                    {
                                            //IssueList #76 - MR49870 : RTPL
                                            //Updating the status array excluding the deleted elements
                                           audioListDelFlg = 0x00;
                                           audioListDelFlg = audioList_deleteCheck( gRadioTVPresetList_Pos[RadioTVPresetListLine], gRTPL_Pos_insDel, gRTPL_CSVtotalElem);

                                        if( audioListDelFlg == 0x00 )
                                        {

                                            if( indexsize )
                                            {
                                                requestarray[Offset] = ( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF );
                                                Offset++;
                                                requestarray[Offset] = (( gRadioTVPresetList_Pos[RadioTVPresetListLine] & 0xFF00 ) / 0x100 );
                                                Offset++;
                                            }
                                            else
                                            {
                                                requestarray[Offset] = gRadioTVPresetList_Pos[RadioTVPresetListLine];
                                                Offset++;
                                            }
                                        }//audioListDelFlg
                                    }
                                }
                                //IssueList #76 - MR49870 : RTPL
                                if( audioListDelFlg == 0x00 )
                                current_element++;

                                RadioTVPresetListLine =RadioTVPresetList_nextvalidLine( RadioTVPresetListLine, direction );

                            }//end while

                            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                     break;

                    default:
                        write( "AudioSD RadioTVPresetList_Request: invalid recordaddress %d", recordaddress );
                     break;
                } //end switch "recordaddress"
            //changes from Jran Karl (28.03.2012 )
        }
            else
            {
                write( "AudioSD RadioTVPresetList_Request: Simulate timeout of Status-Array!" );
            }
         break; //end Data_REQ

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
         break; //end Error_REQ

    } //end switch "request"
}

byte RadioTVPresetList_nextvalidLine( byte current_RadioTVPresetListLine, byte direction )
{
    byte next_RadioTVPresetListLine;
    int i;

    //init lokal variables
    next_RadioTVPresetListLine = 0;
    i = 0;

    //search next "list entry"
    if( (( gRadioTVPresetList_sum - 1 ) == current_RadioTVPresetListLine && FORWARD == direction ) || ( 0 == current_RadioTVPresetListLine && BACKWARD == direction ) )   //last-/fist-element of array reached
        next_RadioTVPresetListLine = 0xFF;
    else
    {
        next_RadioTVPresetListLine = current_RadioTVPresetListLine + 1 - 2 * direction;       //increment or decrement array-line ( depends on direction );

        if( 0 == gRadioTVPresetList_ListEntryValidInformation[next_RadioTVPresetListLine] )  // check if next element is "valid"
            next_RadioTVPresetListLine = 0xff;
    }

    return (next_RadioTVPresetListLine );
}

RadioTVPresetList_init_static()
{
    byte j, i, RadioTVPresetListLine;

    //clear
    RadioTVPresetListLine = 0;
    gRadioTVPresetList_sum = 0;

    for( j = 0; j < AUDIO_RADIOTVPRESETLIST_ENTRIES; j++ )
    {
        gRadioTVPresetList_Pos[j] = 0;
        gRadioTVPresetList_PresetIndex[j] = 0;
        gRadioTVPresetList_Waveband[j] = 0;

        gRadioTVPresetList_Attributes_IBOC_Bit0[j] = 0;
        gRadioTVPresetList_Attributes_DABSecServ_Bit1[j] = 0;
        gRadioTVPresetList_Attributes_DABPrimServ_Bit2[j] = 0;
        gRadioTVPresetList_Attributes_TP_Bit5[j] = 0;
        gRadioTVPresetList_Attributes_TMC_Bit6[j] = 0;
        gRadioTVPresetList_Attributes_SDRAS_Bit7[j] = 0;
        gRadioTVPresetList_Attributes_StatSelect_Bit8[j] = 0;
        gRadioTVPresetList_Attributes_OnlineRadioMute_Bit9[j] = 0;
        gRadioTVPresetList_Attributes_LinkedToOnlRadio_Bit10[j] = 0;
        gRadioTVPresetList_Attributes[j] = 0;

        gRadioTVPresetList_ListEntryValidInformation[j] = 0;

        for( i = 0; i < AUDIO_RADIOTVPRESETLIST_NAME_LENGTH; i++ )
            gRadioTVPresetList_Name[j][i] = 0;
    }

    //entry 0
    gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0x52;
    gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 2;
    gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_FM;

    gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes[RadioTVPresetListLine] =
      gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] +
      ( gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] * 0x02 ) +
      ( gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] * 0x04 ) +
      ( gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] * 0x20 ) +
      ( gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] * 0x40 ) +
      ( gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] * 0x80 );

    strncpy( gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_0", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
    RadioTVPresetListLine++;

    //entry 1
    gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0x03;
    gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 9;
    gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_SDARSSIRIUS;

    gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes[RadioTVPresetListLine] =
      gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] +
      ( gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] * 0x02 ) +
      ( gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] * 0x04 ) +
      ( gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] * 0x20 ) +
      ( gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] * 0x40 ) +
      ( gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] * 0x80 );

    strncpy( gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_1", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
    RadioTVPresetListLine++;

    //entry 2
    gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0x99;
    gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 34;
    gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_DAB;

    gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes[RadioTVPresetListLine] =
      gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] +
      ( gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] * 0x02 ) +
      ( gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] * 0x04 ) +
      ( gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] * 0x20 ) +
      ( gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] * 0x40 ) +
      ( gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] * 0x80 );

    strncpy( gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_2", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
    RadioTVPresetListLine++;

    //entry 3
    gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0x11;
    gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 41;
    gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_TV;

    gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes[RadioTVPresetListLine] =
      gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] +
      ( gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] * 0x02 ) +
      ( gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] * 0x04 ) +
      ( gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] * 0x20 ) +
      ( gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] * 0x40 ) +
      ( gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] * 0x80 );

    strncpy( gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_3", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
    RadioTVPresetListLine++;

    //entry 4
    gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0xDA;
    gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 34;
    gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_AMMW;

    gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes[RadioTVPresetListLine] =
      gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] +
      ( gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] * 0x02 ) +
      ( gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] * 0x04 ) +
      ( gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] * 0x20 ) +
      ( gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] * 0x40 ) +
      ( gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] * 0x80 );

    strncpy( gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_4", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
    RadioTVPresetListLine++;

    //entry 5
    gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0x72;
    gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 4;
    gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_AMLW;

    gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes[RadioTVPresetListLine] = gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] + ( gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] * 0x02 ) + ( gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] * 0x04 ) + ( gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] * 0x20 ) + ( gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] * 0x40 ) + ( gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] * 0x80 );

    strncpy( gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_5", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
    RadioTVPresetListLine++;

    //entry 6
    gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0x06;
    gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 87;
    gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_SDARSSIRIUS;

    gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes[RadioTVPresetListLine] = gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] + ( gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] * 0x02 ) + ( gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] * 0x04 ) + ( gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] * 0x20 ) + ( gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] * 0x40 ) + ( gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] * 0x80 );

    strncpy( gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_6", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
    RadioTVPresetListLine++;

    //entry 7
    gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0xFE;
    gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 32;
    gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_AMLW;

    gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes[RadioTVPresetListLine] = gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] + ( gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] * 0x02 ) + ( gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] * 0x04 ) + ( gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] * 0x20 ) + ( gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] * 0x40 ) + ( gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] * 0x80 );

    strncpy( gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_7", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
    RadioTVPresetListLine++;

    //entry 8
    gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0x92;
    gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 21;
    gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_UNKNOWN;

    gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes[RadioTVPresetListLine] = gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] + ( gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] * 0x02 ) + ( gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] * 0x04 ) + ( gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] * 0x20 ) + ( gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] * 0x40 ) + ( gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] * 0x80 );

    strncpy( gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_8", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
    RadioTVPresetListLine++;

    //entry 9
    gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0x31;
    gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 6;
    gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_FM;

    gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes[RadioTVPresetListLine] = gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] + ( gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] * 0x02 ) + ( gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] * 0x04 ) + ( gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] * 0x20 ) + ( gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] * 0x40 ) + ( gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] * 0x80 );

    strncpy( gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_9", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
    RadioTVPresetListLine++;

    //entry 10
    gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Pos[RadioTVPresetListLine] = 0x37;
    gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] = 53;
    gRadioTVPresetList_Waveband[RadioTVPresetListLine] = AUDIO_RADIOTVPRESETLIST_WB_SDARSXM;

    gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] = TRUE;
    gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] = FALSE;
    gRadioTVPresetList_Attributes[RadioTVPresetListLine] = gRadioTVPresetList_Attributes_IBOC_Bit0[RadioTVPresetListLine] + ( gRadioTVPresetList_Attributes_DABSecServ_Bit1[RadioTVPresetListLine] * 0x02 ) + ( gRadioTVPresetList_Attributes_DABPrimServ_Bit2[RadioTVPresetListLine] * 0x04 ) + ( gRadioTVPresetList_Attributes_TP_Bit5[RadioTVPresetListLine] * 0x20 ) + ( gRadioTVPresetList_Attributes_TMC_Bit6[RadioTVPresetListLine] * 0x40 ) + ( gRadioTVPresetList_Attributes_SDRAS_Bit7[RadioTVPresetListLine] * 0x80 );

    strncpy( gRadioTVPresetList_Name[RadioTVPresetListLine], "Name_10", AUDIO_RADIOTVPRESETLIST_NAME_LENGTH);
    RadioTVPresetListLine++;

    gRadioTVPresetList_sum = RadioTVPresetListLine;
    gRadioTVPresetList_TotalNumListElements = gRadioTVPresetList_sum;

    if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: *******Default RadioTVPresetList_Array*******" );
    if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: " );

    for( i = 0; i < gRadioTVPresetList_sum; i++ )
    {
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: *******Element %d*******", i);

        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Pos[%d]: 0x%x", i, gRadioTVPresetList_Pos[i] );

        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: PresetIndex[%d]: 0x%x", i, gRadioTVPresetList_PresetIndex[i] );

        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Waveband[%d]: 0x%x", i, gRadioTVPresetList_Waveband[i] );
        if( gRadioTVPresetList_Waveband[i] < 0x0E )
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList:  -> '%s'", gRadioTVPresetList_Waveband_s[gRadioTVPresetList_Waveband[i]] );
        else
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList:  -> '%s'", gstring_reserved );

        if( gRadioTVPresetList_Attributes[i] & 0x01 )
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit0[%d]: 'not an IBOC service'", i);
        else
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit0[%d]: 'IBOC service'", i);

        if( gRadioTVPresetList_Attributes[i] & 0x02 )
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit1[%d]: 'DAB secondary service'", i);
        else
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit1[%d]: 'not a DAB secondary service'", i);

        if( gRadioTVPresetList_Attributes[i] & 0x04 )
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit2[%d]: 'DAB primary service contains secondary service(s )'", i);
        else
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit2[%d]: 'DAB primary service contains no secondary service(s ) / no DAB primary service'", i);

        if( gRadioTVPresetList_Attributes[i] & 0x20 )
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit5[%d]: 'TP available/supported by station'", i);
        else
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit5[%d]: 'TP not available/not supported by station'", i);

        if( gRadioTVPresetList_Attributes[i] & 0x40 )
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit6[%d]: 'TMC available/supported by station'", i);
        else
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit6[%d]: 'TMC not supported/not available by station'", i);

        if( gRadioTVPresetList_Attributes[i] & 0x80 )
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit7[%d]: 'SDARS station not subscribed'", i);
        else
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit7[%d]: 'SDARS station not subscribed'", i);

        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Name[%d]: '%s'", i, gRadioTVPresetList_Name[i] );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: " );
    }

    if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Anzahl der Listenelemente: %d", gRadioTVPresetList_sum);

    putvalue( env_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements );
}

RadioTVPresetList_init_CSV() //Byte & file selection
{
    dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, current_CSV_line = 0, count1 = 0, count2 = 0;
    char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
    byte RadioTVPresetListLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
    char RadioTVPresetList_Pos_string[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8 ) code in the *.csv
    char RadioTVPresetList_PresetIndex_string[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_TEXTLENGTH];//help value ->"PresetIndex" is stored in the ASCII(UTF-8 ) code in the *.csv
    char RadioTVPresetList_Waveband_string[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Waveband" is stored in the ASCII(UTF-8 ) code in the *.csv
    char RadioTVPresetList_Attributes_string[AUDIO_RADIOTVPRESETLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Attributes" is stored in the ASCII(UTF-8 ) code in the *.csv

    if( getvalue( env_AudioSD_RTPL_DataSource ) == AUDIO_EXTERNAL_LIST ) //output data in write window "FSGRadioTVPresetList"
    {
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: *******External RadioTVPresetList*******" );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: " );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: **********************Start load new RadioTVPresetList**********************" );

        //clear
        for( j = 0; j < AUDIO_RADIOTVPRESETLIST_ENTRIES; j++ )
        {
            gRadioTVPresetList_Pos[j]                          = 0;
            gRadioTVPresetList_PresetIndex[j]                  = 0;
            gRadioTVPresetList_Waveband[j]                     = 0;

            gRadioTVPresetList_Attributes_IBOC_Bit0[j]         = 0;
            gRadioTVPresetList_Attributes_DABSecServ_Bit1[j]   = 0;
            gRadioTVPresetList_Attributes_DABPrimServ_Bit2[j]  = 0;
            gRadioTVPresetList_Attributes_TP_Bit5[j]           = 0;
            gRadioTVPresetList_Attributes_TMC_Bit6[j]          = 0;
            gRadioTVPresetList_Attributes_SDRAS_Bit7[j]        = 0;
            gRadioTVPresetList_Attributes_StatSelect_Bit8[j]   = 0;
            gRadioTVPresetList_Attributes_OnlineRadioMute_Bit9[j] = 0;
            gRadioTVPresetList_Attributes_LinkedToOnlRadio_Bit10[j] = 0;
            gRadioTVPresetList_Attributes[j]                   = 0;

            gRadioTVPresetList_ListEntryValidInformation[j] = 0;

            for( i = 0; i < AUDIO_RADIOTVPRESETLIST_NAME_LENGTH; i++ )
                gRadioTVPresetList_Name[j][i] = 0;
        }

        for( i = 0; i < AUDIO_FILENAME_SIZE; i++ ) //clear "filename"
            gRadioTVPresetList_CSV_filename[i] = 0;

        for( j = 0; j < AUDIO_RADIOTVPRESETLIST_ENTRIES; j++ ) //clear "buffer"
        {
            buffer_string[j]    = 0;
            buffer_byte[j]      = 0;

            for( i = 0; i < AUDIO_TEXTLENGTH; i++ ) //clear help value
            {
                RadioTVPresetList_Pos_string[j][i]          = 0;
                RadioTVPresetList_PresetIndex_string[j][i]  = 0;
                RadioTVPresetList_Waveband_string[j][i]     = 0;
                RadioTVPresetList_Attributes_string[j][i]   = 0;
            }
        }

        i = 0; j = 0; RadioTVPresetListLine = 0; current_CSV_line = 0; //reset values


        getvalue( env_AudioSD_RTPL_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel

        //write( "complete path *.csv: %s", Path_CSV); //debug
        i = 0;

        while ( Path_CSV[i] != 0 ) //scan "path"
        {
            if( Path_CSV[i] == 0x5C) //count "/" to seperate later "path" & "filename"
                count1++;

            //write( "Path[%d] of *.csv: %x",i, Path_CSV[i] ); //debug
            i++;
        }

        i = 0; j = 0; //reset values

        while ( Path_CSV[i] != 0 ) //seperate "path" and "filename"
        {
            if( count2==count1 ) //get filename after last "\"
            {
                gRadioTVPresetList_CSV_filename[j] = Path_CSV[i];
                j++;

                Path_CSV[i] = 0;
            }

            if( Path_CSV[i] == 0x5C) //count "\" to get filename after last "\"
                count2++;

            i++;
        }

        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: path of *.csv: %s", Path_CSV);        //output file path

        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: filename of *.csv: '%s'", gRadioTVPresetList_CSV_filename );  //output filename

        putvalue( env_AudioSD_RTPL_DataSource_file, gRadioTVPresetList_CSV_filename ); //output current loaded *.csv-file on panel

        setFilePath( Path_CSV, 0 ); //set path for *.csv file

        CSVfileHandle = openFileRead( gRadioTVPresetList_CSV_filename, 1 ); //open *.csv ( binary-mode ->get the ASCII/UTF-8 code )

        if( CSVfileHandle!= 0 ) //*.csv file access successful
        {
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: Dateizugriff auf '%s' erfolgreich", gRadioTVPresetList_CSV_filename );    //output result
            putvalue( env_AudioSD_RTPL_DataSource_res, "successful" );   //output result on panel
            Num_of_csv_byte = fileGetBinaryBlock( buffer_byte, elcount( buffer_byte ), CSVfileHandle );//get data from *.csv and store the total number of byte in *.csv-file
            for( i = 0; i <Num_of_csv_byte; i++ ) //copy data into "RadioTVPresetList"
            {
                if( buffer_byte[i] != 0x3B) //read data if no ";" is detected
                {
                    if( buffer_byte[i] == 0x0D && buffer_byte[i + 1] == 0x0A) //nextline in *.csv (next "record element" in RadioTVPresetList ) -> "LF" and "CR" detected -> copy ( transform string -> long ) data from help values in global values
                    {
                        if( current_CSV_line> 0 && RadioTVPresetListLine < AUDIO_RADIOTVPRESETLIST_ENTRIES) //ignore first line in *.csv file
                        {
                            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: " );
                            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "TVPresetList: *******Element %d*******", RadioTVPresetListLine );

                            //transform 'string' to 'long' for "POS", "SourceType", "Waveband" and "Attributes"
                            gRadioTVPresetList_Pos[RadioTVPresetListLine]           =atol( RadioTVPresetList_Pos_string[RadioTVPresetListLine] );
                            gRadioTVPresetList_PresetIndex[RadioTVPresetListLine]   =atol( RadioTVPresetList_PresetIndex_string[RadioTVPresetListLine] );
                            gRadioTVPresetList_Waveband[RadioTVPresetListLine]      =atol( RadioTVPresetList_Waveband_string[RadioTVPresetListLine] );
                            gRadioTVPresetList_Attributes[RadioTVPresetListLine]    =atol( RadioTVPresetList_Attributes_string[RadioTVPresetListLine] );

                            if( boTraceStatus_ON )
                            {
                                writeLineEx( gBAP_Trace, 0, "TVPresetList: Pos[%d]: 0x%x", RadioTVPresetListLine, gRadioTVPresetList_Pos[RadioTVPresetListLine] );
                                writeLineEx( gBAP_Trace, 0, "TVPresetList: PresetIndex[%d]: 0x%x", RadioTVPresetListLine, gRadioTVPresetList_PresetIndex[RadioTVPresetListLine] );
                                writeLineEx( gBAP_Trace, 0, "TVPresetList: Waveband[%d]: 0x%x", RadioTVPresetListLine, gRadioTVPresetList_Waveband[RadioTVPresetListLine] );
                                if( gRadioTVPresetList_Waveband[RadioTVPresetListLine] < 0x0E )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList:  -> '%s'", gRadioTVPresetList_Waveband_s[gRadioTVPresetList_Waveband[RadioTVPresetListLine]] );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList:  -> '%s'", gstring_reserved );

                                writeLineEx( gBAP_Trace, 0, "TVPresetList: Attributes[%d]: 0x%x", RadioTVPresetListLine, gRadioTVPresetList_Attributes[RadioTVPresetListLine] );

                                if( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0x0001 )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit0[%d]: 'IBOC service'", RadioTVPresetListLine );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit0[%d]: 'not an IBOC service'", RadioTVPresetListLine );

                                if( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0x0002 )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit1[%d]: 'DAB secondary service'", RadioTVPresetListLine );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit1[%d]: 'not a DAB secondary service'", RadioTVPresetListLine );

                                if( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0x0004 )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit2[%d]: 'DAB primary service contains secondary service(s )'", RadioTVPresetListLine );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit2[%d]: 'DAB primary service contains no secondary service(s ) / no DAB primary service'", RadioTVPresetListLine );

                                if( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0x0008 )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit3[%d]: 'Online radio secondary service'", RadioTVPresetListLine );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit3[%d]: 'not an online radio secondary service'", RadioTVPresetListLine );

                                if( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0x0010 )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit4[%d]: 'Online radio primary service contains secondary service(s )'", RadioTVPresetListLine );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit4[%d]: 'Online radio primary service contains no secondary service(s ) / no online radio primary service'", RadioTVPresetListLine );

                                if( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0x0020 )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit5[%d]: 'TP available/supported by station'", RadioTVPresetListLine );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit5[%d]: 'TP not available/not supported by station'", RadioTVPresetListLine );

                                if( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0x0040 )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit6[%d]: 'TMC available/supported by station'", RadioTVPresetListLine );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit6[%d]: 'TMC not supported/not available by station'", RadioTVPresetListLine );

                                if( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0x0080 )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit7[%d]: 'SDARS station subscribed or not an SDARS station'", RadioTVPresetListLine );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit7[%d]: 'SDARS station not subscribed'", RadioTVPresetListLine );

                                if( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0x0100 )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit8[%d]: 'Station selectable'", RadioTVPresetListLine );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit8[%d]: 'Station not selectable'", RadioTVPresetListLine );

                                if( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0x0200 )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit9[%d]: 'OnlineRadio muting / low signal'", RadioTVPresetListLine );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit9[%d]: 'OnlineRadio not muted / signal OK'", RadioTVPresetListLine );

                                if( gRadioTVPresetList_Attributes[RadioTVPresetListLine] & 0x0400 )
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit10[%d]: 'Station linked to online radio'", RadioTVPresetListLine );
                                else
                                    writeLineEx( gBAP_Trace, 0, "TVPresetList: Attribues_Bit10[%d]: 'Station not linked to online radio'", RadioTVPresetListLine );

                                writeLineEx( gBAP_Trace, 0, "TVPresetList: Name[%d]: %s", RadioTVPresetListLine, gRadioTVPresetList_Name[RadioTVPresetListLine] );
                            }
                            gRadioTVPresetList_ListEntryValidInformation[RadioTVPresetListLine]  = TRUE;

                            RadioTVPresetListLine++; // -> next line in *.csv (next record element )
                        }

                        current_CSV_line++; //next line in *.csv file
                        element = 0; //start at 'POS' ( first record element of "array data" )
                        j = 0; //reset value
                    }

                    else if( current_CSV_line> 0 && RadioTVPresetListLine < AUDIO_RADIOTVPRESETLIST_ENTRIES) //copy data from "buffer_byte" ( data from *.csv file ) in help values and "name" until end of line is not detected
                    {
                        switch(  element )
                        {
                            case 0: //POS
                                    RadioTVPresetList_Pos_string[RadioTVPresetListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //PresetIndex
                                    RadioTVPresetList_PresetIndex_string[RadioTVPresetListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 2: //Waveband
                                    RadioTVPresetList_Waveband_string[RadioTVPresetListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 3: //Attributes
                                    RadioTVPresetList_Attributes_string[RadioTVPresetListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 4: //Name
                                    gRadioTVPresetList_Name[RadioTVPresetListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            default:
                             break;
                        }
                    }
                }
                else  // ";" is detected ->next record element of "array data"
                {
                    element++;
                    j = 0; //reset value
                }
            }
            if( getValue( env_AudioSD_RTPL_insert_UPD_btn ) == 0x00 )
            gRadioTVPresetList_TotalNumListElements = gRadioTVPresetList_sum =RadioTVPresetListLine; //get "total number of list elements"

            putvalue( env_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements );
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "" );
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "Anzahl der Listenelemente: %d", gRadioTVPresetList_sum); //output total number of list elements
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "" );
            if( fileClose( CSVfileHandle ) != 0 ) //close *.csv file
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "Datei '%s' geschlossen", gRadioTVPresetList_CSV_filename ); //output result
            else
                if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "Fehler beim Schlieen der Datei '%s'", gRadioTVPresetList_CSV_filename );//output result
        }
        else //*.csv file access not successful
        {
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "Fehler beim Dateizugriff auf '%s'", gRadioTVPresetList_CSV_filename ); //output result
            putvalue( env_AudioSD_RTPL_DataSource_res, "not successful" ); //output result
        }
    }
     for( i = 0; i < gRadioTVPresetList_TotalNumListElements; i++ )
    gRTPL_Pos_insDel[i] [0] = gRadioTVPresetList_Pos[i];

    if( getValue( env_AudioSD_RTPL_insert_UPD_btn ) == 0x00 )
    {
        for( i = 0; i < gRadioTVPresetList_TotalNumListElements; i++ )
        gRTPL_Pos_insDel[i] [2] = i + 1;
        gRTPL_totalDELctr = 0;
    }
}

on envVar env_AudioSD_RTPL_CA
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        recordaddress   = getvalue( env_AudioSD_RTPL_AH_RA);
        shift           = getvalue( env_AudioSD_RTPL_AH_shift );
        direction       = getvalue( env_AudioSD_RTPL_AH_dir );
        transmitpos     = getvalue( env_AudioSD_RTPL_AH_POS);
        indexsize       = getvalue( env_AudioSD_RTPL_AH_IS);
        startelement    = getvalue( env_AudioSD_RTPL_AH_start );
        elements        = getvalue( env_AudioSD_RTPL_AH_elements );

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;


        /***Startelement = 0***/
        if( getvalue( env_AudioSD_RTPL_CA_switch ) ) //ArrayData
        {
            if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
            {
                if( FORWARD==direction )  //forward-start
                {
                    valid_startelement = 0;

                    if( AUDIO_RADIOTVPRESETLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES; i++ )
                            {
                                if( 0 != gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                    }
                    else    //2. number of requested elements < elements in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < elements; i++ )
                            {
                                if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                    }
                }                                                               //forward ends

                else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                {
                    //searching for valid startelement
                    for( i = ( AUDIO_RADIOTVPRESETLIST_ENTRIES-1 ); i>= 0; i--)
                    {
                        if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )        //found valid startelement
                        {
                            valid_startelement = i;
                            i = 0;
                        }
                    }

                    //searching for valid elements
                    if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                    else if( 0 ==valid_startelement )
                        valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                        {
                            if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                            if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                               //backward-end
            }                                                                   //startelement == 0 -end
            /***Startelement!= 0***/
            else                                                                //searching for Startelement-ID
            {
                //searching for valid startelement
                for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES; i++ )
                {
                    if( gRadioTVPresetList_Pos[i] == startelement )                        //found a valid element
                    {
                        if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                        {
                            if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                valid_startelement = i + 1-2* direction;

                            else if( i == 0 && BACKWARD==direction )
                                valid_startelement = gRadioTVPresetList_sum;     //valid element is last element in Array

                            else if( i == 0 && FORWARD==direction )
                                valid_startelement = 0;                          //valid element is first element in Array
                        }

                        else
                            valid_startelement = i;                              //found element is valid_startelement

                        i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                    }
                    else
                        valid_startelement = 0xff;
                }
                if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else                                                                //found valid entry for startelement in array
                {
                    //verify number of valid elements
                    if( BACKWARD==direction )                                            //backward-start
                    {
                        if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                            valid_elements= 1;

                        else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                        {
                            for( i =valid_startelement; i>= 0; i--)
                            {
                                if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                        else                                                        //enougth array-elements available
                        {
                            for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                            {
                                if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                    }                                                                //backward-end
                    else                                                            //forward-start
                    {
                        if((valid_startelement+elements )>= AUDIO_RADIOTVPRESETLIST_ENTRIES)
                        {
                            for( i =valid_startelement; i < AUDIO_RADIOTVPRESETLIST_ENTRIES; i++ )
                            {
                                if( 0!= gRadioTVPresetList_Pos[i] )                            //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                            }
                        }
                        else
                        {
                            for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                            {
                                if( 0!= gRadioTVPresetList_Pos[i] )                            //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                            }
                        }
                    }
                }
            }
            putvalue( env_AudioSD_RTPL_AH_elements, valid_elements );

            //send ChangedArray
            RadioTVPresetList_Request( Changed_REQ, 0, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
        }
        else
        {
            //send ChangedArray
            RadioTVPresetList_Request( Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0 );
        }
    }
}

on envVar env_AudioSD_RTPL_DataSource
{
    if( getvalue( this ) == AUDIO_DEFAULT_LIST )
    {
        RadioTVPresetList_init_static();
        putvalue( env_AudioSD_RTPL_DataSource_file, empty_string );
        putvalue( env_AudioSD_RTPL_DataSource_res, empty_string );
    }
}

on envVar env_AudioSD_RTPL_reload //load external RadioTVPresetList from *.csv
{
    byte i;

    if( getvalue( this ) && getvalue( env_AudioSD_RTPL_DataSource ) == AUDIO_EXTERNAL_LIST )

        {
         if( getValue( env_AudioSD_RTPL_insert_UPD_btn )== 0x00 )
         {
             for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES; i++ )
             {
                  gRTPL_Pos_insDel[i] [0] = 0x00;
                  gRTPL_Pos_insDel[i] [1] = 0x00;
                  gRTPL_Pos_insDel[i] [2] = 0x00;
              }
        }
        RadioTVPresetList_init_CSV();
             if( gAudioSD_PowerOnOff == POWER_ON )
            {
                gRTPL_loadReloadFlg = 0x00;
                if( getValue( env_AudioSD_RTPL_insert_UPD_btn )== 0x00 )
                {
                    gRTPL_CSVtotalElem = gRadioTVPresetList_TotalNumListElements;
                    //Clear insert/delete panel
                    putValue( env_AudioSD_RTPL_delete_start, 0 );
                    putValue( env_AudioSD_RTPL_insert_start, 0 );
                    putValue( env_AudioSD_RTPL_insert_start, 0 );
                    putValue( env_AudioSD_RTPL_insert_succr, 0 );
                    putValue( env_AudioSD_RTPL_del_ErrHandler, 1 );
                    putValue( env_AudioSD_RTPL_delete_Message, empty_string );

                    putValue( env_AudioSD_RTPL_insert_ErrHndlr, 1 );
                    putValue( env_AudioSD_RTPL_Insert_Message, empty_string );

                    gRTPL_loadReloadFlg = 0x01;           //for Indexing after Insert
                 }
            //Clearing send buffer
            for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES; i++ )
            {
            gRTPL_Send[i][0] = 0;
            gRTPL_Send[i][1] = 0;
            }
          }// POWER ON
        }// if External list
    else if( getvalue( env_AudioSD_RTPL_DataSource ) != AUDIO_EXTERNAL_LIST )
        putvalue( env_AudioSD_RTPL_DataSource_res, "not successful, select 'external *.csv'" );
}

on envVar env_AudioSD_RTPL_StatusArray
{
    word tnle, requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i, transSuppression;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;
    transSuppression        = getvalue( env_AudioSD_PL_noStatusArray );

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        //get data from Panel
        gRadioTVPresetList_ASGID                = getvalue( env_AudioSD_RTPL_ASGID);
        gRadioTVPresetList_TAID                 = getvalue( env_AudioSD_RTPL_TAID);

        //MR 63332 #3   02.07.2014
        //gRadioTVPresetList_TotalNumListElements = getvalue( env_AudioSD_RTPL_TotalNumLE );

        //MR 63667 11.07.2014 -TNLE with SA-button
        tnle = getvalue( env_AudioSD_RTPL_TotalNumLE );

        recordaddress   = getvalue( env_AudioSD_RTPL_AH_RA);
        shift           = getvalue( env_AudioSD_RTPL_AH_shift );
        direction       = getvalue( env_AudioSD_RTPL_AH_dir );
        transmitpos     = getvalue( env_AudioSD_RTPL_AH_POS);
        indexsize       = getvalue( env_AudioSD_RTPL_AH_IS);
        startelement    = getvalue( env_AudioSD_RTPL_AH_start );
        elements        = getvalue( env_AudioSD_RTPL_AH_elements );

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;

        /***Startelement = 0***/
        if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
        {
            if( FORWARD==direction )  //forward-start
            {
                valid_startelement = 0;

                if( AUDIO_RADIOTVPRESETLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                {
                    if( shift == FALSE )
                    {
                        for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES; i++ )
                        {
                            if( 0 != gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                        }
                    }
                    else if( shift == TRUE )
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if( shift == FALSE )
                    {
                        for( i = 0; i < elements; i++ )
                        {
                            if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                        }
                    }
                    else if( shift == TRUE )
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                }
            }                                                               //forward ends

            else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
            {
                //searching for valid startelement
                for( i = ( AUDIO_RADIOTVPRESETLIST_ENTRIES-1 ); i>= 0; i--)
                {
                    if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )        //found valid startelement
                    {
                        valid_startelement = i;
                        i = 0;
                    }
                }

                //searching for valid elements
                if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else if( 0 ==valid_startelement )
                    valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for( i =valid_startelement; i>= 0; i--)
                    {
                        if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                    {
                        if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
            }                                                               //backward-end
        }                                                                   //startelement == 0 -end

        /***Startelement!= 0***/
        else                                                                //searching for Startelement-ID
        {
            //searching for valid startelement
            for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES; i++ )
            {
                if( gRadioTVPresetList_Pos[i] == startelement )                        //found a valid element
                {
                    if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                    {
                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement = i + 1-2* direction;

                        else if( i == 0 && BACKWARD==direction )
                            valid_startelement = gRadioTVPresetList_sum;     //valid element is last element in Array

                        else if( i == 0 && FORWARD==direction )
                            valid_startelement = 0;                          //valid element is first element in Array
                    }

                    else
                        valid_startelement = i;                              //found element is valid_startelement

                    i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                }
                else
                    valid_startelement = 0xff;
            }

            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
            {
                valid_startelement  = startelement;
                valid_elements      = 0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if( BACKWARD==direction )                                            //backward-start
                {
                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                        valid_elements= 1;

                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                        {
                            if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                            if( 0!= gRadioTVPresetList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements )>= AUDIO_RADIOTVPRESETLIST_ENTRIES)
                    {
                        for( i =valid_startelement; i < AUDIO_RADIOTVPRESETLIST_ENTRIES; i++ )
                        {
                            if( 0!= gRadioTVPresetList_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                        }
                    }
                    else
                    {
                        for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                        {
                            if( 0!= gRadioTVPresetList_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_RADIOTVPRESETLIST_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue( env_AudioSD_RTPL_AH_elements, valid_elements );

        //send StatusArray
    //MR 63667
        if(!transSuppression )
            RadioTVPresetList_Request( Data_REQ, tnle, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
    }
}

TpMemoList_Indication( dword Indication_array [], int datalength )
{
    byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements;
    int i = 0, transSuppression;

    // Init local variables.
    mode = 0;
    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    recordaddress = 0;
    requested_startelement = 0;
    startelement = 0;
    elements = 0;
    valid_startelement = 0xff;
    i = 0;
    valid_elements = 0;
    transSuppression = getvalue( env_AudioSD_TML_noStatusArray );

    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:

            if( getvalue( env_AudioSD_TML_Error_on ) )
            {
                //MR 63667 11.07.2014 -TNLE with SA-button
                //TpMemoList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue( env_AudioSD_TML_ErrorCode ) );
                TpMemoList_Request(Error_REQ, 0, 0, 0, 0, 0, 0, getvalue( env_AudioSD_TML_ErrorCode ) );
            }
            //MR 63336    02.07.2014
            else if( getvalue( env_AudioSD_FctList_0x1B_TimeOut ) == TRUE )
            {
                /* NOP */
            }
            else
            {

                //getData
                gTpMemoList_ASGID = ( gBAP_Indication[3] & 0xF0 ) / 0x10;
                gTpMemoList_TAID = gBAP_Indication[3] & 0x0F;

                //decode BAP-ArrayHeader
                mode = ( gBAP_Indication[4] & 0xF0 ) / 0x10;

                // decode "mode -byte"
                shift = mode & 0x01;
                direction = ( mode & 0x02 ) / 0x02;
                transmitpos = ( mode & 0x04 ) / 0x04;
                indexsize = ( mode & 0x08 ) / 0x08;

                recordaddress = gBAP_Indication[4] & 0x0F;
                if( indexsize )
                {
                    startelement = gBAP_Indication[5];
                    startelement += gBAP_Indication[6] * 0x100;
                    elements = gBAP_Indication[7];
                    elements += gBAP_Indication[8] * 0x100;
                }
                else
                {
                    startelement = gBAP_Indication[5];
                    elements = gBAP_Indication[6];
                }

                requested_startelement = startelement;

                transmitpos = TRUE; //Position must always be sent in the case of *.GetArray.
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + indexsize * 0x08;

                /***Startelement = 0***/
                if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
                {
                    if( FORWARD == direction )  //forward-start
                    {
                        valid_startelement = 0;

                        if( AUDIO_TPMEMOLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                        {
                            if( shift == FALSE )
                            {
                                for( i = 0; i < AUDIO_TPMEMOLIST_ENTRIES; i++ )
                                {
                                    if( 0 != gTpMemoList_ListEntryValidInformation[i] )  //if there is an valid element
                                        valid_elements++;                               //increment elements
                                    else                                                //no valid element, loop finished
                                        i = AUDIO_TPMEMOLIST_ENTRIES;
                                }
                            }
                            else if( shift == TRUE )
                            {
                                valid_startelement = startelement;
                                valid_elements = 0;
                            }
                        }
                        else    //2. number of requested elements < elements in array
                        {
                            if( shift == FALSE )
                            {
                                for( i = 0; i < elements; i++ )
                                {
                                    if( 0 != gTpMemoList_ListEntryValidInformation[i] )      //if there is an valid element
                                        valid_elements++;                               //increment elements
                                    else                                                //no valid element, loop finished
                                        i = AUDIO_TPMEMOLIST_ENTRIES;
                                }
                            }
                            else if( shift == TRUE )
                            {
                                valid_startelement = startelement;
                                valid_elements = 0;
                            }
                        }
                    }                                                               //forward ends

                    else if( BACKWARD == direction && TRUE == shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                    {
                        //searching for valid startelement
                        for( i = ( AUDIO_TPMEMOLIST_ENTRIES - 1 ); i >= 0; i--)
                        {
                            if( 0 != gTpMemoList_ListEntryValidInformation[i] )      //found valid startelement
                            {
                                valid_startelement = i;
                                i = 0;
                            }
                        }

                        //searching for valid elements
                        if( 0xFF == valid_startelement )                             //Startelement-ID doesn't exist in SMSReceived-array
                        {
                            valid_startelement = startelement;
                            valid_elements = 0;
                        }
                        else if( 0 == valid_startelement )
                            valid_elements = 1;                                       //only 1 element because valid startelement is on position 0

                        else if( elements > (valid_startelement + 1 ) )                   //not enougth array-elements available, because array endet at array-position 0
                        {
                            for( i = valid_startelement; i >= 0; i--)
                            {
                                if( 0 != gTpMemoList_ListEntryValidInformation[i] )  //if there is an valid element
                                    valid_elements++;                               //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                        else                                                        //enougth array-elements available
                        {
                            for( i = valid_startelement; i > (valid_startelement - elements ); i--)
                            {
                                if( 0 != gTpMemoList_ListEntryValidInformation[i] )  //if there is an valid element
                                    valid_elements++;                               //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }

                        }
                    }                                                               //backward-end
                }                                                                   //startelement == 0 -end

                /***Startelement!= 0***/
                else                                                                //searching for Startelement-ID
                {
                    //searching for valid startelement
                    for( i = 0; i < AUDIO_TPMEMOLIST_ENTRIES; i++ )
                    {
                        if( gTpMemoList_Pos[i] == startelement )                     //found a valid element
                        {
                            if( shift == TRUE )                                          //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                            {
                                if( i != 0 || BACKWARD != direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                    valid_startelement = i + 1 - 2 * direction;

                                else if( i == 0 && BACKWARD == direction )
                                    valid_startelement = gTpMemoList_sum;        //valid element is last element in Array

                                else if( i == 0 && FORWARD == direction )
                                    valid_startelement = 0;                          //valid element is first element in Array
                            }

                            else
                                valid_startelement = i;                              //found element is valid_startelement

                            i = AUDIO_TPMEMOLIST_ENTRIES;
                        }
                    }

                    if( 0xFF == valid_startelement )                                     //Startelement-ID doesn't exist in array
                    {
                        valid_startelement = startelement;
                        valid_elements = 0;
                    }
                    else                                                                //found valid entry for startelement in array
                    {
                        //verify number of valid elements
                        if( BACKWARD == direction )                                          //backward-start
                        {
                            if( valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                                valid_elements = 1;

                            else if( elements > (valid_startelement + 1 ) )                   //not enougth array-elements available, because array endet at array-position 0
                            {
                                for( i = valid_startelement; i >= 0; i--)
                                {
                                    if( 0 != gTpMemoList_ListEntryValidInformation[i] )  //if there is an valid element
                                        valid_elements++;                               //increment elements
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for( i = valid_startelement; i > (valid_startelement - elements ); i--)
                                {
                                    if( 0 != gTpMemoList_ListEntryValidInformation[i] )  //if there is an valid element
                                        valid_elements++;                               //increment elements
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }
                            }
                        }                                                               //backward-end
                        else                                                            //forward-start
                        {
                            if( (valid_startelement + elements ) >= AUDIO_TPMEMOLIST_ENTRIES)
                            {
                                for( i = valid_startelement; i < AUDIO_TPMEMOLIST_ENTRIES; i++ )
                                {
                                    if( 0 != gTpMemoList_Pos[i] )                        //if there is an valid element
                                        valid_elements++;                               //increment elements
                                    else                                                //no valid element, loop finished
                                        i = AUDIO_TPMEMOLIST_ENTRIES;
                                }
                            }
                            else
                            {
                                for( i = valid_startelement; i < (valid_startelement + elements ); i++ )
                                {
                                    if( 0 != gTpMemoList_Pos[i] )                            //if there is an valid element
                                        valid_elements++;                               //increment elements
                                    else                                                //no valid element, loop finished
                                        i = AUDIO_TPMEMOLIST_ENTRIES;
                                }
                            }
                        }
                    }
                }
                if(!getvalue( env_AudioSD_TML_noStatusArray ) )
                TpMemoList_Request( Data_REQ, mode, gTpMemoList_TotalNumListElements, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
            }
            //Panel
            putvalue( env_AudioSD_SL_ASGID, gTpMemoList_ASGID);
            putvalue( env_AudioSD_SL_TAID, gTpMemoList_TAID);

            break;

        case Error_IND:
            writelineEx( gError_Trace, 0, "TpMemo: FSG_AudioSD TpMemoList_Indication: received error, errorcode:0x%x", Indication_array[3] );
            break;

        default:
            writelineEx( gError_Trace, 0, "TpMemo: FSG_AudioSD TpMemoList_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

TpMemoList_Request( byte request, word tnle, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word TpMemoListLine;

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    TpMemoListLine = 0;
    current_element = 0;
    Offset = 0;

    // decode "mode -byte"
    shift = mode & 0x01;
    direction = ( mode & 0x02 ) / 0x02;
    transmitpos = ( mode & 0x04 ) / 0x04;
    indexsize = ( mode & 0x08 ) / 0x08;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_TPMemoList;         //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;

    switch( request )
    {
        case Changed_REQ:

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff; Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100; Offset++;
                requestarray[Offset] = elements & 0xff; Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100; Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement; Offset++;
                requestarray[Offset] = elements; Offset++;
            }

            TpMemoListLine = startelement;

            if( getvalue( env_AudioSD_TML_CA_switch ) ) //ArrayData
            {
                //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                        while ( current_element < elements )
                        {
                            if( TpMemoListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD TpMemoList_Request: invalid TpMemoListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gTpMemoList_Pos[TpMemoListLine] & 0xFF ); Offset++;
                                        requestarray[Offset] = (( gTpMemoList_Pos[TpMemoListLine] & 0xFF00 ) / 0x100 ); Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gTpMemoList_Pos[TpMemoListLine]; Offset++;
                                    }
                                }
                                requestarray[Offset] = gTpMemoList_Attributes[TpMemoListLine]; Offset++; //Attributes
                                requestarray[Offset] = gTpMemoList_Hour[TpMemoListLine]; Offset++; //MessageTime_Hour
                                requestarray[Offset] = gTpMemoList_Minute[TpMemoListLine]; Offset++; //MessageTime_Minute
                                requestarray[Offset] = strlen( gTpMemoList_StationName[TpMemoListLine] ); Offset++; //StationName
                                for( i = 0; i < strlen( gTpMemoList_StationName[TpMemoListLine] ); i++ )
                                {
                                    requestarray[Offset] = gTpMemoList_StationName[TpMemoListLine][i]; Offset++;
                                }
                            }
                            current_element++;
                            TpMemoListLine = TpMemoList_nextvalidLine( TpMemoListLine, direction );

                        }//end while
                        break;

                    case 1: //Attributes, MessageTime_Hour, MessageTime_Minute, StationName
                        while ( current_element < elements )
                        {
                            if( TpMemoListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD TpMemoList_Request: invalid TpMemoListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gTpMemoList_Pos[TpMemoListLine] & 0xFF ); Offset++;
                                        requestarray[Offset] = (( gTpMemoList_Pos[TpMemoListLine] & 0xFF00 ) / 0x100 ); Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gTpMemoList_Pos[TpMemoListLine]; Offset++;
                                    }
                                }

                                //Attributes
                                requestarray[Offset] = gTpMemoList_Attributes[TpMemoListLine] & 0xFF;
                                Offset++;

                                //MessageTime_Hour
                                requestarray[Offset] = gTpMemoList_Hour[TpMemoListLine];
                                Offset++;

                                //MessageTime_Minute
                                requestarray[Offset] = gTpMemoList_Minute[TpMemoListLine];
                                Offset++;
                            }
                            current_element++;
                            TpMemoListLine = TpMemoList_nextvalidLine( TpMemoListLine, direction );
                        }//end while
                        break;

                    case 15: //Pos
                        while ( current_element < elements )
                        {
                            if( TpMemoListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD TpMemoList_Request: invalid TpMemoListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gTpMemoList_Pos[TpMemoListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gTpMemoList_Pos[TpMemoListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gTpMemoList_Pos[TpMemoListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            TpMemoListLine = TpMemoList_nextvalidLine( TpMemoListLine, direction );
                        }//end while
                        break;

                    default:
                        write( "AudioSD TpMemoList_Request: invalid recordaddress %d", recordaddress );
                        break;
                } //end switch "recordaddress"

            }//end 'ArrayData'

            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            break; //end Changed_REQ

        case Data_REQ:
            //IssueList #62
            //MR 63336    02.07.2014
        //if( getValue( env_AudioSD_FctList_0x1B_TimeOut ) != TRUE )
            if( /*getValue( env_AudioSD_FctList_0x1B_TimeOut ) != */ TRUE )
            {
            //VAGH-10511
            ASGID = gTpMemoList_ASGID;
            TAID = gTpMemoList_TAID;
            if( getvalue( env_AudioSD_TML_ASGID_Error ) != FALSE )
            {
                ASGID += 0x2;
            }
            if( getvalue( env_AudioSD_TML_TAID_Error ) != FALSE )
            {
                TAID += 0x02;
            }
            requestarray[Offset] = (( ASGID * 0x10 ) & 0xF0 ) + ( TAID & 0x0F );
            Offset++;
            //MR 63667 11.07.2014 -TNLE with SA-button
            //requestarray[Offset] = gTpMemoList_TotalNumListElements;
            requestarray[Offset] = tnle;

            Offset++;

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            TpMemoListLine = startelement;

            //copy data
            switch( recordaddress )
            {
                case 0: //complete record
                    while ( current_element < elements )
                    {
                        if( TpMemoListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD TpMemoList_Request: invalid TpMemoListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if( transmitpos ) // Pos  ->Array position transmitted
                            {
                                if( indexsize )
                                {
                                    requestarray[Offset] = ( gTpMemoList_Pos[TpMemoListLine] & 0xFF );
                                    Offset++;
                                    requestarray[Offset] = (( gTpMemoList_Pos[TpMemoListLine] & 0xFF00 ) / 0x100 );
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gTpMemoList_Pos[TpMemoListLine];
                                    Offset++;
                                }
                            }

                            //Attributes
                            requestarray[Offset] = gTpMemoList_Attributes[TpMemoListLine] & 0xFF;
                            Offset++;

                            //MessageTime_Hour
                            requestarray[Offset] = gTpMemoList_Hour[TpMemoListLine];
                            Offset++;

                            //MessageTime_Minute
                            requestarray[Offset] = gTpMemoList_Minute[TpMemoListLine];
                            Offset++;

                            //StationName
                            requestarray[Offset] = strlen( gTpMemoList_StationName[TpMemoListLine] );
                            Offset++;

                            for( i = 0; i < strlen( gTpMemoList_StationName[TpMemoListLine] ); i++ )
                            {
                                requestarray[Offset] = gTpMemoList_StationName[TpMemoListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        TpMemoListLine = TpMemoList_nextvalidLine( TpMemoListLine, direction );

                    }//end while

                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                    break;

                case 1: //Attributes, MessageTime_Hour, MessageTime_Minute, StationName
                    while ( current_element < elements )
                    {
                        if( TpMemoListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD TpMemoList_Request: invalid TpMemoListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if( transmitpos ) // Pos  ->Array position transmitted
                            {
                                if( indexsize )
                                {
                                    requestarray[Offset] = ( gTpMemoList_Pos[TpMemoListLine] & 0xFF );
                                    Offset++;
                                    requestarray[Offset] = (( gTpMemoList_Pos[TpMemoListLine] & 0xFF00 ) / 0x100 );
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gTpMemoList_Pos[TpMemoListLine];
                                    Offset++;
                                }
                            }

                            //Attributes
                            requestarray[Offset] = gTpMemoList_Attributes[TpMemoListLine] & 0xFF;
                            Offset++;

                            //MessageTime_Hour
                            requestarray[Offset] = gTpMemoList_Hour[TpMemoListLine];
                            Offset++;

                            //MessageTime_Minute
                            requestarray[Offset] = gTpMemoList_Minute[TpMemoListLine];
                            Offset++;
                        }
                        current_element++;
                        TpMemoListLine = TpMemoList_nextvalidLine( TpMemoListLine, direction );
                    }//end while

                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                    break;

                case 15: //Pos
                    while ( current_element < elements )
                    {
                        if( TpMemoListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD TpMemoList_Request: invalid TpMemoListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if( transmitpos ) // Pos  ->Array position transmitted
                            {
                                if( indexsize )
                                {
                                    requestarray[Offset] = ( gTpMemoList_Pos[TpMemoListLine] & 0xFF );
                                    Offset++;
                                    requestarray[Offset] = (( gTpMemoList_Pos[TpMemoListLine] & 0xFF00 ) / 0x100 );
                                    Offset++;
                                }
                                else
                                {
                                    requestarray[Offset] = gTpMemoList_Pos[TpMemoListLine];
                                    Offset++;
                                }
                            }
                        }
                        current_element++;
                        TpMemoListLine = TpMemoList_nextvalidLine( TpMemoListLine, direction );

                    }//end while

                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                    break;

                default:
                    write( "AudioSD TpMemoList_Request: invalid recordaddress %d", recordaddress );
                    break;
            } //end switch "recordaddress"
            } //end if for IssueList#62
            break; //end Data_REQ

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break; //end Error_REQ

    } //end switch "request"
}

byte TpMemoList_nextvalidLine( byte current_TpMemoListLine, byte direction )
{
    byte next_TpMemoListLine;
    int i;

    //init lokal variables
    next_TpMemoListLine = 0;
    i = 0;

    //search next "list entry"
    if( (( gTpMemoList_sum - 1 ) == current_TpMemoListLine && FORWARD == direction ) || ( 0 == current_TpMemoListLine && BACKWARD == direction ) )    //last-/fist-element of array reached
        next_TpMemoListLine = 0xFF;
    else
    {
        next_TpMemoListLine = current_TpMemoListLine + 1 - 2 * direction;       //increment or decrement array-line ( depends on direction );

        if( 0 == gTpMemoList_ListEntryValidInformation[next_TpMemoListLine] )    // check if next element is "valid"
            next_TpMemoListLine = 0xff;
    }

    return (next_TpMemoListLine );
}

TpMemoList_init_static()
{
    byte j, i, TpMemoListLine;

    //clear
    TpMemoListLine = 0;
    gTpMemoList_sum = 0;

    for( j = 0; j < AUDIO_TPMEMOLIST_ENTRIES; j++ )
    {
        gTpMemoList_Pos[j] = 0;

        gTpMemoList_Attributes_MessageNew_Bit0[j] = 0;
        gTpMemoList_Attributes[j] = 0;

        gTpMemoList_Hour[j] = 0;

        gTpMemoList_Minute[j] = 0;

        gTpMemoList_ListEntryValidInformation[j] = 0;

        for( i = 0; i < AUDIO_TPMEMOLIST_STATIONNAME_LENGTH; i++ )
            gTpMemoList_StationName[j][i] = 0;
    }

    //entry 0
    gTpMemoList_ListEntryValidInformation[TpMemoListLine] = TRUE;
    gTpMemoList_Pos[TpMemoListLine] = 0x57;

    gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine] = TRUE;
    gTpMemoList_Attributes[TpMemoListLine] = gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine];

    gTpMemoList_Hour[TpMemoListLine] = 12;

    gTpMemoList_Minute[TpMemoListLine] = 04;

    strncpy( gTpMemoList_StationName[TpMemoListLine], "StationName_0", AUDIO_TPMEMOLIST_STATIONNAME_LENGTH);
    TpMemoListLine++;

    //entry 1
    gTpMemoList_ListEntryValidInformation[TpMemoListLine] = TRUE;
    gTpMemoList_Pos[TpMemoListLine] = 0x31;

    gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine] = FALSE;
    gTpMemoList_Attributes[TpMemoListLine] = gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine];

    gTpMemoList_Hour[TpMemoListLine] = 08;

    gTpMemoList_Minute[TpMemoListLine] = 05;

    strncpy( gTpMemoList_StationName[TpMemoListLine], "StationName_1", AUDIO_TPMEMOLIST_STATIONNAME_LENGTH);
    TpMemoListLine++;

    //entry 2
    gTpMemoList_ListEntryValidInformation[TpMemoListLine] = TRUE;
    gTpMemoList_Pos[TpMemoListLine] = 0x87;

    gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine] = TRUE;
    gTpMemoList_Attributes[TpMemoListLine] = gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine];

    gTpMemoList_Hour[TpMemoListLine] = 01;

    gTpMemoList_Minute[TpMemoListLine] = 03;

    strncpy( gTpMemoList_StationName[TpMemoListLine], "StationName_2", AUDIO_TPMEMOLIST_STATIONNAME_LENGTH);
    TpMemoListLine++;

    //entry 3
    gTpMemoList_ListEntryValidInformation[TpMemoListLine] = TRUE;
    gTpMemoList_Pos[TpMemoListLine] = 0x64;

    gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine] = FALSE;
    gTpMemoList_Attributes[TpMemoListLine] = gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine];

    gTpMemoList_Hour[TpMemoListLine] = 09;

    gTpMemoList_Minute[TpMemoListLine] = 55;

    strncpy( gTpMemoList_StationName[TpMemoListLine], "StationName_3", AUDIO_TPMEMOLIST_STATIONNAME_LENGTH);
    TpMemoListLine++;

    //entry 4
    gTpMemoList_ListEntryValidInformation[TpMemoListLine] = TRUE;
    gTpMemoList_Pos[TpMemoListLine] = 0x01;

    gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine] = FALSE;
    gTpMemoList_Attributes[TpMemoListLine] = gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine];

    gTpMemoList_Hour[TpMemoListLine] = 08;

    gTpMemoList_Minute[TpMemoListLine] = 59;

    strncpy( gTpMemoList_StationName[TpMemoListLine], "StationName_4", AUDIO_TPMEMOLIST_STATIONNAME_LENGTH);
    TpMemoListLine++;

    //entry 5
    gTpMemoList_ListEntryValidInformation[TpMemoListLine] = TRUE;
    gTpMemoList_Pos[TpMemoListLine] = 0x08;

    gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine] = TRUE;
    gTpMemoList_Attributes[TpMemoListLine] = gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine];

    gTpMemoList_Hour[TpMemoListLine] = 04;

    gTpMemoList_Minute[TpMemoListLine] = 44;

    strncpy( gTpMemoList_StationName[TpMemoListLine], "StationName_5", AUDIO_TPMEMOLIST_STATIONNAME_LENGTH);
    TpMemoListLine++;

    //entry 6
    gTpMemoList_ListEntryValidInformation[TpMemoListLine] = TRUE;
    gTpMemoList_Pos[TpMemoListLine] = 0x66;

    gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine] = FALSE;
    gTpMemoList_Attributes[TpMemoListLine] = gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine];

    gTpMemoList_Hour[TpMemoListLine] = 06;

    gTpMemoList_Minute[TpMemoListLine] = 15;

    strncpy( gTpMemoList_StationName[TpMemoListLine], "StationName_6", AUDIO_TPMEMOLIST_STATIONNAME_LENGTH);
    TpMemoListLine++;

    //entry 7
    gTpMemoList_ListEntryValidInformation[TpMemoListLine] = TRUE;
    gTpMemoList_Pos[TpMemoListLine] = 0x84;

    gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine] = FALSE;
    gTpMemoList_Attributes[TpMemoListLine] = gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine];

    gTpMemoList_Hour[TpMemoListLine] = 07;

    gTpMemoList_Minute[TpMemoListLine] = 77;

    strncpy( gTpMemoList_StationName[TpMemoListLine], "StationName_7", AUDIO_TPMEMOLIST_STATIONNAME_LENGTH);
    TpMemoListLine++;

    //entry 8
    gTpMemoList_ListEntryValidInformation[TpMemoListLine] = TRUE;
    gTpMemoList_Pos[TpMemoListLine] = 0x25;

    gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine] = FALSE;
    gTpMemoList_Attributes[TpMemoListLine] = gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine];

    gTpMemoList_Hour[TpMemoListLine] = 03;

    gTpMemoList_Minute[TpMemoListLine] = 39;

    strncpy( gTpMemoList_StationName[TpMemoListLine], "StationName_8", AUDIO_TPMEMOLIST_STATIONNAME_LENGTH);
    TpMemoListLine++;

    //entry 9
    gTpMemoList_ListEntryValidInformation[TpMemoListLine] = TRUE;
    gTpMemoList_Pos[TpMemoListLine] = 0x62;

    gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine] = TRUE;
    gTpMemoList_Attributes[TpMemoListLine] = gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine];

    gTpMemoList_Hour[TpMemoListLine] = 05;

    gTpMemoList_Minute[TpMemoListLine] = 16;

    strncpy( gTpMemoList_StationName[TpMemoListLine], "StationName_9", AUDIO_TPMEMOLIST_STATIONNAME_LENGTH);
    TpMemoListLine++;

    //entry 10
    gTpMemoList_ListEntryValidInformation[TpMemoListLine] = TRUE;
    gTpMemoList_Pos[TpMemoListLine] = 0x39;

    gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine] = TRUE;
    gTpMemoList_Attributes[TpMemoListLine] = gTpMemoList_Attributes_MessageNew_Bit0[TpMemoListLine];

    gTpMemoList_Hour[TpMemoListLine] = 10;

    gTpMemoList_Minute[TpMemoListLine] = 12;

    strncpy( gTpMemoList_StationName[TpMemoListLine], "StationName_10", AUDIO_TPMEMOLIST_STATIONNAME_LENGTH);
    TpMemoListLine++;

    gTpMemoList_sum = TpMemoListLine;
    gTpMemoList_TotalNumListElements = gTpMemoList_sum;

    //write Array in "write -window"
    if( boTraceStatus_ON )
    {
        writelineEx( gBAP_Trace, 0, "TpMemo: " );
        writelineEx( gBAP_Trace, 0, "TpMemo: *******Default TpMemoList_Array*******" );
        writelineEx( gBAP_Trace, 0, "TpMemo: " );

        for( i = 0; i < gTpMemoList_sum; i++ )
        {
            writelineEx( gBAP_Trace, 0, "TpMemo: *******Element %d*******", i);

            writelineEx( gBAP_Trace, 0, "TpMemo: Pos[%d]: 0x%x", i, gTpMemoList_Pos[i] );

            if( gTpMemoList_Attributes[i] & 0x01 )
                writelineEx( gBAP_Trace, 0, "TpMemo: Attribues_Bit0[%d]: 'message is not new'", i);
            else
                writelineEx( gBAP_Trace, 0, "TpMemo: Attribues_Bit0[%d]: 'new message'", i);

            writelineEx( gBAP_Trace, 0, "TpMemo: MessageTime_Hour[%d]: %d", i, gTpMemoList_Hour[i] );

            writelineEx( gBAP_Trace, 0, "TpMemo: MessageTime_Minute[%d]: %d", i, gTpMemoList_Minute[i] );

            writelineEx( gBAP_Trace, 0, "TpMemo: StationName[%d]: '%s'", i, gTpMemoList_StationName[i] );
            writelineEx( gBAP_Trace, 0, "TpMemo: " );
        }

        writelineEx( gBAP_Trace, 0, "TpMemo: Anzahl der Listenelemente: %d", gTpMemoList_sum);
    }
    putvalue( env_AudioSD_TML_TotalNumLE, gTpMemoList_TotalNumListElements );
}

TpMemoList_init_CSV() //Byte & file selection
{
    dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, current_CSV_line = 0, count1 = 0, count2 = 0;
    char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
    byte TpMemoListLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
    char TpMemoList_Pos_string[AUDIO_TPMEMOLIST_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8 ) code in the *.csv
    char TpMemoList_Attributes_string[AUDIO_TPMEMOLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Attributes" is stored in the ASCII(UTF-8 ) code in the *.csv
    char TpMemoList_Hour_string[AUDIO_TPMEMOLIST_ENTRIES][AUDIO_TEXTLENGTH];       //help value ->"MessageTime_Hour" is stored in the ASCII(UTF-8 ) code in the *.csv
    char TpMemoList_Minute_string[AUDIO_TPMEMOLIST_ENTRIES][AUDIO_TEXTLENGTH];     //help value ->"MessageTime_Minute" is stored in the ASCII(UTF-8 ) code in the *.csv

    if( getvalue( env_AudioSD_TML_DataSource ) == AUDIO_EXTERNAL_LIST ) //output data in write window "FSGTpMemoList"
    {
        if( boTraceStatus_ON )
        {
            writelineEx( gBAP_Trace, 0, "TpMemo: *******External TpMemoList*******" );
            writelineEx( gBAP_Trace, 0, "TpMemo: " );
            writelineEx( gBAP_Trace, 0, "TpMemo: **********************Start load new TpMemoList**********************" );
        }
        //clear
        for( j = 0; j < AUDIO_TPMEMOLIST_ENTRIES; j++ )
        {
            gTpMemoList_Pos[j]                          = 0;

            gTpMemoList_Attributes_MessageNew_Bit0[j]   = 0;
            gTpMemoList_Attributes[j]                   = 0;

            gTpMemoList_Hour[j]                         = 0;

            gTpMemoList_Minute[j]                       = 0;

            gTpMemoList_ListEntryValidInformation[j]    = 0;

            for( i = 0; i < AUDIO_TPMEMOLIST_STATIONNAME_LENGTH; i++ )
                gTpMemoList_StationName[j][i] = 0;
        }

        for( i = 0; i < AUDIO_FILENAME_SIZE; i++ ) //clear "filename"
            gTpMemoList_CSV_filename[i] = 0;

        for( j = 0; j < AUDIO_TPMEMOLIST_ENTRIES; j++ ) //clear "buffer"
        {
            buffer_string[j]    = 0;
            buffer_byte[j]      = 0;

            for( i = 0; i < AUDIO_TEXTLENGTH; i++ ) //clear help value
            {
                TpMemoList_Pos_string[j][i]          = 0;
                TpMemoList_Attributes_string[j][i]   = 0;
                TpMemoList_Hour_string[j][i]         = 0;
                TpMemoList_Minute_string[j][i]       = 0;
            }
        }

        i = 0; j = 0; TpMemoListLine = 0; current_CSV_line = 0; //reset values


        getvalue( env_AudioSD_TML_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel

//write( "complete path *.csv: %s", Path_CSV); //debug

i = 0;

        while ( Path_CSV[i] != 0 ) //scan "path"
        {
            if( Path_CSV[i] == 0x5C) //count "/" to seperate later "path" & "filename"
                count1++;

            //write( "Path[%d] of *.csv: %x",i, Path_CSV[i] ); //debug
            i++;
        }

        i = 0; j = 0; //reset values

        while ( Path_CSV[i] != 0 ) //seperate "path" and "filename"
        {
            if( count2==count1 ) //get filename after last "\"
            {
                gTpMemoList_CSV_filename[j] = Path_CSV[i];
                j++;

                Path_CSV[i] = 0;
            }

            if( Path_CSV[i] == 0x5C) //count "\" to get filename after last "\"
                count2++;

            i++;
        }

        writelineEx( gBAP_Trace, 0, "TpMemo: path of *.csv: %s", Path_CSV);        //output file path

        writelineEx( gBAP_Trace, 0, "TpMemo: filename of *.csv: '%s'", gTpMemoList_CSV_filename );  //output filename

        putvalue( env_AudioSD_TML_DataSource_file, gTpMemoList_CSV_filename ); //output current loaded *.csv-file on panel

        setFilePath( Path_CSV, 0 ); //set path for *.csv file

        CSVfileHandle =openFileRead( gTpMemoList_CSV_filename,1 ); //open *.csv ( binary-mode ->get the ASCII/UTF-8 code )

        if( CSVfileHandle!= 0 ) //*.csv file access successful
        {
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "TpMemo: Dateizugriff auf '%s' erfolgreich", gTpMemoList_CSV_filename );    //output result


            putvalue( env_AudioSD_TML_DataSource_res, "successful" );   //output result on panel

            Num_of_csv_byte = fileGetBinaryBlock( buffer_byte, elcount( buffer_byte ), CSVfileHandle );//get data from *.csv and store the total number of byte in *.csv-file

            for( i = 0; i <Num_of_csv_byte; i++ ) //copy data into "TpMemoList"
            {
                if( buffer_byte[i] != 0x3B) //read data if no ";" is detected
                {
                    if( buffer_byte[i] == 0x0D && buffer_byte[i + 1] == 0x0A) //nextline in *.csv (next "record element" in TpMemoList ) -> "LF" and "CR" detected -> copy ( transform string -> long ) data from help values in global values
                    {
                        if( current_CSV_line> 0 && TpMemoListLine < AUDIO_TPMEMOLIST_ENTRIES) //ignore first line in *.csv file
                        {
                            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "TpMemo: " );
                            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "TpMemo: *******Element %d*******", TpMemoListLine );

                            //transform 'string' to 'long' for "POS", "SourceType", "Waveband" and "Attributes"
                            gTpMemoList_Pos[TpMemoListLine]           =atol( TpMemoList_Pos_string[TpMemoListLine] );
                            gTpMemoList_Attributes[TpMemoListLine]    =atol( TpMemoList_Attributes_string[TpMemoListLine] );
                            gTpMemoList_Hour[TpMemoListLine]          =atol( TpMemoList_Hour_string[TpMemoListLine] );
                            gTpMemoList_Minute[TpMemoListLine]        =atol( TpMemoList_Minute_string[TpMemoListLine] );
                            if( boTraceStatus_ON )
                            {
                                writelineEx( gBAP_Trace, 0, "TpMemo: Pos[%d]: 0x%x", TpMemoListLine, gTpMemoList_Pos[TpMemoListLine] );
                                writelineEx( gBAP_Trace, 0, "TpMemo: Attributes[%d]: 0x%x", TpMemoListLine, gTpMemoList_Attributes[TpMemoListLine] );
                                if( gTpMemoList_Attributes[TpMemoListLine] & 0x01 )
                                    writelineEx( gBAP_Trace, 0, "TpMemo: Attribues_Bit0[%d]: 'new message'", TpMemoListLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "TpMemo: Attribues_Bit0[%d]: 'message is not new'", TpMemoListLine );
                                writelineEx( gBAP_Trace, 0, "TpMemo: MessageTime_Hour[%d]: 0x%x", TpMemoListLine, gTpMemoList_Hour[TpMemoListLine] );
                                writelineEx( gBAP_Trace, 0, "TpMemo: MessageTime_Minute[%d]: 0x%x", TpMemoListLine, gTpMemoList_Minute[TpMemoListLine] );
                                writelineEx( gBAP_Trace, 0, "TpMemo: StationName[%d]: %s", TpMemoListLine, gTpMemoList_StationName[TpMemoListLine] );
                            }
                            gTpMemoList_ListEntryValidInformation[TpMemoListLine]  = TRUE;

                            TpMemoListLine++; // -> next line in *.csv (next record element )
                        }

                        current_CSV_line++; //next line in *.csv file
                        element = 0; //start at 'POS' ( first record element of "array data" )
                        j = 0; //reset value
                    }

                    else if( current_CSV_line> 0 && TpMemoListLine < AUDIO_TPMEMOLIST_ENTRIES) //copy data from "buffer_byte" ( data from *.csv file ) in help values and "name" until end of line is not detected
                    {
                        switch(  element )
                        {
                            case 0: //POS
                                    TpMemoList_Pos_string[TpMemoListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 1: //Attributes
                                    TpMemoList_Attributes_string[TpMemoListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 2: //MessageTime_Hour
                                    TpMemoList_Hour_string[TpMemoListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 3: //MessageTime_Minute
                                    TpMemoList_Minute_string[TpMemoListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            case 4: //StationName
                                    gTpMemoList_StationName[TpMemoListLine][j] =buffer_byte[i];
                                    j++;
                             break;

                            default:
                             break;
                        }
                    }
                }

                else  // ";" is detected ->next record element of "array data"
                {
                    element++;
                    j = 0; //reset value
                }
            }
            gTpMemoList_TotalNumListElements = gTpMemoList_sum = TpMemoListLine; //get "total number of list elements"
            putvalue( env_AudioSD_TML_TotalNumLE, gTpMemoList_TotalNumListElements );
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "TpMemo: " );
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "TpMemo: Anzahl der Listenelemente: %d", gTpMemoList_sum); //output total number of list elements
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "TpMemo: " );
            if( fileClose( CSVfileHandle ) != 0 ) //close *.csv file
                { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "TpMemo: Datei '%s' geschlossen", gTpMemoList_CSV_filename ); } //output result }
            else
                { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "TpMemo: Fehler beim Schlieen der Datei '%s'", gTpMemoList_CSV_filename ); }//output result }
        }
        else //*.csv file access not successful
        {
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "TpMemo: Fehler beim Dateizugriff auf '%s'", gTpMemoList_CSV_filename ); //output result
            putvalue( env_AudioSD_TML_DataSource_res, "not successful" ); //output result
        }
    }
}

on envVar env_AudioSD_TML_CA
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        recordaddress   = getvalue( env_AudioSD_TML_AH_RA);
        shift           = getvalue( env_AudioSD_TML_AH_shift );
        direction       = getvalue( env_AudioSD_TML_AH_dir );
        transmitpos     = getvalue( env_AudioSD_TML_AH_POS);
        indexsize       = getvalue( env_AudioSD_TML_AH_IS);
        startelement    = getvalue( env_AudioSD_TML_AH_start );
        elements        = getvalue( env_AudioSD_TML_AH_elements );

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;


        /***Startelement = 0***/
        if( getvalue( env_AudioSD_TML_CA_switch ) ) //ArrayData
        {
            if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
            {
                if( FORWARD==direction )  //forward-start
                {
                    valid_startelement = 0;

                    if( AUDIO_TPMEMOLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < AUDIO_TPMEMOLIST_ENTRIES; i++ )
                            {
                                if( 0 != gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_TPMEMOLIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                    }
                    else    //2. number of requested elements < elements in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < elements; i++ )
                            {
                                if( 0!= gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_TPMEMOLIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                    }
                }                                                               //forward ends

                else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                {
                    //searching for valid startelement
                    for( i = ( AUDIO_TPMEMOLIST_ENTRIES-1 ); i>= 0; i--)
                    {
                        if( 0!= gTpMemoList_ListEntryValidInformation[i] )        //found valid startelement
                        {
                            valid_startelement = i;
                            i = 0;
                        }
                    }

                    //searching for valid elements
                    if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                    else if( 0 ==valid_startelement )
                        valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                        {
                            if( 0!= gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                            if( 0!= gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                               //backward-end
            }                                                                   //startelement == 0 -end

            /***Startelement!= 0***/
            else                                                                //searching for Startelement-ID
            {
                //searching for valid startelement
                for( i = 0; i < AUDIO_TPMEMOLIST_ENTRIES; i++ )
                {
                    if( gTpMemoList_Pos[i] == startelement )                        //found a valid element
                    {
                        if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                        {
                            if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                valid_startelement = i + 1-2* direction;

                            else if( i == 0 && BACKWARD==direction )
                                valid_startelement = gTpMemoList_sum;     //valid element is last element in Array

                            else if( i == 0 && FORWARD==direction )
                                valid_startelement = 0;                          //valid element is first element in Array
                        }

                        else
                            valid_startelement = i;                              //found element is valid_startelement

                        i = AUDIO_TPMEMOLIST_ENTRIES;
                    }
                    else
                        valid_startelement = 0xff;
                }

                if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else                                                                //found valid entry for startelement in array
                {
                    //verify number of valid elements
                    if( BACKWARD==direction )                                            //backward-start
                    {
                        if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                            valid_elements= 1;

                        else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                        {
                            for( i =valid_startelement; i>= 0; i--)
                            {
                                if( 0!= gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                        else                                                        //enougth array-elements available
                        {
                            for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                            {
                                if( 0!= gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                    }                                                                //backward-end
                    else                                                            //forward-start
                    {
                        if((valid_startelement+elements )>= AUDIO_TPMEMOLIST_ENTRIES)
                        {
                            for( i =valid_startelement; i < AUDIO_TPMEMOLIST_ENTRIES; i++ )
                            {
                                if( 0!= gTpMemoList_Pos[i] )                            //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_TPMEMOLIST_ENTRIES;
                            }
                        }
                        else
                        {
                            for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                            {
                                if( 0!= gTpMemoList_Pos[i] )                            //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_TPMEMOLIST_ENTRIES;
                            }
                        }
                    }
                }
            }
            putvalue( env_AudioSD_TML_AH_elements, valid_elements );

            //send ChangedArray
            TpMemoList_Request( Changed_REQ, 0, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
        }
        else
        {
            //send ChangedArray
            TpMemoList_Request( Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0 );
        }
    }
}

on envVar env_AudioSD_TML_DataSource
{
    if( getvalue( this ) == AUDIO_DEFAULT_LIST )
    {
        TpMemoList_init_static();
        putvalue( env_AudioSD_TML_DataSource_file, empty_string );
        putvalue( env_AudioSD_TML_DataSource_res, empty_string );
    }
}

on envVar env_AudioSD_TML_reload //load external TpMemoList from *.csv
{
    if( getvalue( this ) && getvalue( env_AudioSD_TML_DataSource ) == AUDIO_EXTERNAL_LIST )

        TpMemoList_init_CSV();

    else if( getvalue( env_AudioSD_TML_DataSource ) != AUDIO_EXTERNAL_LIST )
        putvalue( env_AudioSD_TML_DataSource_res, "not successful, select 'external *.csv'" );
}

on envVar env_AudioSD_TML_StatusArray
{
    //MR 63667
    word tnle, requested_startelement, startelement, elements, valid_startelement, valid_elements;
byte mode, shift, direction, transmitpos, indexsize, recordaddress;
int i, transSuppression;

// Init local variables.
mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;
    transSuppression        = getvalue( env_AudioSD_TML_noStatusArray );

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        //get data from Panel
        gTpMemoList_ASGID                = getvalue( env_AudioSD_TML_ASGID);
gTpMemoList_TAID                 = getvalue( env_AudioSD_TML_TAID);

        //MR 63332 #3   02.07.2014
        //gTpMemoList_TotalNumListElements = getvalue( env_AudioSD_TML_TotalNumLE );

        //MR 63667 11.07.2014 -TNLE with SA-button
        tnle = getvalue( env_AudioSD_TML_TotalNumLE );

recordaddress   = getvalue( env_AudioSD_TML_AH_RA);
shift           = getvalue( env_AudioSD_TML_AH_shift );
direction       = getvalue( env_AudioSD_TML_AH_dir );
transmitpos     = getvalue( env_AudioSD_TML_AH_POS);
indexsize       = getvalue( env_AudioSD_TML_AH_IS);
startelement    = getvalue( env_AudioSD_TML_AH_start );
elements        = getvalue( env_AudioSD_TML_AH_elements );

mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;

        /***Startelement = 0***/
        if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
        {
            if( FORWARD==direction )  //forward-start
            {
                valid_startelement = 0;

                if( AUDIO_TPMEMOLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                {
                    if( shift == FALSE )
                    {
                        for( i = 0; i < AUDIO_TPMEMOLIST_ENTRIES; i++ )
                        {
                            if( 0 != gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_TPMEMOLIST_ENTRIES;
                        }
                    }
                    else if( shift == TRUE )
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if( shift == FALSE )
                    {
                        for( i = 0; i < elements; i++ )
                        {
                            if( 0!= gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i = AUDIO_TPMEMOLIST_ENTRIES;
                        }
                    }
                    else if( shift == TRUE )
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                }
            }                                                               //forward ends

            else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
            {
                //searching for valid startelement
                for( i = ( AUDIO_TPMEMOLIST_ENTRIES-1 ); i>= 0; i--)
                {
                    if( 0!= gTpMemoList_ListEntryValidInformation[i] )        //found valid startelement
                    {
                        valid_startelement = i;
                        i = 0;
                    }
                }

                //searching for valid elements
                if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else if( 0 ==valid_startelement )
                    valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for( i =valid_startelement; i>= 0; i--)
                    {
                        if( 0!= gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                    {
                        if( 0!= gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
            }                                                               //backward-end
        }                                                                   //startelement == 0 -end

        /***Startelement!= 0***/
        else                                                                //searching for Startelement-ID
        {
            //searching for valid startelement
            for( i = 0; i < AUDIO_TPMEMOLIST_ENTRIES; i++ )
            {
                if( gTpMemoList_Pos[i] == startelement )                        //found a valid element
                {
                    if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                    {
                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement = i + 1-2* direction;

                        else if( i == 0 && BACKWARD==direction )
                            valid_startelement = gTpMemoList_sum;     //valid element is last element in Array

                        else if( i == 0 && FORWARD==direction )
                            valid_startelement = 0;                          //valid element is first element in Array
                    }

                    else
                        valid_startelement = i;                              //found element is valid_startelement

                    i = AUDIO_TPMEMOLIST_ENTRIES;
                }
                else
                    valid_startelement = 0xff;
            }

            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
            {
                valid_startelement  = startelement;
                valid_elements      = 0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if( BACKWARD==direction )                                            //backward-start
                {
                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                        valid_elements= 1;

                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                        {
                            if( 0!= gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                            if( 0!= gTpMemoList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements )>= AUDIO_TPMEMOLIST_ENTRIES)
                    {
                        for( i =valid_startelement; i < AUDIO_TPMEMOLIST_ENTRIES; i++ )
                        {
                            if( 0!= gTpMemoList_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_TPMEMOLIST_ENTRIES;
                        }
                    }
                    else
                    {
                        for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                        {
                            if( 0!= gTpMemoList_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_TPMEMOLIST_ENTRIES;
                        }
                    }
                }
            }
        }
        putvalue( env_AudioSD_TML_AH_elements, valid_elements );

        //send StatusArray
        if(!transSuppression )
            TpMemoList_Request( Data_REQ, mode, tnle, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
    }
}

on timer DAC_MethodHandling_Timer
{
    switch(  gAudioSD_DAC_MethodHandling )
    {
      case 1:
                if( gAudioSD_DAC_ControlType == AUDIO_DAC_SELECT_LIST_ENTRY)
                {
                    //IssueList #72 & IssueList #108
                    if( ( gAudioSD_DAC_ListType == AUDIO_DAC_RECEPTIONLIST ) && ( gAudioSD_DAC_Result != AUDIO_DAC_NOTSUCCESSFUL) )
                    {
                    gAudioSD_CSIhandle_FSGhandle = gAudioSD_DAC_FSGHandle;
                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    }

                    //IssueList #72
                    if( gAudioSD_DAC_ListType == AUDIO_DAC_RADIOTVPRESETLIST )
                    {
                    gAudioSD_CSIhandle_PresetListRef = gAudioSD_DAC_FSGHandle;
                    }

                     //IssueList #103
                    if( gAudioSD_DAC_ListType == AUDIO_DAC_MEDIABROWSER)
                    {
                    gAudioSD_CSIhandle_FSGhandle = gAudioSD_DAC_FSGHandle;
                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    }



                    get_AbsolutePos();
                }


        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
        gAudioSD_DAC_MethodHandling = 0;
      break;
      case 2:
        CurrentStationInfo_Request( Data_REQ, 0 );    //send status
        gAudioSD_DAC_MethodHandling = 0;
      break;
      case 3:
        if( gAudioSD_DAC_status == TRUE )
        {
            CurrentStationInfo_Request( Data_REQ, 0 );    //send status
            gAudioSD_DAC_MethodHandling = 3;
            settimer( DAC_MethodHandling_Timer, 250 );
        }
      break;
      default:
      break;
    }
}

on timer AnnouncementEscape_MethodHandling_Timer
{
    switch(  gAudioSD_AnnouncementEscape_MethodHandling )
    {
        case 1:
                //IssueList #123 - only if result = successful
                if( gAudioSD_AnnouncementEscape_Result == AUDIO_ANNOUNCEMENTESCAPE_SUCCESSFUL)
                {
                gAudioSD_AnnouncementInfo_Type = ANNOUNCEMENT_TYPE_NO_MESSAGE;
                putvalue( env_AudioSD_AnInfo_Type, gAudioSD_AnnouncementInfo_Type );

                AnnouncementInfo_Request( Data_REQ, 0 );    //send status
                gAudioSD_AnnouncementEscape_MethodHandling = 0;
                }
         break;

        default:
         break;
    }
}

on timer StartFSG_Timer
{
    gAudioSD_FSG_OperationState_OpState = FSGOPERATIONSTATE_NORMALOPERATION;
    putvalue( env_AudioSD_FSGOpState_OpState, gAudioSD_FSG_OperationState_OpState );


    FSG_OperationState_Request( Data_REQ, 0 );    //send status
}

on envVar env_AudioSD_ErrorGen_ErrorCode
{
    putvalue( env_AudioSD_ErrorGen_ErrorCode_h, getvalue( this ) );
}

on envVar env_AudioSD_ErrorGen_send
{
    dword requestarray[BAP_BUFFER_SIZE], FctID, Errorcode;
int i;

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;
    FctID       = 0;
    Errorcode   = 0;

    if( getvalue( this ) )
    {
        FctID       = getvalue( env_AudioSD_ErrorGen_FctID);
Errorcode   = getvalue( env_AudioSD_ErrorGen_ErrorCode_h );

requestarray[0] = LSG_AudioSD;        //LSG-ID
        requestarray[1] = FctID;             //Fct.-ID
        requestarray[2] = Error_REQ;         //request type:Error
        requestarray[3] = Errorcode;         //Errorcode
    }

    set_status_requestbuffer( requestarray, 4, Bap_Error );
}

byte MediaBrowser_nextvalidLine( byte current_MediaBrowserLine, byte direction )
{
  byte next_MediaBrowserLine;
  int i;

  //init lokal variables
  next_MediaBrowserLine = 0;
  i = 0;

  //search next "list entry"
  if( (( gMediaBrowser_sum - 1 ) == current_MediaBrowserLine && FORWARD == direction ) || ( 0 == current_MediaBrowserLine && BACKWARD == direction ) )  //last-/fist-element of array reached
      next_MediaBrowserLine = 0xFF;
  else
  {
      next_MediaBrowserLine = current_MediaBrowserLine + 1 - 2 * direction;       //increment or decrement array-line ( depends on direction );

      if( 0 == gMediaBrowser_ListEntryValidInformation[next_MediaBrowserLine] )    // check if next element is "valid"
          next_MediaBrowserLine = 0xff;
  }
  return (next_MediaBrowserLine );
}

void MediaBrowser_init_static()
{
    byte j, i, MediaBrowserLine;

    //clear
    MediaBrowserLine = 0;
    gMediaBrowser_sum = 0;

    for( j = 0; j < AUDIO_MEDIABROWSER_ENTRIES; j++ )
    {
      gMediaBrowser_Pos[j] = 0;
      gMediaBrowser_FileType[j] = 0;

      gMediaBrowser_FileState_emptyFolder_Bit0[j] = 0;
      gMediaBrowser_FileState_DRM_Bit1[j] = 0;
      gMediaBrowser_FileState_FileCorrupted_Bit2[j] = 0;
      gMediaBrowser_FileState_DeadLink_Bit3[j] = 0;
      gMediaBrowser_FileState_ImportFinished_Bit4[j] = 0;
      gMediaBrowser_FileState_ImportPending_Bit5[j] = 0;
      gMediaBrowser_FileState_ImportPlayable_Bit6[j] = 0;
      gMediaBrowser_FileState[j] = 0;

      gMediaBrowser_ListEntryValidInformation[j] = 0;

      for( i = 0; i < AUDIO_MEDIABROWSER_FILENAME_LENGTH; i++ )
        gMediaBrowser_FileName[j][i] = 0;
    }

    //entry 0
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0x10FE;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_ITEM;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_0", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 1
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0xD0AB;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_SONG;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_1", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 2
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0x21;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_DVDMAIN;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_2", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 3
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0x34;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_NOTSUPPORTED;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_3", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 4
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0x1234;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_DVDCHAPTER;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_4", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 5
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0xEA;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_YEAR;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_5", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 6
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0x9874;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_VOICEMEMO;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_6", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 7
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0x7410;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_IMAGEFILE;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_7", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 8
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0xBC87;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_UNKNOWNCAT;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_8", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 9
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0x7610;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_CATCOPMPOSER;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_9", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 10
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0x02;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_CATCOMPOSERS;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_10", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 11
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0x9741;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_DYNPLAYLIST_2;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_11", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    //entry 12
    gMediaBrowser_ListEntryValidInformation[MediaBrowserLine] = TRUE;
    gMediaBrowser_Pos[MediaBrowserLine] = 0xFDA2;
    gMediaBrowser_FileType[MediaBrowserLine] = AUDIO_MEDIABROWSER_FILETYPE_CATALL;

    gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] = FALSE;
    gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] = TRUE;
    gMediaBrowser_FileState[MediaBrowserLine] = gMediaBrowser_FileState_emptyFolder_Bit0[MediaBrowserLine] + ( gMediaBrowser_FileState_DRM_Bit1[MediaBrowserLine] * 0x02 ) + ( gMediaBrowser_FileState_FileCorrupted_Bit2[MediaBrowserLine] * 0x04 ) + ( gMediaBrowser_FileState_DeadLink_Bit3[MediaBrowserLine] * 0x08 ) + ( gMediaBrowser_FileState_ImportFinished_Bit4[MediaBrowserLine] * 0x10 ) + ( gMediaBrowser_FileState_ImportPending_Bit5[MediaBrowserLine] * 0x20 ) + ( gMediaBrowser_FileState_ImportPlayable_Bit6[MediaBrowserLine] * 0x40 );

    strncpy( gMediaBrowser_FileName[MediaBrowserLine], "FileName_12", AUDIO_MEDIABROWSER_FILENAME_LENGTH);
    MediaBrowserLine++;

    gMediaBrowser_sum = MediaBrowserLine;
    gMediaBrowser_TotalNumListElements = gMediaBrowser_sum;
    if( boTraceStatus_ON )
    {
        //write Array in "write -window"
        writeClear( gBAP_Trace);
        writelineEx( gBAP_Trace, 0, "MediaBrowser: " );
        writelineEx( gBAP_Trace, 0, "MediaBrowser: *******Default MediaBrowser_Array*******" );
        writelineEx( gBAP_Trace, 0, "MediaBrowser: " );

        for( i = 0; i < gMediaBrowser_sum; i++ )
        {
            writelineEx( gBAP_Trace, 0, "MediaBrowser: *******Element %d*******", i);

            writelineEx( gBAP_Trace, 0, "MediaBrowser: Pos[%d]: 0x%x", i, gMediaBrowser_Pos[i] );

            writelineEx( gBAP_Trace, 0, "MediaBrowser: FileType[%d]: 0x%x", i, gMediaBrowser_FileType[i] );
            if( gMediaBrowser_FileType[i] < 0x67)
                writeEx( gBAP_Trace, 0, "MediaBrowser:  -> '%s'", gMediaBrowser_FileType_s[gMediaBrowser_FileType[i]] );
            else if( gMediaBrowser_FileType[i] == 0xFF )
                writeEx( gBAP_Trace, 0, "MediaBrowser:  -> '%s'", gstring_not_supported );
            else
                writeEx( gBAP_Trace, 0, "MediaBrowser:  -> '%s'", gstring_reserved );

            if( gMediaBrowser_FileState[i] & 0x01 )
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit0[%d]: 'not an empty folder'", i);
            else
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit0[%d]: 'empty folder'", i);

            if( gMediaBrowser_FileState[i] & 0x02 )
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit1[%d]: 'DRM proteced'", i);
            else
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit1[%d]: 'not DRM proteced'", i);

            if( gMediaBrowser_FileState[i] & 0x04 )
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit2[%d]: 'corrupted file/folder'", i);
            else
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit2[%d]: 'file/folder is not corrupted'", i);

            if( gMediaBrowser_FileState[i] & 0x08 )
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit3[%d]: 'dead link'", i);
            else
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit3[%d]: 'not a dead link'", i);

            if( gMediaBrowser_FileState[i] & 0x10 )
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit4[%d]: 'import running'", i);
            else
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit4[%d]: 'import finished / unknown import state'", i);

            if( gMediaBrowser_FileState[i] & 0x20 )
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit5[%d]: 'import pending'", i);
            else
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit5[%d]: 'import not pending'", i);

            if( gMediaBrowser_FileState[i] & 0x40 )
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit6[%d]: 'import not playable'", i);
            else
                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit6[%d]: 'import playable / not an import'", i);

            writelineEx( gBAP_Trace, 0, "MediaBrowser: FileName[%d]: '%s'", i, gMediaBrowser_FileName[i] );
            writelineEx( gBAP_Trace, 0, "MediaBrowser: " );
        }
        writelineEx( gBAP_Trace, 0, "MediaBrowser: Anzahl der Listenelemente: %d", gMediaBrowser_sum);
    }
    putvalue( env_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements );
}

on envVar env_AudioSD_MB_CA
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        if( getvalue( env_AudioSD_MB_AH_start ) >255 && getvalue( env_AudioSD_MB_AH_IS) == 0 ) // check if 8 or 16 bit
            putvalue( env_AudioSD_MB_AH_IS,1 );

        //get data from Panel
        recordaddress   = getvalue( env_AudioSD_MB_AH_RA);
        shift           = getvalue( env_AudioSD_MB_AH_shift );
        direction       = getvalue( env_AudioSD_MB_AH_dir );
        transmitpos     = getvalue( env_AudioSD_MB_AH_POS);
        indexsize       = getvalue( env_AudioSD_MB_AH_IS);
        startelement    = getvalue( env_AudioSD_MB_AH_start );
        elements        = getvalue( env_AudioSD_MB_AH_elements );

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;


        /***Startelement = 0***/
        if( getvalue( env_AudioSD_MB_CA_switch ) ) //ArrayData
        {
            if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
            {
                if( FORWARD==direction )  //forward-start
                {
                    valid_startelement = 0;

                    if( AUDIO_MEDIABROWSER_ENTRIES <= elements ) //1. more elements requested, than in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
                            {
                                if( 0 != gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_MEDIABROWSER_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                    }
                    else    //2. number of requested elements < elements in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < elements; i++ )
                            {
                                if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_MEDIABROWSER_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }

                    }
                }                                                               //forward ends

                else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                {
                    //searching for valid startelement
                    for( i = ( AUDIO_MEDIABROWSER_ENTRIES-1 ); i>= 0; i--)
                    {
                        if( 0!= gMediaBrowser_ListEntryValidInformation[i] )        //found valid startelement
                        {
                            valid_startelement = i;
                            i = 0;
                        }
                    }

                    //searching for valid elements
                    if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                    else if( 0 ==valid_startelement )
                        valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                        {
                            if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                            if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                               //backward-end
            }                                                                   //startelement == 0 -end

            /***Startelement!= 0***/
            else                                                                //searching for Startelement-ID
            {
                //searching for valid startelement
                for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
                {
                    if( gMediaBrowser_Pos[i] == startelement )                        //found a valid element
                    {
                        if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                        {
                            if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                valid_startelement = i + 1-2* direction;

                            else if( i == 0 && BACKWARD==direction )
                                valid_startelement = gMediaBrowser_sum;     //valid element is last element in Array

                            else if( i == 0 && FORWARD==direction )
                                valid_startelement = 0;                          //valid element is first element in Array
                        }

                        else
                            valid_startelement = i;                              //found element is valid_startelement

                        i = AUDIO_MEDIABROWSER_ENTRIES;
                    }
                    else
                        valid_startelement = 0xff;
                }

                if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else                                                                //found valid entry for startelement in array
                {
                    //verify number of valid elements
                    if( BACKWARD==direction )                                            //backward-start
                    {
                        if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                            valid_elements= 1;

                        else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                        {
                            for( i =valid_startelement; i>= 0; i--)
                            {
                                if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                        else                                                        //enougth array-elements available
                        {
                            for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                            {
                                if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                    }                                                                //backward-end
                    else                                                            //forward-start
                    {
                        if((valid_startelement+elements )>= AUDIO_MEDIABROWSER_ENTRIES)
                        {
                            for( i =valid_startelement; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
                            {
                                if( 0!= gMediaBrowser_Pos[i] )                            //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_MEDIABROWSER_ENTRIES;
                            }
                        }
                        else
                        {
                            for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                            {
                                if( 0!= gMediaBrowser_Pos[i] )                            //if there is an valid element
                                    valid_elements++;                                //increment elements
                                else                                                //no valid element, loop finished
                                    i = AUDIO_MEDIABROWSER_ENTRIES;
                            }
                        }
                    }
                }
            }
            putvalue( env_AudioSD_MB_AH_elements, valid_elements );

            //send ChangedArray
            MediaBrowser_Request( Changed_REQ, 0, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
        }
        else
        {
            //send ChangedArray
            MediaBrowser_Request( Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0 );
        }
    }
}

on envVar env_AudioSD_MB_DataSource
{
    if( getvalue( this ) == AUDIO_DEFAULT_LIST )
    {
        MediaBrowser_init_static();
        putvalue( env_AudioSD_MB_DataSource_file, empty_string );
        putvalue( env_AudioSD_MB_DataSource_result, empty_string );
    }
}

on envVar env_AudioSD_MB_reload //load external MediaBrowser from *.csv
{
    //IssueList #76 - MR49870 : MediaBrowser
    byte i;
    if( getvalue( this ) && getvalue( env_AudioSD_MB_DataSource ) == AUDIO_EXTERNAL_LIST )
        {
         if( getValue( env_AudioSD_MB_insert_UPD_button )== 0x00 )
         {
             for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
             {
              gMediaBrowser_Pos_insDel[i] [0] = 0x00;
              gMediaBrowser_Pos_insDel[i] [1] = 0x00;
              gMediaBrowser_Pos_insDel[i] [2] = 0x00;
              }
        }
         MediaBrowser_init_CSV();
            //IssueList #76 - MR49870 : MediaBrowser
             if( gAudioSD_PowerOnOff == POWER_ON )
            {
                gMB_loadReloadFlg = 0x00;
                if( getValue( env_AudioSD_MB_insert_UPD_button )== 0x00 )
                {
                    //MR 63332 #3   02.07.2014
                    //gMediaBrowser_TotalNumListElements = getValue( env_AudioSD_MB_TotalNumLE );

                    gMB_CSVtotalElem = gMediaBrowser_TotalNumListElements;
                    //Clear insert/delete panel
                    putValue( env_AudioSD_MB_delete_start, 0 );
                    putValue( env_AudioSD_MB_insert_start, 0 );
                    putValue( env_AudioSD_MB_insert_start, 0 );
                    putValue( env_AudioSD_MB_insert_successor, 0 );
                    putValue( env_AudioSD_MB_delete_ErrHandler, 1 );
                    putValue( env_AudioSD_MB_delete_Message, empty_string );

                    putValue( env_AudioSD_MB_insert_ErrHandler, 1 );
                    putValue( env_AudioSD_MB_Insert_Message, empty_string );

                    gMB_loadReloadFlg = 0x01;           //for Indexing after Insert

                    gAudioSD_CSIhandle_FSGhandle               = 0x1;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos   = 0x1;


                 }
            //Clearing send buffer
            for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
            {
            gMediaBrowser_Send[i][0] = 0;
            gMediaBrowser_Send[i][1] = 0;
            }
          }// POWER ON

        }// if External list


    else if( getvalue( env_AudioSD_MB_DataSource ) != AUDIO_EXTERNAL_LIST )
        putvalue( env_AudioSD_MB_DataSource_result, "not successful, select 'external *.csv'" );
}

on envVar env_AudioSD_MB_StatusArray
{
  //MR 63667
  word tnle, requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i, transSuppression;

  // Init local variables.
  mode                    = 0;
  shift                   = 0;
  direction               = 0;
  transmitpos             = 0;
  indexsize               = 0;
  recordaddress           = 0;
  requested_startelement  = 0;
  startelement            = 0;
  elements                = 0;
  valid_startelement      = 0;
  i                       = 0;
  valid_elements          = 0;
  transSuppression        = getvalue( env_AudioSD_MB_noStatusArray );

  if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
    if( getvalue( env_AudioSD_MB_AH_start ) >255 && getvalue( env_AudioSD_MB_AH_IS) == 0 ) // check if 8 or 16 bit
        putvalue( env_AudioSD_MB_AH_IS,1 );

    //get data from Panel
    gMediaBrowser_ASGID                = getvalue( env_AudioSD_MB_ASGID);
    gMediaBrowser_TAID                 = getvalue( env_AudioSD_MB_TAID);
    gMediaBrowser_ActiveListPos        = getvalue( env_AudioSD_MB_ActiveListPos );
        //MR 63332 #3   02.07.2014
        //gMediaBrowser_TotalNumListElements = getvalue( env_AudioSD_MB_TotalNumLE );

        //MR 63667 11.07.2014 -TNLE with SA-button
        tnle = getvalue( env_AudioSD_MB_TotalNumLE );

    recordaddress   = getvalue( env_AudioSD_MB_AH_RA);
    shift           = getvalue( env_AudioSD_MB_AH_shift );
    direction       = getvalue( env_AudioSD_MB_AH_dir );
    transmitpos     = getvalue( env_AudioSD_MB_AH_POS);
    indexsize       = getvalue( env_AudioSD_MB_AH_IS);
    startelement    = getvalue( env_AudioSD_MB_AH_start );
    elements        = getvalue( env_AudioSD_MB_AH_elements );

    mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

    requested_startelement = startelement;

    /***Startelement = 0***/
    if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
        {
      if( FORWARD==direction )  //forward-start
            {
        valid_startelement = 0;

        if( AUDIO_MEDIABROWSER_ENTRIES <= elements ) //1. more elements requested, than in array
                {
          if( shift == FALSE )
          {
            for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
                        {
                          if( 0 != gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                              i = AUDIO_MEDIABROWSER_ENTRIES;
                      }
          }
          else if( shift == TRUE )
          {
            valid_startelement  = startelement;
                  valid_elements      = 0;
          }
              }
        else    //2. number of requested elements < elements in array
                {
          if( shift == FALSE )
          {
                      for( i = 0; i < elements; i++ )
                        {
                          if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                            i = AUDIO_MEDIABROWSER_ENTRIES;
                      }
          }
          else if( shift == TRUE )
          {
            valid_startelement  = startelement;
                      valid_elements      = 0;
          }
                }
      }
      else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
            {
              //searching for valid startelement
                for( i = ( AUDIO_MEDIABROWSER_ENTRIES-1 ); i>= 0; i--)
                {
                  if( 0!= gMediaBrowser_ListEntryValidInformation[i] )        //found valid startelement
                    {
                      valid_startelement = i;
                        i = 0;
                    }
                }
        //searching for valid elements
                if( 0xff ==valid_startelement ) //Startelement-ID doesn't exist in SMSReceived-array
                {
                  valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else if( 0 ==valid_startelement )
                  valid_elements= 1;//only 1 element because valid startelement is on position 0
                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                {
                  for( i =valid_startelement; i>= 0; i--)
                    {
                      if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                          valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                          i = 0;
                  }
                }
        else                                                        //enougth array-elements available
                {
                  for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                    {
                      if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                          valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
        }                                                               //backward-end
    }
    /***Startelement!= 0***/
    else                                                                //searching for Startelement-ID
        {
          //searching for valid startelement
            for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
            {
                if( gMediaBrowser_Pos[i] == startelement )                        //found a valid element
                {
          if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                    {
                      if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                          valid_startelement = i + 1-2* direction;
            else if( i == 0 && BACKWARD==direction )
              valid_startelement = gMediaBrowser_sum;     //valid element is last element in Array
            else if( i == 0 && FORWARD==direction )
              valid_startelement = 0;                          //valid element is first element in Array
          }
          else
            valid_startelement = i;                              //found element is valid_startelement
                    i = AUDIO_MEDIABROWSER_ENTRIES;
                }
        else
          valid_startelement = 0xff;
            }

            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
            {
                valid_startelement  = startelement;
                valid_elements      = 0;
            }
            else                                                                //found valid entry for startelement in array
            {
              //verify number of valid elements
                if( BACKWARD==direction )                                            //backward-start
                {
                  if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                      valid_elements= 1;
                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                  {
                      for( i =valid_startelement; i>= 0; i--)
                      {
                          if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
              else                                                //no valid element, loop finished
                              i = 0;
                        }
                  }
                    else                                                        //enougth array-elements available
                    {
                      for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                          if( 0!= gMediaBrowser_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                  if((valid_startelement+elements )>= AUDIO_MEDIABROWSER_ENTRIES)
                    {
                      for( i =valid_startelement; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
                        {
                          if( 0!= gMediaBrowser_Pos[i] )                            //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                              i = AUDIO_MEDIABROWSER_ENTRIES;
                        }
                    }
                    else
                    {
                      for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                        {
                          if( 0!= gMediaBrowser_Pos[i] )                            //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                              i = AUDIO_MEDIABROWSER_ENTRIES;
                        }
                    }
                }
            }
        }
    putvalue( env_AudioSD_MB_AH_elements, valid_elements );

    //send StatusArray
    if(!transSuppression )
        MediaBrowser_Request( Data_REQ, tnle, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
  }
}

void MediaBrowser_init_CSV() //Byte & file selection
{
    dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, current_CSV_line = 0, count1 = 0, count2 = 0;
    char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
    byte MediaBrowserLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
    char MediaBrowser_Pos_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8 ) code in the *.csv
    char MediaBrowser_FileType_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"FileType" is stored in the ASCII(UTF-8 ) code in the *.csv
    char MediaBrowser_FileState_string[AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"FileState" is stored in the ASCII(UTF-8 ) code in the *.csv

    //BAP_MOST sync StationArt
    char MediaBrowser_SourceType_string [AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];
    char MediaBrowser_StationArt_string [AUDIO_MEDIABROWSER_ENTRIES][AUDIO_TEXTLENGTH];
    if( getvalue( env_AudioSD_MB_DataSource ) == AUDIO_EXTERNAL_LIST ) //output data in write window "FSGMediaBrowser"
    {
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: *******External MediaBrowser*******" );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: " );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: **********************Start load new MediaBrowser**********************" );

        //clear
        for( j = 0; j < AUDIO_MEDIABROWSER_ENTRIES; j++ )
        {
            gMediaBrowser_Pos[j]                            = 0;
            gMediaBrowser_FileType[j]                       = 0;

            gMediaBrowser_FileState_emptyFolder_Bit0[j]     = 0;
            gMediaBrowser_FileState_DRM_Bit1[j]             = 0;
            gMediaBrowser_FileState_FileCorrupted_Bit2[j]   = 0;
            gMediaBrowser_FileState_DeadLink_Bit3[j]        = 0;
            gMediaBrowser_FileState_ImportFinished_Bit4[j]  = 0;
            gMediaBrowser_FileState_ImportPending_Bit5[j]   = 0;
            gMediaBrowser_FileState_ImportPlayable_Bit6[j]  = 0;
            gMediaBrowser_FileState[j]                      = 0;

            gMediaBrowser_ListEntryValidInformation[j] = 0;

            //BAP_MOST sync StationArt
            gMediaBrowserSourceType[j] = 0;
            gMediaBrowserStationArtType[j] = 0;
            for( i = 0; i < AUDIO_MEDIABROWSER_FILENAME_LENGTH; i++ )
                gMediaBrowser_FileName[j][i] = 0;
        }

        for( i = 0; i < AUDIO_FILENAME_SIZE; i++ ) //clear "filename"
            gMediaBrowser_CSV_filename[i] = 0;

        for( j = 0; j < AUDIO_MEDIABROWSER_ENTRIES; j++ ) //clear "buffer"
        {
            buffer_string[j]    = 0;
            buffer_byte[j]      = 0;

            //BAP_MOST sync StationArt
            //tagging the POS and index per PictureFile
            gMediaBrowser_PictureFileIndex[j] [0]        = 0;
            gMediaBrowser_PictureFileIndex[j] [1]        = 0;
            for( i = 0; i < AUDIO_TEXTLENGTH; i++ ) //clear help value
            {
                MediaBrowser_Pos_string[j][i]       = 0;
                MediaBrowser_FileType_string[j][i]  = 0;
                MediaBrowser_FileState_string[j][i] = 0;
                //BAP_MOST sync StationArt
                MediaBrowser_SourceType_string[j][i] = 0;
                MediaBrowser_StationArt_string[j][i] = 0;
            }
            //BAP_MOST sync StationArt
            for( i = 0; i < AUDIO_MEDIABROWSER_PICFILE_LENGTH; i++ )
            gMediaBrowser_PictureFile[j][i] = 0;
        }

        i = 0; j = 0; MediaBrowserLine = 0; current_CSV_line = 0; //reset values
        getvalue( env_AudioSD_MB_CSVPath, Path_CSV); //get filename & path of *.csv-file from Panel
        i = 0;
        while ( Path_CSV[i] != 0 ) //scan "path"
        {
            if( Path_CSV[i] == 0x5C) //count "/" to seperate later "path" & "filename"
            count1++;
            //write( "Path[%d] of *.csv: %x",i, Path_CSV[i] ); //debug
            i++;
        }
        i = 0; j = 0; //reset values
        while ( Path_CSV[i] != 0 ) //seperate "path" and "filename"
        {
            if( count2==count1 ) //get filename after last "\"
            {
                gMediaBrowser_CSV_filename[j] = Path_CSV[i];
                j++;
                Path_CSV[i] = 0;
            }

            if( Path_CSV[i] == 0x5C) //count "\" to get filename after last "\"
            count2++;
            i++;
        }
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: path of *.csv: %s", Path_CSV);        //output file path
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: filename of *.csv: '%s'", gMediaBrowser_CSV_filename );  //output filename
        putvalue( env_AudioSD_MB_DataSource_file, gMediaBrowser_CSV_filename ); //output current loaded *.csv-file on panel
        setFilePath( Path_CSV, 0 ); //set path for *.csv file
        CSVfileHandle =openFileRead( gMediaBrowser_CSV_filename,1 ); //open *.csv ( binary-mode ->get the ASCII/UTF-8 code )
        if( CSVfileHandle!= 0 ) //*.csv file access successful
        {
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: Dateizugriff auf '%s' erfolgreich", gMediaBrowser_CSV_filename );    //output result
            putvalue( env_AudioSD_MB_DataSource_result, "successful" );   //output result on panel
            Num_of_csv_byte = fileGetBinaryBlock( buffer_byte, elcount( buffer_byte ), CSVfileHandle );//get data from *.csv and store the total number of byte in *.csv-file
            for( i = 0; i <Num_of_csv_byte; i++ ) //copy data into "MediaBrowser"
            {
                if( buffer_byte[i] != 0x3B) //read data if no ";" is detected
                {
                    if( buffer_byte[i] == 0x0D && buffer_byte[i + 1] == 0x0A) //nextline in *.csv (next "record element" in MediaBrowser ) -> "LF" and "CR" detected -> copy ( transform string -> long ) data from help values in global values
                    {
                        if( current_CSV_line> 0 && MediaBrowserLine < AUDIO_MEDIABROWSER_ENTRIES) //ignore first line in *.csv file
                        {
                            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: " );
                            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: *******Element %d*******", MediaBrowserLine );

                            //transform 'string' to 'long' for "POS", "FileType" and "FileState"
                            gMediaBrowser_Pos[MediaBrowserLine]         =atol(MediaBrowser_Pos_string[MediaBrowserLine] );
                            gMediaBrowser_FileType[MediaBrowserLine]    =atol(MediaBrowser_FileType_string[MediaBrowserLine] );
                            gMediaBrowser_FileState[MediaBrowserLine]   =atol(MediaBrowser_FileState_string[MediaBrowserLine] );
                            //BAP_MOST sync StationArt
                            gMediaBrowserSourceType[MediaBrowserLine]   =atol(MediaBrowser_SourceType_string[MediaBrowserLine] );
                            gMediaBrowserStationArtType[MediaBrowserLine] =atol(MediaBrowser_StationArt_string[MediaBrowserLine] );

                            //POS
                            gMediaBrowser_PictureFileIndex[MediaBrowserLine][0] = gMediaBrowser_Pos[MediaBrowserLine];
                            //index
                            gMediaBrowser_PictureFileIndex[MediaBrowserLine][1] = MediaBrowserLine;

                            if( boTraceStatus_ON )
                            {
                                writelineEx( gBAP_Trace, 0, "MediaBrowser: Pos[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_Pos[MediaBrowserLine] );
                                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileType[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_FileType[MediaBrowserLine] );
                                if( gMediaBrowser_FileType[MediaBrowserLine] < 0x67)
                                    writeEx( gBAP_Trace, 0, "MediaBrowser:  -> '%s'", gMediaBrowser_FileType_s[gMediaBrowser_FileType[MediaBrowserLine]] );
                                else if( gMediaBrowser_FileType[MediaBrowserLine] == 0xFF )
                                    writeEx( gBAP_Trace, 0, "MediaBrowser:  -> '%s'", gstring_not_supported );
                                else
                                    writeEx( gBAP_Trace, 0, "MediaBrowser:  -> '%s'", gstring_reserved );

                                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState[%d]: 0x%x", MediaBrowserLine, gMediaBrowser_FileState[MediaBrowserLine] );

                                if( gMediaBrowser_FileState[MediaBrowserLine] & 0x01 )
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit0[%d]: 'empty folder'", MediaBrowserLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit0[%d]: 'not an empty folder'", MediaBrowserLine );

                                if( gMediaBrowser_FileState[MediaBrowserLine] & 0x02 )
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit1[%d]: 'DRM proteced'", MediaBrowserLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit1[%d]: 'not DRM proteced'", MediaBrowserLine );

                                if( gMediaBrowser_FileState[MediaBrowserLine] & 0x04 )
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit2[%d]: 'corrupted file/folder'", MediaBrowserLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit2[%d]: 'file/folder is not corrupted'", MediaBrowserLine );

                                if( gMediaBrowser_FileState[MediaBrowserLine] & 0x08 )
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit3[%d]: 'dead link'", MediaBrowserLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit3[%d]: 'not a dead link'", MediaBrowserLine );

                                if( gMediaBrowser_FileState[MediaBrowserLine] & 0x10 )
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit4[%d]: 'import running'", MediaBrowserLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit4[%d]: 'import finished / unknown import state'", MediaBrowserLine );

                                if( gMediaBrowser_FileState[MediaBrowserLine] & 0x20 )
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit5[%d]: 'import pending'", MediaBrowserLine );
                                else
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit5[%d]: 'import not pending'", MediaBrowserLine );

                                if( gMediaBrowser_FileState[MediaBrowserLine] & 0x40 )
                                    writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit6[%d]: 'import not playable'", MediaBrowserLine );
                                else
                                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileState_Bit6[%d]: 'import playable / not an import'", MediaBrowserLine );
                                writelineEx( gBAP_Trace, 0, "MediaBrowser: FileName[%d]: %s", MediaBrowserLine, gMediaBrowser_FileName[MediaBrowserLine] );
                            }
                            gMediaBrowser_ListEntryValidInformation[MediaBrowserLine]  = TRUE;

                            MediaBrowserLine++; // -> next line in *.csv (next record element )
                        }
                        current_CSV_line++; //next line in *.csv file
                        element = 0; //start at 'POS' ( first record element of "array data" )
                        j = 0; //reset value
                    }
                    else if( current_CSV_line> 0 && MediaBrowserLine < AUDIO_MEDIABROWSER_ENTRIES) //copy data from "buffer_byte" ( data from *.csv file ) in help values and "name" until end of line is not detected
                    {
                        switch(  element )
                        {
                            case 0: //POS
                                      MediaBrowser_Pos_string[MediaBrowserLine][j] =buffer_byte[i]; j++; break;
                            case 1: //FileType
                                      MediaBrowser_FileType_string[MediaBrowserLine][j] =buffer_byte[i]; j++; break;
                            case 2: //FileState
                                      MediaBrowser_FileState_string[MediaBrowserLine][j] =buffer_byte[i]; j++; break;
                            case 3: //FileName
                                      gMediaBrowser_FileName[MediaBrowserLine][j] =buffer_byte[i]; j++; break;
                                      //BAP_MOST sync StationArt
                            case 4: //SourceType
                                      MediaBrowser_SourceType_string[MediaBrowserLine][j] =buffer_byte[i]; j++; break;
                            case 5: //StationArt
                                      MediaBrowser_StationArt_string[MediaBrowserLine][j] =buffer_byte[i]; j++; break;
                            case 6: //PictureFile
                                      gMediaBrowser_PictureFile[MediaBrowserLine][j] =buffer_byte[i]; j++; break;
                            default: break;
                        }
                    }
                }
                else  // ";" is detected ->next record element of "array data"
                {
                     element++;
                     j = 0; //reset value
                }
            }
            //IssueList #76 - MR49870 : MediaBrowser
            // - if condition
            if( getValue( env_AudioSD_MB_insert_UPD_button ) == 0x00 )
            gMediaBrowser_TotalNumListElements = gMediaBrowser_sum =MediaBrowserLine; //get "total number of list elements"
            putvalue( env_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements );
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: " );
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: Anzahl der Listenelemente: %d", gMediaBrowser_sum); //output total number of list elements
            if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: " );
            if( fileClose( CSVfileHandle ) != 0 ) //close *.csv file
                { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: Datei '%s' geschlossen", gMediaBrowser_CSV_filename ); } //output result }
            else
                { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "MediaBrowser: Fehler beim Schlieen der Datei '%s'", gMediaBrowser_CSV_filename ); } //output result }
        }
        else //*.csv file access not successful
        {
            writelineEx( gBAP_Trace, 0, "MediaBrowser: Fehler beim Dateizugriff auf '%s'", gMediaBrowser_CSV_filename ); //output result
            putvalue( env_AudioSD_MB_DataSource_result, "not successful" ); //output result
        }
        gAudioSD_CSIhandle_FSGhandle = gMediaBrowser_Pos[0];
        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );

        gAudioSD_CSIhandle_FSGhandle_absolutePos = 0x01;
        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );

        for( i = 0; i < gMediaBrowser_TotalNumListElements; i++ )
        gMediaBrowser_Pos_insDel[i] [0] = gMediaBrowser_Pos[i];
        if( getValue( env_AudioSD_MB_insert_UPD_button ) == 0x00 )
        {
            for( i = 0; i < gMediaBrowser_TotalNumListElements; i++ )
            gMediaBrowser_Pos_insDel[i] [2] = i + 1;
            gRL_totalDELctr = 0;
        }
    }
}

//***************************
on envVar Env_FSG_LSL_status
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i, transSuppression;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;
    transSuppression        = getvalue(Env_FSG_LSL_E_TS_stop);
	

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        if( getvalue(Env_FSG_LSL_H_startBit ) >255 && getvalue(Env_FSG_LSL_H_indexSize ) == 0 ) // check if 8 or 16 bit
            putvalue(Env_FSG_LSL_H_indexSize,1 );

        //get data from Panel
        gLSL_ASGID= getvalue(Env_FSG_LSL_ASGID);
        gLSL_TAID = getvalue(Env_FSG_LSL_TAID);
        //gLSL_ALP  = getvalue(Env_FSG_LSL_ALP );
        gLSL_TNLE = getvalue(Env_FSG_LSL_TNLE );

        recordaddress   = getvalue(Env_FSG_LSL_H_recAdress );
        shift           = getvalue(Env_FSG_LSL_H_shift );
        direction       = getvalue(Env_FSG_LSL_H_direction );
        transmitpos     = getvalue(Env_FSG_LSL_H_transPos );
        indexsize       = getvalue(Env_FSG_LSL_H_indexSize );
        startelement    = getvalue(Env_FSG_LSL_H_startBit );
        elements        = getvalue(Env_FSG_LSL_H_elements );
		

        mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;

        /***Startelement = 0***/
        if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
        {
        if( FORWARD==direction )  //forward-start
            {
            valid_startelement = 0;

            if( AUDIO_LASTSTATIONLIST_ENTRIES <= elements ) //1. more elements requested, than in array
            {
                if( shift == FALSE )
                {
                    for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
                    {
                        if( 0 != gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = AUDIO_LASTSTATIONLIST_ENTRIES;
                    }
                }
                else if( shift == TRUE )
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
            }
            else    //2. number of requested elements < elements in array
            {
                if( shift == FALSE )
                {
                    for( i = 0; i < elements; i++ )
                    {
                        if( 0!= gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = AUDIO_LASTSTATIONLIST_ENTRIES;
                    }
                }
          else if( shift == TRUE )
          {
            valid_startelement  = startelement;
                      valid_elements      = 0;
          }
                }
      }
      else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
            {
              //searching for valid startelement
                for( i = ( AUDIO_LASTSTATIONLIST_ENTRIES-1 ); i>= 0; i--)
                {
                  if( 0!= gLSL_ListEntryValidInformation[i] )        //found valid startelement
                    {
                      valid_startelement = i;
                        i = 0;
                    }
                }
        //searching for valid elements
                if( 0xff ==valid_startelement ) //Startelement-ID doesn't exist in SMSReceived-array
                {
                  valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else if( 0 ==valid_startelement )
                  valid_elements= 1;//only 1 element because valid startelement is on position 0
                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                {
                  for( i =valid_startelement; i>= 0; i--)
                    {
                      if( 0!= gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                          valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                          i = 0;
                  }
                }
        else                                                        //enougth array-elements available
                {
                  for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                    {
                      if( 0!= gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                          valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
        }                                                               //backward-end
    }
    /***Startelement!= 0***/
    else                                                                //searching for Startelement-ID
        {
          //searching for valid startelement
            for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
            {
                if( gLSL_Pos[i] == startelement )                        //found a valid element
                {
          if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                    {
                      if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                          valid_startelement = i + 1-2* direction;
            else if( i == 0 && BACKWARD==direction )
              valid_startelement = gLSL_sum;     //valid element is last element in Array
            else if( i == 0 && FORWARD==direction )
              valid_startelement = 0;                          //valid element is first element in Array
          }
          else
            valid_startelement = i;                              //found element is valid_startelement
                    i = AUDIO_LASTSTATIONLIST_ENTRIES;
                }
        else
          valid_startelement = 0xff;
            }

            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
            {
                valid_startelement  = startelement;
                valid_elements      = 0;
            }
            else                                                                //found valid entry for startelement in array
            {
              //verify number of valid elements
                if( BACKWARD==direction )                                            //backward-start
                {
                  if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                      valid_elements= 1;
                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                  {
                      for( i =valid_startelement; i>= 0; i--)
                      {
                          if( 0!= gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
              else                                                //no valid element, loop finished
                              i = 0;
                        }
                  }
                    else                                                        //enougth array-elements available
                    {
                      for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                          if( 0!= gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                  if((valid_startelement+elements )>= AUDIO_LASTSTATIONLIST_ENTRIES)
                    {
                      for( i =valid_startelement; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
                        {
                          if( 0!= gLSL_Pos[i] )                            //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                              i = AUDIO_LASTSTATIONLIST_ENTRIES;
                        }
                    }
                    else
                    {
                      for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                        {
                          if( 0!= gLSL_Pos[i] )                            //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                              i = AUDIO_LASTSTATIONLIST_ENTRIES;
                        }
                    }
                }
            }
        }
    putvalue(Env_FSG_LSL_H_elements, valid_elements );

    //send StatusArray
    if(!transSuppression )
        LastStationList_Request( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
  }
}

byte LastStationList_nextvalidLine( byte current_LastStationListLine, byte direction )
{
  byte next_LastStationListLine;
  int i;

  //init lokal variables
  next_LastStationListLine = 0;
  i = 0;

  //search next "list entry"
  if( (( gLSL_sum - 1 ) == current_LastStationListLine && FORWARD == direction ) || ( 0 == current_LastStationListLine && BACKWARD == direction ) )  //last-/fist-element of array reached
      {next_LastStationListLine = 0xFF;
	  }
  else
  {
      next_LastStationListLine = current_LastStationListLine + 1 - 2 * direction;       //increment or decrement array-line ( depends on direction );

      if( 0 == gLSL_ListEntryValidInformation[next_LastStationListLine] )    // check if next element is "valid"
          {next_LastStationListLine = 0xff;
		  }
  }
  return (next_LastStationListLine );
}

void LastStationList_init_static()
{
    byte j, i, LastStationListLine;

    //clear
    LastStationListLine = 0;
    gLSL_sum = 0;

    for( j = 0; j < AUDIO_LASTSTATIONLIST_ENTRIES; j++ )
    {
      gLSL_Pos[j] = 0;
      gLSL_PresentIndex[j] = 0;
      gLSL_Waveband[j] = 0;
      gLSL_Attributes[j] = 0;

      gLSL_Attribute_IBOC_Bit0[j] = 0;
      gLSL_Attribute_DABsec_Bit1[j] = 0;
      gLSL_Attribute_DABprim_Bit2[j] = 0;
      gLSL_Attribute_OnlineRadioSec_Bit3[j] = 0;
      gLSL_Attribute_OnlineRadioPrim_Bit4[j] = 0;
      gLSL_Attribute_TP_Bit5[j] = 0;
      gLSL_Attribute_TMC_Bit6[j] = 0;
      gLSL_Attribute_SDARS_Bit7[j] = 0;
      gLSL_Attribute_StationSelc_Bit8[j] = 0;
      gLSL_Attribute_mute_Bit9[j] = 0;
      gLSL_Attribute_StationLinkedORadio_Bit10[j] = 0;
      gLSL_Attribute_StationLinkedFM_Bit11[j] = 0;

      gLSL_ListEntryValidInformation[j] = 0;

      for( i = 0; i < AUDIO_LASTSTATION_NAME_LENGTH; i++ )
        gLSL_Name[j][i] = 0;
      for( i = 0; i < AUDIO_LASTSTATION_FREQUENZ_LENGTH; i++ )
        gLSL_Frequenz[j][i] = 0;
    }

    //entry 0
    gLSL_ListEntryValidInformation[LastStationListLine] = TRUE;
    gLSL_Pos[LastStationListLine] = 0xF1;
    gLSL_PresentIndex[LastStationListLine] = 0xA;
    gLSL_Waveband[LastStationListLine] = 0x09;

    gLSL_Attribute_IBOC_Bit0[LastStationListLine] = TRUE;
    gLSL_Attribute_DABsec_Bit1[LastStationListLine] = FALSE;
    gLSL_Attribute_DABprim_Bit2[LastStationListLine] = FALSE;
    gLSL_Attribute_OnlineRadioSec_Bit3[LastStationListLine] = TRUE;
    gLSL_Attribute_OnlineRadioPrim_Bit4[LastStationListLine] = TRUE;
    gLSL_Attribute_TP_Bit5[LastStationListLine] = TRUE;
    gLSL_Attribute_TMC_Bit6[LastStationListLine] = FALSE;
    gLSL_Attribute_SDARS_Bit7[LastStationListLine] = FALSE;
    gLSL_Attribute_StationSelc_Bit8[LastStationListLine] = FALSE;
    gLSL_Attribute_mute_Bit9[LastStationListLine] = TRUE;
    gLSL_Attribute_StationLinkedORadio_Bit10[LastStationListLine] = TRUE;
    gLSL_Attribute_StationLinkedFM_Bit11[LastStationListLine] = TRUE;
    gLSL_Attributes[LastStationListLine] = gLSL_Attribute_IBOC_Bit0[LastStationListLine]
                                          + ( gLSL_Attribute_DABsec_Bit1[LastStationListLine] * 0x02 )
                                          + ( gLSL_Attribute_DABprim_Bit2[LastStationListLine] * 0x04 )
                                          + ( gLSL_Attribute_OnlineRadioSec_Bit3[LastStationListLine] * 0x08 )
                                          + ( gLSL_Attribute_OnlineRadioPrim_Bit4[LastStationListLine] * 0x10 )
                                          + ( gLSL_Attribute_TP_Bit5[LastStationListLine] * 0x20 )
                                          + ( gLSL_Attribute_TMC_Bit6[LastStationListLine] * 0x40 )
                                          + ( gLSL_Attribute_SDARS_Bit7[LastStationListLine] * 0x80 )
                                          + ( gLSL_Attribute_StationSelc_Bit8[LastStationListLine] * 0x100 )
                                          + ( gLSL_Attribute_mute_Bit9[LastStationListLine] * 0x200 )
                                          + ( gLSL_Attribute_StationLinkedORadio_Bit10[LastStationListLine] * 0x400 )
                                          + ( gLSL_Attribute_StationLinkedFM_Bit11[LastStationListLine] * 0x800 );

    strncpy( gLSL_Name[LastStationListLine], "Name_0", AUDIO_LASTSTATION_NAME_LENGTH);
    strncpy( gLSL_Frequenz[LastStationListLine], "Name_0", AUDIO_LASTSTATION_FREQUENZ_LENGTH);
    LastStationListLine++;

    //entry 1
    gLSL_ListEntryValidInformation[LastStationListLine] = TRUE;
    gLSL_Pos[LastStationListLine] = 0x1B;
    gLSL_PresentIndex[LastStationListLine] = 0xA5;
    gLSL_Waveband[LastStationListLine] = 0x0B;

    gLSL_Attribute_IBOC_Bit0[LastStationListLine] = TRUE;
    gLSL_Attribute_DABsec_Bit1[LastStationListLine] = TRUE;
    gLSL_Attribute_DABprim_Bit2[LastStationListLine] = TRUE;
    gLSL_Attribute_OnlineRadioSec_Bit3[LastStationListLine] = TRUE;
    gLSL_Attribute_OnlineRadioPrim_Bit4[LastStationListLine] = TRUE;
    gLSL_Attribute_TP_Bit5[LastStationListLine] = TRUE;
    gLSL_Attribute_TMC_Bit6[LastStationListLine] = TRUE;
    gLSL_Attribute_SDARS_Bit7[LastStationListLine] = TRUE;
    gLSL_Attribute_StationSelc_Bit8[LastStationListLine] = TRUE;
    gLSL_Attribute_mute_Bit9[LastStationListLine] = TRUE;
    gLSL_Attribute_StationLinkedORadio_Bit10[LastStationListLine] = TRUE;
    gLSL_Attribute_StationLinkedFM_Bit11[LastStationListLine] = TRUE;
    gLSL_Attributes[LastStationListLine] = gLSL_Attribute_IBOC_Bit0[LastStationListLine]
                                          + ( gLSL_Attribute_DABsec_Bit1[LastStationListLine] * 0x02 )
                                          + ( gLSL_Attribute_DABprim_Bit2[LastStationListLine] * 0x04 )
                                          + ( gLSL_Attribute_OnlineRadioSec_Bit3[LastStationListLine] * 0x08 )
                                          + ( gLSL_Attribute_OnlineRadioPrim_Bit4[LastStationListLine] * 0x10 )
                                          + ( gLSL_Attribute_TP_Bit5[LastStationListLine] * 0x20 )
                                          + ( gLSL_Attribute_TMC_Bit6[LastStationListLine] * 0x40 )
                                          + ( gLSL_Attribute_SDARS_Bit7[LastStationListLine] * 0x80 )
                                          + ( gLSL_Attribute_StationSelc_Bit8[LastStationListLine] * 0x100 )
                                          + ( gLSL_Attribute_mute_Bit9[LastStationListLine] * 0x200 )
                                          + ( gLSL_Attribute_StationLinkedORadio_Bit10[LastStationListLine] * 0x400 )
                                          + ( gLSL_Attribute_StationLinkedFM_Bit11[LastStationListLine] * 0x800 );

    strncpy( gLSL_Name[LastStationListLine], "Name_1", AUDIO_LASTSTATION_NAME_LENGTH);
    strncpy( gLSL_Frequenz[LastStationListLine], "Name_1", AUDIO_LASTSTATION_FREQUENZ_LENGTH);
    LastStationListLine++;

    //entry 2
    gLSL_ListEntryValidInformation[LastStationListLine] = FALSE;
    gLSL_Pos[LastStationListLine] = 0x1;
    gLSL_PresentIndex[LastStationListLine] = 0xF;
    gLSL_Waveband[LastStationListLine] = 0x00;
	

    gLSL_Attribute_IBOC_Bit0[LastStationListLine] = FALSE;
    gLSL_Attribute_DABsec_Bit1[LastStationListLine] = FALSE;
    gLSL_Attribute_DABprim_Bit2[LastStationListLine] = FALSE;
    gLSL_Attribute_OnlineRadioSec_Bit3[LastStationListLine] = FALSE;
    gLSL_Attribute_OnlineRadioPrim_Bit4[LastStationListLine] = FALSE;
    gLSL_Attribute_TP_Bit5[LastStationListLine] = FALSE;
    gLSL_Attribute_TMC_Bit6[LastStationListLine] = FALSE;
    gLSL_Attribute_SDARS_Bit7[LastStationListLine] = FALSE;
    gLSL_Attribute_StationSelc_Bit8[LastStationListLine] = FALSE;
    gLSL_Attribute_mute_Bit9[LastStationListLine] = FALSE;
    gLSL_Attribute_StationLinkedORadio_Bit10[LastStationListLine] = FALSE;
    gLSL_Attribute_StationLinkedFM_Bit11[LastStationListLine] = FALSE;
    gLSL_Attributes[LastStationListLine] = gLSL_Attribute_IBOC_Bit0[LastStationListLine]
                                          + ( gLSL_Attribute_DABsec_Bit1[LastStationListLine] * 0x02 )
                                          + ( gLSL_Attribute_DABprim_Bit2[LastStationListLine] * 0x04 )
                                          + ( gLSL_Attribute_OnlineRadioSec_Bit3[LastStationListLine] * 0x08 )
                                          + ( gLSL_Attribute_OnlineRadioPrim_Bit4[LastStationListLine] * 0x10 )
                                          + ( gLSL_Attribute_TP_Bit5[LastStationListLine] * 0x20 )
                                          + ( gLSL_Attribute_TMC_Bit6[LastStationListLine] * 0x40 )
                                          + ( gLSL_Attribute_SDARS_Bit7[LastStationListLine] * 0x80 )
                                          + ( gLSL_Attribute_StationSelc_Bit8[LastStationListLine] * 0x100 )
                                          + ( gLSL_Attribute_mute_Bit9[LastStationListLine] * 0x200 )
                                          + ( gLSL_Attribute_StationLinkedORadio_Bit10[LastStationListLine] * 0x400 )
                                          + ( gLSL_Attribute_StationLinkedFM_Bit11[LastStationListLine] * 0x800 );

    strncpy( gLSL_Name[LastStationListLine], "Name_2", AUDIO_LASTSTATION_NAME_LENGTH);
    strncpy( gLSL_Frequenz[LastStationListLine], "Name_2", AUDIO_LASTSTATION_FREQUENZ_LENGTH);
    LastStationListLine++;

    //entry 3
    gLSL_ListEntryValidInformation[LastStationListLine] = TRUE;
    gLSL_Pos[LastStationListLine] = 0x12;
    gLSL_PresentIndex[LastStationListLine] = 0x5F;
    gLSL_Waveband[LastStationListLine] = 0x0C;

    gLSL_Attribute_IBOC_Bit0[LastStationListLine] = TRUE;
    gLSL_Attribute_DABsec_Bit1[LastStationListLine] = TRUE;
    gLSL_Attribute_DABprim_Bit2[LastStationListLine] = TRUE;
    gLSL_Attribute_OnlineRadioSec_Bit3[LastStationListLine] = FALSE;
    gLSL_Attribute_OnlineRadioPrim_Bit4[LastStationListLine] = FALSE;
    gLSL_Attribute_TP_Bit5[LastStationListLine] = TRUE;
    gLSL_Attribute_TMC_Bit6[LastStationListLine] = TRUE;
    gLSL_Attribute_SDARS_Bit7[LastStationListLine] = FALSE;
    gLSL_Attribute_StationSelc_Bit8[LastStationListLine] = FALSE;
    gLSL_Attribute_mute_Bit9[LastStationListLine] = TRUE;
    gLSL_Attribute_StationLinkedORadio_Bit10[LastStationListLine] = FALSE;
    gLSL_Attribute_StationLinkedFM_Bit11[LastStationListLine] = TRUE;
    gLSL_Attributes[LastStationListLine] = gLSL_Attribute_IBOC_Bit0[LastStationListLine]
                                          + ( gLSL_Attribute_DABsec_Bit1[LastStationListLine] * 0x02 )
                                          + ( gLSL_Attribute_DABprim_Bit2[LastStationListLine] * 0x04 )
                                          + ( gLSL_Attribute_OnlineRadioSec_Bit3[LastStationListLine] * 0x08 )
                                          + ( gLSL_Attribute_OnlineRadioPrim_Bit4[LastStationListLine] * 0x10 )
                                          + ( gLSL_Attribute_TP_Bit5[LastStationListLine] * 0x20 )
                                          + ( gLSL_Attribute_TMC_Bit6[LastStationListLine] * 0x40 )
                                          + ( gLSL_Attribute_SDARS_Bit7[LastStationListLine] * 0x80 )
                                          + ( gLSL_Attribute_StationSelc_Bit8[LastStationListLine] * 0x100 )
                                          + ( gLSL_Attribute_mute_Bit9[LastStationListLine] * 0x200 )
                                          + ( gLSL_Attribute_StationLinkedORadio_Bit10[LastStationListLine] * 0x400 )
                                          + ( gLSL_Attribute_StationLinkedFM_Bit11[LastStationListLine] * 0x800 );

    strncpy( gLSL_Name[LastStationListLine], "Name_3", AUDIO_LASTSTATION_NAME_LENGTH);
    strncpy( gLSL_Frequenz[LastStationListLine], "Name_3", AUDIO_LASTSTATION_FREQUENZ_LENGTH);
    LastStationListLine++;

    //entry 4
    gLSL_ListEntryValidInformation[LastStationListLine] = TRUE;
    gLSL_Pos[LastStationListLine] = 0x12;
    gLSL_PresentIndex[LastStationListLine] = 0x5F;
    gLSL_Waveband[LastStationListLine] = 0x0A;

    gLSL_Attribute_IBOC_Bit0[LastStationListLine] = TRUE;
    gLSL_Attribute_DABsec_Bit1[LastStationListLine] = TRUE;
    gLSL_Attribute_DABprim_Bit2[LastStationListLine] = TRUE;
    gLSL_Attribute_OnlineRadioSec_Bit3[LastStationListLine] = FALSE;
    gLSL_Attribute_OnlineRadioPrim_Bit4[LastStationListLine] = FALSE;
    gLSL_Attribute_TP_Bit5[LastStationListLine] = TRUE;
    gLSL_Attribute_TMC_Bit6[LastStationListLine] = TRUE;
    gLSL_Attribute_SDARS_Bit7[LastStationListLine] = FALSE;
    gLSL_Attribute_StationSelc_Bit8[LastStationListLine] = FALSE;
    gLSL_Attribute_mute_Bit9[LastStationListLine] = TRUE;
    gLSL_Attribute_StationLinkedORadio_Bit10[LastStationListLine] = FALSE;
    gLSL_Attribute_StationLinkedFM_Bit11[LastStationListLine] = TRUE;
    gLSL_Attributes[LastStationListLine] = gLSL_Attribute_IBOC_Bit0[LastStationListLine]
                                          + ( gLSL_Attribute_DABsec_Bit1[LastStationListLine] * 0x02 )
                                          + ( gLSL_Attribute_DABprim_Bit2[LastStationListLine] * 0x04 )
                                          + ( gLSL_Attribute_OnlineRadioSec_Bit3[LastStationListLine] * 0x08 )
                                          + ( gLSL_Attribute_OnlineRadioPrim_Bit4[LastStationListLine] * 0x10 )
                                          + ( gLSL_Attribute_TP_Bit5[LastStationListLine] * 0x20 )
                                          + ( gLSL_Attribute_TMC_Bit6[LastStationListLine] * 0x40 )
                                          + ( gLSL_Attribute_SDARS_Bit7[LastStationListLine] * 0x80 )
                                          + ( gLSL_Attribute_StationSelc_Bit8[LastStationListLine] * 0x100 )
                                          + ( gLSL_Attribute_mute_Bit9[LastStationListLine] * 0x200 )
                                          + ( gLSL_Attribute_StationLinkedORadio_Bit10[LastStationListLine] * 0x400 )
                                          + ( gLSL_Attribute_StationLinkedFM_Bit11[LastStationListLine] * 0x800 );

    strncpy( gLSL_Name[LastStationListLine], "Name_4", AUDIO_LASTSTATION_NAME_LENGTH);
    strncpy( gLSL_Frequenz[LastStationListLine], "Name_4", AUDIO_LASTSTATION_FREQUENZ_LENGTH);
    LastStationListLine++;

    gLSL_sum = LastStationListLine;
    gLSL_TNLE = gLSL_sum;
	
	gLastStationList_TotalNumListElements = gLSL_CSVtotalElem = gLSL_TNLE;

    if( boTraceStatus_ON )
    {
        for( i = 0; i < gLSL_sum; i++ )
        {
            if( boTraceStatus_ON )
            {
                writelineEx( gBAP_Trace, 0, "LastStation: *******Element %d*******", i);
                writelineEx( gBAP_Trace, 0, "LastStation: Pos[%d]: 0x%x", i, gLSL_Pos[i] );
                writelineEx( gBAP_Trace, 0, "LastStation: PresentIndex[%d]: 0x%x", i, gLSL_PresentIndex[i] );

                if( gLSL_Waveband[i] < 0xD)
                    writelineEx( gBAP_Trace, 0, "LastStation: Waveband -> '%s'", gLSL_Waveband_s[gLSL_Waveband[i]] );
                else
                    writelineEx( gBAP_Trace, 0, "LastStation: Waveband -> '%s'", gstring_reserved );

                writelineEx( gBAP_Trace, 0, "LastStation: Attributes[%d]: 0x%x", i, gLSL_Attributes[i] );
                if( gLSL_Attributes[i] & 0x01 )
                    writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit0[%d]: 'IBOC service'", i);
                else
                    writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit0[%d]: 'not an IBOC service'", i);

                if( gLSL_Attributes[i] & 0x02 )
                    writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit1[%d]: 'DAB secondary service'", i);
                else
                    writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit1[%d]: 'not a DAB secondary service'", i);

                if( gLSL_Attributes[i] & 0x04 )
                    writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit2[%d]: 'DAB primary service contains secondary service(s )'", i);
                else
                    writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit2[%d]: 'DAB primary service contains no secondary service(s ) / no DAB primary service'", i);

                if( gLSL_Attributes[i] & 0x08 )
                    writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit3[%d]: 'Online radio secondary service'", i);
                else
                    writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit3[%d]: 'not an online radio secondary service'", i);

                if( gLSL_Attributes[i] & 0x10 )
                    writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit4[%d]: 'Online radio primary service contains secondary service(s )'", i);
                else
                    writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit4[%d]: 'Online radio primary service contains no secondary service(s ) / no online radio primary service'", i);

                if( gLSL_Attributes[i] & 0x20 )
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit5[%d]: 'TP available/supported by station'", i);
                else
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit5[%d]: 'TP not available/not supported by station'", i);

                if( gLSL_Attributes[i] & 0x40 )
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit6[%d]: 'TMC available/supported by station'", i);
                else
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit6[%d]: 'TMC not supported/not available by station'", i);

                if( gLSL_Attributes[i] & 0x80 )
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit7[%d]: 'SDARS station subscribed or not an SDARS station'", i);
                else
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit7[%d]: 'SDARS station not subscribed'", i);

                if( gLSL_Attributes[i] & 0x100 )
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit8[%d]: 'Station not selectable'", i);
                else
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit8[%d]: 'Station selectable'", i);

                if( gLSL_Attributes[i] & 0x200 )
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit9[%d]: 'muting / low signal'", i);
                else
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit9[%d]: 'not muted / signal OK'", i);

                if( gLSL_Attributes[i] & 0x400 )
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit10[%d]: 'Station linked to online radio'", i);
                else
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit10[%d]: 'Station not linked to online radio'", i);

                if( gLSL_Attributes[i] & 0x800 )
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit11[%d]: 'Station linked to FM'", i);
                else
                writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit11[%d]: 'Station not linked to FM'", i);

                writelineEx( gBAP_Trace, 0, "LastStation: Name[%d]: %s", i, gLSL_Name[i] );
                writelineEx( gBAP_Trace, 0, "LastStation: Frequenz[%d]: %s", i, gLSL_Frequenz[i] );
            }
        }
    }
    putvalue(Env_FSG_LSL_TNLE, gLSL_TNLE );
	
	for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
	{
		gLastStationList_Pos_insDel[i] [0] = 0;
		gLastStationList_Pos_insDel[i] [1] = 0;
		gLastStationList_Pos_insDel[i] [2] = 0;
	}
	
	//gAudioSD_CSIhandle_FSGhandle = gLSL_Pos[0];
    //putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
     //IssueList #72
    gAudioSD_CSIhandle_FSGhandle_absolutePos = 0x01;
    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );

    if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: Anzahl der Listenelemente: %d", gLSL_sum);
}

void LastStationList_init_CSV() //Byte & file selection
{
    dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, current_CSV_line = 0, count1 = 0, count2 = 0;
    char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
    byte LastStationListLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
    char LastStationList_Pos_string[AUDIO_LASTSTATIONLIST_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8 ) code in the *.csv
    char LastStationList_PIndex_string[AUDIO_LASTSTATIONLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"PresentIndex" is stored in the ASCII(UTF-8 ) code in the *.csv
    char LastStationList_Name_string[AUDIO_LASTSTATIONLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Name" is stored in the ASCII(UTF-8 ) code in the *.csv
    char LastStationList_Frequenz_string[AUDIO_LASTSTATIONLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Frequenz" is stored in the ASCII(UTF-8 ) code in the *.csv
    char LastStationList_Waveband_string[AUDIO_LASTSTATIONLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Waveband" is stored in the ASCII(UTF-8 ) code in the *.csv
    char LastStationList_Attributes_string[AUDIO_LASTSTATIONLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Attributes" is stored in the ASCII(UTF-8 ) code in the *.csv

    if( getvalue(Env_FSG_LSL_DS_List ) == AUDIO_EXTERNAL_LIST ) //output data in write window "FSGLastStationList"
    {
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: *******External LastStationList*******" );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: " );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: **********************Start load new LastStationList**********************" );

        //clear
        for( j = 0; j < AUDIO_LASTSTATIONLIST_ENTRIES; j++ )
        {
            gLSL_Pos[j] = 0;
            gLSL_PresentIndex[j]  = 0;
            gLSL_Waveband[j] = 0;

            gLSL_Attributes[j] = 0;
            gLSL_Attribute_IBOC_Bit0[j] = 0;
            gLSL_Attribute_DABsec_Bit1[j] = 0;
            gLSL_Attribute_DABprim_Bit2[j] = 0;
            gLSL_Attribute_OnlineRadioSec_Bit3[j] = 0;
            gLSL_Attribute_OnlineRadioPrim_Bit4[j] = 0;
            gLSL_Attribute_TP_Bit5[j] = 0;
            gLSL_Attribute_TMC_Bit6[j] = 0;
            gLSL_Attribute_SDARS_Bit7[j] = 0;
            gLSL_Attribute_StationSelc_Bit8[j] = 0;
            gLSL_Attribute_mute_Bit9[j] = 0;
            gLSL_Attribute_StationLinkedORadio_Bit10[j] = 0;
            gLSL_Attribute_StationLinkedFM_Bit11[j] = 0;

            for( i = 0; i < AUDIO_LASTSTATION_NAME_LENGTH; i++ )
                gLSL_Name[j][i] = 0;

            for( i = 0; i < AUDIO_LASTSTATION_FREQUENZ_LENGTH; i++ )
                gLSL_Frequenz[j][i] = 0;
        }

    for( i = 0; i < AUDIO_FILENAME_SIZE; i++ ) //clear "filename"
          gLSL_CSV_filename[i] = 0;

    for( j = 0; j < AUDIO_LASTSTATIONLIST_ENTRIES; j++ ) //clear "buffer"
    {
      buffer_string[j]    = 0;
      buffer_byte[j]      = 0;

      for( i = 0; i < AUDIO_TEXTLENGTH; i++ ) //clear help value
      {
        LastStationList_Pos_string[j][i] = 0;
        LastStationList_Name_string[j][i] = 0;
        LastStationList_Frequenz_string[j][i] = 0;
      }
    }

    i = 0; j = 0; LastStationListLine = 0; current_CSV_line = 0; //reset values

    getvalue(Env_FSG_LSL_DS_externalPath, Path_CSV); //get filename & path of *.csv-file from Panel

    //write( "complete path *.csv: %s", Path_CSV); //debug

    i = 0;

    while ( Path_CSV[i] != 0 ) //scan "path"
    {
        if( Path_CSV[i] == 0x5C) //count "/" to seperate later "path" & "filename"
            count1++;

        //write( "Path[%d] of *.csv: %x",i, Path_CSV[i] ); //debug
        i++;
    }

    i = 0; j = 0; //reset values

    while ( Path_CSV[i] != 0 ) //seperate "path" and "filename"
    {
        if( count2==count1 ) //get filename after last "\"
        {
            gLSL_CSV_filename[j] = Path_CSV[i];
            j++;

            Path_CSV[i] = 0;
        }

        if( Path_CSV[i] == 0x5C) //count "\" to get filename after last "\"
            count2++;

        i++;
    }

    if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: path of *.csv: %s", Path_CSV);        //output file path

    if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: filename of *.csv: '%s'", gLSL_CSV_filename );  //output filename

    putvalue(Env_FSG_LSL_DS_currentPath, gLSL_CSV_filename ); //output current loaded *.csv-file on panel

    setFilePath( Path_CSV, 0 ); //set path for *.csv file

    CSVfileHandle =openFileRead( gLSL_CSV_filename,1 ); //open *.csv ( binary-mode ->get the ASCII/UTF-8 code )

    if( CSVfileHandle!= 0 ) //*.csv file access successful
    {
      if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: Dateizugriff auf '%s' erfolgreich", gLSL_CSV_filename );    //output result

      putvalue(Env_FSG_LSL_DS_reloadRes, "successful" );   //output result on panel

      Num_of_csv_byte = fileGetBinaryBlock( buffer_byte, elcount( buffer_byte ), CSVfileHandle );//get data from *.csv and store the total number of byte in *.csv-file

      for( i = 0; i <Num_of_csv_byte; i++ ) //copy data into "LastStationList"
      {
        if( buffer_byte[i] != 0x3B) //read data if no ";" is detected
        {
          if( buffer_byte[i] == 0x0D && buffer_byte[i + 1] == 0x0A) //nextline in *.csv (next "record element" in LastStationList ) -> "LF" and "CR" detected -> copy ( transform string -> long ) data from help values in global values
          {
            if( current_CSV_line> 0 && LastStationListLine < AUDIO_LASTSTATIONLIST_ENTRIES) //ignore first line in *.csv file
            {
              if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: " );
              if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: *******Element %d*******", LastStationListLine );

              //transform 'string' to 'long'
              gLSL_Pos[LastStationListLine] = atol(LastStationList_Pos_string[LastStationListLine] );
              gLSL_PresentIndex[LastStationListLine] = atol(LastStationList_PIndex_string[LastStationListLine] );
              gLSL_Waveband[LastStationListLine] = atol(LastStationList_Waveband_string[LastStationListLine] );
              gLSL_Attributes[LastStationListLine] = atol(LastStationList_Attributes_string[LastStationListLine] );

              if( boTraceStatus_ON )
              {
                  writelineEx( gBAP_Trace, 0, "LastStation: Pos[%d]: 0x%x", LastStationListLine, gLSL_Pos[LastStationListLine] );
                  writelineEx( gBAP_Trace, 0, "LastStation: Presentindex[%d]: 0x%x", LastStationListLine, gLSL_PresentIndex[LastStationListLine] );

                  if( gLSL_Waveband[LastStationListLine] < 0xF )
                      writelineEx( gBAP_Trace, 0, "LastStation: Waveband -> '%s'", gLSL_Waveband_s[gLSL_Waveband[LastStationListLine]] );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Waveband -> '%s'", gstring_reserved );

                  writelineEx( gBAP_Trace, 0, "LastStation: Attributes[%d]: 0x%x", LastStationListLine, gLSL_Attributes[LastStationListLine] );

                  if( gLSL_Attributes[LastStationListLine] & 0x01 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit0[%d]: 'IBOC service'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit0[%d]: 'not an IBOC service'", LastStationListLine );

                  if( gLSL_Attributes[LastStationListLine] & 0x02 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit1[%d]: 'DAB secondary service'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit1[%d]: 'not a DAB secondary service'", LastStationListLine );

                  if( gLSL_Attributes[LastStationListLine] & 0x04 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit2[%d]: 'DAB primary service contains secondary service(s )'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit2[%d]: 'DAB primary service contains no secondary service(s ) / no DAB primary service'", LastStationListLine );

                  if( gLSL_Attributes[LastStationListLine] & 0x08 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit3[%d]: 'Online radio secondary service'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit3[%d]: 'not an online radio secondary service'", LastStationListLine );

                  if( gLSL_Attributes[LastStationListLine] & 0x10 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit4[%d]: 'Online radio primary service contains secondary service(s )'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit4[%d]: 'Online radio primary service contains no secondary service(s ) / no online radio primary service'", LastStationListLine );

                  if( gLSL_Attributes[LastStationListLine] & 0x20 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit5[%d]: 'TP available/supported by station'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit5[%d]: 'TP not available/not supported by station'", LastStationListLine );

                  if( gLSL_Attributes[LastStationListLine] & 0x40 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit6[%d]: 'TMC available/supported by station'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit6[%d]: 'TMC not supported/not available by station'", LastStationListLine );

                  if( gLSL_Attributes[LastStationListLine] & 0x80 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit7[%d]: 'SDARS station subscribed or not an SDARS station'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit7[%d]: 'SDARS station not subscribed'", LastStationListLine );

                  if( gLSL_Attributes[LastStationListLine] & 0x100 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit8[%d]: 'Station not selectable'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit8[%d]: 'Station selectable'", LastStationListLine );

                  if( gLSL_Attributes[LastStationListLine] & 0x200 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit9[%d]: 'muting / low signal'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit9[%d]: 'not muted / signal OK'", LastStationListLine );

                  if( gLSL_Attributes[LastStationListLine] & 0x400 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit10[%d]: 'Station linked to online radio'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit10[%d]: 'Station not linked to online radio'", LastStationListLine );

                  if( gLSL_Attributes[LastStationListLine] & 0x800 )
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit11[%d]: 'Station linked to FM'", LastStationListLine );
                  else
                      writelineEx( gBAP_Trace, 0, "LastStation: Attributes_Bit11[%d]: 'Station not linked to FM'", LastStationListLine );


                  writelineEx( gBAP_Trace, 0, "LastStation: Name[%d]: %s", LastStationListLine, gLSL_Name[LastStationListLine] );
                  writelineEx( gBAP_Trace, 0, "LastStation: Frequenz[%d]: %s", LastStationListLine, gLSL_Frequenz[LastStationListLine] );
              }
              gLSL_ListEntryValidInformation[LastStationListLine]  = TRUE;

              LastStationListLine++; // -> next line in *.csv (next record element )
            }
            current_CSV_line++; //next line in *.csv file
            element = 0; //start at 'POS' ( first record element of "array data" )
            j = 0; //reset value
          }
          else if( current_CSV_line> 0 && LastStationListLine < AUDIO_LASTSTATIONLIST_ENTRIES) //copy data from "buffer_byte" ( data from *.csv file ) in help values and "name" until end of line is not detected
          {
            switch(  element )
            {
              case 0: //POS
                      LastStationList_Pos_string[LastStationListLine][j] =buffer_byte[i];
                      j++;
               break;

              case 1: //PresentIndex
                      LastStationList_PIndex_string[LastStationListLine][j] =buffer_byte[i];
                      j++;
               break;

              case 2: //Waveband
                      LastStationList_Waveband_string[LastStationListLine][j] =buffer_byte[i];
                      j++;
               break;

              case 3: //Attributes
                      LastStationList_Attributes_string[LastStationListLine][j] =buffer_byte[i];
                      j++;
               break;

              case 4: //Name
                      gLSL_Name[LastStationListLine][j] =buffer_byte[i];
                      j++;
               break;

              case 5: //Frequenz
                      gLSL_Frequenz[LastStationListLine][j] =buffer_byte[i];
                      j++;
               break;

              default:
               break;
                    }
                }
            }
            else  // ";" is detected ->next record element of "array data"
            {
                element++;
                j = 0; //reset value
            }
        }
        gLSL_TNLE = gLSL_sum = gLastStationList_TotalNumListElements = gLSL_CSVtotalElem = LastStationListLine; //get "total number of list elements"
        putvalue(Env_FSG_LSL_TNLE, gLSL_TNLE );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: " );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: Anzahl der Listenelemente: %d", gLSL_sum); //output total number of list elements
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: " );
        if( fileClose( CSVfileHandle ) != 0 ) //close *.csv file
            { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: Datei '%s' geschlossen", gLSL_CSV_filename ); } //output result }
        else
            { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "LastStation: Fehler beim Schlieen der Datei '%s'", gLSL_CSV_filename ); } //output result }
        }
        else //*.csv file access not successful
        {
            writelineEx( gBAP_Trace, 0, "Fehler beim Dateizugriff auf '%s'", gLSL_CSV_filename ); //output result
            putvalue(Env_FSG_LSL_DS_reloadRes, "not successful" ); //output result
        }
		
		for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
		{
            gLastStationList_Pos_insDel[i] [0] = 0;
			gLastStationList_Pos_insDel[i] [1] = 0;
			gLastStationList_Pos_insDel[i] [2] = 0;
		}
		
		gAudioSD_CSIhandle_FSGhandle = gLSL_Pos[0];
        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );

        gAudioSD_CSIhandle_FSGhandle_absolutePos = 0x01;
        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );

        for( i = 0; i < gLastStationList_TotalNumListElements; i++ )
            gLastStationList_Pos_insDel[i] [0] = gLSL_Pos[i];

        if( getValue( env_AudioSD_LSL_insert_UPD_button ) == 0x00 )
        {
            for( i = 0; i < gLastStationList_TotalNumListElements; i++ )
            gLastStationList_Pos_insDel[i] [2] = i + 1;

            gLSL_totalDELctr = 0;
		}
    }
}

on envVar Env_FSG_LSL_change
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        if( getvalue(Env_FSG_LSL_H_startBit ) >255 && getvalue(Env_FSG_LSL_H_indexSize ) == 0 ) // check if 8 or 16 bit
            putvalue(Env_FSG_LSL_H_indexSize,1 );

        //get data from Panel
        recordaddress   = getvalue(Env_FSG_LSL_H_recAdress );
        shift           = getvalue(Env_FSG_LSL_H_shift );
        direction       = getvalue(Env_FSG_LSL_H_direction );
        transmitpos     = getvalue(Env_FSG_LSL_H_transPos );
        indexsize       = getvalue(Env_FSG_LSL_H_indexSize );
        startelement    = getvalue(Env_FSG_LSL_H_startBit );
        elements        = getvalue(Env_FSG_LSL_H_elements );
        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;


        /***Startelement = 0***/
        if( getvalue( env_AudioSD_MB_CA_switch ) ) //ArrayData
        {
      if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
      {
        if( FORWARD==direction )  //forward-start
          {
          valid_startelement = 0;

          if( AUDIO_LASTSTATIONLIST_ENTRIES <= elements ) //1. more elements requested, than in array
              {
            if( shift == FALSE )
            {
              for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
                      {
                          if( 0 != gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                            i = AUDIO_LASTSTATIONLIST_ENTRIES;
                        }
            }
            else if( shift == TRUE )
            {
              valid_startelement  = startelement;
                        valid_elements      = 0;
            }
                }
          else    //2. number of requested elements < elements in array
                  {
            if( shift == FALSE )
            {
                        for( i = 0; i < elements; i++ )
                          {
                            if( 0!= gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                              i = AUDIO_LASTSTATIONLIST_ENTRIES;
                        }
            }
            else if( shift == TRUE )
            {
              valid_startelement  = startelement;
                        valid_elements      = 0;
            }
                  }
        }//forward ends
        else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
              {
                //searching for valid startelement
                  for( i = ( AUDIO_LASTSTATIONLIST_ENTRIES-1 ); i>= 0; i--)
                  {
                    if( 0!= gLSL_ListEntryValidInformation[i] )        //found valid startelement
                      {
                        valid_startelement = i;
                          i = 0;
                      }
                  }
          //searching for valid elements
                  if( 0xff ==valid_startelement ) //Startelement-ID doesn't exist in SMSReceived-array
                  {
                    valid_startelement  = startelement;
                      valid_elements      = 0;
                  }
                  else if( 0 ==valid_startelement )
                    valid_elements= 1;//only 1 element because valid startelement is on position 0
                  else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                  {
                  for( i =valid_startelement; i>= 0; i--)
                      {
                        if( 0!= gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                            i = 0;
                    }
                  }
          else                                                        //enougth array-elements available
                  {
                    for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                      {
                        if( 0!= gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                              i = 0;
                      }
                  }
        }//backward-end
      }//startelement == 0 -end

      /***Startelement!= 0***/
      else                                                                //searching for Startelement-ID
          {
            //searching for valid startelement
              for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
              {
                  if( gLSL_Pos[i] == startelement )                        //found a valid element
                  {
            if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                      {
                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement = i + 1-2* direction;
              else if( i == 0 && BACKWARD==direction )
                valid_startelement = gMediaBrowser_sum;     //valid element is last element in Array
              else if( i == 0 && FORWARD==direction )
                valid_startelement = 0;                          //valid element is first element in Array
            }
            else
              valid_startelement = i;                              //found element is valid_startelement
                      i = AUDIO_LASTSTATIONLIST_ENTRIES;
                  }
          else
            valid_startelement = 0xff;
              }
              if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
              {
                  valid_startelement  = startelement;
                  valid_elements      = 0;
              }
              else                                                                //found valid entry for startelement in array
              {
                //verify number of valid elements
                  if( BACKWARD==direction )                                            //backward-start
                  {
                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                        valid_elements= 1;
                      else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                          {
                            if( 0!= gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                else                                                //no valid element, loop finished
                                i = 0;
                          }
                    }
                      else                                                        //enougth array-elements available
                      {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                          {
                            if( 0!= gLSL_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                              else                                                //no valid element, loop finished
                                  i = 0;
                          }
                      }
                  }                                                                //backward-end
                  else                                                            //forward-start
                  {
                    if((valid_startelement+elements )>= AUDIO_LASTSTATIONLIST_ENTRIES)
                      {
                        for( i =valid_startelement; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
                          {
                            if( 0!= gLSL_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                              else                                                //no valid element, loop finished
                                i = AUDIO_LASTSTATIONLIST_ENTRIES;
                          }
                      }
                      else
                      {
                        for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                          {
                            if( 0!= gLSL_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                              else                                                //no valid element, loop finished
                                i = AUDIO_LASTSTATIONLIST_ENTRIES;
                          }
                      }
                  }
              }
          }
      putvalue(Env_FSG_LSL_H_elements, valid_elements );
      //send ChangedArray
      LastStationList_Request( Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
    }
    else
    {
      //send ChangedArray
      LastStationList_Request( Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0 );
    }
  }
}

on envVar Env_FSG_LSL_DS_List
{
    if( getvalue( this ) == AUDIO_DEFAULT_LIST )
    {
        LastStationList_init_static();
        putvalue(Env_FSG_LSL_DS_currentPath, empty_string );
        putvalue(Env_FSG_LSL_DS_reloadRes, empty_string );
    }
}

on envVar Env_FSG_LSL_DS_reload //load external MediaBrowser from *.csv
{
    if( getvalue( this ) && getvalue(Env_FSG_LSL_DS_List ) == AUDIO_EXTERNAL_LIST )

        LastStationList_init_CSV();

    else if( getvalue(Env_FSG_LSL_DS_List ) != AUDIO_EXTERNAL_LIST )
        putvalue(Env_FSG_LSL_DS_reloadRes, "not successful, select 'external *.csv'" );
}

//*****************************

on envVar env_AudioSD_InfoStates_update
{
  if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
  {
    gAudioSD_InfoStates_States = getvalue( env_AudioSD_InfoStates_states );
    InfoStates_Request( Data_REQ, 0 );
  }
}

on envVar env_AudioSD_RL_FRU
{
   word i,j;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        //MR49870
       ReceptionList_FRU();

       //addition of insertFlag for reset of Index(absolutePos ) assignment
       j = 0;

       if( gRL_loadReloadFlg == 0x00 )
       {
           if( gRL_InsertFlg == 0x01 )
           {
                for( i = 0; i < gRL_CSVtotalElem; i++ )
                {
                    if( gReceptionList_Pos_insDel[i][1] == 0x00 )
                    {
                    gReceptionList_Pos_insDel[i] [2] =j+ 1;
                    j++;

                         if( gReceptionList_Pos_insDel[i][0] == gAudioSD_CSIhandle_FSGhandle )
                         {
                            gAudioSD_CSIhandle_FSGhandle_absolutePos = gReceptionList_Pos_insDel[i] [2];

                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                         }

                    }
                }
                gRL_InsertFlg = 0x00;

           }

        }//end if gRL_loadReloadFlg

     }
      //changes from J.Karl 30.11.2012
    putvalue( env_AudioSD_RL_FRU, 0x0 );
}

on envVar env_AudioSD_TML_FRU
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;

  // Init local variables.
  mode                    = 0;
  shift                   = 0;
  direction               = 0;
  transmitpos             = 0;
  indexsize               = 0;
  recordaddress           = 0;
  requested_startelement  = 0;
  startelement            = 0;
  elements                = 0;
  valid_startelement      = 0;
  i                       = 0;
  valid_elements          = 0;

  if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
  {
    recordaddress   = 0;
    shift           = 0;
    direction       = 0;
    transmitpos     = 0;
    indexsize       = 0;
    startelement    = 0;
    elements        = 255;

        //MR 63332 #2 02.07.2014
        /*
        putvalue( env_AudioSD_TML_CA_switch, FALSE );

        putvalue( env_AudioSD_TML_AH_RA, recordaddress );
        putvalue( env_AudioSD_TML_AH_shift, shift );
        putvalue( env_AudioSD_TML_AH_dir, direction );
        putvalue( env_AudioSD_TML_AH_POS, transmitpos );
        putvalue( env_AudioSD_TML_AH_IS, indexsize );
        putvalue( env_AudioSD_TML_AH_start, startelement );
        putvalue( env_AudioSD_TML_AH_elements, elements );
        */


    mode= shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

    //send ChangedArray
    TpMemoList_Request( Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0 );
  }
}

on envVar env_AudioSD_SL_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
byte mode, shift, direction, transmitpos, indexsize, recordaddress;
int i,j;

// Init local variables.
mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        recordaddress   = 0;
        shift           = 0;
        direction       = 0;
        transmitpos     = 0;
        //IssueList #76 - MR49870: SourceList
        //indexsize       = 1;
        indexsize       = 0;
        startelement    = 0;
        elements        =65535;


        //MR 63332 #2 02.07.2014
        /*
        putvalue( env_AudioSD_SL_CA_switch, FALSE );

        putvalue( env_AudioSD_SL_AH_RA, recordaddress );
        putvalue( env_AudioSD_SL_AH_shift, shift );
        putvalue( env_AudioSD_SL_AH_dir, direction );
        putvalue( env_AudioSD_SL_AH_POS, transmitpos );
        putvalue( env_AudioSD_SL_AH_IS, indexsize );
        putvalue( env_AudioSD_SL_AH_start, startelement );
        putvalue( env_AudioSD_SL_AH_elements, elements );
        */


        mode= shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //send ChangedArray
        SourceList_Request( Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0 );
    }
      //changes from J.Karl 30.11.2012
    putvalue( env_AudioSD_RL_FRU, 0x0 );
}

on envVar env_AudioSD_RTPL_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
byte mode, shift, direction, transmitpos, indexsize, recordaddress;
int i,j;

// Init local variables.
mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        recordaddress   = 0;
        shift           = 0;
        direction       = 0;
        transmitpos     = 0;
        indexsize       = 0;
        startelement    = 0;
        elements        = 255;


        //MR 63332 #2 02.07.2014
        /*
        putvalue( env_AudioSD_RTPL_CA_switch, FALSE );

        putvalue( env_AudioSD_RTPL_AH_RA, recordaddress );
        putvalue( env_AudioSD_RTPL_AH_shift, shift );
        putvalue( env_AudioSD_RTPL_AH_dir, direction );
        putvalue( env_AudioSD_RTPL_AH_POS, transmitpos );
        putvalue( env_AudioSD_RTPL_AH_IS, indexsize );
        putvalue( env_AudioSD_RTPL_AH_start, startelement );
        putvalue( env_AudioSD_RTPL_AH_elements, elements );
        */


mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //send ChangedArray
        RadioTVPresetList_Request( Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0 );
        //MR49870
        //addition of insertFlag for reset of Index(absolutePos ) assignment
       j = 0;

       if( gRTPL_loadReloadFlg == 0x00 )
       {
           if( gRTPL_InsertFlg == 0x01 )
           {
                for( i = 0; i < gRTPL_CSVtotalElem; i++ )
                {
                    if( gRTPL_Pos_insDel[i][1] == 0x00 )
                    {
                    gRTPL_Pos_insDel[i] [2] =j+ 1;
                    j++;

                         if( gRTPL_Pos_insDel[i][0] == gAudioSD_CSIhandle_PresetListRef )
                         {
                            gAudioSD_CSIhandle_PresetListabsolutePos = gRTPL_Pos_insDel[i] [2];

                            putvalue( env_AudioSD_CSH_PresetListRef, gAudioSD_CSIhandle_PresetListRef );
                            putValue( env_AudioSD_CSH_PresetListAbsPos, gAudioSD_CSIhandle_PresetListabsolutePos );
                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                         }

                    }
                }
                gRTPL_InsertFlg = 0x00;

           }

        }//end if gRTPL_loadReloadFlg

     }
      //changes from J.Karl 30.11.2012
    putvalue( env_AudioSD_RTPL_FRU, 0x0 );
}

on envVar env_AudioSD_MB_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
byte mode, shift, direction, transmitpos, indexsize, recordaddress;
int i,j;

// Init local variables.
mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        recordaddress   = 0;
        shift           = 0;
        direction       = 0;
        transmitpos     = 0;
        //MR49870
        //indexsize       = 1;
        indexsize       = 0;
        startelement    = 0;
        elements        =65535;

        //MR 63332 #2 02.07.2014
        /*
        putvalue( env_AudioSD_MB_CA_switch, FALSE );

        putvalue( env_AudioSD_MB_AH_RA, recordaddress );
        putvalue( env_AudioSD_MB_AH_shift, shift );
        putvalue( env_AudioSD_MB_AH_dir, direction );
        putvalue( env_AudioSD_MB_AH_POS, transmitpos );
        putvalue( env_AudioSD_MB_AH_IS, indexsize );
        putvalue( env_AudioSD_MB_AH_start, startelement );
        putvalue( env_AudioSD_MB_AH_elements, elements );
        */


mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //send ChangedArray
        MediaBrowser_Request( Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0 );
        //IssueList #76 - MR49870 : MediaBrowser
         //addition of insertFlag for reset of Index(absolutePos ) assignment
       j = 0;

       if( gMB_loadReloadFlg == 0x00 )
       {
           if( gMB_InsertFlg == 0x01 )
           {
                for( i = 0; i < gMB_CSVtotalElem; i++ )
                {
                    if( gMediaBrowser_Pos_insDel[i][1] == 0x00 )
                    {
                    gMediaBrowser_Pos_insDel[i] [2] =j+ 1;
                    j++;

                         if( gMediaBrowser_Pos_insDel[i][0] == gAudioSD_CSIhandle_FSGhandle )
                         {
                            gAudioSD_CSIhandle_FSGhandle_absolutePos = gMediaBrowser_Pos_insDel[i] [2];

                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                         }
                    }
                }
                gMB_InsertFlg = 0x00;

           }

        }//end if gMB_loadReloadFlg

     }
      //changes from J.Karl 30.11.2012
    putvalue( env_AudioSD_MB_FRU, 0x0 );
}

on envVar env_AudioSD_RL_delete
{
    //IssueList #76 - MR49870 : ReceptionList
    word startelement, elements, PosCtr,RLlistCtr, PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_RECEPTIONLIST_ENTRIES];
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,z,x,y, csHandlectr;
    byte SHReqSent, c,posHandleFlg, handleDeletedFlg;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;

    for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
        POS[i] = 0;

    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;


  // do action
  if(  gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
  {

    gRL_DelInvalidCtr = 0;
    gRL_DelValidCtr = 0;
    csHandlectr = 0;
    SHReqSent = 0;
    posHandleFlg= 0;
    PosVal = 0x00;
    handleDeletedFlg = 0;

    for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
        gRL_InvalidDel[i] = 0;

    for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
        {
        gReceptionList_Send[i][0] = 0;   //POS value
        gReceptionList_Send[i][1] = 0;   //index
        }

    putvalue ( env_AudioSD_RL_Insert_Message, empty_string );
    //MR 63332 #3   02.07.2014
    //gRL_TotalElem = getValue( env_AudioSD_RL_TotalNumLE );
    gRL_TotalElem = gReceptionList_TotalNumListElements;



    //get data from Panel
    gReceptionList_ElementType  = getvalue( env_AudioSD_RL_ElementType );
    gReceptionList_ParentID     = getvalue( env_AudioSD_RL_ParentID);
    recordaddress               = 0x0F;

    //changes from Gerd Bewersdorf
    shift           = 0x1;
    direction       = 0x1;
    //shift                       = getvalue( env_AudioSD_RL_AH_shift );
    //direction                   = getvalue( env_AudioSD_RL_AH_dir );
    transmitpos                 = 0x1;
    indexsize                   = getvalue( env_AudioSD_RL_delete_size );


    //message
    requestarray[0] = LSG_AudioSD;          //LSG-ID
    requestarray[1] = FctID_ReceptionList;  //Fct.-ID
    requestarray[2] = Changed_REQ;          //request type

    requestarray[3] = gReceptionList_ElementType;
    requestarray[4] = gReceptionList_ParentID& 0xff;
    requestarray[5] = ( gReceptionList_ParentID& 0xff00 ) / 0x100;
    Offset =6;

    switch(  indexsize ) // POS size
    {
        case 0: //8Bit
            getvalue( env_AudioSD_RL_delete_POS_8, POS);
            //startelement = POS[0];
            startelement = getvalue( env_AudioSD_RL_delete_start );
            elements     = getValueSize( env_AudioSD_RL_delete_POS_8 );

            //ErrHandler = ON
            if( getValue( env_AudioSD_RL_delete_ErrHandler )== 0x01 )
            {
                if( elements== 0x00 )   // if no data
                {
                    putValue( env_AudioSD_RL_delete_Message, "NO DATA TO SEND" );
                    break;
                }
                else     // with data
                {
                    ReceptionList_delete_ErrHandler_8 ( POS,elements );
                    //if all elements are invalid
                    if( elements == gRL_DelInvalidCtr )
                    {
                        putValue( env_AudioSD_RL_delete_Message, "POS INVALID" );
                        break;
                    }
                    else
                        elements = gRL_DelValidCtr;
                }
            }
            else  // no errorhandling
            {
                if( elements== 0x00 )   // if no data
                    transmitpos     = 0x0;
            }

            //mode
            mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;

            requestarray[Offset] = startelement;
            Offset++;

            requestarray[Offset] = elements;
            Offset++;

            /***ArrayData***/
            //IssueList #129  if-else condition
            if( getValue( env_AudioSD_RL_delete_Auto)== 0x00 )
            {
                if( getValue( env_AudioSD_RL_delete_ErrHandler )== 0x00 )
                {
                    for(  i = 0; i < elements; i++ )
                    {
                        requestarray[Offset] = POS[i];
                        Offset++;
                    }
                }
                else    // with error handling
                {
                    //check if handle is deleted
                    for( i = 0; i < gRL_DelValidCtr; i++ )
                    {
                        if( gReceptionList_Send[i][0] == gAudioSD_CSIhandle_FSGhandle )
                            handleDeletedFlg = 0x01;
                    }

                    //set FFFF, 0 as handle if all elements are deleted
                     if( gRL_totalDELctr == gRL_CSVtotalElem)
                     {
                    gAudioSD_CSIhandle_FSGhandle= 0xFFFF;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos= 0;

                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    //CurrentStationHandle_Request( Data_REQ, 0 );//sendstatus
                    }

                    for( i = 0; i < gRL_DelValidCtr; i++ )
                    {
                        requestarray[Offset] = gReceptionList_Send[i][0];
                        Offset++;

                        //UPDATING HANDLE VALUE
                    // if not all elements are deleted
                     if( gRL_totalDELctr < gRL_CSVtotalElem)
                     {
                        if( gReceptionList_Send[i][1]<= gAudioSD_CSIhandle_FSGhandle_absolutePos )
                        {

                            for( j = 0; j < gRL_CSVtotalElem; j++ )
                            {
                                if( gReceptionList_Pos_insDel[j][1] == 0x01 )
                                    csHandlectr++;

                                if( gReceptionList_Pos_insDel[j][0] == gReceptionList_Send[i][0] )
                                {
                                    for( z=j;z< gRL_CSVtotalElem;z++ )
                                    {
                                        if( gReceptionList_Pos_insDel[z][1] == 0x01 && z!=j)
                                            csHandlectr++;

                                        //if handle is deleted
                                        if( handleDeletedFlg == 0x01 )
                                        {
                                            if( gReceptionList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                gAudioSD_CSIhandle_FSGhandle = gReceptionList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gReceptionList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            }
                                        }
                                        //if handle is not deleted
                                        else if( gReceptionList_Pos_insDel[z][0] == gAudioSD_CSIhandle_FSGhandle )
                                        {
                                            gAudioSD_CSIhandle_FSGhandle = gReceptionList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gReceptionList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                        }
                                    }//for
                                }
                            }//for

                            csHandlectr = 0; // Reset deleted counter

                            //if new handle is not found moving forward, move backwards
                            if( SHReqSent == 0 )
                            {
                                for( j = gRL_CSVtotalElem-1; j>= 0; j--)
                                {

                                    //if( gReceptionList_Pos_insDel[j][1] == 0x01 )
                                    //csHandlectr++;

                                    if( gReceptionList_Pos_insDel[j][0] == gReceptionList_Send[i][0] )
                                    {
                                        for( z=j;z>= 0;z--)
                                        {
                                            if( gReceptionList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                for( c = 0; c<z; c++ )
                                                {
                                                    if( gReceptionList_Pos_insDel[c][1] == 0x01 )
                                                    {
                                                        csHandlectr++;
                                                    }
                                                }
                                                gAudioSD_CSIhandle_FSGhandle = gReceptionList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gReceptionList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            } //if( gReceptionList_Pos_insDel[z][1] != 0x01 )
                                        } //for( z=j;z>= 0;z--)
                                    } //if( gReceptionList_Pos_insDel[j][0] == gReceptionList_Send[i] )
                                } //for( j = gRL_CSVtotalElem-1; j>= 0; j--)
                            } //if( SHReqSent == 0 )
                        } //if( gReceptionList_Send[i] == gAudioSD_CSIhandle_FSGhandle )

                         //UPDATING THE HANDLE below the deleted element
                        x= 0;
                        for( y= 0;y< gRL_CSVtotalElem;y++ )
                        {

                            if( gReceptionList_Pos_insDel[y][1] == 0x01 )
                            continue ;
                            else
                            {
                            x++;
                                //if( gReceptionList_Pos_insDel[j][2] > gAudioSD_CSIhandle_FSGhandle_absolutePos )
                                    //gReceptionList_Pos_insDel[i][2] = gReceptionList_Pos_insDel[i][2] -1;
                                    gReceptionList_Pos_insDel[y][2] = x;

                            }//else
                        }//for

                       } //gRL_totalDELctr
                    } //for( i = 0; i < gRL_DelValidCtr; i++ )

                   //send STATUS
                   CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                }//else // with error handling
            }
            else
            {
                requestarray[Offset] = getValue( env_AudioSD_RL_delete_POS_8_A);
                Offset++;
            }

            break;

      case 1:  //16Bit
        // Note:
        // - POS[]: MSB,LSB,...
        // - RequestArray[]: LSB,MSB,...
        getvalue( env_AudioSD_RL_delete_POS_16, POS);
        //startelement  = ( POS[0]* 0x100 );
        //startelement += POS[1];
        startelement  = getvalue( env_AudioSD_RL_delete_start );
        elements      = getValueSize( env_AudioSD_RL_delete_POS_16 ) /2;

        if( getValue( env_AudioSD_RL_delete_ErrHandler )== 0x01 )
          {
                    if( elements== 0 )   // if insufficient data
                    {
                    putValue( env_AudioSD_RL_delete_Message, "NO DATA TO SEND" );
                    break;
                    }

                    else     // with data
                    {
                    ReceptionList_delete_ErrHandler_16 ( POS,elements *2 );
                        //if all elements are invalid
                        if( elements == gRL_DelInvalidCtr/2 )
                        {
                        putValue( env_AudioSD_RL_delete_Message, "ALL POS INVALID" );
                        break;
                        }

                        else
                       elements = gRL_DelValidCtr/2;
                    }
            }
        else  // no errorhandling
            {
            if( elements== 0x00 )   // if no data
            transmitpos     = 0x0;
            }

                //mode
                mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;

                requestarray[Offset] = startelement & 0xff;
                Offset++;
                requestarray[Offset] = (startelement & 0xff00 ) / 0x100;
                Offset++;


                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;

                /***ArrayData***/

                if( getValue( env_AudioSD_RL_delete_ErrHandler )== 0x00 )
                {
                    for(  i = 0; i < elements; i++ )    //2 elements are inserted to the array below
                    {
                       requestarray[Offset] = POS[(2*i)+ 1];
                       Offset++;

                       requestarray[Offset] = POS[(2*i)];
                       Offset++;
                    }
                }
                 else    // with error handling
                 {
                    //check if handle is deleted
                    for( i = 0; i < gRL_DelValidCtr; i++ )
                    {
                     PosVal= 0x00;
                     PosVal = gReceptionList_Send[i][0] << 8;
                     PosVal = PosVal|gReceptionList_Send[i + 1][0];

                    if( PosVal== gAudioSD_CSIhandle_FSGhandle )
                    handleDeletedFlg = 0x01;
                    }

                     //set FFFF, 0 as handle if all elements are deleted
                     if( gRL_totalDELctr == gRL_CSVtotalElem)
                    {
                    gAudioSD_CSIhandle_FSGhandle= 0xFFFF;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos= 0;

                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    //CurrentStationHandle_Request( Data_REQ, 0 );//sendstatus
                    }


                    for( i = 0; i < elements; i++ )
                    {
                           PosVal = 0x00;

                           requestarray[Offset] = gReceptionList_Send[(2*i)+ 1][0];
                           PosVal = requestarray[Offset];
                           Offset++;

                            requestarray[Offset] = gReceptionList_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;

                     //updating the handle value if not all elements are deleted
                     if( gRL_totalDELctr < gRL_CSVtotalElem)
                     {
                        if( PosVal<= gAudioSD_CSIhandle_FSGhandle )
                        {
                            for( j = 0; j < gRL_CSVtotalElem; j++ )
                            {
                                if( gReceptionList_Pos_insDel[j][1] == 0x01 )
                                    csHandlectr++;

                                //if( gReceptionList_Pos_insDel[j][0] == gReceptionList_Send[i] )
                                if( gReceptionList_Pos_insDel[j][0] == PosVal)
                                {
                                    for( z=j;z< gRL_CSVtotalElem;z++ )
                                    {
                                        if( gReceptionList_Pos_insDel[z][1] == 0x01 && z!=j)
                                            csHandlectr++;

                                        //if handle is deleted
                                        if( handleDeletedFlg == 0x01 )
                                        {

                                            if( gReceptionList_Pos_insDel[z][1] != 0x01 )
                                            {
                                            gAudioSD_CSIhandle_FSGhandle = gReceptionList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gReceptionList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index
                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                            }
                                        }
                                            //if handle is not deleted
                                        else if( gReceptionList_Pos_insDel[z][0] == gAudioSD_CSIhandle_FSGhandle )
                                        {
                                            gAudioSD_CSIhandle_FSGhandle = gReceptionList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gReceptionList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index
                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                         }
                                    }//for
                                }
                            }//for

                            csHandlectr = 0; // Reset deleted counter

                            //if new handle is not found moving forward, move backwards
                            if( SHReqSent == 0 )
                            {
                                for( j = gRL_CSVtotalElem-1; j>= 0; j--)
                                {

                                    //if( gReceptionList_Pos_insDel[j][1] == 0x01 )
                                        //csHandlectr++;

                                   //if( gReceptionList_Pos_insDel[j][0] == gReceptionList_Send[i] )
                                    if( gReceptionList_Pos_insDel[j][0] == PosVal)
                                    {
                                        for( z=j;z>= 0;z--)
                                        {

                                            if( gReceptionList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                for( c = 0; c<z; c++ )
                                                {
                                                    if( gReceptionList_Pos_insDel[c][1] == 0x01 )
                                                    {
                                                        csHandlectr++;
                                                    }
                                                }
                                                gAudioSD_CSIhandle_FSGhandle = gReceptionList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gReceptionList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            } //if( gReceptionList_Pos_insDel[z][1] != 0x01 )
                                        } //for( z=j;z>= 0;z--)
                                    } //if( gReceptionList_Pos_insDel[j][0] == gReceptionList_Send[i] )
                                } //for( j = gRL_CSVtotalElem-1; j>= 0; j--)
                            } //if( SHReqSent == 0 )
                        } //if( gReceptionList_Send[i] == gAudioSD_CSIhandle_FSGhandle )

                         //UPDATING THE HANDLE below the deleted element
                        /*for( j = 0; j < gRL_CSVtotalElem; j++ )
                        {
                            if( gReceptionList_Pos_insDel[j][2] > gAudioSD_CSIhandle_FSGhandle_absolutePos )
                            {
                                gReceptionList_Pos_insDel[j][2] = gReceptionList_Pos_insDel[j][2] -1;
                            }
                        }*///for

                        x= 0;
                        for( y= 0;y< gRL_CSVtotalElem;y++ )
                        {

                            if( gReceptionList_Pos_insDel[y][1] == 0x01 )
                            continue ;
                            else
                            {
                            x++;
                            gReceptionList_Pos_insDel[y][2] = x;

                            }//else
                        } //for

                       } //gRL_totalDELctr
                    } //for( i = 0; i < gRL_DelValidCtr; i++ )

                    //send STATUS
                   CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                } //else ERRORHANDLING

        break;

      default:
        break;
    }

    //resetting LoadReload Flg after Delete
    gRL_loadReloadFlg = 0x00;
    putValue( env_AudioSD_RL_insert_UPD_button, 0 );

        //DATA SENDING
        if( getValue( env_AudioSD_RL_delete_ErrHandler )== 0x00 )
       set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else
        {
            if( gRL_DelInvalidCtr!= 0 )
                putValue( env_AudioSD_RL_delete_Invalid, gRL_InvalidDel);

            if( gRL_DelValidCtr != 0x00 )
            {
                set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

                if( indexsize == 0x00 )
                //MR 63332 #3   02.07.2014
                //putValue( env_AudioSD_RL_TotalNumLE, gRL_TotalElem -gRL_DelValidCtr );
                gReceptionList_TotalNumListElements = gRL_TotalElem - gRL_DelValidCtr;
                else
                //putValue( env_AudioSD_RL_TotalNumLE, gRL_TotalElem -( gRL_DelValidCtr/2 ) );
                gReceptionList_TotalNumListElements = gRL_TotalElem -( gRL_DelValidCtr/2 );

                //gReceptionList_TotalNumListElements = getValue( env_AudioSD_RL_TotalNumLE );
                putValue( env_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements );

            }//if
        } //else

    } //if do action
}

on envVar env_AudioSD_TML_delete
{
    word startelement, elements;
byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_TPMEMOLIST_ENTRIES];
dword requestarray[BAP_BUFFER_SIZE], Offset, i;

// Init local variables.
mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;

    for( i = 0; i < AUDIO_TPMEMOLIST_ENTRIES; i++ )
        POS[i] = 0;

    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;


    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        //get data from Panel
        recordaddress   = 0x0F;
        shift           = 0x1;
        direction       = 0x1;
        transmitpos     = 0x1;
        indexsize       = 0;

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //message
        requestarray[0] = LSG_AudioSD;                //LSG-ID
        requestarray[1] = FctID_TPMemoList;            //Fct.-ID
        requestarray[2] =Changed_REQ;               //request type
        Offset = 3;

        getvalue( env_AudioSD_TML_delete_POS_8, POS);
                //IssueList #129  if-else condition
                if( getValue( env_AudioSD_TML_delete_Auto)== 0x00 )
                {
                startelement    = POS[0];
                elements        = getValueSize( env_AudioSD_TML_delete_POS_8 );
                }
                else
                {
                startelement    = getValue( env_AudioSD_TML_delete_POS_8_A);
                elements        = 1;
                }


/***ArrayHeader***/
requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
        Offset++;

        requestarray[Offset] = startelement;
        Offset++;

        requestarray[Offset] = elements;
        Offset++;

        /***ArrayData***/
        //IssueList #129  if-else condition
        if( getValue( env_AudioSD_TML_delete_Auto)== 0x00 )

            for( i = 0; i < getValueSize( env_AudioSD_TML_delete_POS_8 ); i++ )
            {
             requestarray[Offset] = POS[i];
             Offset++;
             }

          else
          {
          requestarray[Offset] = getValue( env_AudioSD_TML_delete_POS_8_A);
          Offset++;
          }



        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
    }
}

on envVar env_AudioSD_SL_delete
{
    //IssueList #76 - MR49870 : SourceList
    word startelement, elements, PosCtr,SLlistCtr, PosVal,x,y;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_SOURCELIST_ENTRIES];
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,z, csHandlectr;
    byte SHReqSent, c,posHandleFlg,handleDeletedFlg;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;

    for( i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++ )
        POS[i] = 0;

    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;


    // do action
    if(  gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
          gSL_DelInvalidCtr = 0;
        gSL_DelValidCtr = 0;
        csHandlectr = 0;
        SHReqSent = 0;
        posHandleFlg= 0;
        PosVal = 0x00;
        handleDeletedFlg = 0;

        for( i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++ )
            gSL_InvalidDel[i] = 0;

        for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
        {
        gSourceList_Send[i][0] = 0; //pos
        gSourceList_Send[i][1] = 0; //sourcetype
        }

        putvalue ( env_AudioSD_SL_Insert_Message, empty_string );
        //MR 63332 #3   02.07.2014
        //gSL_TotalElem = getValue( env_AudioSD_SL_TotalNumLE );
        gSL_TotalElem = gSourceList_TotalNumListElements;

         //get data from Panel
        recordaddress   = 0x0F;
        shift           = 0x1;
        direction       = 0x1;
        transmitpos     = 0x1;
        indexsize       = getvalue( env_AudioSD_SL_delete_size );


        //message
        requestarray[0] = LSG_AudioSD;          //LSG-ID
        requestarray[1] = FctID_SourceList;  //Fct.-ID
        requestarray[2] = Changed_REQ;          //request type
        Offset = 3;

        switch(  indexsize ) // POS size
        {
          case 0: //8Bit
            getvalue( env_AudioSD_SL_delete_POS_8, POS);
            startelement = getvalue( env_AudioSD_SL_delete_start );
            elements     = getValueSize( env_AudioSD_SL_delete_POS_8 );

            //ErrHandler = ON
            if( getValue( env_AudioSD_SL_delete_ErrHandler )== 0x01 )
            {
                    if( elements== 0x00 )   // if no data
                    {
                    putValue( env_AudioSD_SL_delete_Message, "NO DATA TO SEND" );
                    break;
                    }

                    else     // with data
                    {
                    SourceList_delete_ErrHandler_8 ( POS,elements );
                            //if all elements are invalid
                            if( elements == gSL_DelInvalidCtr )
                            {
                            putValue( env_AudioSD_SL_delete_Message, "ALL POS INVALID" );
                            break;
                            }

                            else
                            elements = gSL_DelValidCtr;
                    }
            }
            else  // no errorhandling
            {
                if( elements== 0x00 )   // if no data
                transmitpos     = 0x0;
            }

            //mode
            mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

                    /***ArrayHeader***/
                    requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                    Offset++;

                    requestarray[Offset] = startelement;
                    Offset++;

                    requestarray[Offset] = elements;
                    Offset++;

                    /***ArrayData***/
                    //IssueList #129  if-else condition
                    if( getValue( env_AudioSD_SL_delete_Auto)== 0x00 )
                    {
                        if( getValue( env_AudioSD_SL_delete_ErrHandler )== 0x00 )
                        {
                            for(  i = 0; i < elements; i++ )
                            {
                              requestarray[Offset] = POS[i];
                              Offset++;
                            }

                        }//if
                        else    // with error handling
                        {

                            //set FFFF, 0 as handle if all elements are deleted
                             if( gSL_totalDELctr == gSL_CSVtotalElem)
                            {
                            gAudioSD_activeSource_SourceList_Reference = 0xFFFF;
                            gAudioSD_activeSource_SourceType = 0;

                            putvalue( env_AudioSD_activeSrc_Type, gAudioSD_activeSource_SourceType );
                            putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_activeSource_SourceList_Reference );
                            }

                            for( i = 0; i < gSL_DelValidCtr; i++ )
                            {
                                requestarray[Offset] = gSourceList_Send[i][0];
                                Offset++;

                                //checking if handle is deleted
                                if( gSourceList_Send[i][0] == gAudioSD_activeSource_SourceList_Reference )
                                handleDeletedFlg = 0x01;

                                //UPDATING HANDLE VALUE
                                //if handle is deleted
                                if( handleDeletedFlg == 0x01 )
                                {
                                // if not all elements are deleted
                                 if( gSL_totalDELctr < gSL_CSVtotalElem)
                                {
                                        for( j = 0; j < gSL_CSVtotalElem; j++ )
                                        {
                                            if( gSourceList_Pos_insDel[j][0] == gSourceList_Send[i][0] )
                                            {
                                                for( z=j;z< gSL_CSVtotalElem;z++ )
                                                {
                                                        if( gSourceList_Pos_insDel[z][1] != 0x01 )
                                                        {
                                                        gAudioSD_activeSource_SourceType = gSourceList_Pos_insDel[z][2];
                                                        gAudioSD_activeSource_SourceList_Reference = gSourceList_Pos_insDel[z][0];
                                                        putvalue( env_AudioSD_activeSrc_Type, gAudioSD_activeSource_SourceType );
                                                        putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_activeSource_SourceList_Reference );
                                                        SHReqSent = 1;
                                                        break;
                                                        }

                                                }//for
                                            } //if
                                        }//for

                                        //if new handle is not found moving forward, move backwards
                                        if( SHReqSent == 0 )
                                        {
                                            for( j = gSL_CSVtotalElem-1; j>= 0; j--)
                                            {
                                                if( gSourceList_Pos_insDel[j][0] == gSourceList_Send[i][0] )
                                                {
                                                    for( z=j;z>= 0;z--)
                                                    {
                                                        if( gSourceList_Pos_insDel[z][1] != 0x01 )
                                                        {
                                                            gAudioSD_activeSource_SourceType = gSourceList_Pos_insDel[z][2];
                                                            gAudioSD_activeSource_SourceList_Reference = gSourceList_Pos_insDel[z][0];

                                                            putvalue( env_AudioSD_activeSrc_Type, gAudioSD_activeSource_SourceType );
                                                            putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_activeSource_SourceList_Reference );
                                                            SHReqSent = 1;
                                                            break;
                                                        } //if( gSourceList_Pos_insDel[z][1] != 0x01 )
                                                    } //for( z=j;z>= 0;z--)
                                                }
                                            } //for( j = gSL_CSVtotalElem-1; j>= 0; j--)
                                        } //if( SHReqSent == 0 )

                                } //gSL_totalDELctr
                              } //handleDeletedFlg
                            } //for( i = 0; i < gSL_DelValidCtr; i++ )
                            //send STATUS
                            if( handleDeletedFlg == 0x01 )
                            {
                            //updating the envars in 0x10 ActiveSource panel
                            sourceListType ();

                            //setting the values for available lists
                            gAudioSD_activeSource_ReceptionList          = getvalue( env_AudioSD_activeSrc_ReceptList );
                            gAudioSD_activeSource_PresetList             = getvalue( env_AudioSD_activeSrc_PresetList );
                            gAudioSD_activeSource_MediaBrowserList       = getvalue( env_AudioSD_activeSrc_MedBrList );
                             gAudioSD_activeSource_ListAvailable         = gAudioSD_activeSource_ReceptionList + gAudioSD_activeSource_PresetList* 0x02 + gAudioSD_activeSource_MediaBrowserList* 0x04;
                             //send status
                            activeSource_Request( Data_REQ, 0 );
                            }
                        }//else // with error handling
                    }//env_AudioSD_SL_delete_Auto
                    else
                    {
                    requestarray[Offset] = getValue( env_AudioSD_SL_delete_POS_8_A);
                    Offset++;
                    }

                break;

          case 1:  //16Bit
            // Note:
            // - POS[]: MSB,LSB,...
            // - RequestArray[]: LSB,MSB,...
            getvalue( env_AudioSD_SL_delete_POS_16, POS);
            startelement  = getvalue( env_AudioSD_SL_delete_start );
            elements      = getValueSize( env_AudioSD_SL_delete_POS_16 ) /2;

            if( getValue( env_AudioSD_SL_delete_ErrHandler )== 0x01 )
            {
                if( elements== 0 )   // if insufficient data
                    {
                    putValue( env_AudioSD_SL_delete_Message, "NO DATA TO SEND" );
                    break;
                    }

                    else     // with data
                    {
                    SourceList_delete_ErrHandler_16 ( POS,elements *2 );
                    //if all elements are invalid
                        if( elements == gSL_DelInvalidCtr/2 )
                        {
                        putValue( env_AudioSD_SL_delete_Message, "ALL POS INVALID" );
                        break;
                        }

                        else
                         elements = gSL_DelValidCtr/2;
                    }
            }
            else  // no errorhandling
            {
                if( elements== 0x00 )   // if no data
                transmitpos     = 0x0;
            }

                    //mode
                    mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

                    /***ArrayHeader***/
                    requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                    Offset++;

                    requestarray[Offset] = startelement & 0xff;
                    Offset++;
                    requestarray[Offset] = (startelement & 0xff00 ) / 0x100;
                    Offset++;


                    requestarray[Offset] = elements & 0xff;
                    Offset++;
                    requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                    Offset++;

                    /***ArrayData***/

                    if( getValue( env_AudioSD_SL_delete_ErrHandler )== 0x00 )
                    {
                            for(  i = 0; i < elements; i++ )    //2 elements are inserted to the array below
                            {
                              requestarray[Offset] = POS[(2*i)+ 1];
                              Offset++;

                              requestarray[Offset] = POS[(2*i)];
                              Offset++;
                            }
                    }
                    else    // with error handling
                    {
                        //check if handle is deleted

                         //set FFFF, 0 as handle if all elements are deleted
                         if( gSL_totalDELctr == gSL_CSVtotalElem)
                        {
                        gAudioSD_activeSource_SourceList_Reference = 0xFFFF;
                        gAudioSD_activeSource_SourceType = 0;

                         putvalue( env_AudioSD_activeSrc_Type, gAudioSD_activeSource_SourceType );
                         putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_activeSource_SourceList_Reference );
                        }

                        for( i = 0; i < gSL_DelValidCtr; i++ )
                        {

                            //IDENTIFYING IF HANDLE IS DELETED
                            PosVal= 0x00;
                            PosVal = gSourceList_Send[i][0] << 8;
                            PosVal = PosVal|gSourceList_Send[i + 1][0];

                            if( PosVal== gAudioSD_activeSource_SourceList_Reference )
                            handleDeletedFlg = 0x01;


                            //ARRAY DATA
                            PosVal = 0x00;
                            requestarray[Offset] = gSourceList_Send[(2*i)+ 1][0];
                            PosVal = requestarray[Offset] << 8;
                            Offset++;

                            requestarray[Offset] = gSourceList_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset];
                            Offset++;



                            //UPDATING HANDLE VALUE
                            //if handle is deleted
                            if( handleDeletedFlg == 0x01 )
                            {
                                if( gSL_totalDELctr < gSL_CSVtotalElem)
                                {
                                        for( j = 0; j < gSL_CSVtotalElem; j++ )
                                        {
                                            if( gSourceList_Pos_insDel[j][0] == PosVal)
                                            {
                                                for( z=j;z< gSL_CSVtotalElem;z++ )
                                                {
                                                        if( gSourceList_Pos_insDel[z][1] != 0x01 )
                                                        {
                                                        gAudioSD_activeSource_SourceType = gSourceList_Pos_insDel[z][2];
                                                        gAudioSD_activeSource_SourceList_Reference = gSourceList_Pos_insDel[z][0];
                                                        putvalue( env_AudioSD_activeSrc_Type, gAudioSD_activeSource_SourceType );
                                                        putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_activeSource_SourceList_Reference );
                                                        SHReqSent = 1;
                                                        break;
                                                        }
                                                }//for
                                            } //if
                                        }//for

                                    //if new handle is not found moving forward, move backwards
                                    if( SHReqSent == 0 )
                                    {
                                        for( j = gSL_CSVtotalElem-1; j>= 0; j--)
                                        {
                                            if( gSourceList_Pos_insDel[j][0] == PosVal)
                                            {
                                                for( z=j;z>= 0;z--)
                                                {
                                                    if( gSourceList_Pos_insDel[z][1] != 0x01 )
                                                    {
                                                        gAudioSD_activeSource_SourceType = gSourceList_Pos_insDel[z][2];
                                                        gAudioSD_activeSource_SourceList_Reference = gSourceList_Pos_insDel[z][0];

                                                        putvalue( env_AudioSD_activeSrc_Type, gAudioSD_activeSource_SourceType );
                                                        putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_activeSource_SourceList_Reference );
                                                        SHReqSent = 1;
                                                        break;
                                                    } //if( gSourceList_Pos_insDel[z][1] != 0x01 )
                                                } //for( z=j;z>= 0;z--)
                                            } //if( gSourceList_Pos_insDel[j][0] == PosVal)
                                        } //for( j = gSL_CSVtotalElem-1; j>= 0; j--)
                                    } //if( SHReqSent == 0 )

                            } //gSL_totalDELctr
                           } //handleDeleted
                        } //for( i = 0; i < gSL_DelValidCtr; i++ )
                        //send STATUS
                        if( handleDeletedFlg == 0x01 )
                        {
                         //updating the envars in 0x10 ActiveSource panel
                            sourceListType ();

                            //setting the values for available lists
                            gAudioSD_activeSource_ReceptionList          = getvalue( env_AudioSD_activeSrc_ReceptList );
                            gAudioSD_activeSource_PresetList             = getvalue( env_AudioSD_activeSrc_PresetList );
                            gAudioSD_activeSource_MediaBrowserList       = getvalue( env_AudioSD_activeSrc_MedBrList );
                            gAudioSD_activeSource_ListAvailable         = gAudioSD_activeSource_ReceptionList + gAudioSD_activeSource_PresetList* 0x02 + gAudioSD_activeSource_MediaBrowserList* 0x04;
                             //send status
                            activeSource_Request( Data_REQ, 0 );
                        }
                    }// with error handling
            break;

          default:
            break;
        }

        putValue( env_AudioSD_SL_insert_UPD_button, 0 );

            //DATA SENDING
            if( getValue( env_AudioSD_SL_delete_ErrHandler )== 0x00 )
           set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

            else
            {
                if( gSL_DelInvalidCtr!= 0 )
                    putValue( env_AudioSD_SL_delete_Invalid, gSL_InvalidDel);

                if( gSL_DelValidCtr != 0x00 )
                {
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                    //MR 63332 #3   02.07.2014
                    if( indexsize == 0x00 )
                    //putValue( env_AudioSD_SL_TotalNumLE, gSL_TotalElem -gSL_DelValidCtr );
                                gSourceList_TotalNumListElements = gSL_TotalElem - gSL_DelValidCtr;
                    else
                    //putValue( env_AudioSD_SL_TotalNumLE, gSL_TotalElem -( gSL_DelValidCtr/2 ) );
                                gSourceList_TotalNumListElements = gSL_TotalElem -( gSL_DelValidCtr/2 );

                    //gSourceList_TotalNumListElements = getValue( env_AudioSD_SL_TotalNumLE );
                                putValue( env_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements );
                }//if
            } //else

    } //if do action
}

on envVar env_AudioSD_RTPL_delete
{
    //IssueList #76 - MR49870 : RTPL
    word startelement, elements, PosCtr,RTPLCtr, PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_RADIOTVPRESETLIST_ENTRIES ];
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,z,x,y, csHandlectr;
    byte SHReqSent, c,posHandleFlg, handleDeletedFlg;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;

    for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES ; i++ )
        POS[i] = 0;

    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;


  // do action
  if(  gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
  {

    gRTPL_DelInvalidCtr = 0;
    gRTPL_DelValidCtr = 0;
    csHandlectr = 0;
    SHReqSent = 0;
    posHandleFlg= 0;
    PosVal = 0x00;
    handleDeletedFlg = 0;

    for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES ; i++ )
        gRTPL_InvalidDel[i] = 0;

    for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES ; i++ )
        {
        gRTPL_Send[i][0] = 0;
        gRTPL_Send[i][1] = 0;
        }

    putvalue ( env_AudioSD_RTPL_Insert_Message, empty_string );
    //MR 63332 #3   02.07.2014
    //gRTPL_TotalElem = getValue( env_AudioSD_RTPL_TotalNumLE );
    gRTPL_TotalElem = gRadioTVPresetList_TotalNumListElements;


    //get data from Panel
    recordaddress               = 0x0F;

    //changes from Gerd Bewersdorf
    shift           = 0x1;
    direction       = 0x1;
    //shift                       = getvalue( env_AudioSD_RTPL_AH_shift );
    //direction                   = getvalue( env_AudioSD_RTPL_AH_dir );
    transmitpos                 = 0x1;
    indexsize                   = getvalue( env_AudioSD_RTPL_delete_size );


    //message
    requestarray[0] = LSG_AudioSD;                //LSG-ID
    requestarray[1] = FctID_RadioTV_PresetList;    //Fct.-ID
    requestarray[2] =Changed_REQ;               //request type
    Offset = 3;

    switch(  indexsize ) // POS size
    {
        case 0: //8Bit
            getvalue( env_AudioSD_RTPL_delete_POS_8, POS);
            //startelement = POS[0];
            startelement = getvalue( env_AudioSD_RTPL_delete_start );
            elements     = getValueSize( env_AudioSD_RTPL_delete_POS_8 );

            //ErrHandler = ON
            if( getValue( env_AudioSD_RTPL_del_ErrHandler )== 0x01 )
            {
                if( elements== 0x00 )   // if no data
                {
                    putValue( env_AudioSD_RTPL_delete_Message, "NO DATA TO SEND" );
                    break;
                }
                else     // with data
                {
                    RTPL_delete_ErrHandler_8 ( POS,elements );
                    //if all elements are invalid
                    if( elements == gRTPL_DelInvalidCtr )
                    {
                        putValue( env_AudioSD_RTPL_delete_Message, "POS INVALID" );
                        break;
                    }
                    else
                        elements = gRTPL_DelValidCtr;
                }
            }
            else  // no errorhandling
            {
                if( elements== 0x00 )   // if no data
                    transmitpos     = 0x0;
            }

            //mode
            mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;

            requestarray[Offset] = startelement;
            Offset++;

            requestarray[Offset] = elements;
            Offset++;

            /***ArrayData***/
            //IssueList #129  if-else condition
            if( getValue( env_AudioSD_RTPL_delete_Auto)== 0x00 )
            {
                if( getValue( env_AudioSD_RTPL_del_ErrHandler )== 0x00 )
                {
                    for(  i = 0; i < elements; i++ )
                    {
                        requestarray[Offset] = POS[i];
                        Offset++;
                    }
                }
                else    // with error handling
                {
                    //check if handle is deleted
                    for( i = 0; i < gRTPL_DelValidCtr; i++ )
                    {
                        if( gRTPL_Send[i][0] == gAudioSD_CSIhandle_PresetListRef )
                            handleDeletedFlg = 0x01;
                    }

                    //set FFFF, 0 as handle if all elements are deleted
                     if( gRTPL_totalDELctr == gRTPL_CSVtotalElem)
                     {
                    gAudioSD_CSIhandle_PresetListRef = 0xFFFF;
                    gAudioSD_CSIhandle_PresetListabsolutePos= 0;

                    putvalue( env_AudioSD_CSH_PresetListRef, gAudioSD_CSIhandle_PresetListRef );
                    putValue( env_AudioSD_CSH_PresetListAbsPos, gAudioSD_CSIhandle_PresetListabsolutePos );
                    //CurrentStationHandle_Request( Data_REQ, 0 );//sendstatus
                    }

                    for( i = 0; i < gRTPL_DelValidCtr; i++ )
                    {
                        requestarray[Offset] = gRTPL_Send[i][0];
                        Offset++;

                        //UPDATING HANDLE VALUE
                    // if not all elements are deleted
                     if( gRTPL_totalDELctr < gRTPL_CSVtotalElem)
                     {
                        if( gRTPL_Send[i][1]<= gAudioSD_CSIhandle_PresetListabsolutePos )
                        {

                            for( j = 0; j < gRTPL_CSVtotalElem; j++ )
                            {
                                if( gRTPL_Pos_insDel[j][1] == 0x01 )
                                    csHandlectr++;

                                if( gRTPL_Pos_insDel[j][0] == gRTPL_Send[i][0] )
                                {
                                    for( z=j;z< gRTPL_CSVtotalElem;z++ )
                                    {
                                        if( gRTPL_Pos_insDel[z][1] == 0x01 && z!=j)
                                            csHandlectr++;

                                        //if handle is deleted
                                        if( handleDeletedFlg == 0x01 )
                                        {
                                            if( gRTPL_Pos_insDel[z][1] != 0x01 )
                                            {
                                                gAudioSD_CSIhandle_PresetListRef = gRTPL_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_PresetListabsolutePos = (z-csHandlectr )+ 1;
                                                gRTPL_Pos_insDel[z][2] = gAudioSD_CSIhandle_PresetListabsolutePos;

                                                putvalue( env_AudioSD_CSH_PresetListRef, gAudioSD_CSIhandle_PresetListRef );
                                                putValue( env_AudioSD_CSH_PresetListAbsPos, gAudioSD_CSIhandle_PresetListabsolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            }
                                        }
                                        //if handle is not deleted
                                        else if( gRTPL_Pos_insDel[z][0] == gAudioSD_CSIhandle_PresetListRef )
                                        {
                                            gAudioSD_CSIhandle_PresetListRef = gRTPL_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_PresetListabsolutePos = (z-csHandlectr )+ 1;
                                            gRTPL_Pos_insDel[z][2] = gAudioSD_CSIhandle_PresetListabsolutePos;

                                            putvalue( env_AudioSD_CSH_PresetListRef, gAudioSD_CSIhandle_PresetListRef );
                                            putValue( env_AudioSD_CSH_PresetListAbsPos, gAudioSD_CSIhandle_PresetListabsolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                        }
                                    }//for
                                }
                            }//for

                            csHandlectr = 0; // Reset deleted counter

                            //if new handle is not found moving forward, move backwards
                            if( SHReqSent == 0 )
                            {
                                for( j = gRTPL_CSVtotalElem-1; j>= 0; j--)
                                {

                                    //if( gRTPL_Pos_insDel[j][1] == 0x01 )
                                    //csHandlectr++;

                                    if( gRTPL_Pos_insDel[j][0] == gRTPL_Send[i][0] )
                                    {
                                        for( z=j;z>= 0;z--)
                                        {
                                            if( gRTPL_Pos_insDel[z][1] != 0x01 )
                                            {
                                                for( c = 0; c<z; c++ )
                                                {
                                                    if( gRTPL_Pos_insDel[c][1] == 0x01 )
                                                    {
                                                        csHandlectr++;
                                                    }
                                                }
                                                gAudioSD_CSIhandle_PresetListRef = gRTPL_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_PresetListabsolutePos = (z-csHandlectr )+ 1;
                                                gRTPL_Pos_insDel[z][2] = gAudioSD_CSIhandle_PresetListabsolutePos;

                                                putvalue( env_AudioSD_CSH_PresetListRef, gAudioSD_CSIhandle_PresetListRef );
                                                putValue( env_AudioSD_CSH_PresetListAbsPos, gAudioSD_CSIhandle_PresetListabsolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            } //if( gRTPL_Pos_insDel[z][1] != 0x01 )
                                        } //for( z=j;z>= 0;z--)
                                    } //if( gRTPL_Pos_insDel[j][0] == gRTPL_Send[i] )
                                } //for( j = gRTPL_CSVtotalElem-1; j>= 0; j--)
                            } //if( SHReqSent == 0 )
                        } //if( gRTPL_Send[i] == gAudioSD_CSIhandle_PresetListRef )

                         //UPDATING THE HANDLE below the deleted element
                        x= 0;
                        for( y= 0;y< gRTPL_CSVtotalElem;y++ )
                        {

                            if( gRTPL_Pos_insDel[y][1] == 0x01 )
                            continue ;
                            else
                            {
                            x++;
                            gRTPL_Pos_insDel[y][2] = x;
                            }//else
                        }//for

                       } //gRTPL_totalDELctr
                    } //for( i = 0; i < gRTPL_DelValidCtr; i++ )

                   //send STATUS
                   CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                }//else // with error handling
            }
            else
            {
                requestarray[Offset] = getValue( env_AudioSD_RTPL_delete_POS_8_A);
                Offset++;
            }

            break;


      default:
        break;
    }

    //resetting LoadReload Flg after Delete
    gRTPL_loadReloadFlg = 0x00;
    putValue( env_AudioSD_RTPL_insert_UPD_btn, 0 );


        //DATA SENDING
        if( getValue( env_AudioSD_RTPL_del_ErrHandler )== 0x00 )
       set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else
        {
            if( gRTPL_DelInvalidCtr!= 0 )
                putValue( env_AudioSD_RTPL_delete_Invalid, gRTPL_InvalidDel);

            if( gRTPL_DelValidCtr != 0x00 )
            {
                set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                //MR 63332 #3   02.07.2014
                if( indexsize == 0x00 )
                //putValue( env_AudioSD_RTPL_TotalNumLE, gRTPL_TotalElem -gRTPL_DelValidCtr );
                gRadioTVPresetList_TotalNumListElements = gRTPL_TotalElem - gRTPL_DelValidCtr;
                else
                //putValue( env_AudioSD_RTPL_TotalNumLE, gRTPL_TotalElem -( gRTPL_DelValidCtr/2 ) );
                gRadioTVPresetList_TotalNumListElements = gRTPL_TotalElem -( gRTPL_DelValidCtr/2 );

                putValue( env_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements );
            }//if
        } //else

    } //if do action
}

on envVar env_AudioSD_MB_delete
{
    //IssueList #76 - MR49870 : MediaBrowser
    word startelement, elements, PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_MEDIABROWSER_ENTRIES];
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,z,x,y, csHandlectr;
    byte SHReqSent, c,posHandleFlg, handleDeletedFlg;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;

    for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
        POS[i] = 0;

    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

  // do action
  if(  gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
  {
    gMB_DelInvalidCtr = 0;
    gMB_DelValidCtr = 0;
    csHandlectr = 0;
    SHReqSent = 0;
    posHandleFlg= 0;
    PosVal = 0x00;
    handleDeletedFlg = 0;

    for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
        gMB_InvalidDel[i] = 0;

    for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
        {
        gMediaBrowser_Send[i][0] = 0;
        gMediaBrowser_Send[i][1] = 0;
        }

    putvalue ( env_AudioSD_MB_Insert_Message, empty_string );
    //MR 63332 #3   02.07.2014
    //gMB_TotalElem = getValue( env_AudioSD_MB_TotalNumLE );
    gMB_TotalElem = gMediaBrowser_TotalNumListElements;

    //get data from Panel
    recordaddress               = 0x0F;

    //changes from Gerd Bewersdorf
    shift           = 0x1;
    direction       = 0x1;
    transmitpos     = 0x1;
    indexsize       = getvalue( env_AudioSD_MB_delete_size );

    //message
    requestarray[0] = LSG_AudioSD;                //LSG-ID
    requestarray[1] = FctID_MediaBrowser;        //Fct.-ID
    requestarray[2] =Changed_REQ;               //request type
    Offset = 3;

    switch(  indexsize ) // POS size
    {
        case 0: //8Bit
            getvalue( env_AudioSD_MB_delete_POS_8, POS);
            //startelement = POS[0];
            startelement = getvalue( env_AudioSD_MB_delete_start );
            elements     = getValueSize( env_AudioSD_MB_delete_POS_8 );

            //ErrHandler = ON
            if( getValue( env_AudioSD_MB_delete_ErrHandler )== 0x01 )
            {
                if( elements== 0x00 )   // if no data
                {
                    putValue( env_AudioSD_MB_delete_Message, "NO DATA TO SEND" );
                    break;
                }
                else     // with data
                {
                    MediaBrowser_delete_ErrHandler_8 ( POS,elements );
                    //if all elements are invalid
                    if( elements == gMB_DelInvalidCtr )
                    {
                        putValue( env_AudioSD_MB_delete_Message, "POS INVALID" );
                        break;
                    }
                    else
                        elements = gMB_DelValidCtr;
                }
            }
            else  // no errorhandling
            {
                if( elements== 0x00 )   // if no data
                    transmitpos     = 0x0;
            }

            //mode
            mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;

            requestarray[Offset] = startelement;
            Offset++;

            requestarray[Offset] = elements;
            Offset++;

            /***ArrayData***/
            //IssueList #129  if-else condition
            if( getValue( env_AudioSD_MB_delete_Auto)== 0x00 )
            {
                if( getValue( env_AudioSD_MB_delete_ErrHandler )== 0x00 )
                {
                    for(  i = 0; i < elements; i++ )
                    {
                        requestarray[Offset] = POS[i];
                        Offset++;
                    }
                }
                else    // with error handling
                {
                    //check if handle is deleted
                    for( i = 0; i < gMB_DelValidCtr; i++ )
                    {
                        if( gMediaBrowser_Send[i][0] == gAudioSD_CSIhandle_FSGhandle )
                            handleDeletedFlg = 0x01;
                    }

                    //set FFFF, 0 as handle if all elements are deleted
                     if( gMB_totalDELctr == gMB_CSVtotalElem)
                     {
                    gAudioSD_CSIhandle_FSGhandle= 0xFFFF;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos= 0;

                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    //CurrentStationHandle_Request( Data_REQ, 0 );//sendstatus
                    }

                    for( i = 0; i < gMB_DelValidCtr; i++ )
                    {
                        requestarray[Offset] = gMediaBrowser_Send[i][0];
                        Offset++;

                        //UPDATING HANDLE VALUE
                    // if not all elements are deleted
                     if( gMB_totalDELctr < gMB_CSVtotalElem)
                     {
                        if( gMediaBrowser_Send[i][1]<= gAudioSD_CSIhandle_FSGhandle_absolutePos )
                        {

                            for( j = 0; j < gMB_CSVtotalElem; j++ )
                            {
                                if( gMediaBrowser_Pos_insDel[j][1] == 0x01 )
                                    csHandlectr++;

                                if( gMediaBrowser_Pos_insDel[j][0] == gMediaBrowser_Send[i][0] )
                                {
                                    for( z=j;z< gMB_CSVtotalElem;z++ )
                                    {
                                        if( gMediaBrowser_Pos_insDel[z][1] == 0x01 && z!=j)
                                            csHandlectr++;

                                        //if handle is deleted
                                        if( handleDeletedFlg == 0x01 )
                                        {
                                            if( gMediaBrowser_Pos_insDel[z][1] != 0x01 )
                                            {
                                                gAudioSD_CSIhandle_FSGhandle = gMediaBrowser_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gMediaBrowser_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            }
                                        }
                                        //if handle is not deleted
                                        else if( gMediaBrowser_Pos_insDel[z][0] == gAudioSD_CSIhandle_FSGhandle )
                                        {
                                            gAudioSD_CSIhandle_FSGhandle = gMediaBrowser_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gMediaBrowser_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                        }
                                    }//for
                                }
                            }//for

                            csHandlectr = 0; // Reset deleted counter

                            //if new handle is not found moving forward, move backwards
                            if( SHReqSent == 0 )
                            {
                                for( j = gMB_CSVtotalElem-1; j>= 0; j--)
                                {

                                    //if( gMediaBrowser_Pos_insDel[j][1] == 0x01 )
                                    //csHandlectr++;

                                    if( gMediaBrowser_Pos_insDel[j][0] == gMediaBrowser_Send[i][0] )
                                    {
                                        for( z=j;z>= 0;z--)
                                        {
                                            if( gMediaBrowser_Pos_insDel[z][1] != 0x01 )
                                            {
                                                for( c = 0; c<z; c++ )
                                                {
                                                    if( gMediaBrowser_Pos_insDel[c][1] == 0x01 )
                                                    {
                                                        csHandlectr++;
                                                    }
                                                }
                                                gAudioSD_CSIhandle_FSGhandle = gMediaBrowser_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gMediaBrowser_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            } //if( gMediaBrowser_Pos_insDel[z][1] != 0x01 )
                                        } //for( z=j;z>= 0;z--)
                                    } //if( gMediaBrowser_Pos_insDel[j][0] == gMediaBrowser_Send[i] )
                                } //for( j = gMB_CSVtotalElem-1; j>= 0; j--)
                            } //if( SHReqSent == 0 )
                        } //if( gMediaBrowser_Send[i] == gAudioSD_CSIhandle_FSGhandle )

                         //UPDATING THE HANDLE below the deleted element
                        x= 0;
                        for( y= 0;y< gMB_CSVtotalElem;y++ )
                        {

                            if( gMediaBrowser_Pos_insDel[y][1] == 0x01 )
                            continue ;
                            else
                            {
                            x++;
                            gMediaBrowser_Pos_insDel[y][2] = x;
                            }//else
                        }//for

                       } //gMB_totalDELctr
                    } //for( i = 0; i < gMB_DelValidCtr; i++ )

                   //send STATUS
                   CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                }//else // with error handling
            }
            else
            {
            requestarray[Offset] = getValue( env_AudioSD_MB_delete_POS_8_A);
            Offset++;
            }

            break;

      case 1:  //16Bit
        // Note:
        // - POS[]: MSB,LSB,...
        // - RequestArray[]: LSB,MSB,...
        getvalue( env_AudioSD_MB_delete_POS_16, POS);
        startelement  = getvalue( env_AudioSD_MB_delete_start );
        elements      = getValueSize( env_AudioSD_MB_delete_POS_16 ) /2;

        if( getValue( env_AudioSD_MB_delete_ErrHandler )== 0x01 )
          {
                    if( elements== 0 )   // if insufficient data
                    {
                    putValue( env_AudioSD_MB_delete_Message, "NO DATA TO SEND" );
                    break;
                    }
                    else     // with data
                    {
                    MediaBrowser_delete_ErrHandler_16 ( POS,elements *2 );
                        //if all elements are invalid
                        if( elements == gMB_DelInvalidCtr/2 )
                        {
                        putValue( env_AudioSD_MB_delete_Message, "ALL POS INVALID" );
                        break;
                        }

                        else
                       elements = gMB_DelValidCtr/2;
                    }
            }
        else  // no errorhandling
            {
            if( elements== 0x00 )   // if no data
            transmitpos     = 0x0;
            }

                //mode
                mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;

                requestarray[Offset] = startelement & 0xff;
                Offset++;
                requestarray[Offset] = (startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;

                /***ArrayData***/

                if( getValue( env_AudioSD_MB_delete_ErrHandler )== 0x00 )
                {
                    for(  i = 0; i < elements; i++ )    //2 elements are inserted to the array below
                    {
                       requestarray[Offset] = POS[(2*i)+ 1];
                       Offset++;

                       requestarray[Offset] = POS[(2*i)];
                       Offset++;
                    }
                }
                 else    // with error handling
                 {
                    //check if handle is deleted
                    for( i = 0; i < gMB_DelValidCtr; i++ )
                    {
                     PosVal= 0x00;
                     PosVal = gMediaBrowser_Send[i][0] << 8;
                     PosVal = PosVal|gMediaBrowser_Send[i + 1][0];

                    if( PosVal== gAudioSD_CSIhandle_FSGhandle )
                    handleDeletedFlg = 0x01;
                    }

                     //set FFFF, 0 as handle if all elements are deleted
                     if( gMB_totalDELctr == gMB_CSVtotalElem)
                    {
                    gAudioSD_CSIhandle_FSGhandle= 0xFFFF;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos= 0;

                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    //CurrentStationHandle_Request( Data_REQ, 0 );//sendstatus
                    }


                    for( i = 0; i < elements; i++ )
                    {
                           PosVal = 0x00;

                           requestarray[Offset] = gMediaBrowser_Send[(2*i)+ 1][0];
                           PosVal = requestarray[Offset];
                           Offset++;

                            requestarray[Offset] = gMediaBrowser_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;

                     //updating the handle value if not all elements are deleted
                     if( gMB_totalDELctr < gMB_CSVtotalElem)
                     {
                        if( PosVal<= gAudioSD_CSIhandle_FSGhandle )
                        {
                            for( j = 0; j < gMB_CSVtotalElem; j++ )
                            {
                                if( gMediaBrowser_Pos_insDel[j][1] == 0x01 )
                                    csHandlectr++;

                                //if( gMediaBrowser_Pos_insDel[j][0] == gMediaBrowser_Send[i] )
                                if( gMediaBrowser_Pos_insDel[j][0] == PosVal)
                                {
                                    for( z=j;z< gMB_CSVtotalElem;z++ )
                                    {
                                        if( gMediaBrowser_Pos_insDel[z][1] == 0x01 && z!=j)
                                            csHandlectr++;

                                        //if handle is deleted
                                        if( handleDeletedFlg == 0x01 )
                                        {

                                            if( gMediaBrowser_Pos_insDel[z][1] != 0x01 )
                                            {
                                            gAudioSD_CSIhandle_FSGhandle = gMediaBrowser_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gMediaBrowser_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index
                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                            }
                                        }
                                            //if handle is not deleted
                                        else if( gMediaBrowser_Pos_insDel[z][0] == gAudioSD_CSIhandle_FSGhandle )
                                        {
                                            gAudioSD_CSIhandle_FSGhandle = gMediaBrowser_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gMediaBrowser_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index
                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                         }
                                    }//for
                                }
                            }//for

                            csHandlectr = 0; // Reset deleted counter

                            //if new handle is not found moving forward, move backwards
                            if( SHReqSent == 0 )
                            {
                                for( j = gMB_CSVtotalElem-1; j>= 0; j--)
                                {

                                    //if( gMediaBrowser_Pos_insDel[j][1] == 0x01 )
                                        //csHandlectr++;

                                   //if( gMediaBrowser_Pos_insDel[j][0] == gMediaBrowser_Send[i] )
                                    if( gMediaBrowser_Pos_insDel[j][0] == PosVal)
                                    {
                                        for( z=j;z>= 0;z--)
                                        {

                                            if( gMediaBrowser_Pos_insDel[z][1] != 0x01 )
                                            {
                                                for( c = 0; c<z; c++ )
                                                {
                                                    if( gMediaBrowser_Pos_insDel[c][1] == 0x01 )
                                                    {
                                                        csHandlectr++;
                                                    }
                                                }
                                                gAudioSD_CSIhandle_FSGhandle = gMediaBrowser_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gMediaBrowser_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            } //if( gMediaBrowser_Pos_insDel[z][1] != 0x01 )
                                        } //for( z=j;z>= 0;z--)
                                    } //if( gMediaBrowser_Pos_insDel[j][0] == gMediaBrowser_Send[i] )
                                } //for( j = gMB_CSVtotalElem-1; j>= 0; j--)
                            } //if( SHReqSent == 0 )
                        } //if( gMediaBrowser_Send[i] == gAudioSD_CSIhandle_FSGhandle )

                         //UPDATING THE HANDLE below the deleted element
                        /*for( j = 0; j < gMB_CSVtotalElem; j++ )
                        {
                            if( gMediaBrowser_Pos_insDel[j][2] > gAudioSD_CSIhandle_FSGhandle_absolutePos )
                            {
                                gMediaBrowser_Pos_insDel[j][2] = gMediaBrowser_Pos_insDel[j][2] -1;
                            }
                        }*///for

                        x= 0;
                        for( y= 0;y< gMB_CSVtotalElem;y++ )
                        {

                            if( gMediaBrowser_Pos_insDel[y][1] == 0x01 )
                            continue ;
                            else
                            {
                            x++;
                            gMediaBrowser_Pos_insDel[y][2] = x;

                            }//else
                        } //for

                       } //gMB_totalDELctr
                    } //for( i = 0; i < gMB_DelValidCtr; i++ )

                    //send STATUS
                   CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                } //else ERRORHANDLING

        break;

      default:
        break;
    }

    //resetting LoadReload Flg after Delete
    gMB_loadReloadFlg = 0x00;
    putValue( env_AudioSD_MB_insert_UPD_button, 0 );

        //DATA SENDING
        if( getValue( env_AudioSD_MB_delete_ErrHandler )== 0x00 )
       set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else
        {
            if( gMB_DelInvalidCtr!= 0 )
                putValue( env_AudioSD_MB_delete_Invalid, gMB_InvalidDel);

            if( gMB_DelValidCtr != 0x00 )
            {
                set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                //if( indexsize == 0x00 )
                //putValue( env_AudioSD_MB_TotalNumLE, gMB_TotalElem -gMB_DelValidCtr );
                //else
                //putValue( env_AudioSD_MB_TotalNumLE, gMB_TotalElem -( gMB_DelValidCtr/2 ) );
                //gMediaBrowser_TotalNumListElements = getValue( env_AudioSD_MB_TotalNumLE );

                if( indexsize == 0x00 )
                gMediaBrowser_TotalNumListElements =  gMB_TotalElem - gMB_DelValidCtr;
                else
                gMediaBrowser_TotalNumListElements =  gMB_TotalElem -( gMB_DelValidCtr/2 );

                putValue( env_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements );
            }//if
        } //else

    } //if do action
}

//IssueList #32
void Audio_Current_Station_Handle_Update()
{
    int i = 0;

    switch( gAudioSD_DAC_ListType )
    {
        case AUDIO_DAC_RECEPTIONLIST:
        {
            //IssueList #108 - updating the currentStationInfo only when result is successful
            if( gAudioSD_DAC_Result != AUDIO_DAC_NOTSUCCESSFUL )
             {
                for( i = 0; i < gReceptionList_TotalNumListElements; i++ )
                {
                    if( gReceptionList_Pos[i] == gAudioSD_DAC_FSGHandle )
                    {

                        putValue( env_AudioSD_CSH_FSGhandle, gReceptionList_Pos[i] );
                        //IssueList #72
                        //putValue( env_AudioSD_CSH_FSGAbsPos, gReceptionList_Type[i] );
                        putValue( env_AudioSD_CSH_FSGAbsPos, i + 1 );

                        putValue( env_AudioSD_CSH_update, 0x1 );
                        //IssueList #32
                        setTimer( Station_Handle_Timer, 100 );

                        break;
                    }
                }//for
             }//if
        }
        break;

        case AUDIO_DAC_RADIOTVPRESETLIST:
        {
            for( i = 0; i < gRadioTVPresetList_TotalNumListElements; i++ )
            {
                if( gRadioTVPresetList_Pos[i] == gAudioSD_DAC_FSGHandle )
                {
                    putValue( env_AudioSD_CSH_PresetListRef, gRadioTVPresetList_Pos[i] );
                    //IssueList #72
                    //putValue( env_AudioSD_CSH_PresetListAbsPos, gRadioTVPresetList_PresetIndex[i] );
                    putValue( env_AudioSD_CSH_PresetListAbsPos, i + 1 );
                    putValue( env_AudioSD_CSH_update, 0x1 );
                    //IssueList #32
            setTimer( Station_Handle_Timer, 100 );
                    break;
                }
            }
        }
        break;
        //IssueList #103
        case AUDIO_DAC_MEDIABROWSER:
        {
            for( i = 0; i < gMediaBrowser_TotalNumListElements; i++ )
            {
                if( gMediaBrowser_Pos[i] == gAudioSD_CSIhandle_FSGhandle )
                {
                    if( i == 0 )
                    {
                        i = gMediaBrowser_TotalNumListElements;
                    }

                    putValue( env_AudioSD_CSH_FSGhandle, gMediaBrowser_Pos[i-1] );

                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_update, 0x1 );
            setTimer( Station_Handle_Timer, 100 );

                    break;
                }
            }
        }
        break;

        default:
        break;
    }
}

//IssueList #32
on timer Station_Handle_Timer
{
    putValue( env_AudioSD_CSH_update, 0x0 );
    //IssueList #32
    cancelTimer( Station_Handle_Timer );
}

//IssueList #32
void Audio_Previous_Station_Handle_Update()
{
    int i = 0;

    switch( gAudioSD_DAC_ListType )
    {
        case AUDIO_DAC_RECEPTIONLIST:
        {
            //IssueList #108
            if( gAudioSD_DAC_Result != AUDIO_DAC_NOTSUCCESSFUL)
            {
                for( i = 0; i < gReceptionList_TotalNumListElements; i++ )
                {
                    if( gReceptionList_Pos[i] == gAudioSD_CSIhandle_FSGhandle )
                    {
                        if( i == 0 )
                        {
                            i = gReceptionList_TotalNumListElements;
                        }

                        putValue( env_AudioSD_CSH_FSGhandle, gReceptionList_Pos[i-1] );
                        //IssueList #72
                        //putValue( env_AudioSD_CSH_FSGAbsPos, gReceptionList_Type[i-1] );
                        putValue( env_AudioSD_CSH_FSGAbsPos, i + 1 );
                        putValue( env_AudioSD_CSH_update, 0x1 );
                        //IssueList #32
                        setTimer( Station_Handle_Timer, 100 );

                        break;
                    }//if
                }//for
              }//if
        }
        break;

        case AUDIO_DAC_RADIOTVPRESETLIST:
        {
            for( i = 0; i < gRadioTVPresetList_TotalNumListElements; i++ )
            {
                if( gRadioTVPresetList_Pos[i] == gAudioSD_CSIhandle_PresetListRef )
                {
                    if( i == 0 )
                    {
                        i = gRadioTVPresetList_TotalNumListElements;
                    }

                    putValue( env_AudioSD_CSH_PresetListRef, gRadioTVPresetList_Pos[i-1] );
                    //IssueList #72
                    //putValue( env_AudioSD_CSH_PresetListAbsPos, gRadioTVPresetList_PresetIndex[i-1] );
                    putValue( env_AudioSD_CSH_PresetListAbsPos, i + 1 );
                    putValue( env_AudioSD_CSH_update, 0x1 );
                    //IssueList #32
            setTimer( Station_Handle_Timer, 100 );

                    break;
                }
            }
        }
        break;

        //IssueList #103
        case AUDIO_DAC_MEDIABROWSER:
        {
            for( i = 0; i < gMediaBrowser_TotalNumListElements; i++ )
            {
                if( gMediaBrowser_Pos[i] == gAudioSD_CSIhandle_FSGhandle )
                {
                    if( i == 0 )
                    {
                        i = gMediaBrowser_TotalNumListElements;
                    }

                    putValue( env_AudioSD_CSH_FSGhandle, gMediaBrowser_Pos[i-1] );

                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_update, 0x1 );
            setTimer( Station_Handle_Timer, 100 );

                    break;
                }
            }
        }
        break;

        default:
        break;
    }
}

//IssueList #32
void Audio_Next_Station_Handle_Update()
{
    int i = 0;

    switch( gAudioSD_DAC_ListType )
    {
        case AUDIO_DAC_RECEPTIONLIST:
        {
            //IssueList #108
            if( gAudioSD_DAC_Result != AUDIO_DAC_NOTSUCCESSFUL)
             {
                for( i = 0; i < gReceptionList_TotalNumListElements; i++ )
                {
                    if( gReceptionList_Pos[i] == gAudioSD_CSIhandle_FSGhandle )
                    {
                        if( i == ( gReceptionList_TotalNumListElements - 1 ) )
                        {
                            i = -1;
                        }

                        putValue( env_AudioSD_CSH_FSGhandle, gReceptionList_Pos[i + 1] );
                        //IssueList #72
                        //putValue( env_AudioSD_CSH_FSGAbsPos, gReceptionList_Type[i + 1] );
                        putValue( env_AudioSD_CSH_FSGAbsPos, i + 1 );
                        putValue( env_AudioSD_CSH_update, 0x1 );
                        //IssueList #32
                setTimer( Station_Handle_Timer, 100 );

                        break;
                    }
                }//for
              }//if
        }
        break;

        case AUDIO_DAC_RADIOTVPRESETLIST:
        {
            for( i = 0; i < gRadioTVPresetList_TotalNumListElements; i++ )
            {
                if( gRadioTVPresetList_Pos[i] == gAudioSD_CSIhandle_PresetListRef )
                {
                    if( i == ( gRadioTVPresetList_TotalNumListElements - 1 ) )
                    {
                        i = -1;
                    }

                    putValue( env_AudioSD_CSH_PresetListRef, gRadioTVPresetList_Pos[i + 1] );
                    //IssueList #72
                    //putValue( env_AudioSD_CSH_PresetListAbsPos, gRadioTVPresetList_PresetIndex[i + 1] );
                    putValue( env_AudioSD_CSH_PresetListAbsPos, i + 1 );
                    putValue( env_AudioSD_CSH_update, 0x1 );
                    //IssueList #32
            setTimer( Station_Handle_Timer, 100 );
                    break;
                }
            }
        }
        break;


        //IssueList #103
        case AUDIO_DAC_MEDIABROWSER:
        {
            for( i = 0; i < gMediaBrowser_TotalNumListElements; i++ )
            {
                if( gMediaBrowser_Pos[i] == gAudioSD_CSIhandle_FSGhandle )
                {
                    if( i == 0 )
                    {
                        i = gMediaBrowser_TotalNumListElements;
                    }

                    putValue( env_AudioSD_CSH_FSGhandle, gMediaBrowser_Pos[i-1] );

                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_update, 0x1 );
            setTimer( Station_Handle_Timer, 100 );

                    break;
                }
            }
        }
        break;
        default:
        break;
    }
}

//IssueList #32
void Audio_Previous_Station_Info_Update()
{
    int i = 0;

    switch( gAudioSD_DAC_ListType )
    {
        case AUDIO_DAC_RECEPTIONLIST:
        {
            for( i = 0; i < gReceptionList_sum; i++ )
            {
                if( gReceptionList_Pos[i] == gAudioSD_CSIhandle_FSGhandle )
                {
                    /*if( i == 0 )
                    {
                        i = gReceptionList_TotalNumListElements;
                    }*/

                    //MR63833
                    //strncat( Pri_Station_Name, gReceptionList_Name[i-1], 30 );
                    //strncat( Sec_Station_Name, gReceptionList_Name[i-1], 30 );
                    //strncat( Ter_Station_Name, gReceptionList_Name[i-1], 30 );
                    //strncat( Quart_Station_Name, gReceptionList_Name[i-1], 30 );

                    strncat( Pri_Station_Name, gReceptionList_Name[i], 30 );
                    strncat( Sec_Station_Name, gReceptionList_Name[i], 30 );
                    strncat( Ter_Station_Name, gReceptionList_Name[i], 30 );
                    strncat( Quart_Station_Name, gReceptionList_Name[i], 30 );

                    putValue( env_AudioSD_CSI_PI_s, Pri_Station_Name );
                    putValue( env_AudioSD_CSI_SI_s, Sec_Station_Name );
                    putValue( env_AudioSD_CSI_TI_s, Ter_Station_Name );
                    putValue( env_AudioSD_CSI_QI_s, Quart_Station_Name );

                    strncpy( Pri_Station_Name, "", elcount( Pri_Station_Name ) );
                    strncpy( Sec_Station_Name, "Sec", elcount( Sec_Station_Name ) );
                    strncpy( Ter_Station_Name, "Ter", elcount( Ter_Station_Name ) );
                    strncpy( Quart_Station_Name, "Quart", elcount( Quart_Station_Name ) );

                    putValue( env_AudioSD_CSI_update, 0x1 );
                    setTimer( Station_Info_Timer, 100 );

                    break;
                }
            }
        }
        break;

        case AUDIO_DAC_RADIOTVPRESETLIST:
        {
            for( i = 0; i < gRadioTVPresetList_TotalNumListElements; i++ )
            {
                if( gRadioTVPresetList_Pos[i] == gAudioSD_CSIhandle_PresetListRef )
                {
                    if( i == 0 )
                    {
                        i = gRadioTVPresetList_TotalNumListElements;
                    }

                    strncat( Pri_Station_Name, gRadioTVPresetList_Name[i-1], 30 );
                    strncat( Sec_Station_Name, gRadioTVPresetList_Name[i-1], 30 );
                    strncat( Ter_Station_Name, gRadioTVPresetList_Name[i-1], 30 );
                    strncat( Quart_Station_Name, gRadioTVPresetList_Name[i-1], 30 );

                    putValue( env_AudioSD_CSI_PI_s, Pri_Station_Name );
                    putValue( env_AudioSD_CSI_SI_s, Sec_Station_Name );
                    putValue( env_AudioSD_CSI_TI_s, Ter_Station_Name );
                    putValue( env_AudioSD_CSI_QI_s, Quart_Station_Name );

                    strncpy( Pri_Station_Name, "", elcount( Pri_Station_Name ) );
                    strncpy( Sec_Station_Name, "Sec", elcount( Sec_Station_Name ) );
                    strncpy( Ter_Station_Name, "Ter", elcount( Ter_Station_Name ) );
                    strncpy( Quart_Station_Name, "Quart", elcount( Quart_Station_Name ) );

                    putValue( env_AudioSD_CSI_update, 0x1 );
                    setTimer( Station_Info_Timer, 100 );

                    break;
                }
            }
        }
        break;

        default:
        break;
    }
}

//IssueList #32
void Audio_Next_Station_Info_Update()
{
    int i = 0;

    switch( gAudioSD_DAC_ListType )
    {
        case AUDIO_DAC_RECEPTIONLIST:
        {
            for( i = 0; i < gReceptionList_sum; i++ )
            {
                if( gReceptionList_Pos[i] == gAudioSD_CSIhandle_FSGhandle )
                {
                    strncat( Pri_Station_Name, gReceptionList_Name[i], 30 );
                    strncat( Sec_Station_Name, gReceptionList_Name[i], 30 );
                    strncat( Ter_Station_Name, gReceptionList_Name[i], 30 );
                    strncat( Quart_Station_Name, gReceptionList_Name[i], 30 );


                    putValue( env_AudioSD_CSI_PI_s, Pri_Station_Name );
                    putValue( env_AudioSD_CSI_SI_s, Sec_Station_Name );
                    putValue( env_AudioSD_CSI_TI_s, Ter_Station_Name );
                    putValue( env_AudioSD_CSI_QI_s, Quart_Station_Name );

                    strncpy( Pri_Station_Name, "", elcount( Pri_Station_Name ) );
                    strncpy( Sec_Station_Name, "Sec", elcount( Sec_Station_Name ) );
                    strncpy( Ter_Station_Name, "Ter", elcount( Ter_Station_Name ) );
                    strncpy( Quart_Station_Name, "Quart", elcount( Quart_Station_Name ) );

                    putValue( env_AudioSD_CSI_update, 0x1 );
                    setTimer( Station_Info_Timer, 100 );

                    break;
                }
            }
        }
        break;

        case AUDIO_DAC_RADIOTVPRESETLIST:
        {
            for( i = 0; i < gRadioTVPresetList_TotalNumListElements; i++ )
            {
                if( gRadioTVPresetList_Pos[i] == gAudioSD_CSIhandle_PresetListRef )
                {
                    if( i == ( gRadioTVPresetList_TotalNumListElements - 1 ) )
                    {
                        i = -1;
                    }

                    strncat( Pri_Station_Name, gRadioTVPresetList_Name[i + 1], 30 );
                    strncat( Sec_Station_Name, gRadioTVPresetList_Name[i + 1], 30 );
                    strncat( Ter_Station_Name, gRadioTVPresetList_Name[i + 1], 30 );
                    strncat( Quart_Station_Name, gRadioTVPresetList_Name[i + 1], 30 );

                    putValue( env_AudioSD_CSI_PI_s, Pri_Station_Name );
                    putValue( env_AudioSD_CSI_SI_s, Sec_Station_Name );
                    putValue( env_AudioSD_CSI_TI_s, Ter_Station_Name );
                    putValue( env_AudioSD_CSI_QI_s, Quart_Station_Name );

                    strncpy( Pri_Station_Name, "", elcount( Pri_Station_Name ) );
                    strncpy( Sec_Station_Name, "Sec", elcount( Sec_Station_Name ) );
                    strncpy( Ter_Station_Name, "Ter", elcount( Ter_Station_Name ) );
                    strncpy( Quart_Station_Name, "Quart", elcount( Quart_Station_Name ) );

                    putValue( env_AudioSD_CSI_update, 0x1 );
                    setTimer( Station_Info_Timer, 100 );
                }
            }
        }
        break;

        default:
        break;
    }
}

//IssueList #32
void Audio_Current_Station_Info_Update()
{
    int i = 0;

    switch( gAudioSD_DAC_ListType )
    {
        case AUDIO_DAC_RECEPTIONLIST:
        {
            for( i = 0; i < gReceptionList_sum; i++ )
            {
                if( gReceptionList_Pos[i] == gAudioSD_DAC_FSGHandle )
                {
                    strncat( Pri_Station_Name, gReceptionList_Name[i], 30 );
                    strncat( Sec_Station_Name, gReceptionList_Name[i], 30 );
                    strncat( Ter_Station_Name, gReceptionList_Name[i], 30 );
                    strncat( Quart_Station_Name, gReceptionList_Name[i], 30 );


                    putValue( env_AudioSD_CSI_PI_s, Pri_Station_Name );
                    putValue( env_AudioSD_CSI_SI_s, Sec_Station_Name );
                    putValue( env_AudioSD_CSI_TI_s, Ter_Station_Name );
                    putValue( env_AudioSD_CSI_QI_s, Quart_Station_Name );

                    strncpy( Pri_Station_Name, "", elcount( Pri_Station_Name ) );
                    strncpy( Sec_Station_Name, "Sec", elcount( Sec_Station_Name ) );
                    strncpy( Ter_Station_Name, "Ter", elcount( Ter_Station_Name ) );
                    strncpy( Quart_Station_Name, "Quart", elcount( Quart_Station_Name ) );

                    putValue( env_AudioSD_CSI_update, 0x1 );
                    setTimer( Station_Info_Timer, 100 );

                    break;
                }
            }
        }
        break;

        case AUDIO_DAC_RADIOTVPRESETLIST:
        {
            for( i = 0; i < gRadioTVPresetList_TotalNumListElements; i++ )
            {
                if( gRadioTVPresetList_Pos[i] == gAudioSD_DAC_FSGHandle )
                {
                    strncat( Pri_Station_Name, gRadioTVPresetList_Name[i], 30 );
                    strncat( Sec_Station_Name, gRadioTVPresetList_Name[i], 30 );
                    strncat( Ter_Station_Name, gRadioTVPresetList_Name[i], 30 );
                    strncat( Quart_Station_Name, gRadioTVPresetList_Name[i], 30 );

                    putValue( env_AudioSD_CSI_PI_s, Pri_Station_Name );
                    putValue( env_AudioSD_CSI_SI_s, Sec_Station_Name );
                    putValue( env_AudioSD_CSI_TI_s, Ter_Station_Name );
                    putValue( env_AudioSD_CSI_QI_s, Quart_Station_Name );

                    strncpy( Pri_Station_Name, "", elcount( Pri_Station_Name ) );
                    strncpy( Sec_Station_Name, "Sec", elcount( Sec_Station_Name ) );
                    strncpy( Ter_Station_Name, "Ter", elcount( Ter_Station_Name ) );
                    strncpy( Quart_Station_Name, "Quart", elcount( Quart_Station_Name ) );

                    putValue( env_AudioSD_CSI_update, 0x1 );
                    setTimer( Station_Info_Timer, 100 );

                    break;
                }
            }
        }
        break;

        default:
        break;
    }
}

initBapConfig()
{
    long config[3];

    config[0] = 0x31;
    config[1] = 0;
    config[2] = getValue( BAPCFG_FSG_AudioSD_ProtocolMajor );
    ChangeConfig( 0x0012, config );
    config[2] = getValue( BAPCFG_FSG_AudioSD_ProtocolMinor );
    ChangeConfig( 0x0013, config );
    config[2] = getValue( BAPCFG_FSG_AudioSD_LsgClassMajor );
    ChangeConfig( 0x0010, config );
    config[2] = getValue( BAPCFG_FSG_AudioSD_LsgClassMinor );
    ChangeConfig( 0x0011, config );
    config[2] = getValue( BAPCFG_FSG_AudioSD_DFMajor );
    ChangeConfig( 0x0014, config );
    config[2] = getValue( BAPCFG_FSG_AudioSD_DFMinor );
    ChangeConfig( 0x0015, config );
}

ChangeConfig( long paramIndex,long config[] )
{
    byte temp ;

    temp = BAP180_ChangeConfig( NODE_INDEX, paramIndex, config );
    if( temp == 0 )
        { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "AudioSD: BAP170_ChangeConfig succesful (LSG %d, NODE_INDEX %d )", 0x31, NODE_INDEX); }
    else
        { if( boTraceStatus_ON ) writelineEx( gError_Trace, 0, "AudioSD: BAP170_ChangeConfig error 0x%X (LSG %d, NODE_INDEX %d )", temp, 0x31, NODE_INDEX); }
}

MediaImportState_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            MediaImportState_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD MediaImportState_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

CustomerDownloadState_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            CustomerDownloadState_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CustomerDownloadState_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

OnlineMusic_State_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            OnlineMusic_State_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD OnlineMusic_State_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

CommonList_Indication( dword Indication_array [], int datalength )
{
    byte mode, shift, direction, recordaddress, indexsize, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements, Offset, valid_elements;
    int i = 0, transSuppression;

    // Init local variables.
    mode = 0;
    shift = 0;
    Offset = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    recordaddress = 0;
    requested_startelement = 0;
    startelement = 0;
    elements = 0;
    valid_startelement = 0xff;
    i = 0;
    valid_elements = 0;
    transSuppression = getvalue( env_AudioSD_CL_noStatusArray );

    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:

            //VAGH-10511
            if( @sysvar::FSG_AudioSD::ComList_error_control)
            {
                CommonList_Request(Error_REQ, 0, 0, 0, 0, 0, 0, @sysvar::FSG_AudioSD::ComList_error_code );
            }
            else if( getvalue( env_AudioSD_CL_Timeout ) == TRUE )
            {
                //none
            }
            else
            {
                //getData
                gCommonList_ASGID = ( gBAP_Indication[3] & 0xF0 ) / 0x10;
                gCommonList_TAID = gBAP_Indication[3] & 0x0F;

                /***ArrayHeader***/
                mode = ( Indication_array[4] & 0xF0 ) / 0x10;
                recordaddress = Indication_array[4] & 0x0F;
                Offset = 5;

                // decode "mode -byte"
                shift = mode & 0x01;
                direction = ( mode & 0x02 ) / 0x02;
                transmitpos = ( mode & 0x04 ) / 0x04;
                indexsize = ( mode & 0x08 ) / 0x08;

                if( indexsize )
                {
                    startelement = Indication_array[Offset];
                    Offset++;
                    startelement += ( Indication_array[Offset] * 0x100 );
                    Offset++;

                    elements = Indication_array[Offset];
                    Offset++;
                    elements += ( Indication_array[Offset] * 0x100 );
                    Offset++;
                }
                else
                {
                    startelement = Indication_array[Offset];
                    Offset++;

                    elements = Indication_array[Offset];
                    Offset++;
                }
                requested_startelement = startelement;

                /***Startelement = 0***/
                if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
                {
                    if( FORWARD == direction )  //forward-start
                    {
                        valid_startelement = 0;

                        if( AUDIO_COMMONLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                        {
                            if( shift == FALSE )
                            {
                                for( i = 0; i < AUDIO_COMMONLIST_ENTRIES; i++ )
                                {
                                    if( 0 != gCommonList_ListEntryValidInformation[i] )  //if there is an valid element
                                    {
                                        if( gCommonList_Pos[i] > 0xFF )
                                            indexsize = TRUE;

                                        valid_elements++;                               //increment elements
                                    }

                                    else                                                //no valid element, loop finished
                                        i = AUDIO_COMMONLIST_ENTRIES;
                                }
                            }
                            else
                            {
                                valid_startelement = startelement;
                                valid_elements = 0;
                            }
                        }
                        else    //2. number of requested elements < elements in array
                        {
                            if( shift == FALSE )
                            {
                                for( i = 0; i < elements; i++ )
                                {
                                    if( 0 != gCommonList_ListEntryValidInformation[i] )  //if there is an valid element
                                    {
                                        if( gCommonList_Pos[i] > 0xFF )
                                            indexsize = TRUE;

                                        valid_elements++;                               //increment elements
                                    }
                                    else                                                //no valid element, loop finished
                                        i = AUDIO_COMMONLIST_ENTRIES;
                                }
                            }
                            else
                            {
                                valid_startelement = startelement;
                                valid_elements = 0;
                            }
                        }
                    }                                                               //forward ends
                    else if( BACKWARD == direction && TRUE == shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                    {
                        //searching for valid startelement
                        for( i = ( AUDIO_COMMONLIST_ENTRIES - 1 ); i >= 0; i--)
                        {
                            if( 0 != gCommonList_ListEntryValidInformation[i] )      //found valid startelement
                            {
                                valid_startelement = i;
                                i = 0;
                            }
                        }

                        //searching for valid elements
                        if( 0xFF == valid_startelement )                             //Startelement-ID doesn't exist in SMSReceived-array
                        {
                            valid_startelement = startelement;
                            valid_elements = 0;
                        }
                        else if( 0 == valid_startelement )
                            valid_elements = 1;                                       //only 1 element because valid startelement is on position 0

                        else if( elements > (valid_startelement + 1 ) )                   //not enougth array-elements available, because array endet at array-position 0
                        {
                            for( i = valid_startelement; i >= 0; i--)
                            {
                                if( 0 != gCommonList_ListEntryValidInformation[i] )  //if there is an valid element
                                {
                                    if( gCommonList_Pos[i] > 0xFF )
                                        indexsize = TRUE;

                                    valid_elements++;                               //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                        else                                                        //enougth array-elements available
                        {
                            for( i = valid_startelement; i > (valid_startelement - elements ); i--)
                            {
                                if( 0 != gCommonList_ListEntryValidInformation[i] )  //if there is an valid element
                                {
                                    valid_elements++;                               //increment elements

                                    if( gCommonList_Pos[i] > 0xFF )
                                        indexsize = TRUE;
                                }
                                else                                                //no valid element, loop finished
                                    i = 0;
                            }
                        }
                    }                                                               //backward-end
                }                                                                   //startelement == 0 -end
                /***Startelement!= 0***/
                else                                                                //searching for Startelement-ID
                {
                    //searching for valid startelement
                    for( i = 0; i < AUDIO_COMMONLIST_ENTRIES; i++ )
                    {
                        if( gCommonList_Pos[i] == startelement )                     //found a valid element
                        {
                            if( shift == TRUE )                                          //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                            {
                                if( i != 0 || BACKWARD != direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                    valid_startelement = i + 1 - 2 * direction;

                                else if( i == 0 && BACKWARD == direction )
                                    valid_startelement = gCommonListLine_sum;           //valid element is last element in Array

                                else if( i == 0 && FORWARD == direction )
                                    valid_startelement = 0;                          //valid element is first element in Array
                            }

                            else
                                valid_startelement = i;                              //found element is valid_startelement

                            i = AUDIO_COMMONLIST_ENTRIES;
                        }
                    }

                    if( 0xFF == valid_startelement )                                     //Startelement-ID doesn't exist in array
                    {
                        valid_startelement = startelement;
                        valid_elements = 0;
                    }
                    else                                                                //found valid entry for startelement in array
                    {
                        //verify number of valid elements
                        if( BACKWARD == direction )                                          //backward-start
                        {
                            if( valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                                valid_elements = 1;

                            else if( elements > (valid_startelement + 1 ) )                   //not enougth array-elements available, because array endet at array-position 0
                            {
                                for( i = valid_startelement; i >= 0; i--)
                                {
                                    if( 0 != gCommonList_ListEntryValidInformation[i] )  //if there is an valid element
                                    {
                                        if( gCommonList_Pos[i] > 0xFF )
                                            indexsize = TRUE;

                                        valid_elements++;                               //increment elements
                                    }
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for( i = valid_startelement; i > (valid_startelement - elements ); i--)
                                {
                                    if( 0 != gCommonList_ListEntryValidInformation[i] )  //if there is an valid element
                                    {
                                        if( gCommonList_Pos[i] > 0xFF )
                                            indexsize = TRUE;

                                        valid_elements++;                               //increment elements
                                    }
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }
                            }
                        }                                                               //backward-end
                        else                                                            //forward-start
                        {
                            if( (valid_startelement + elements ) >= AUDIO_COMMONLIST_ENTRIES)
                            {
                                for( i = valid_startelement; i < AUDIO_COMMONLIST_ENTRIES; i++ )
                                {
                                    if( 0 != gCommonList_Pos[i] )                            //if there is an valid element
                                    {
                                        if( gCommonList_Pos[i] > 0xFF )
                                            indexsize = TRUE;

                                        valid_elements++;                               //increment elements
                                    }
                                    else                                                    //no valid element, loop finished
                                        i = AUDIO_COMMONLIST_ENTRIES;
                                }
                            }
                            else
                            {
                                for( i = valid_startelement; i < (valid_startelement + elements ); i++ )
                                {
                                    if( 0 != gCommonList_Pos[i] )                            //if there is an valid element
                                    {
                                        if( gCommonList_Pos[i] > 0xFF )
                                            indexsize = TRUE;

                                        valid_elements++;                               //increment elements
                                    }
                                    else                                                //no valid element, loop finished
                                        i = AUDIO_COMMONLIST_ENTRIES;
                                }
                            }
                        }
                    } //END: if( BACKWARD==direction )
                } //END: if( 0 == startelement )

                transmitpos = TRUE;
                if( ( requested_startelement > 0xFF ) || (valid_startelement > 0xFF ) )
                    indexsize = TRUE;

                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + indexsize * 0x08;
                //send StatusArray
                if( !transSuppression )
                    CommonList_Request( Data_REQ, gCommonList_TotalNumListElements, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
            }
            break;

        case Error_IND:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CommonList_Indication: received error, errorcode:0x%x", Indication_array[3] );
            break;

        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CommonList_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

on envVar env_AudioSD_open_properties_5
{
    openPanel( "FSG_Property_DF41" );
}

on sysvar sysvar::FSG_AudioSD::MeImSe_InID
{
}

on sysvar sysvar::FSG_AudioSD::MeImSe_ST
{
      if( @sysvar::FSG_AudioSD::MeImSe_ST < 0x24 || !temp1 )
      {
          gMIS_STact = @sysvar::FSG_AudioSD::MeImSe_ST;
      }

      if( @sysvar::FSG_AudioSD::MeImSe_ST == 255 || !temp1 )
      {
          gMIS_STact = @sysvar::FSG_AudioSD::MeImSe_ST;
      }
      temp1 = 0;
      if( @sysvar::FSG_AudioSD::MeImSe_SThex != gMIS_STact )
      {
          @sysvar::FSG_AudioSD::MeImSe_SThex = @sysvar::FSG_AudioSD::MeImSe_ST;
      }
}

on sysvar sysvar::FSG_AudioSD::MeImSe_State0
{
    if( @sysvar::FSG_AudioSD::MeImSe_State0 == 1 )
        @sysvar::FSG_AudioSD::MeImSe_State1 = 0;
}

on sysvar sysvar::FSG_AudioSD::MeImSe_State1
{
    if( @sysvar::FSG_AudioSD::MeImSe_State1 == 1 )
        @sysvar::FSG_AudioSD::MeImSe_State0 = 0;
}

on sysvar sysvar::FSG_AudioSD::MeImSe_Status
{
      if( gAudioSD_PowerOnOff == @sysvar::FSG_AudioSD::MeImSe_Status )
      {
          MediaImportState_Request( Data_REQ, 0 );
      }
}

on envVar Env_FSG_Update_PP
{
    if( gAudioSD_PowerOnOff == @Env_FSG_Update_PP )
    {
        PlayPosition_Request( Data_REQ, 0 );
    }
}

on envVar Env_FSG_Update_SDS
{
    if( gAudioSD_PowerOnOff == @Env_FSG_Update_SDS)
    {
        SDS_RecognizerState_Request( Data_REQ, 0 );
    }
}

on envVar Env_FSG_Update_CSI2
{
    if( gAudioSD_PowerOnOff == @Env_FSG_Update_CSI2 )
    {
        CurrentStationInfo2_Request( Data_REQ, 0 );
    }
}

on envVar Env_FSG_Update_CSH3
{
    if( gAudioSD_PowerOnOff == @Env_FSG_Update_CSH3)
    {
        CurrentStationHandle3_Request( Data_REQ, 0 );
    }
}

on sysvar sysvar::FSG_AudioSD::MeImSe_SThex
{
    if( @sysvar::FSG_AudioSD::MeImSe_SThex > 0x24 && @sysvar::FSG_AudioSD::MeImSe_SThex != 255)
    {
        gMIS_STact = @sysvar::FSG_AudioSD::MeImSe_SThex;
        temp1 = 1;
        @sysvar::FSG_AudioSD::MeImSe_ST = @sysvar::FSG_AudioSD::MeImSe_SThex;
    }
    else
    {
        if( @sysvar::FSG_AudioSD::MeImSe_SThex != gMIS_STact )
            @sysvar::FSG_AudioSD::MeImSe_ST = @sysvar::FSG_AudioSD::MeImSe_SThex;
    }
}

on sysvar sysvar::FSG_AudioSD::OnMuSt_Status
{
    if( gAudioSD_PowerOnOff == @sysvar::FSG_AudioSD::OnMuSt_Status )
    {
        OnlineMusic_State_Request( Data_REQ, 0 );
    }
}

on sysvar sysvar::FSG_AudioSD::CuVoEx_Status
{
    if( gAudioSD_PowerOnOff == @sysvar::FSG_AudioSD::CuVoEx_Status )
    {
        CurrentVolumeExtended_Request( Data_REQ, 0 );
    }
}

on sysvar sysvar::FSG_AudioSD::CuStHa2_Status
{
    if( gAudioSD_PowerOnOff == @sysvar::FSG_AudioSD::CuStHa2_Status )
    {
        CurrentStation_Handle2_Request( Data_REQ, 0 );
    }
}

on sysvar sysvar::FSG_AudioSD::CuDoSt_Status
{
    if( gAudioSD_PowerOnOff == @sysvar::FSG_AudioSD::CuDoSt_Status )
    {
        CustomerDownloadState_Request( Data_REQ, 0 );
    }
}

on sysvar sysvar::FSG_AudioSD::CuVoEx_CVT
{
    if( @sysvar::FSG_AudioSD::CuVoEx_CVT < 0x0D || !temp2 )
        gCVE_CVTact = @sysvar::FSG_AudioSD::CuVoEx_CVT;
    if( @sysvar::FSG_AudioSD::CuVoEx_CVT == 0x10 || !temp2 )
        gCVE_CVTact = @sysvar::FSG_AudioSD::CuVoEx_CVT;
    if( @sysvar::FSG_AudioSD::CuVoEx_CVT == 0x11 || !temp2 )
        gCVE_CVTact = @sysvar::FSG_AudioSD::CuVoEx_CVT;
    temp2 = 0;
    if( @sysvar::FSG_AudioSD::CuVoEx_CVThex != gCVE_CVTact )
        @sysvar::FSG_AudioSD::CuVoEx_CVThex = @sysvar::FSG_AudioSD::CuVoEx_CVT;
}

on sysvar sysvar::FSG_AudioSD::CuVoEx_CVThex
{
    if( @sysvar::FSG_AudioSD::CuVoEx_CVThex > 0x0D && @sysvar::FSG_AudioSD::CuVoEx_CVThex != 0x10 && @sysvar::FSG_AudioSD::CuVoEx_CVThex != 0x11 )
    {
        gCVE_CVTact = @sysvar::FSG_AudioSD::CuVoEx_CVThex;
        temp2 = 1;
        @sysvar::FSG_AudioSD::CuVoEx_CVT = @sysvar::FSG_AudioSD::CuVoEx_CVThex;
    }
    else
    {
        if( @sysvar::FSG_AudioSD::CuVoEx_CVThex != gCVE_CVTact )
            @sysvar::FSG_AudioSD::CuVoEx_CVT = @sysvar::FSG_AudioSD::CuVoEx_CVThex;
    }
}

on sysvar sysvar::FSG_AudioSD::CuVoEx_VolS0
{
    if( @sysvar::FSG_AudioSD::CuVoEx_VolS0 == 1 )
        @sysvar::FSG_AudioSD::CuVoEx_VolS1 = 0;

}

on sysvar sysvar::FSG_AudioSD::CuVoEx_VolS1
{
    if( @sysvar::FSG_AudioSD::CuVoEx_VolS1 == 1 )
        @sysvar::FSG_AudioSD::CuVoEx_VolS0 = 0;
}

on sysvar sysvar::FSG_AudioSD::CuDoSt_CuDoSt
{
    if( @sysvar::FSG_AudioSD::CuDoSt_CuDoSt<4 || !temp3)
        gCDS_Sact = @sysvar::FSG_AudioSD::CuDoSt_CuDoSt;
    temp3 = 0;
    if( @sysvar::FSG_AudioSD::CuDoSt_CuDoSthex != gCDS_Sact )
        @sysvar::FSG_AudioSD::CuDoSt_CuDoSthex = @sysvar::FSG_AudioSD::CuDoSt_CuDoSt;
}

on sysvar sysvar::FSG_AudioSD::CuDoSt_CuDoSthex
{
    if( @sysvar::FSG_AudioSD::CuDoSt_CuDoSthex >4 )
    {
        gCDS_Sact = @sysvar::FSG_AudioSD::CuDoSt_CuDoSthex;
        temp3 = 1;
        @sysvar::FSG_AudioSD::CuDoSt_CuDoSt = @sysvar::FSG_AudioSD::CuDoSt_CuDoSthex;
    }
    else
    {
        if( @sysvar::FSG_AudioSD::CuDoSt_CuDoSthex != gCDS_Sact )
            @sysvar::FSG_AudioSD::CuDoSt_CuDoSt = @sysvar::FSG_AudioSD::CuDoSt_CuDoSthex;
    }
}

on sysvar sysvar::FSG_AudioSD::OnMuSt_State
{
    if( @sysvar::FSG_AudioSD::OnMuSt_State <37 || !temp4 )
        gOMS_Sact = @sysvar::FSG_AudioSD::OnMuSt_State;
    temp4 = 0;
    if( @sysvar::FSG_AudioSD::OnMuSt_Statehex != gOMS_Sact )
        @sysvar::FSG_AudioSD::OnMuSt_Statehex = @sysvar::FSG_AudioSD::OnMuSt_State;
}

on sysvar sysvar::FSG_AudioSD::OnMuSt_Statehex
{
    if( @sysvar::FSG_AudioSD::OnMuSt_Statehex > 0x24 )
    {
        gOMS_Sact = @sysvar::FSG_AudioSD::OnMuSt_Statehex;
        temp4 = 1;
        @sysvar::FSG_AudioSD::OnMuSt_State = @sysvar::FSG_AudioSD::OnMuSt_Statehex;
    }
    else
    {
        if( @sysvar::FSG_AudioSD::OnMuSt_Statehex != gOMS_Sact )
            @sysvar::FSG_AudioSD::OnMuSt_State = @sysvar::FSG_AudioSD::OnMuSt_Statehex;
    }
}

MediaImportState_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;          //LSG-ID
    requestarray[1] = FctID_MediaImportState;   //Fct.-ID
    requestarray[2] = request;               //request type

    switch( request )
    {
        case Data_REQ:
            requestarray[3] = @sysvar::FSG_AudioSD::MeImSe_SThex;
            requestarray[4] = @sysvar::FSG_AudioSD::MeImSe_InID;
            requestarray[5] = @sysvar::FSG_AudioSD::MeImSe_State1;
            requestarray[6] = @sysvar::FSG_AudioSD::MeImSe_Progress;

            set_status_requestbuffer( requestarray, 7, Bap_ByteSequence );
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD MediaImportState_Request: invalid request %d", request );
            break;
    }
}

CurrentVolumeExtended_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            CurrentVolumeExtended_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentVolumeExtended_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

CurrentVolumeExtended_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;          //LSG-ID
    requestarray[1] = FctID_CurrentVloumeExtended;   //Fct.-ID
    requestarray[2] = request;               //request type

    switch( request )
    {
        case Data_REQ:
            requestarray[3] = @sysvar::FSG_AudioSD::CuVoEx_CVThex;
            requestarray[4] = @sysvar::FSG_AudioSD::CuVoEx_VolS1;
            requestarray[5] = @sysvar::FSG_AudioSD::CuVoEx_MaxVol;
            requestarray[6] = @sysvar::FSG_AudioSD::CuVoEx_GenVol;

            set_status_requestbuffer( requestarray, 7, Bap_ByteSequence );
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentVolumeExtended_Request: invalid request %d", request );
            break;
    }
}

void OnlineMusic_State_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_OnlineMusic_State;   //Fct.-ID
    requestarray[2] = request;                   //request type

    switch( request )
    {
        case Data_REQ:
            requestarray[3] = @sysvar::FSG_AudioSD::OnMuSt_Statehex;
            requestarray[4] = @sysvar::FSG_AudioSD::OnMuSt_BuLvl;
            requestarray[5] = 0;
            requestarray[6] = 0;

            set_status_requestbuffer( requestarray, 7, Bap_ByteSequence );
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD OnlineMusic_State_Request: invalid request %d", request );
            break;
    }
}

CurrentStation_Handle2_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            CurrentStation_Handle2_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentStation_Handle2_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

void CurrentStation_Handle2_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ ) requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;          //LSG-ID
    requestarray[1] = FctID_CurrentStation_Handle2;   //Fct.-ID
    requestarray[2] = request;               //request type

    switch( request )
    {
        case Data_REQ:
            requestarray[3] = gAudioSD_CSIhandle_FSGhandle & 0xff;
            requestarray[4] = ( gAudioSD_CSIhandle_FSGhandle & 0xff00 ) / 0x100;
            requestarray[5] = gAudioSD_CSIhandle_FSGhandle_absolutePos & 0xff;
            requestarray[6] = ( gAudioSD_CSIhandle_FSGhandle_absolutePos & 0xff00 ) / 0x100;
            requestarray[7] = gAudioSD_CSIhandle_PresetListRef;
            requestarray[8] = gAudioSD_CSIhandle_PresetListabsolutePos;
            write("cst2 req");
            set_status_requestbuffer( requestarray, 9, Bap_ByteSequence );
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentStation_Handle2_Request: invalid request %d", request );
            break;
    }
}

void PlayPosition_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            PlayPosition_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD PlayPosition_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

void PlayPosition_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ ) requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;          //LSG-ID
    requestarray[1] = FctID_PlayPosition;   //Fct.-ID
    requestarray[2] = request;               //request type

    switch( request )
    {
      case Data_REQ:
        requestarray[3] = @Env_FSG_PP_TP & 0xff;
        requestarray[4] = ( @Env_FSG_PP_TP & 0xff00 ) / 0x100;
        requestarray[5] = @Env_FSG_PP_TPT & 0xff;
        requestarray[6] = ( @Env_FSG_PP_TPT & 0xff00 ) / 0x100;
        requestarray[7] = @Env_FSG_PP_A;
        requestarray[8] = @Env_FSG_PP_BL;

        set_status_requestbuffer( requestarray, 9, Bap_ByteSequence );
      break;

      case Error_REQ:
        requestarray[3] = errorcode;
        set_status_requestbuffer( requestarray, 4, Bap_Error );

      break;
      default:
        writelineEx( gError_Trace, 0, "FSG_AudioSD PlayPosition_Request: invalid request %d", request );
      break;
    }

}

void SDS_RecognizerState_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
      case DataGet_IND:
        SDS_RecognizerState_Request( Data_REQ, 0 );    //send status
      break;
      default:
        writelineEx( gError_Trace, 0, "FSG_AudioSD SDS_RecognizerState_Indication: invalid indication %d", Indication_array[2] );
      break;
    }
}

void SDS_RecognizerState_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ ) requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;          //LSG-ID
    requestarray[1] = FctID_SDS_RecognizerState;   //Fct.-ID
    requestarray[2] = request;               //request type

    switch( request )
    {
      case Data_REQ:
        requestarray[3] = @Env_FSG_SDS_IL;
        requestarray[4] = @Env_FSG_SDS_IQ;

        set_status_requestbuffer( requestarray, 9, Bap_ByteSequence );
      break;
      case Error_REQ:
        requestarray[3] = errorcode;
        set_status_requestbuffer( requestarray, 4, Bap_Error );
      break;
      default:
        writelineEx( gError_Trace, 0, "FSG_AudioSD SDS_RecognizerState_Request: invalid request %d", request );
      break;
    }
}

void CurrentStationInfo2_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
      case DataGet_IND:
        CurrentStationInfo2_Request( Data_REQ, 0 );    //send status
      break;
      default:
        writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentStationInfo2_Indication: invalid indication %d", Indication_array[2] );
      break;
    }
}

void CurrentStationInfo2_Request( byte request, byte errorcode )
{
  const STRINGBYTE = 73;
  char buffer_Information[STRINGBYTE];

  int i,Offset,bufferSTS= 0,bufferSP= 0;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables.
  for( i = 0; i < BAP_BUFFER_SIZE; i++ ) requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;          //LSG-ID
  requestarray[1] = FctID_CurrentStationInfo2;   //Fct.-ID
  requestarray[2] = request;               //request type
  Offset = 3;

  switch( request )
  {
    case Data_REQ:
      //Information1
      getValue(Env_FSG_CSI2_I1,buffer_Information );
      requestarray[Offset] = strlen( buffer_Information );
      Offset++;
      for( i = 0; i < strlen( buffer_Information ); i++ )
      {
          requestarray[Offset] = buffer_Information[i];
          Offset++;
      }
      //InformationType1
      requestarray[Offset] = @Env_FSG_CSI2_IT1;
      Offset++;
      //InformationID1
      requestarray[Offset] = @Env_FSG_CSI2_ID1;
      Offset++;
      requestarray[Offset] = @Env_FSG_CSI2_ID1/ 0x100;
      Offset++;

      //Information2
      getValue(Env_FSG_CSI2_I2,buffer_Information );
      requestarray[Offset] = strlen( buffer_Information );
      Offset++;
      for( i = 0; i < strlen( buffer_Information ); i++ )
      {
          requestarray[Offset] = buffer_Information[i];
          Offset++;
      }
      //InformationType2
      requestarray[Offset] = @Env_FSG_CSI2_IT2;
      Offset++;

      //Information3
      getValue(Env_FSG_CSI2_I3,buffer_Information );
      requestarray[Offset] = strlen( buffer_Information );
      Offset++;
      for( i = 0; i < strlen( buffer_Information ); i++ )
      {
          requestarray[Offset] = buffer_Information[i];
          Offset++;
      }
      //InformationType3
      requestarray[Offset] = @Env_FSG_CSI2_IT3;
      Offset++;

       //Information4
      getValue(Env_FSG_CSI2_I4,buffer_Information );
      requestarray[Offset] = strlen( buffer_Information );
      Offset++;
      for( i = 0; i < strlen( buffer_Information ); i++ )
      {
          requestarray[Offset] = buffer_Information[i];
          Offset++;
      }
      //InformationType4
      requestarray[Offset] = @Env_FSG_CSI2_IT4;
      Offset++;

       //Information5
      getValue(Env_FSG_CSI2_I5,buffer_Information );
      requestarray[Offset] = strlen( buffer_Information );
      Offset++;
      for( i = 0; i < strlen( buffer_Information ); i++ )
      {
          requestarray[Offset] = buffer_Information[i];
          Offset++;
      }
      //InformationType5
      requestarray[Offset] = @Env_FSG_CSI2_IT5;
      Offset++;

       //Information6
      getValue(Env_FSG_CSI2_I6,buffer_Information );
      requestarray[Offset] = strlen( buffer_Information );
      Offset++;
      for( i = 0; i < strlen( buffer_Information ); i++ )
      {
          requestarray[Offset] = buffer_Information[i];
          Offset++;
      }
      //InformationType6
      requestarray[Offset] = @Env_FSG_CSI2_IT6;
      Offset++;

       //Information7
      getValue(Env_FSG_CSI2_I7,buffer_Information );
      requestarray[Offset] = strlen( buffer_Information );
      Offset++;
      for( i = 0; i < strlen( buffer_Information ); i++ )
      {
          requestarray[Offset] = buffer_Information[i];
          Offset++;
      }
      //InformationType7
      requestarray[Offset] = @Env_FSG_CSI2_IT7;
      Offset++;

       //Information8
      getValue(Env_FSG_CSI2_I8,buffer_Information );
      requestarray[Offset] = strlen( buffer_Information );
      Offset++;
      for( i = 0; i < strlen( buffer_Information ); i++ )
      {
          requestarray[Offset] = buffer_Information[i];
          Offset++;
      }
      //InformationType8
      requestarray[Offset] = @Env_FSG_CSI2_IT8;
      Offset++;

      //StationInfoSwitches
      bufferSTS = buildCSI2_STS();
      requestarray[Offset] = bufferSTS;
      Offset++;
      Offset++;

      //StationProperties
      bufferSP = buildCSI2_SP();
      requestarray[Offset] = bufferSP;
      Offset++;
      Offset++;

      //Channel_ID
      requestarray[Offset] = @Env_FSG_CSI2_CID & 0xff;
      Offset++;
      requestarray[Offset] = ( @Env_FSG_CSI2_CID & 0xff00 ) / 0x100;
      Offset++;

      set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
      break;

    case Error_REQ:
      requestarray[3] = errorcode;

      set_status_requestbuffer( requestarray, 4, Bap_Error );
      break;
    default:
      writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentStation2Info_Request: invalid request %d", request );
      break;
  }
}

//build bitfield for station properties ( in panel every variable has his specifical bit )
int buildCSI2_SP()
{
    int buffer;
    buffer = 0;

    buffer += @Env_FSG_CSI2_SP_Ball;
    buffer += @Env_FSG_CSI2_SP_DAB;
    buffer += @Env_FSG_CSI2_SP_DAB2;
    buffer += @Env_FSG_CSI2_SP_IBOC;
    buffer += @Env_FSG_CSI2_SP_Online;
    buffer += @Env_FSG_CSI2_SP_Smart;
    buffer += @Env_FSG_CSI2_SP_station;

    return buffer;
}

//build bitfield for station info switches ( in panel every variable has his specifical bit )
int buildCSI2_STS()
{
    int buffer;
    buffer = 0;

    buffer += @Env_FSG_CSI2_STS_IBOC;
    buffer += @Env_FSG_CSI2_STS_Radio;
    buffer += @Env_FSG_CSI2_STS_TA;
    buffer += @Env_FSG_CSI2_STS_TMC;
    buffer += @Env_FSG_CSI2_STS_VICS;

    return buffer;
}

void CustomerDownloadState_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ ) requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;          //LSG-ID
    requestarray[1] = FctID_CustomerDownloadState;   //Fct.-ID
    requestarray[2] = request;               //request type

    switch( request )
    {
        case Data_REQ:
            requestarray[3] = @sysvar::FSG_AudioSD::CuDoSt_CuDoSthex;
            requestarray[4] = @sysvar::FSG_AudioSD::CuDoSt_PCD;

            set_status_requestbuffer( requestarray, 5, Bap_ByteSequence );
            break;

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CustomerDownloadState_Request: invalid request %d", request );
            break;
    }
}

void CurrentStationHandle3_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ ) requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;          //LSG-ID
    requestarray[1] = FctID_CurrentStation_Handle3;   //Fct.-ID
    requestarray[2] = request;               //request type

    switch( request )
    {
      case Data_REQ:
        requestarray[3] = @Env_FSG_CSH3_FL;
        requestarray[4] = @Env_FSG_CSH3_FLabso;
        requestarray[5] = @Env_FSG_CSH3_Ext1;
        requestarray[6] = @Env_FSG_CSH3_Ext2;
        requestarray[7] = @Env_FSG_CSH3_Ext3;
        requestarray[8] = @Env_FSG_CSH3_Ext4;

        set_status_requestbuffer( requestarray, 9, Bap_ByteSequence );
      break;
      case Error_REQ:
        requestarray[3] = errorcode;
        set_status_requestbuffer( requestarray, 4, Bap_Error );
      break;
      default:
        writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentStationHandle3_Request: invalid request %d", request );
      break;
    }
}

void CurrentStationHandle3_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
            CurrentStationHandle3_Request( Data_REQ, 0 );    //send status
            break;
        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD CurrentStationHandle3_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

on sysvar sysvar::FSG_AudioSD::SwRaMe_SwRaMeRe
{
    if( @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRe <4 || !tempSwRaMe )
       gSwRaMe_SwRaMeReact = @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRe;
    tempSwRaMe = 0;
    if( @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRehex != gSwRaMe_SwRaMeReact )
        @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRehex = @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRe;
}

on sysvar sysvar::FSG_AudioSD::SwRaMe_SwRaMeRehex
{
    if( @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRehex >4 )
    {
        gSwRaMe_SwRaMeReact = @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRehex;
        tempSwRaMe = 1;
        @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRe = 5;
    }
    else
    {
        if( @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRehex != gSwRaMe_SwRaMeReact )
            @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRe = @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRehex;
    }
}

on sysvar sysvar::FSG_AudioSD::SwRaMe_Sourcehex
{
    if( @sysvar::FSG_AudioSD::SwRaMe_Sourcehex >6 )
    {
        gSwRaMe_Sourceeact = @sysvar::FSG_AudioSD::SwRaMe_Sourcehex;
        tempSwRaMe2 = 1;
        @sysvar::FSG_AudioSD::SwRaMe_Source =7;
    }
    else
    {
        if( @sysvar::FSG_AudioSD::SwRaMe_Sourcehex != gSwRaMe_Sourceeact )
            @sysvar::FSG_AudioSD::SwRaMe_Source = @sysvar::FSG_AudioSD::SwRaMe_Sourcehex;
    }
}

on sysvar sysvar::FSG_AudioSD::SwRaMe_Source
{
    if( @sysvar::FSG_AudioSD::SwRaMe_Source <6 || !tempSwRaMe2 )
       gSwRaMe_Sourceeact = @sysvar::FSG_AudioSD::SwRaMe_Source;
    tempSwRaMe2 = 0;
    if( @sysvar::FSG_AudioSD::SwRaMe_Sourcehex != gSwRaMe_Sourceeact )
        @sysvar::FSG_AudioSD::SwRaMe_Sourcehex = @sysvar::FSG_AudioSD::SwRaMe_Source;
}

void SwitchRadioMedia_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] )
    {
        case Processing_CNF:
            SwitchRadioMedia_Request( Processing_REQ, 0 );
            break;
        case StartResult_IND:

            if( @sysvar::FSG_AudioSD::SwRaMe_errorState )
                SwitchRadioMedia_Request(Error_REQ, @sysvar::FSG_AudioSD::SwRaMe_errorCode );
            else
            {
                @sysvar::FSG_AudioSD::SwRaMe_Sourcehex = Indication_array[3];

                SwitchRadioMedia_Request( Result_REQ, 0 );                                //send result-message
            }
            break;
        case Abort_IND:

            if( @sysvar::FSG_AudioSD::SwRaMe_errorState )
                SwitchRadioMedia_Request(Error_REQ, @sysvar::FSG_AudioSD::SwRaMe_errorCode );

            else
            {
                SwitchRadioMedia_Request( Result_REQ, 0 );                                //send result-message
            }
            break;
        default:
            writelineEx( gError_Trace, 0, "SwitchRadioMedia_Indication: unknown indication %d", Indication_array[2] );
            break;
    }
}

SwitchRadioMedia_Request( byte request, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    // Handle request.
    requestarray[0] = LSG_AudioSD;                  //LSG-ID
    requestarray[1] = FctID_SwitchRadioMedia;        //Fct.-ID
    requestarray[2] = request;

    switch( request )
    {
        case Processing_REQ:
            requestarray[3] = 0;                        //reserved1 is const set to zero
            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            break;
        case Result_REQ:
            requestarray[3] = @sysvar::FSG_AudioSD::SwRaMe_SwRaMeRehex;
            set_status_requestbuffer( requestarray, 4, Bap_UInt8 );
            break;
        case Error_REQ:
            requestarray[3] = errorcode;
            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break;
        default:    //error
            writelineEx( gError_Trace, 0, "NaviSD SwitchRadioMedia_Request: unknown request %d", request );
            break;
    }
}

on envVar env_AudioSD_Method2
{
    if( getvalue( this ) )
        openPanel( "Method_2_AudioSD_FSG" );
}

on envVar env_AudioSD_CommomList
{
    if( getvalue( this ) )
        openPanel( "CommonList_FSG" );
}

on sysvar sysvar::FSG_AudioSD::ComList_ChangedArray
{
    word requested_startelement, startelement, elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
    int i;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && @sysvar::FSG_AudioSD::ComList_ChangedArray )
    {
        if( @sysvar::FSG_AudioSD::ComList_start >255 && @sysvar::FSG_AudioSD::ComList_indexSize_8bit == 1 ) // check if 8 or 16 bit
            @sysvar::FSG_AudioSD::ComList_indexSize_16bit = 1;

        //get data from Panel
        recordaddress   = @sysvar::FSG_AudioSD::ComList_recordaddress;
        shift           = @sysvar::FSG_AudioSD::ComList_shift_1;
        direction       = @sysvar::FSG_AudioSD::ComList_direction_b;
        transmitpos     = @sysvar::FSG_AudioSD::ComList_transmitPos_1;
        indexsize       = @sysvar::FSG_AudioSD::ComList_indexSize_16bit;
        startelement    = @sysvar::FSG_AudioSD::ComList_start;
        elements        = @sysvar::FSG_AudioSD::ComList_elements;

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;

        //if( @sysvar::FSG_AudioSD::ComList_arrayHeadder || @sysvar::FSG_AudioSD::ComList_arrayHeadderData ) // ArrayHeader (+ Data )
       // {


                    /***Startelement = 0***/
                    if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
                    {
                        if( FORWARD==direction )  //forward-start
                        {
                            valid_startelement = 0;

                            if( AUDIO_COMMONLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                            {
                                if( shift == FALSE )
                                {
                                    for( i = 0; i < AUDIO_COMMONLIST_ENTRIES; i++ )
                                    {
                                        if( 0 != gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                                        {
                                            if( gCommonList_Pos[i] > 0xff )
                                                indexsize = TRUE;

                                            valid_elements++;                                //increment elements
                                        }

                                        else                                                //no valid element, loop finished
                                            i = AUDIO_COMMONLIST_ENTRIES;
                                    }
                                }
                                else
                                {
                                    valid_startelement  = startelement;
                                    valid_elements      = 0;
                                }
                            }
                            else    //2. number of requested elements < elements in array
                            {
                                if( shift == FALSE )
                                {
                                    for( i = 0; i < elements; i++ )
                                    {
                                        if( 0!= gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                                        {
                                            if( gCommonList_Pos[i] > 0xff )
                                                indexsize = TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i = AUDIO_COMMONLIST_ENTRIES;
                                    }
                                }
                                else
                                {
                                    valid_startelement  = startelement;
                                    valid_elements      = 0;
                                }
                            }
                        }                                                               //forward ends

                        else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                        {
                            //searching for valid startelement
                            for( i = ( AUDIO_COMMONLIST_ENTRIES-1 ); i>= 0; i--)
                            {
                                if( 0!= gCommonList_ListEntryValidInformation[i] )        //found valid startelement
                                {
                                    valid_startelement = i;
                                    i = 0;
                                }
                            }

                            //searching for valid elements
                            if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                            {
                                valid_startelement  = startelement;
                                valid_elements      = 0;
                            }
                            else if( 0 ==valid_startelement )
                                valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                            else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                            {
                                for( i =valid_startelement; i>= 0; i--)
                                {
                                    if( 0!= gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                                    {
                                        if( gCommonList_Pos[i] > 0xff )
                                                indexsize = TRUE;

                                        valid_elements++;                                //increment elements
                                    }
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                                {
                                    if( 0!= gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                                    {
                                        valid_elements++;                                //increment elements

                                        if( gCommonList_Pos[i] > 0xff )
                                                indexsize = TRUE;
                                    }
                                    else                                                //no valid element, loop finished
                                        i = 0;
                                }
                            }
                        }                                                               //backward-end
                    }                                                                   //startelement == 0 -end

                    /***Startelement!= 0***/
                    else                                                                //searching for Startelement-ID
                    {
                        //searching for valid startelement
                        for( i = 0; i < AUDIO_COMMONLIST_ENTRIES; i++ )
                        {
                            if( gCommonList_Pos[i] == startelement )                        //found a valid element
                            {
                                if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                                {
                                    if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                                        valid_startelement = i + 1-2* direction;

                                    else if( i == 0 && BACKWARD==direction )
                                        valid_startelement = gCommonListLine_sum;     //valid element is last element in Array

                                    else if( i == 0 && FORWARD==direction )
                                        valid_startelement = 0;                          //valid element is first element in Array
                                }

                                else
                                    valid_startelement = i;                              //found element is valid_startelement

                                i = AUDIO_COMMONLIST_ENTRIES;
                            }
                        }

                        if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                        else                                                                //found valid entry for startelement in array
                        {
                            //verify number of valid elements
                            if( BACKWARD==direction )                                            //backward-start
                            {
                                if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                                    valid_elements= 1;

                                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                                {
                                    for( i =valid_startelement; i>= 0; i--)
                                    {
                                        if( 0!= gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                                        {
                                            if( gCommonList_Pos[i] > 0xff )
                                                indexsize = TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i = 0;
                                    }
                                }
                                else                                                        //enougth array-elements available
                                {
                                    for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                                    {
                                        if( 0!= gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                                        {
                                            if( gCommonList_Pos[i] > 0xff )
                                                indexsize = TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i = 0;
                                    }
                                }
                            }                                                                //backward-end
                            else                                                            //forward-start
                            {
                                if((valid_startelement+elements )>= AUDIO_COMMONLIST_ENTRIES)
                                {
                                    for( i =valid_startelement; i < AUDIO_COMMONLIST_ENTRIES; i++ )
                                    {
                                        if( 0!= gCommonList_Pos[i] )                            //if there is an valid element
                                        {
                                            if( gCommonList_Pos[i] > 0xff )
                                                indexsize = TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                    //no valid element, loop finished
                                            i = AUDIO_COMMONLIST_ENTRIES;
                                    }
                                }
                                else
                                {
                                    for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                                    {
                                        if( 0!= gCommonList_Pos[i] )                            //if there is an valid element
                                        {
                                            if( gCommonList_Pos[i] > 0xff )
                                                indexsize = TRUE;

                                            valid_elements++;                                //increment elements
                                        }
                                        else                                                //no valid element, loop finished
                                            i = AUDIO_COMMONLIST_ENTRIES;
                                    }
                                }
                            }
                        } //END: if( BACKWARD==direction )
                    } //END: if( 0 == startelement )

                    transmitpos = TRUE;
                    if(( requested_startelement > 0xFF ) || (valid_startelement > 0xFF ) )
                        indexsize = TRUE;

                    mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;
                    //send StatusArray
                    CommonList_Request( Changed_REQ, 0, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
            //} // END: if( getvalue( env_NaviSD_AL_CA_switch ) )
    }//END: if( gAudioSD_PowerOnOff == POWER_ON && @sysvar::FSG_AudioSD::ComList_ChangedArray )
}

on sysvar sysvar::FSG_AudioSD::ComList_DataSource_default
{
    if( @sysvar::FSG_AudioSD::ComList_DataSource_default )
        @sysvar::FSG_AudioSD::ComList_DataSource_external = 0;
}

on sysvar sysvar::FSG_AudioSD::ComList_DataSource_external
{
    if( @sysvar::FSG_AudioSD::ComList_DataSource_external)
        @sysvar::FSG_AudioSD::ComList_DataSource_default = 0;
}

on sysvar sysvar::FSG_AudioSD::ComList_deleteElement
{
}

on sysvar sysvar::FSG_AudioSD::ComList_direction_b
{
    if( @sysvar::FSG_AudioSD::ComList_direction_b)
        @sysvar::FSG_AudioSD::ComList_direction_f = 0;
}

on sysvar sysvar::FSG_AudioSD::ComList_direction_f
{
    if( @sysvar::FSG_AudioSD::ComList_direction_f )
        @sysvar::FSG_AudioSD::ComList_direction_b = 0;

}

on sysvar sysvar::FSG_AudioSD::ComList_error_control
{
}

on sysvar sysvar::FSG_AudioSD::ComList_FRU
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
byte mode, shift, direction, transmitpos, indexsize, recordaddress;
int i;

// Init local variables.
mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && @sysvar::FSG_AudioSD::ComList_FRU)
    {
        recordaddress   = 0;
        shift           = 0;
        direction       = 0;
        transmitpos     = 0;
        indexsize       = 0;
        startelement    = 0;
        elements        =65535;
        //MR 63332 #2 02.07.2014
        /*
        @sysvar::FSG_AudioSD::ComList_recordaddress     = recordaddress;
        @sysvar::FSG_AudioSD::ComList_shift_1           = shift;
        @sysvar::FSG_AudioSD::ComList_direction_b       = direction;
        @sysvar::FSG_AudioSD::ComList_transmitPos_1     = transmitpos;
        @sysvar::FSG_AudioSD::ComList_indexSize_16bit   = indexsize;
        @sysvar::FSG_AudioSD::ComList_start             = startelement;
        @sysvar::FSG_AudioSD::ComList_elements          = elements;
        */
        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //send ChangedArray
        CommonList_Request( Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0 );
    }
}

on sysvar sysvar::FSG_AudioSD::ComList_indexSize_8bit
{
    if( @sysvar::FSG_AudioSD::ComList_indexSize_8bit )
        @sysvar::FSG_AudioSD::ComList_indexSize_16bit = 0;
}

on sysvar sysvar::FSG_AudioSD::ComList_indexSize_16bit
{
    if( @sysvar::FSG_AudioSD::ComList_indexSize_16bit )
        @sysvar::FSG_AudioSD::ComList_indexSize_8bit = 0;
}

on sysvar sysvar::FSG_AudioSD::ComList_shift_0
{
    if( @sysvar::FSG_AudioSD::ComList_shift_0 )
        @sysvar::FSG_AudioSD::ComList_shift_1 = 0;
}

on sysvar sysvar::FSG_AudioSD::ComList_shift_1
{
    if( @sysvar::FSG_AudioSD::ComList_shift_1 )
        @sysvar::FSG_AudioSD::ComList_shift_0 = 0;
}

on sysvar sysvar::FSG_AudioSD::ComList_StatusArray
{
   //MR 63667 11.07.2014 -TNLE with SA-button
    word tnle, requested_startelement, startelement, elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
    int i, transSuppression;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0xff;
    i                       = 0;
    valid_elements          = 0;
    transSuppression        = getvalue( env_AudioSD_CL_noStatusArray );

    if( gAudioSD_PowerOnOff == POWER_ON && @sysvar::FSG_AudioSD::ComList_StatusArray )
    {
        if( @sysvar::FSG_AudioSD::ComList_start >255) // && @sysvar::FSG_AudioSD::ComList_indexSize_8bit == 1 ) // check if 8 or 16 bit
            @sysvar::FSG_AudioSD::ComList_indexSize_16bit = 1;

        //get data from Panel
        gCommonList_ASGID                 = @sysvar::FSG_AudioSD::ComList_ASG_ID;
        gCommonList_TAID                  = @sysvar::FSG_AudioSD::ComList_TAID;
        gCommonList_TotalNumListElements  = @sysvar::FSG_AudioSD::ComList_TNLE;


        recordaddress   = @sysvar::FSG_AudioSD::ComList_recordaddress;
        shift           = @sysvar::FSG_AudioSD::ComList_shift_1;
        direction       = @sysvar::FSG_AudioSD::ComList_direction_b;
        transmitpos     = @sysvar::FSG_AudioSD::ComList_transmitPos_1;
        indexsize       = @sysvar::FSG_AudioSD::ComList_indexSize_16bit;
        startelement    = @sysvar::FSG_AudioSD::ComList_start;
        elements        = @sysvar::FSG_AudioSD::ComList_elements;

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        requested_startelement = startelement;


        /***Startelement = 0***/
        if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
        {
            if( FORWARD==direction )  //forward-start
            {
                valid_startelement = 0;

                if( AUDIO_COMMONLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                {
                    if( shift == FALSE )
                    {
                        for( i = 0; i < AUDIO_COMMONLIST_ENTRIES; i++ )
                        {
                            if( 0 != gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_COMMONLIST_ENTRIES;
                        }
                    }
                    else
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                }
                else    //2. number of requested elements < elements in array
                {
                    if( shift == FALSE )
                    {
                        for( i = 0; i < elements; i++ )
                        {
                            if( 0!= gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                               i = AUDIO_COMMONLIST_ENTRIES;
                        }
                    }
                    else
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                }
            }                                                               //forward ends

            else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
            {
                //searching for valid startelement
                for( i = ( AUDIO_COMMONLIST_ENTRIES-1 ); i>= 0; i--)
                {
                    if( 0!= gCommonList_ListEntryValidInformation[i] )        //found valid startelement
                    {
                        valid_startelement = i;
                        i = 0;
                    }
                }

                //searching for valid elements
                if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else if( 0 ==valid_startelement )
                    valid_elements= 1;                                       //only 1 element because valid startelement is on position 0

                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for( i =valid_startelement; i>= 0; i--)
                    {
                        if( 0!= gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
                else                                                        //enougth array-elements available
                {
                    for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                    {
                        if( 0!= gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
            }                                                               //backward-end
        }                                                                   //startelement == 0 -end

        /***Startelement!= 0***/
        else                                                                //searching for Startelement-ID
        {
            //searching for valid startelement
            for( i = 0; i < AUDIO_COMMONLIST_ENTRIES; i++ )
            {
                if( gCommonList_Pos[i] == startelement )                        //found a valid element
                {
                    if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                    {
                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement = i + 1-2* direction;

                        else if( i == 0 && BACKWARD==direction )
                            valid_startelement = gCommonListLine_sum;     //valid element is last element in Array

                        else if( i == 0 && FORWARD==direction )
                            valid_startelement = 0;                          //valid element is first element in Array
                    }

                    else
                        valid_startelement = i;                              //found element is valid_startelement

                    i = AUDIO_COMMONLIST_ENTRIES;
                }
                else
                    valid_startelement = 0xff;
            }

            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
            {
                valid_startelement  = startelement;
                valid_elements      = 0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if( BACKWARD==direction )                                            //backward-start
                {
                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                        valid_elements= 1;

                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                        {
                            if( 0!= gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                            if( 0!= gCommonList_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements )>= AUDIO_COMMONLIST_ENTRIES)
                    {
                        for( i =valid_startelement; i < AUDIO_COMMONLIST_ENTRIES; i++ )
                        {
                            if( 0!= gCommonList_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_COMMONLIST_ENTRIES;
                        }
                    }
                    else
                    {
                        for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                        {
                            if( 0!= gCommonList_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = AUDIO_COMMONLIST_ENTRIES;
                        }
                    }
                }
            }
        }
        @sysvar::FSG_AudioSD::ComList_elements = valid_elements;
        //send StatusArray
        //writeEX( gBAP_Trace, 0, "StatusArray_valid_elements %x",valid_elements ); //debug
        if(!transSuppression )
            CommonList_Request( Data_REQ, tnle, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
}
}

on sysvar sysvar::FSG_AudioSD::ComList_transmitPos_0
{
    if( @sysvar::FSG_AudioSD::ComList_transmitPos_0 )
        @sysvar::FSG_AudioSD::ComList_transmitPos_1 = 0;
}

on sysvar sysvar::FSG_AudioSD::ComList_transmitPos_1
{
    if( @sysvar::FSG_AudioSD::ComList_transmitPos_1 )
        @sysvar::FSG_AudioSD::ComList_transmitPos_0 = 0;

}

//IssueList #216 15S1 update 17.01.2014
CommonList_Request( byte request, word tnle, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element;
    word CommonListLine, Offset;

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    CommonListLine = 0;
    current_element = 0;
    Offset = 0;

    // decode "mode -byte"
    shift = mode & 0x01;
    direction = ( mode & 0x02 ) / 0x02;
    transmitpos = ( mode & 0x04 ) / 0x04;
    indexsize = ( mode & 0x08 ) / 0x08;

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_CommonList;         //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;



    //-------------------------------------------------------------------------
    //-------------------------------------------------------------------------
    switch( request )
    {
        case Changed_REQ:
            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = ( requested_startelement & 0x00FF );
                Offset++;
                requestarray[Offset] = (( requested_startelement & 0xFF00 ) / 0x100 );
                Offset++;
                requestarray[Offset] = ( elements & 0x00FF );
                Offset++;
                requestarray[Offset] = (( elements & 0xFF00 ) / 0x100 );
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;

                requestarray[Offset] = elements;
                Offset++;
            }

            CommonListLine = startelement;
            if( @sysvar::FSG_AudioSD::ComList_arrayHeadder || @sysvar::FSG_AudioSD::ComList_arrayHeadderData ) //ArrayData
            {
                //   if( elements != 0xffff )                                  // if FullRangeUpdate
                //   {
                //copy data
                for( i = 0; i < BAP_BUFFER_SIZE; i++ )
                {
                    requestarrayCommonListGlobal[i] = requestarray[i];
                }
                offsetCommonListGlobal = Offset;
                if( elements != 0xffff )                                  // if no FullRangeUpdate
                    CommonList_Request_RecordAddress( recordaddress, transmitpos, indexsize, elements, CommonListLine );
                for( i = 0; i < BAP_BUFFER_SIZE; i++ )
                {
                    requestarray[i] = requestarrayCommonListGlobal[i];
                }
                Offset = offsetCommonListGlobal;
                // }
                set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }

            break; //end Changed_REQ

        case Data_REQ:
            //VAGH-10511
            ASGID = gCommonList_ASGID;
            TAID = gCommonList_TAID;
            if( getvalue( env_AudioSD_CL_ASGID_Error ) != FALSE )
            {
                ASGID += 0x2;
            }
            if( getvalue( env_AudioSD_CL_TAID_Error ) != FALSE )
            {
                TAID += 0x02;
            }
            requestarray[Offset] = (( ASGID * 0x10 ) & 0xF0 ) + ( TAID & 0x0F );
            Offset++;
        //MR 63667 11.07.2014 -TNLE with SA-button
            requestarray[Offset] = ( tnle /*gCommonList_TotalNumListElements */ & 0xFF );
            Offset++;
            requestarray[Offset] = (( tnle /*gCommonList_TotalNumListElements */ & 0xFF00 ) / 0x100 );
            Offset++;
            //    writelineEx( gError_Trace, 0, "totalNumListElement:0x%x", gCommonList_TotalNumListElements );
            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;

            if( indexsize )
            {
                requestarray[Offset] = ( requested_startelement & 0x00FF );
                Offset++;
                requestarray[Offset] = (( requested_startelement & 0xFF00 ) / 0x100 );
                Offset++;

                requestarray[Offset] = ( elements & 0x00FF );
                Offset++;
                requestarray[Offset] = (( elements & 0xFF00 ) / 0x100 );
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;

                requestarray[Offset] = elements;
                Offset++;
            }
            //writelineEx( gBAP_Trace, 0, "Common_List_request_2 " );                        //debug
            CommonListLine = startelement;
            //copy data
            for( i = 0; i < BAP_BUFFER_SIZE; i++ )
            {
                requestarrayCommonListGlobal[i] = requestarray[i];
            }
            offsetCommonListGlobal = Offset;
            CommonList_Request_RecordAddress( recordaddress, transmitpos, indexsize, elements, CommonListLine );

            for( i = 0; i < BAP_BUFFER_SIZE; i++ )
            {
                requestarray[i] = requestarrayCommonListGlobal[i];
            }
            Offset = offsetCommonListGlobal;
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            break; //end Data_REQ

        case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break; //end Error_REQ

    } //end switch "request"
}

CommonList_Request_RecordAddress( byte recordaddress, byte transmitpos, byte indexsize, word elements, word CommonListLine )
{
    int i, temp = 0, first = 1;
    dword requestarray[BAP_BUFFER_SIZE];
    byte current_element, direction;
    word Offset;

    current_element = 0;
    direction = 0;
    temp = 0;
    //writelineEx( gBAP_Trace, 0, "Common_List_RA_start" );                        //debug
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
    {
        requestarray[i] = requestarrayCommonListGlobal[i];
    }
    Offset = offsetCommonListGlobal;
    if( CommonListLine == 0xFF ) // invalid "list entry"
    {
        write( "AudioSD CommonList_Request: invalid CommonListLine" );
        current_element = elements;
    }
    else //valid "list entry"
    {
        switch( recordaddress )
        {
            case 0: //complete record --> SourceType, Attributes, PresetID, Category, Name, Frequency
                while ( current_element < elements )
                {
                    if( transmitpos ) // Pos  ->Array position transmitted
                    {
                        if( indexsize )
                        {
                            requestarray[Offset] = ( gCommonList_Pos[CommonListLine] & 0x00FF ); Offset++;
                            requestarray[Offset] = (( gCommonList_Pos[CommonListLine] & 0xFF00 ) / 0x100 ); Offset++;
                        }
                        else
                        {
                            requestarray[Offset] = gCommonList_Pos[CommonListLine]; Offset++;
                        }
                    }
                    requestarray[Offset] = gCommonList_SourceType[CommonListLine]; Offset++; // SourceType
                    requestarray[Offset] = ( gCommonList_Attributes[CommonListLine] & 0x00FF ); Offset++; // Attributes
                    requestarray[Offset] = (( gCommonList_Attributes[CommonListLine] & 0xFF00 ) / 0x100 ); Offset++;
                    requestarray[Offset] = gCommonList_PresetID[CommonListLine]; Offset++; // PresetID
                    requestarray[Offset] = gCommonList_Category[CommonListLine]; Offset++; // Category
                    requestarray[Offset] = strlen( gCommonList_Name[CommonListLine] ); Offset++; // Name
                    for( i = 0; i < strlen( gCommonList_Name[CommonListLine] ); i++ )
                    {
                        requestarray[Offset] = gCommonList_Name[CommonListLine][i]; Offset++;
                    }
                    requestarray[Offset] = strlen( gCommonList_Frequency[CommonListLine] ); Offset++; // Frequency
                    for( i = 0; i < strlen( gCommonList_Frequency[CommonListLine] ); i++ )
                    {
                        requestarray[Offset] = gCommonList_Frequency[CommonListLine][i]; Offset++;
                    }
                    current_element++;
                    CommonListLine = CommonList_nextValidLine( CommonListLine, direction );
                }
                break;

            case 1: //SourceType, Attributes, PresetID, Category, Name
                while ( current_element < elements )
                {
                    //writelineEx( gBAP_Trace, 0, "Common_List_RA1_elements: %x", elements );        //debug
                    if( transmitpos ) // Pos  ->Array position transmitted
                    {
                        if( indexsize )
                        {
                            requestarray[Offset] = ( gCommonList_Pos[CommonListLine] & 0x00FF ); Offset++;
                            requestarray[Offset] = (( gCommonList_Pos[CommonListLine] & 0xFF00 ) / 0x100 ); Offset++;
                        }
                        else
                        {
                            requestarray[Offset] = gCommonList_Pos[CommonListLine]; Offset++;
                        }
                    }
                    requestarray[Offset] = gCommonList_SourceType[CommonListLine]; Offset++; // SourceType
                    requestarray[Offset] = ( gCommonList_Attributes[CommonListLine] & 0x00FF );  Offset++; // Attributes
                    requestarray[Offset] = (( gCommonList_Attributes[CommonListLine] & 0xFF00 ) / 0x100 ); Offset++;
                    requestarray[Offset] = gCommonList_PresetID[CommonListLine]; Offset++; // PresetID
                    requestarray[Offset] = gCommonList_Category[CommonListLine]; Offset++; // Category
                    requestarray[Offset] = strlen( gCommonList_Name[CommonListLine] ); Offset++; // Name
                    for( i = 0; i < strlen( gCommonList_Name[CommonListLine] ); i++ )
                    {
                        requestarray[Offset] = gCommonList_Name[CommonListLine][i]; Offset++;
                    }
                    current_element++;
                    CommonListLine = CommonList_nextvalidLine( CommonListLine, direction );
                }
                break;

            case 2: //  Name
                while ( current_element < elements )
                {
                    if( transmitpos ) // Pos  ->Array position transmitted
                    {
                        if( indexsize )
                        {
                            requestarray[Offset] = ( gCommonList_Pos[CommonListLine] & 0x00FF ); Offset++;
                            requestarray[Offset] = (( gCommonList_Pos[CommonListLine] & 0xFF00 ) / 0x100 ); Offset++;
                        }
                        else
                        {
                            requestarray[Offset] = gCommonList_Pos[CommonListLine]; Offset++;
                        }
                    }
                    requestarray[Offset] = strlen( gCommonList_Name[CommonListLine] ); Offset++; // Name
                    for( i = 0; i < strlen( gCommonList_Name[CommonListLine] ); i++ )
                    {
                        requestarray[Offset] = gCommonList_Name[CommonListLine][i]; Offset++;
                    }
                    current_element++;
                    CommonListLine = CommonList_nextvalidLine( CommonListLine, direction );
                }
                break;

            case 3: // Attributes, Frequency
                while ( current_element < elements )
                {
                    if( transmitpos ) // Pos  ->Array position transmitted
                    {
                        if( indexsize )
                        {
                            requestarray[Offset] = ( gCommonList_Pos[CommonListLine] & 0x00FF ); Offset++;
                            requestarray[Offset] = (( gCommonList_Pos[CommonListLine] & 0xFF00 ) / 0x100 ); Offset++;
                        }
                        else
                        {
                            requestarray[Offset] = gCommonList_Pos[CommonListLine]; Offset++;
                        }
                    }
                    requestarray[Offset] = ( gCommonList_Attributes[CommonListLine] & 0x00FF ); Offset++; // Attributes
                    requestarray[Offset] = (( gCommonList_Attributes[CommonListLine] & 0xFF00 ) / 0x100 ); Offset++;
                    requestarray[Offset] = strlen( gCommonList_Frequency[CommonListLine] ); Offset++; // Frequency
                    for( i = 0; i < strlen( gCommonList_Frequency[CommonListLine] ); i++ )
                    {
                        requestarray[Offset] = gCommonList_Frequency[CommonListLine][i]; Offset++;
                    }
                    current_element++;
                    CommonListLine = CommonList_nextvalidLine( CommonListLine, direction );
                }
                break;

            case 15:    //Pos
                while ( current_element < elements )
                {
                    if( transmitpos ) // Pos  ->Array position transmitted
                    {
                        if( indexsize )
                        {
                            requestarray[Offset] = ( gCommonList_Pos[CommonListLine] & 0x00FF ); Offset++;
                            requestarray[Offset] = (( gCommonList_Pos[CommonListLine] & 0xFF00 ) / 0x100 ); Offset++;
                        }
                        else
                        {
                            requestarray[Offset] = gCommonList_Pos[CommonListLine]; Offset++;
                        }
                    }
                    current_element++;
                    CommonListLine = CommonList_nextvalidLine( CommonListLine, direction );
                }
                first = 1;
                break;

            default:
                write( "AudioSD CommonList_Request: invalid recordaddress %d", recordaddress );
                break;
        } //end switch "recordaddress"
    }//end if( CommonListLine == 0xFF )

    //clear
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
    {
        requestarrayCommonListGlobal[i] = 0;
    }
    offsetCommonListGlobal = 0;
    //save data
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
    {
        requestarrayCommonListGlobal[i] = requestarray[i];
    }
    offsetCommonListGlobal = Offset;
    //writelineEx( gBAP_Trace, 0, "Common_List_RA_end" );                        //debug
}

CommonList_initCSV()
{
    dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, current_CSV_line = 0, count1 = 0, count2 = 0;
    char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
    byte CommonListLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
    char CommonList_Pos_string[AUDIO_COMMONLIST_ENTRIES][AUDIO_TEXTLENGTH];           //help value ->"POS" is stored in the ASCII(UTF-8 ) code in the *.csv
    char CommonList_SourceType_string[AUDIO_COMMONLIST_ENTRIES][AUDIO_TEXTLENGTH];       //help value ->"CommonType" is stored in the ASCII(UTF-8 ) code in the *.csv
    char CommonList_Attributes_string[AUDIO_COMMONLIST_ENTRIES][AUDIO_TEXTLENGTH];           //help value ->"CommonType" is stored in the ASCII(UTF-8 ) code in the *.csv
    char CommonList_PresetID_string[AUDIO_COMMONLIST_ENTRIES][AUDIO_TEXTLENGTH];           //help value ->"CommonType" is stored in the ASCII(UTF-8 ) code in the *.csv
    char CommonList_Category_string[AUDIO_COMMONLIST_ENTRIES][AUDIO_TEXTLENGTH];           //help value ->"CommonType" is stored in the ASCII(UTF-8 ) code in the *.csv
    int CSV_Name_Size = 0, stop = 0;
    if( @sysvar::FSG_AudioSD::ComList_DataSource_external) //output data in write window "FSGCommonList"
    {
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: *******External CommonList_List*******" );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: " );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: **********************Start load new CommonList_List**********************" );

        for( j = 0; j < AUDIO_COMMONLIST_ENTRIES; j++ ) //clear "CommonList Array"
        {
            gCommonList_ListEntryValidInformation[j]  = FALSE;
            gCommonList_Pos[j]                  = 0;
            gCommonList_SourceType[j]           = 0;
            gCommonList_Attributes[j]           = 0;
            gCommonList_PresetID[j]             = 0;
            gCommonList_Category[j]             = 0;
            for( i = 0; i < AUDIO_COMMONLIST_NAME_LENGTH; i++ )
                gCommonList_Name[j][i] = 0;
            for( i = 0; i < AUDIO_COMMONLIST_FREQUENCY_LENGTH; i++ )
                gCommonList_Frequency[j][i] = 0;
        }
        for( i = 0; i < AUDIO_FILENAME_SIZE; i++ ) //clear "filename"
            gCommonList_CSV_filename[i] = 0;
        for( j = 0; j < AUDIO_COMMONLIST_ENTRIES; j++ ) //clear "buffer"
        {
            buffer_string[j]    = 0;
            buffer_byte[j]      = 0;

            for( i = 0; i < AUDIO_TEXTLENGTH; i++ ) //clear help value
                CommonList_Pos_string[j][i]       = 0;
        }
        for( i = 0; i < AUDIO_BUFFERSIZE; i++ )
            Path_CSV[i] = 0;


     //   while( @sysvar::naviSD_FSG::Common_List_CSVPath[CSV_Name_Size] != 0x2E && @sysvar::naviSD_FSG::Common_List_CSVPath[CSV_Name_Size+ 1] != 0x63 &&@sysvar::naviSD_FSG::Common_List_CSVPath[CSV_Name_Size+2] != 0x73 && @sysvar::naviSD_FSG::Common_List_CSVPath[CSV_Name_Size+3] != 0x76 )
        while(!stop)
             {
             if( @sysvar::FSG_AudioSD::ComList_erternalFile_path[CSV_Name_Size] == 0x2E && @sysvar::FSG_AudioSD::ComList_erternalFile_path[CSV_Name_Size + 1] == 0x63 &&@sysvar::FSG_AudioSD::ComList_erternalFile_path[CSV_Name_Size + 2] == 0x73 && @sysvar::FSG_AudioSD::ComList_erternalFile_path[CSV_Name_Size + 3] == 0x76 )
                {
                stop= 1;
                CSV_Name_Size = CSV_Name_Size+ 4;
                }
             else
                CSV_Name_Size++;
             }
           // CSV_Name_Size =CSV_Name_Size + 3;
        for( i = 0; i <CSV_Name_Size; i++ )
            Path_CSV[i] = @sysvar::FSG_AudioSD::ComList_erternalFile_path[i];//get filename & path of *.csv-file from Panel
    i = 0; j = 0; CommonListLine = 0; current_CSV_line = 0; //reset values
 //       write( "complete path *.csv: %s", Path_CSV); //debug

        i = 0;

        while ( Path_CSV[i] != 0 ) //scan "path"
        {
            if( Path_CSV[i] == 0x5C) //count "/" to seperate later "path" & "filename"
                count1++;

            //write( "Path[%d] of *.csv: %x",i, Path_CSV[i] ); //debug
            i++;
        }

        i = 0; j = 0; //reset values

        while ( Path_CSV[i] != 0 ) //seperate "path" and "filename"
        {
            if( count2==count1 ) //get filename after last "\"
            {
                gCommonList_CSV_filename[j] = Path_CSV[i];
                j++;

                Path_CSV[i] = 0;
            }

            if( Path_CSV[i] == 0x5C) //count "\" to get filename after last "\"
                count2++;

            i++;
        }

        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: path of *.csv: %s", Path_CSV);        //output file path

        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: filename of *.csv: '%s'", gCommonList_CSV_filename );  //output filename

        sysSetVariableString(sysvar::FSG_AudioSD::ComList_externalFile_current, gCommonList_CSV_filename );
        setFilePath( Path_CSV, 0 ); //set path for *.csv file

        CSVfileHandle =openFileRead( gCommonList_CSV_filename,1 ); //open *.csv ( binary-mode ->get the ASCII/UTF-8 code )
        if( CSVfileHandle!= 0 ) //*.csv file access successful
        {
          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Dateizugriff auf '%s' erfolgreich", gCommonList_CSV_filename );    //output result
          sysSetVariableString(sysvar::FSG_AudioSD::ComList_externalFile_loadState , "successful" );   //output result on panel

          Num_of_csv_byte = fileGetBinaryBlock( buffer_byte, elcount( buffer_byte ), CSVfileHandle );//get data from *.csv and store the total number of byte in *.csv-file
          for( i = 0; i <Num_of_csv_byte; i++ ) //copy data into "CommonList"
          {
              if( buffer_byte[i] != 0x3B) //read data if no ";" is detected
              {
                  if( buffer_byte[i] == 0x0D && buffer_byte[i + 1] == 0x0A) //nextline in *.csv (next "record element" in CommonList ) -> "LF" and "CR" detected -> copy ( transform string -> long ) data from help values in global values
                  {
                      if( current_CSV_line> 0 && CommonListLine < AUDIO_COMMONLIST_ENTRIES) //ignore first line in *.csv file
                      {
                          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: " );
                          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: *******Element %d*******", CommonListLine );

                          //transform 'string' to 'long' for "POS", "CommonType" and "CommonType"
                          gCommonList_Pos[CommonListLine]            =atol( CommonList_Pos_string[CommonListLine] );
                          gCommonList_SourceType[CommonListLine]     =atol( CommonList_SourceType_string[CommonListLine] );
                          gCommonList_Attributes[CommonListLine]     =atol( CommonList_Attributes_string[CommonListLine] );
                          gCommonList_PresetID[CommonListLine]       =atol( CommonList_PresetID_string[CommonListLine] );
                          gCommonList_Category[CommonListLine]       =atol( CommonList_Category_string[CommonListLine] );

                          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: *******Element %d*******", CommonListLine );
                          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Pos[%d]: 0x%x", CommonListLine, gCommonList_Pos[CommonListLine] );
                          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: SourceType[%d]: 0x%x", CommonListLine, gCommonList_SourceType[CommonListLine] );
                          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Attritude[%d]: 0x%x", CommonListLine, gCommonList_Attributes[CommonListLine] );
                          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: PresetID[%d]: 0x%x", CommonListLine, gCommonList_PresetID[CommonListLine] );
                          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Category[%d]: %x", CommonListLine, gCommonList_Category[CommonListLine] );
                          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Name[%d]: %s", CommonListLine, gCommonList_Name[CommonListLine] );
                          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Frequency[%d]: %s", CommonListLine, gCommonList_Frequency[CommonListLine] );

                          gCommonList_ListEntryValidInformation[CommonListLine]  = TRUE;

                          CommonListLine++; // -> next line in *.csv (next record element )
                      }

                      current_CSV_line++; //next line in *.csv file
                      element = 0; //start at 'POS' ( first record element of "array data" )
                      j = 0; //reset value
                  }

                  else if( current_CSV_line> 0 && CommonListLine < AUDIO_COMMONLIST_ENTRIES) //copy data from "buffer_byte" ( data from *.csv file ) in help values and "name" until end of line is not detected
                  {
                      switch(  element )
                      {
                          case 0: //POS
                                  CommonList_Pos_string[CommonListLine][j] =buffer_byte[i];
                                  j++;
                           break;

                          case 1: //SourceType
                                  CommonList_SourceType_string[CommonListLine][j] =buffer_byte[i];
                                  j++;
                           break;

                          case 2: //Attribbutes
                                  CommonList_Attributes_string[CommonListLine][j] =buffer_byte[i];
                                  j++;
                           break;
                          case 3: //PresetID
                                  CommonList_PresetID_string[CommonListLine][j] =buffer_byte[i];
                                  j++;
                           break;

                          case 4: //Category
                                  CommonList_Category_string[CommonListLine][j] =buffer_byte[i];
                                  j++;
                           break;

                          case 5: //Name
                                  gCommonList_Name[CommonListLine][j] =buffer_byte[i];
                                  j++;
                           break;

                          case 6: //Frequency
                                  gCommonList_Frequency[CommonListLine][j] =buffer_byte[i];
                                  j++;
                           break;

                          default:
                           break;
                      }
                  }
              }
              else  // ";" is detected ->next record element of "array data"
              {
                  element++;
                  j = 0; //reset value
              }
          }
          gCommonList_TotalNumListElements = gCommonListLine_sum =CommonListLine; //get "total number of list elements"
          @sysvar::FSG_AudioSD::ComList_TNLE = gCommonList_TotalNumListElements;

          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: " );

          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Anzahl der Listenelemente: %d", gCommonListLine_sum); //output total number of list elements

          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: " );

          if( fileClose( CSVfileHandle ) != 0 ) //close *.csv file
          {
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Datei '%s' geschlossen", gCommonList_CSV_filename ); //output result
          }else
          {
            if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Fehler beim Schlieen der Datei '%s'", gCommonList_CSV_filename );//output result
          }
        }

        else //*.csv file access not successful
        {
          if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Fehler beim Dateizugriff auf '%s'", gCommonList_CSV_filename ); //output result
          sysSetVariableString( sysvar::FSG_AudioSD::ComList_externalFile_loadState , "not successful" ); //output result
        }
    }
}

void CommonList_initStatic()
{
    byte j, i, CommonListLine;
    j = 0;
    i = 0;
    //clear
    CommonListLine = 0;
    gCommonListLine_sum = 0;

    for( j = 0; j < AUDIO_COMMONLIST_ENTRIES; j++ ) //clear "CommonList Array"
    {
      gCommonList_ListEntryValidInformation[j] = FALSE;

      gCommonList_Pos[j] = 0;

      for( i = 0; i < AUDIO_COMMONLIST_NAME_LENGTH; i++ )
          gCommonList_Name[j][i] = 0;

      for( i = 0; i < AUDIO_COMMONLIST_FREQUENCY_LENGTH; i++ )
          gCommonList_Frequency[j][i] = 0;
    }

    //entry 0
    gCommonList_ListEntryValidInformation[CommonListLine] = TRUE;
    gCommonList_Pos[CommonListLine] = 0xb1;
    gCommonList_SourceType[CommonListLine] = 0x00;
    gCommonList_Attributes[CommonListLine] = 0x1234;
    gCommonList_PresetID[CommonListLine] = 0x1a;
    gCommonList_Category[CommonListLine] = 0x12;
    strncpy( gCommonList_Name[CommonListLine], "Name_0", AUDIO_COMMONLIST_NAME_LENGTH);
    strncpy( gCommonList_Frequency[CommonListLine], "Frequency_0", AUDIO_COMMONLIST_FREQUENCY_LENGTH);
    CommonListLine++;
    //entry 1
    gCommonList_ListEntryValidInformation[CommonListLine] = TRUE;
    gCommonList_Pos[CommonListLine] = 0x1d;
    gCommonList_SourceType[CommonListLine] = 0x00;
    gCommonList_Attributes[CommonListLine] = 0x9876;
    gCommonList_PresetID[CommonListLine] = 0x01;
    gCommonList_Category[CommonListLine] = 0x12;
    strncpy( gCommonList_Name[CommonListLine], "Name_1", AUDIO_COMMONLIST_NAME_LENGTH);
    strncpy( gCommonList_Frequency[CommonListLine], "Frequency_1", AUDIO_COMMONLIST_FREQUENCY_LENGTH);
    CommonListLine++;
    //entry 2
    gCommonList_ListEntryValidInformation[CommonListLine] = TRUE;
    gCommonList_Pos[CommonListLine] = 0x42;
    gCommonList_SourceType[CommonListLine] = 0x00;
    gCommonList_Attributes[CommonListLine] = 0x1357;
    gCommonList_PresetID[CommonListLine] = 0xe7;
    gCommonList_Category[CommonListLine] = 0x13;
    strncpy( gCommonList_Name[CommonListLine], "Name_2", AUDIO_COMMONLIST_NAME_LENGTH);
    strncpy( gCommonList_Frequency[CommonListLine], "Frequency_2", AUDIO_COMMONLIST_FREQUENCY_LENGTH);
    CommonListLine++;
    //entry 3
    gCommonList_ListEntryValidInformation[CommonListLine] = TRUE;
    gCommonList_Pos[CommonListLine] = 0x11;
    gCommonList_SourceType[CommonListLine] = 0x02;
    gCommonList_Attributes[CommonListLine] = 0x2468;
    gCommonList_PresetID[CommonListLine] = 0xb3;
    gCommonList_Category[CommonListLine] = 0x14;
    strncpy( gCommonList_Name[CommonListLine], "Name_3", AUDIO_COMMONLIST_NAME_LENGTH);
    strncpy( gCommonList_Frequency[CommonListLine], "Frequency_3", AUDIO_COMMONLIST_FREQUENCY_LENGTH);
    CommonListLine++;
    //entry 4
    gCommonList_ListEntryValidInformation[CommonListLine] = TRUE;
    gCommonList_Pos[CommonListLine] = 0xaa;
    gCommonList_SourceType[CommonListLine] = 0x05;
    gCommonList_Attributes[CommonListLine] = 0x9873;
    gCommonList_PresetID[CommonListLine] = 0x09;
    gCommonList_Category[CommonListLine] = 0x15;
    strncpy( gCommonList_Name[CommonListLine], "Name_4", AUDIO_COMMONLIST_NAME_LENGTH);
    strncpy( gCommonList_Frequency[CommonListLine], "Frequency_4", AUDIO_COMMONLIST_FREQUENCY_LENGTH);
    CommonListLine++;
    //entry 5
    gCommonList_ListEntryValidInformation[CommonListLine] = TRUE;
    gCommonList_Pos[CommonListLine] = 0xa1;
    gCommonList_SourceType[CommonListLine] = 0x03;
    gCommonList_Attributes[CommonListLine] = 0x6758;
    gCommonList_PresetID[CommonListLine] = 0x0f;
    gCommonList_Category[CommonListLine] = 0x16;
    strncpy( gCommonList_Name[CommonListLine], "Name_5", AUDIO_COMMONLIST_NAME_LENGTH);
    strncpy( gCommonList_Frequency[CommonListLine], "Frequency_5", AUDIO_COMMONLIST_FREQUENCY_LENGTH);
    CommonListLine++;
    //entry 6
    gCommonList_ListEntryValidInformation[CommonListLine] = TRUE;
    gCommonList_Pos[CommonListLine] = 0xc7;
    gCommonList_SourceType[CommonListLine] = 0x09;
    gCommonList_Attributes[CommonListLine] = 0x3425;
    gCommonList_PresetID[CommonListLine] = 0x01;
    gCommonList_Category[CommonListLine] = 0x17;
    strncpy( gCommonList_Name[CommonListLine], "Name_6", AUDIO_COMMONLIST_NAME_LENGTH);
    strncpy( gCommonList_Frequency[CommonListLine], "Frequency_6", AUDIO_COMMONLIST_FREQUENCY_LENGTH);
    CommonListLine++;

    gCommonListLine_sum = CommonListLine;
    gCommonList_TotalNumListElements = gCommonListLine_sum;

    //write Array in "write -window"
    if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: " );
    if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: *******Default CommonList_Array*******" );
    if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: " );

    for( i = 0; i < gCommonListLine_sum; i++ )
    {
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: *******Element %d*******", i);
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: SourceType[%d]: 0x%x", i, gCommonList_SourceType[i] );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Attributes[%d]: 0x%x", i, gCommonList_Attributes[i] );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: PresetID[%d]: 0x%x", i, gCommonList_PresetID[i] );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Category[%d]: 0x%x", i, gCommonList_Category[i] );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Name[%d]: %s", i, gCommonList_Name[i] );
        if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Frequency[%d]: %s", i, gCommonList_Frequency[i] );
    }
    if( boTraceStatus_ON ) writeLineEx( gBAP_Trace, 0, "CommonList: Anzahl der Listenelemente: %d", gCommonListLine_sum);
    @sysvar::FSG_AudioSD::ComList_TNLE = gCommonList_TotalNumListElements;
}

byte CommonList_nextValidLine( byte current_CommonListLine, byte direction )
{
    byte next_CommonListLine;
    int i;

    //init lokal variables
    next_CommonListLine = 0;
    i = 0;

    //search next "list entry"
    if( (( gCommonListLine_sum - 1 ) == current_CommonListLine && FORWARD == direction ) || ( 0 == current_CommonListLine && BACKWARD == direction ) )    //last-/fist-element of array reached
        next_CommonListLine = 0xFF;
    else
    {
        next_CommonListLine = current_CommonListLine + 1 - 2 * direction;       //increment or decrement array-line ( depends on direction );

        if( 0 == gCommonList_ListEntryValidInformation[next_CommonListLine] )    // check if next element is "valid"
            next_CommonListLine = 0xff;
    }

    return (next_CommonListLine );
}

on sysvar sysvar::FSG_AudioSD::ComList_arrayHeadder
{
    if( @sysvar::FSG_AudioSD::ComList_arrayHeadder == 1 )
        @sysvar::FSG_AudioSD::ComList_arrayHeadderData = 0;
}

on sysvar sysvar::FSG_AudioSD::ComList_arrayHeadderData
{
    if( @sysvar::FSG_AudioSD::ComList_arrayHeadderData == 1 )
        @sysvar::FSG_AudioSD::ComList_arrayHeadder = 0;
}

on sysvar sysvar::FSG_AudioSD::ComList_externalFile_search
{
   if( @sysvar::FSG_AudioSD::ComList_externalFile_search && @sysvar::FSG_AudioSD::ComList_DataSource_external)

        CommonList_initCSV();

    else if( @sysvar::FSG_AudioSD::ComList_DataSource_external != 1 )
        sysSetVariableString(sysvar::FSG_AudioSD::ComList_externalFile_current, "not successful, select 'external *.csv'" );
}

void SiriusAlertInfo_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
      case DataGet_IND:
        SiriusAlertInfo_Request( Data_REQ, 0 );    //send status
      break;
      default:
        writelineEx( gError_Trace, 0, "FSG_AudioSD SiriusAlertInfo_Indication: invalid indication %d", Indication_array[2] );
      break;
    }
}

void SiriusAlertInfo_Request( byte request, byte errorcode )
{
  const STRINGBYTE_Alert = 60;
  const STRINGBYTE_Station = 48;
  char buffer_Information_Alert[STRINGBYTE_Alert];
  char buffer_Information_Station[STRINGBYTE_Station];

  int i,Offset;
  dword requestarray[BAP_BUFFER_SIZE];

  // Init local variables.
  for( i = 0; i < BAP_BUFFER_SIZE; i++ ) requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;          //LSG-ID
  requestarray[1] = FctID_SiriusAlertInfo;   //Fct.-ID
  requestarray[2] = request;               //request type
  Offset = 3;

  switch( request )
  {
    case Data_REQ:
      //AlertType
      requestarray[Offset] = getvalue(Env_FSG_SAI_AlertType );
      Offset++;
      //AlertName
      getValue(Env_FSG_SAI_AlertName,buffer_Information_Alert );
      requestarray[Offset] = strlen( buffer_Information_Alert );
      Offset++;
      for( i = 0; i < strlen( buffer_Information_Alert ); i++ )
      {
          requestarray[Offset] = buffer_Information_Alert[i];
          Offset++;
      }
      //StationName
      getValue(Env_FSG_SAI_StationName,buffer_Information_Station );
      requestarray[Offset] = strlen( buffer_Information_Station );
      Offset++;
      for( i = 0; i < strlen( buffer_Information_Station ); i++ )
      {
          requestarray[Offset] = buffer_Information_Station[i];
          Offset++;
      }
      //SiriusAlerList_Reference
      requestarray[Offset] = getvalue(Env_FSG_SAI_SalReference ) & 0xff;
      Offset++;
      requestarray[Offset] = ( getvalue(Env_FSG_SAI_SalReference ) & 0xff00 ) / 0x100;
      Offset++;
      //Extension1
      requestarray[Offset] = getvalue(Env_FSG_SAI_Extension1 );
      Offset++;
      //Extension2
      requestarray[Offset] = getvalue(Env_FSG_SAI_Extension2 );
      Offset++;
      //Extension3
      requestarray[Offset] = getvalue(Env_FSG_SAI_Extension3);
      Offset++;

      set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
      break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer( requestarray, 4, Bap_Error );
      break;
    default:
      writelineEx( gError_Trace, 0, "FSG_AudioSD SiriusAlertInfo_Request: invalid request %d", request );
      break;
  }
}

on envVar Env_FSG_Update_SAI
{
  if( gAudioSD_PowerOnOff == @Env_FSG_Update_SAI)
    {
    SiriusAlertInfo_Request( Data_REQ, 0 );
  }
}

void Station_Track_Switch_Indication( dword Indication_array [], int datalength )
{
    switch( Indication_array[2] ) // indication
    {
      case DataGet_IND:
        Station_Track_Switch_Request( Data_REQ, 0 );    //send status
      break;
      default:
        writelineEx( gError_Trace, 0, "FSG_AudioSD Station_Track_Switch_Indication: invalid indication %d", Indication_array[2] );
      break;
    }
}

void Station_Track_Switch_Request( byte request, byte errorcode )
{

  int i,Offset;
  dword requestarray[BAP_BUFFER_SIZE];
  byte byTemp;

  // Init local variables.
  for( i = 0; i < BAP_BUFFER_SIZE; i++ ) requestarray[i] = 0;

  // Handle request.
  requestarray[0] = LSG_AudioSD;          //LSG-ID
  requestarray[1] = FctID_Station_Track_Switch;   //Fct.-ID
  requestarray[2] = request;               //request type
  Offset = 3;

  switch( request )
  {
    case Data_REQ:
      //Event & Direction
      byTemp  = getvalue(Env_FSG_STS_Direction );
      byTemp += getvalue(Env_FSG_STS_Event ) * 0x10;
      requestarray[Offset] = byTemp;
      Offset++;
      //PlayState & Extension1
      byTemp  = getvalue(Env_FSG_STS_Extension1 );
      byTemp += getvalue(Env_FSG_STS_PlayState ) * 0x10;
      requestarray[Offset] = byTemp;
      Offset++;
      //Extension2
      requestarray[Offset] = getvalue(Env_FSG_STS_Extension2 );
      Offset++;
      //Extension3
      requestarray[Offset] = getvalue(Env_FSG_STS_Extension3);
      Offset++;
      //Extension4
      requestarray[Offset] = getvalue(Env_FSG_STS_Extension4 );
      Offset++;
      //Extension5
      requestarray[Offset] = getvalue(Env_FSG_STS_Extension5);
      Offset++;

      set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
      break;
    case Error_REQ:
      requestarray[3] = errorcode;
      set_status_requestbuffer( requestarray, 4, Bap_Error );
      break;
    default:
      writelineEx( gError_Trace, 0, "FSG_AudioSD Station_Track_Switch_Request: invalid request %d", request );
      break;
  }
}

on envVar Env_FSG_Update_STS
{
  if( gAudioSD_PowerOnOff == @Env_FSG_Update_STS)
    {
    Station_Track_Switch_Request( Data_REQ, 0 );
  }
}

void Picture_Indication ( dword Indication_array [], int datalength )
{
  byte mode, shift, direction, recordaddress, indexsize, transmitpos;
  word valid_startelement, requested_startelement, startelement, elements, Offset, valid_elements;
  int i = 0, transSuppression;

  // Init local variables.
  mode                    = 0;
  shift                   = 0;
  direction               = 0;
  transmitpos             = 0;
  indexsize               = 0;
  recordaddress           = 0;
  requested_startelement  = 0;
  startelement            = 0;
  elements                = 0;
  valid_startelement      = 0;
  i                       = 0;
  valid_elements          = 0;
  transSuppression        = getvalue( env_AudioSD_Pic_StatusOFF );

  switch( Indication_array[2] ) // indication
  {
        case DataGet_IND:
        //MR 63336
        if( getvalue( env_AudioSD_Pic_Error_Status ) )
        {
          Request_Picture(Error_REQ, 0, 0, 0, 0, 0, getvalue( env_AudioSD_Pic_ErrorCode ) );
        }
        else if( getvalue( env_AudioSD_Pic_Timeout ) == TRUE )
        {
        /* NOP */
        }
        else
        {
          //getData
          gPicture_ASGID = ( gBAP_Indication[3] & 0xF0 ) / 0x10;
          gPicture_TAID  = gBAP_Indication[3] & 0x0F;

          /***ArrayHeader***/
          mode            = ( Indication_array[4] & 0xF0 ) / 0x10;
          recordaddress   =Indication_array[4] & 0x0F;
          Offset = 5;

          // decode "mode -byte"
          shift       = mode & 0x01;
          direction   = ( mode & 0x02 ) / 0x02;
          transmitpos = ( mode & 0x04 ) / 0x04;
          indexsize   = ( mode & 0x08 ) / 0x08;

          if( indexsize )
          {
              startelement =Indication_array[Offset];
              Offset++;
              startelement += ( Indication_array[Offset] * 0x100 );
              Offset++;

              elements =Indication_array[Offset];
              Offset++;
              elements += ( Indication_array[Offset] * 0x100 );
              Offset++;
          }
          else
          {
              startelement =Indication_array[Offset];
              Offset++;

              elements =Indication_array[Offset];
              Offset++;
          }

          requested_startelement = startelement;


          /***Startelement = 0***/
          if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
                {
            if( FORWARD==direction )  //forward-start
                    {
              valid_startelement = 0;
              if( AUDIO_PICTURE_ENTRIES <= elements ) //1. more elements requested, than in array
                        {
                if( shift == FALSE )
                {
                  for( i = 0; i < AUDIO_PICTURE_ENTRIES; i++ )
                              {
                                  if( 0 != gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                    {
                      if( gPicture_Pos[i] > 0xff )
                      {
                        indexsize = TRUE;
                      }
                      valid_elements++;                                //increment elements
                                  }
                    else      //no valid element, loop finished
                    {
                                      i = AUDIO_PICTURE_ENTRIES;
                    }
                              }
                }
                else
                {
                  valid_startelement  = startelement;
                              valid_elements      = 0;
                }
                        }
              else    //2. number of requested elements < elements in array
                        {
                if( shift == FALSE )
                {
                            for( i = 0; i < elements; i++ )
                            {
                                  if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                    {
                      if( gPicture_Pos[i] > 0xff )
                      {
                        indexsize = TRUE;
                      }
                      valid_elements++;                                //increment elements
                                  }
                                  else                                                //no valid element, loop finished
                    {
                                      i = AUDIO_PICTURE_ENTRIES;
                    }
                              }
                }
                else
                {
                  valid_startelement  = startelement;
                          valid_elements      = 0;
                }
                        }
            }                                                               //forward ends
            else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                    {
                        //searching for valid startelement
                        for( i = ( AUDIO_PICTURE_ENTRIES-1 ); i>= 0; i--)
                        {
                            if( 0!= gPicture_ListEntryValidInformation[i] )        //found valid startelement
                            {
                                valid_startelement = i;
                                i = 0;
                            }
                        }
              //searching for valid elements
                        if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                        {
                            valid_startelement  = startelement;
                            valid_elements      = 0;
                        }
                        else if( 0 ==valid_startelement )
                            valid_elements= 1;                                       //only 1 element because valid startelement is on position 0
                        else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                        {
                            for( i =valid_startelement; i>= 0; i--)
                            {
                                if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                                  {
                    if( gPicture_Pos[i] > 0xff )
                    {
                      indexsize = TRUE;
                    }
                    valid_elements++;                                //increment elements
                                }
                  else                                                //no valid element, loop finished
                  {
                                    i = 0;
                  }
                            }
                        }
              else                                                        //enougth array-elements available
                        {
                            for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                            {
                                if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                                  {
                    valid_elements++;                                //increment elements
                    if( gPicture_Pos[i] > 0xff )
                    {
                      indexsize = TRUE;
                    }
                  }
                  else                                                //no valid element, loop finished
                  {
                                    i = 0;
                  }
                            }
                        }
                  }                                                               //backward-end
          }                                                                   //startelement == 0 -end
          /***Startelement!= 0***/
          else                                                                //searching for Startelement-ID
                {
                    //searching for valid startelement
                    for( i = 0; i < AUDIO_PICTURE_ENTRIES; i++ )
                    {
                      if( gPicture_Pos[i] == startelement )                        //found a valid element
                      {
                if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                            {
                                if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                  {
                                    valid_startelement = i + 1-2*direction;
                  }
                  else if( i == 0 && BACKWARD==direction )
                  {
                    valid_startelement = gPictureLine_sum;           //valid element is last element in Array
                  }
                  else if( i == 0 && FORWARD==direction )
                  {
                    valid_startelement = 0;                          //valid element is first element in Array
                  }
                }
                else
                {
                  valid_startelement = i;                              //found element is valid_startelement
                }
                            i = AUDIO_PICTURE_ENTRIES;
                        }
                    }
                    if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
                    {
                        valid_startelement  = startelement;
                        valid_elements      = 0;
                    }
                    else                                                                //found valid entry for startelement in array
                    {
                        //verify number of valid elements
                        if( BACKWARD==direction )                                            //backward-start
                        {
                            if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                {
                                valid_elements= 1;
                }
                            else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                            {
                                for( i =valid_startelement; i>= 0; i--)
                                {
                                    if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                                      {
                      if( gPicture_Pos[i] > 0xff )
                      {
                        indexsize = TRUE;
                      }
                      valid_elements++;                                //increment elements
                                    }
                    else                                                //no valid element, loop finished
                    {
                                        i = 0;
                    }
                                }
                            }
                            else                                                        //enougth array-elements available
                            {
                                for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                                {
                                    if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                                      {
                      if( gPicture_Pos[i] > 0xff )
                      {
                        indexsize = TRUE;
                      }
                      valid_elements++;                                //increment elements
                    }
                    else                                                //no valid element, loop finished
                    {
                                        i = 0;
                    }
                                }
                            }
                        }                                                                //backward-end
                        else                                                            //forward-start
                        {
                            if((valid_startelement+elements )>= AUDIO_PICTURE_ENTRIES)
                            {
                                for( i =valid_startelement; i < AUDIO_PICTURE_ENTRIES; i++ )
                                {
                                    if( 0!= gPicture_Pos[i] )                            //if there is an valid element
                                      {
                      if( gPicture_Pos[i] > 0xff )
                      {
                        indexsize = TRUE;
                      }
                      valid_elements++;                                //increment elements
                                    }
                    else                                                    //no valid element, loop finished
                    {
                                        i = AUDIO_PICTURE_ENTRIES;
                    }
                                }
                            }
                            else
                            {
                                for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                                {
                                    if( 0!= gPicture_Pos[i] )                            //if there is an valid element
                                      {
                      if( gPicture_Pos[i] > 0xff )
                      {
                        indexsize = TRUE;
                      }
                      valid_elements++;                                //increment elements
                                    }
                    else                                                //no valid element, loop finished
                    {
                                        i = AUDIO_PICTURE_ENTRIES;
                    }
                                }
                            }
                        }
                    } //END: if( BACKWARD==direction )
                } //END: if( 0 == startelement )
          transmitpos = TRUE;
          if(( requested_startelement > 0xFF ) || (valid_startelement > 0xFF ) )
          {
            indexsize = TRUE;
          }
          mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;
          //set header data to panel
          putvalue( env_AudioSD_Pic_AH_RecordAdd,recordaddress );
          putvalue( env_AudioSD_Pic_AH_Start,requested_startelement );
          putvalue( env_AudioSD_Pic_AH_Elements,valid_elements );
          putvalue( env_AudioSD_Pic_AH_Shift,shift );
          putvalue( env_AudioSD_Pic_AH_Dir, direction );
          putvalue( env_AudioSD_Pic_AH_TransPos,transmitpos );
          putvalue( env_AudioSD_Pic_AH_IndexSize,indexsize );
          putvalue( env_AudioSD_Pic_AsgId, gPicture_ASGID);
          putvalue( env_AudioSD_Pic_TAID, gPicture_TAID);
          //send StatusArray
          if(!transSuppression )
          {
            Request_Picture( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
          }
        }
        break;
      case Error_IND:
              writelineEx( gError_Trace, 0, "FSG_AudioSD Indication_Picture: received error, errorcode:0x%x", Indication_array[3] );          break;
      default:
          writelineEx( gError_Trace, 0, "FSG_AudioSD Indication_Picture: invalid indication %d", Indication_array[2] );
      break;
    }
}

void Request_Picture( byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements,  byte errorcode )
{
  int  i;
  dword requestarray [BAP_BUFFER_SIZE];
  byte shift, direction, transmitpos, indexsize, current_element;
  word PictureListLine, Offset;
    // Init local variables.
  for( i = 0; i < BAP_BUFFER_SIZE; i++ )
  {
    requestarray [i] = 0;
  }
  shift               = 0;
  direction           = 0;
    transmitpos         = 0;
    indexsize           = 0;
  PictureListLine     = 0;
  current_element     = 0;
  Offset              = 0;
  // decode "mode -byte"
  shift       = mode & 0x01;
  direction   = ( mode & 0x02 ) / 0x02;
    transmitpos = ( mode & 0x04 ) / 0x04;
    indexsize   = ( mode & 0x08 ) / 0x08;
    // Handle request.
  requestarray[0] = LSG_AudioSD;                //LSG-ID
    requestarray[1] = FctID_Picture;            //Fct.-ID
    requestarray[2] = request;                   //request type
    Offset = 3;

  //-------------------------------------------------------------------------
  //-------------------------------------------------------------------------
  switch( request )
    {
          case Changed_REQ:
        /***ArrayHeader***/
              requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
        Offset++;
        if( indexsize )
        {
          requestarray[Offset] = ( requested_startelement & 0x00FF );
          Offset++;
          requestarray[Offset] = (( requested_startelement & 0xFF00 ) / 0x100 );
          Offset++;
          requestarray[Offset] = ( elements & 0x00FF );
          Offset++;
          requestarray[Offset] = (( elements & 0xFF00 ) / 0x100 );
          Offset++;
        }
        else
        {
          requestarray[Offset] = requested_startelement;
          Offset++;
          requestarray[Offset] = elements;
          Offset++;
        }
        PictureListLine = startelement;
        if( getvalue( env_AudioSD_Pic_Changed_wData )== 0 || getvalue( env_AudioSD_Pic_Changed_wData )== 1 ) //ArrayData
        {
          //   if( elements != 0xffff )                                  // if FullRangeUpdate
          //   {
          //copy data
          for( i = 0; i < BAP_BUFFER_SIZE; i++ )
          {
            requestarrayPictureGlobal[i] = requestarray[i];
          }
          offsetPictureGlobal = Offset;
          if( elements != 0xffff )                                  // if no FullRangeUpdate
          {
            Picture_Request_RecordAddress( recordaddress, transmitpos, indexsize, elements, PictureListLine );
          }
          for( i = 0; i < BAP_BUFFER_SIZE; i++ )
          {
            requestarray[i] = requestarrayPictureGlobal[i];
          }
          Offset = offsetPictureGlobal;
          // }
          set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
        }
      break; //end Changed_REQ
      case Data_REQ:
        //VAGH-10511
        ASGID = gPicture_ASGID;
        TAID = gPicture_TAID;
        if( getvalue( env_AudioSD_Pic_ASGID_Error ) != FALSE )
        {
            ASGID += 0x02;
        }
        if( getvalue( env_AudioSD_Pic_TAID_Error ) != FALSE )
        {
            TAID += 0x02;
        }
        requestarray[Offset] = (( ASGID * 0x10 ) & 0xF0 ) + ( TAID & 0x0F );
        Offset++;
        requestarray[Offset] = gPicture_TotalNumListElements;
        Offset++;
        /***ArrayHeader***/
              requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
        Offset++;
        if( indexsize )
        {
          requestarray[Offset] = ( requested_startelement & 0x00FF );
          Offset++;
          requestarray[Offset] = (( requested_startelement & 0xFF00 ) / 0x100 );
          Offset++;
          requestarray[Offset] = ( elements & 0x00FF );
          Offset++;
          requestarray[Offset] = (( elements & 0xFF00 ) / 0x100 );
          Offset++;
        }
        else
        {
          requestarray[Offset] = requested_startelement;
          Offset++;
          requestarray[Offset] = elements;
          Offset++;
        }
              PictureListLine = startelement;
        //copy data
        for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        {
          requestarrayPictureGlobal[i] = requestarray[i];
        }
        offsetPictureGlobal = Offset;
        Picture_Request_RecordAddress ( recordaddress, transmitpos, indexsize, elements, PictureListLine );
        for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        {
          requestarray[i] = requestarrayPictureGlobal[i];
        }
        Offset = offsetPictureGlobal;
        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
      break; //end Data_REQ
      case Error_REQ:
        requestarray[3] = errorcode;
              set_status_requestbuffer( requestarray, 4, Bap_Error );
      break; //end Error_REQ
  } //end switch "request"
}

void Picture_Request_RecordAddress ( byte recordaddress, byte transmitpos, byte indexsize, word elements, word PictureListLine )
{
  int  i, temp = 0, first = 1;
  dword requestarray [BAP_BUFFER_SIZE];
  byte  current_element, direction;
  word  Offset;
  current_element = 0;
  direction = 0;
  temp = 0;
  for( i = 0; i < BAP_BUFFER_SIZE; i++ )
  {
    requestarray[i] = requestarrayPictureGlobal[i];
  }
  Offset  =offsetPictureGlobal;
  if( PictureListLine == 0xFF ) // invalid "list entry"
  {
    write( "AudioSD Picture_Request_RecordAddress: invalid PictureListLine" );
    current_element = elements;
  }//----------------------
  else //valid "list entry"
  {
    //------------------------------------------------------------------------------------------------------
    //------------------------------------------------------------------------------------------------------
    // PictureType, Handle, IPv6Address, UDP_Port, URI
    switch( recordaddress )
        {
        case 0: //changed array full range update -> POS only
          while( current_element < elements )
          {
            /***Array Data***/
            if( transmitpos ) // Pos  -> Array position transmitted
            {
              if( indexsize )
              {
                  requestarray[Offset] = ( gPicture_Pos[PictureListLine] & 0x00FF );
                  Offset++;
                  requestarray[Offset] = (( gPicture_Pos[PictureListLine]& 0xFF00 ) / 0x100 );
                  Offset++;
              }
              else
              {
                  requestarray[Offset] = gPicture_Pos[PictureListLine];
                  Offset++;
              }
            }
            if( elements != 0xffff ) // if no FullRangeUpdate
            {
                //might be GetArray for List display in ASG -> complete record
                // -------------------------------------------------
                // PictureType
                requestarray[Offset] = gPicture_Type[PictureListLine];
                Offset++;
                // -------------------------------------------------
                // Handle
                requestarray[Offset] = gPicture_Handle[PictureListLine];
                Offset++;
                requestarray[Offset] = (( gPicture_Handle[PictureListLine] & 0xFF00 ) / 0x100 );
                Offset++;
                // -------------------------------------------------
                // IPv6 Address
                requestarray[Offset] = strlen( gPicture_IpAddress[PictureListLine] );
                Offset++;
                for( i = 0; i < strlen( gPicture_IpAddress[PictureListLine] ); i++ )
                      {
                  requestarray[Offset] = gPicture_IpAddress[PictureListLine][i];
                  Offset++;
                }
                // -------------------------------------------------
                // UDP Port
                requestarray[Offset] = gPicture_TcpPort[PictureListLine];
                Offset++;
                requestarray[Offset] = (( gPicture_TcpPort[PictureListLine] & 0xFF00 ) / 0x100 );
                Offset++;
                // -------------------------------------------------
                // URI
                requestarray[Offset] = strlen( gPicture_Uri[PictureListLine] );
                Offset++;
                for( i = 0; i < strlen( gPicture_Uri[PictureListLine] ); i++ )
                      {
                  requestarray[Offset] = gPicture_Uri[PictureListLine][i];
                  Offset++;
                }
            }
            current_element++;
            PictureListLine = Picture_nextvalidLine( PictureListLine, direction );
          }//end while
        break;
        case 1: //PictureType, Handle, IPv6Address, TCP_Port, URI
          while( current_element < elements )
          {
            /***Array Data***/
            if( transmitpos ) // Pos  ->Array position transmitted
            {
              if( indexsize )
              {
                requestarray[Offset] = ( gPicture_Pos[PictureListLine] & 0x00FF );
                Offset++;
                requestarray[Offset] = (( gPicture_Pos[PictureListLine]& 0xFF00 ) / 0x100 );
                Offset++;
              }
              else
              {
                requestarray[Offset] = gPicture_Pos[PictureListLine];
                Offset++;
              }
            }
            // -------------------------------------------------
            // PictureType
            requestarray[Offset] = gPicture_Type[PictureListLine];
            Offset++;
            // -------------------------------------------------
            // Handle
            requestarray[Offset] = gPicture_Handle[PictureListLine];
            Offset++;
            requestarray[Offset] = (( gPicture_Handle[PictureListLine] & 0xFF00 ) / 0x100 );
            Offset++;
            // -------------------------------------------------
            // IPv6 Address
            requestarray[Offset] = strlen( gPicture_IpAddress[PictureListLine] );
            Offset++;
            for( i = 0; i < strlen( gPicture_IpAddress[PictureListLine] ); i++ )
                  {
              requestarray[Offset] = gPicture_IpAddress[PictureListLine][i];
              Offset++;
            }
            // -------------------------------------------------
            // UDP Port
            requestarray[Offset] = gPicture_TcpPort[PictureListLine];
            Offset++;
            requestarray[Offset] = (( gPicture_TcpPort[PictureListLine] & 0xFF00 ) / 0x100 );
            Offset++;
            // -------------------------------------------------
            // URI
            requestarray[Offset] = strlen( gPicture_Uri[PictureListLine] );
            Offset++;
            for( i = 0; i < strlen( gPicture_Uri[PictureListLine] ); i++ )
                  {
              requestarray[Offset] = gPicture_Uri[PictureListLine][i];
              Offset++;
            }
            current_element++;
            PictureListLine = Picture_nextvalidLine( PictureListLine, direction );
          }//end while
        break;
        case 15:    //Pos
          while( current_element < elements )
          {
            /***Array Data***/
            if( transmitpos ) // Pos  ->Array position transmitted
            {
              if( indexsize )
              {
                requestarray[Offset] = ( gPicture_Pos[PictureListLine] & 0x00FF );
                Offset++;
                requestarray[Offset] = (( gPicture_Pos[PictureListLine]& 0xFF00 ) / 0x100 );
                Offset++;
              }
              else
              {
                requestarray[Offset] = gPicture_Pos[PictureListLine];
                Offset++;
              }
            }
            current_element++;
            PictureListLine = Picture_nextvalidLine( PictureListLine, direction );
          }//end while
        break;
        default:
                  write( "AudioSD Picture_Request_RecordAddress: invalid recordaddress %d", recordaddress );
              break;
    } //end switch "recordaddress"
  }//end if( PictureListLine == 0xFF )
  //clear
  for( i = 0; i < BAP_BUFFER_SIZE; i++ )
  {
    requestarrayPictureGlobal[i] = 0;
  }
  offsetPictureGlobal = 0;
  //save data
  for( i = 0; i < BAP_BUFFER_SIZE; i++ )
  {
    requestarrayPictureGlobal[i] = requestarray[i];
  }
  offsetPictureGlobal = Offset;
}

byte Picture_nextvalidLine ( byte current_PictureLine, byte direction )
{
    byte next_PictureLine;
    int i;
    //init local variables
    next_PictureLine  = 0;
    i                       = 0;

    //search next "list entry"
    if((( gPictureLine_sum-1 )==current_PictureLine && FORWARD ==direction ) || ( 0 ==current_PictureLine && BACKWARD ==direction ) )    //last-/fist-element of array reached
    {
        next_PictureLine = 0xFF;
    }
    else
    {
          next_PictureLine =current_PictureLine + 1-2*direction;       //increment or decrement array-line ( depends on direction );
      if( 0 == gPicture_ListEntryValidInformation[next_PictureLine] )    // check if next element is "valid"
      {
            next_PictureLine = 0xff;
      }
    }
    return(next_PictureLine );
}

on envVar env_AudioSD_Pic_FullRangeUpd
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;
  // Init local variables.
  mode                    = 0;
  shift                   = 0;
  direction               = 0;
  transmitpos             = 0;
  indexsize               = 0;
  recordaddress           = 0;
  requested_startelement  = 0;
  startelement            = 0;
  elements                = 0;
  valid_startelement      = 0;
  i                       = 0;
  valid_elements          = 0;

  if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
    recordaddress   = 0;
    shift           = 0;
    direction       = 0;
    transmitpos     = 0;
    indexsize       = 1;
    startelement    = 0;
    elements        =65535;

    putvalue( env_AudioSD_Pic_AH_RecordAdd,recordaddress );
    putvalue( env_AudioSD_Pic_AH_Shift,shift );
    putvalue( env_AudioSD_Pic_AH_Dir, direction );
    putvalue( env_AudioSD_Pic_AH_TransPos,transmitpos );
    putvalue( env_AudioSD_Pic_AH_IndexSize,indexsize );
    putvalue( env_AudioSD_Pic_AH_Start,startelement );
    putvalue( env_AudioSD_Pic_AH_Elements,elements );
    mode = shift+ ( direction * 0x02 )+ ( transmitpos * 0x04 )+indexsize * 0x08;

    //send ChangedArray
    Request_Picture( Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0 );
  }
}

on envVar env_AudioSD_Pic_Changed
{
  word requested_startelement, startelement, elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
  int i;

  // Init local variables.
  mode                    = 0;
  shift                   = 0;
  direction               = 0;
  transmitpos             = 0;
  indexsize               = 0;
  recordaddress           = 0;
  requested_startelement  = 0;
  startelement            = 0;
  elements                = 0;
  valid_startelement      = 0;
  i                       = 0;
  valid_elements          = 0;

  if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
  {
    //get data from Panel
    recordaddress   = getvalue( env_AudioSD_Pic_AH_RecordAdd );
    shift           = getvalue( env_AudioSD_Pic_AH_Shift );
    direction       = getvalue( env_AudioSD_Pic_AH_Dir );
    transmitpos     = getvalue( env_AudioSD_Pic_AH_TransPos );
    indexsize       = getvalue( env_AudioSD_Pic_AH_IndexSize );
    startelement    = getvalue( env_AudioSD_Pic_AH_Start );
    elements        = getvalue( env_AudioSD_Pic_AH_Elements );
    mode            = shift+ ( direction * 0x02 )+ ( transmitpos * 0x04 )+indexsize * 0x08;
    requested_startelement = startelement;

    if( getvalue( env_AudioSD_Pic_Changed_wData )== 0 || getvalue( env_AudioSD_Pic_Changed_wData )== 1 ) // ArrayHeader (+ Data )
    {
      /***Startelement = 0***/
      if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
        {
        if( FORWARD==direction )  //forward-start
            {
          valid_startelement = 0;
          if( AUDIO_PICTURE_ENTRIES <= elements ) //1. more elements requested, than in array
                {
            if( shift == FALSE )
            {
              for( i = 0; i < AUDIO_PICTURE_ENTRIES; i++ )
                    {
                if( 0 != gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                {
                  if( gPicture_Pos[i] > 0xff )
                  {
                    indexsize = TRUE;
                  }
                  valid_elements++;                                //increment elements
                          }
                else                                                //no valid element, loop finished
                {
                                i = AUDIO_PICTURE_ENTRIES;
                }
                      }
            }
            else
            {
              valid_startelement  = startelement;
                    valid_elements      = 0;
            }
                }
          else    //2. number of requested elements < elements in array
                {
            if( shift == FALSE )
            {
                    for( i = 0; i < elements; i++ )
                    {
                          if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                {
                  if( gPicture_Pos[i] > 0xff )
                  {
                    indexsize = TRUE;
                  }
                  valid_elements++;                                //increment elements
                        }
                          else                                                //no valid element, loop finished
                            {
                  i = AUDIO_PICTURE_ENTRIES;
                }
                      }
            }
            else
            {
              valid_startelement  = startelement;
                    valid_elements      = 0;
            }
                }
        }                                                               //forward ends
        else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
            {
                //searching for valid startelement
                for( i = ( AUDIO_PICTURE_ENTRIES-1 ); i>= 0; i--)
                {
                    if( 0!= gPicture_ListEntryValidInformation[i] )        //found valid startelement
                    {
                        valid_startelement = i;
                        i = 0;
                    }
                }
          //searching for valid elements
                if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                    valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else if( 0 ==valid_startelement )
          {
                    valid_elements= 1;                                       //only 1 element because valid startelement is on position 0
          }
                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                {
                    for( i =valid_startelement; i>= 0; i--)
                    {
                        if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                          {
                if( gPicture_Pos[i] > 0xff )
                {
                  indexsize = TRUE;
                }
                valid_elements++;                                //increment elements
                        }
              else                                                //no valid element, loop finished
              {
                            i = 0;
              }
                    }
                }
          else                                                        //enougth array-elements available
                {
                    for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                    {
                        if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                          {
                valid_elements++;                                //increment elements
                if( gPicture_Pos[i] > 0xff )
                {
                  indexsize = TRUE;
                }
              }
              else                                                //no valid element, loop finished
              {
                            i = 0;
              }
                    }
                }
          }  //backward-end
      }    //startelement == 0 -end
      /***Startelement!= 0***/
      else    //searching for Startelement-ID
        {
            //searching for valid startelement
            for( i = 0; i < AUDIO_PICTURE_ENTRIES; i++ )
            {
                if( gPicture_Pos[i] == startelement )                        //found a valid element
                {
            if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                    {
                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
              {
                            valid_startelement = i + 1-2*direction;
              }
              else if( i == 0 && BACKWARD==direction )
              {
                valid_startelement = gPictureLine_sum;     //valid element is last element in Array
              }
              else if( i == 0 && FORWARD==direction )
              {
                valid_startelement = 0;                          //valid element is first element in Array
              }
            }
            else
            {
              valid_startelement = i;                              //found element is valid_startelement
            }
                    i = AUDIO_PICTURE_ENTRIES;
                }
            }
            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
            {
                valid_startelement  = startelement;
                valid_elements      = 0;
            }
            else                                                                //found valid entry for startelement in array
            {
                //verify number of valid elements
                if( BACKWARD==direction )                                            //backward-start
                {
                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
            {
                        valid_elements= 1;
            }
                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                        {
                            if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                              {
                  if( gPicture_Pos[i] > 0xff )
                  {
                    indexsize = TRUE;
                  }
                  valid_elements++;                                //increment elements
                            }
                else                                                //no valid element, loop finished
                {
                                i = 0;
                }
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                            if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
                              {
                  if( gPicture_Pos[i] > 0xff )
                  {
                    indexsize = TRUE;
                  }
                  valid_elements++;                                //increment elements
                }
                else                                                //no valid element, loop finished
                {
                                i = 0;
                }
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                    if((valid_startelement+elements )>= AUDIO_PICTURE_ENTRIES)
                    {
                        for( i =valid_startelement; i < AUDIO_PICTURE_ENTRIES; i++ )
                        {
                            if( 0!= gPicture_Pos[i] )                            //if there is an valid element
                              {
                  if( gPicture_Pos[i] > 0xff )
                  {
                    indexsize = TRUE;
                  }
                  valid_elements++;                                //increment elements
                            }
                else                                                    //no valid element, loop finished
                {
                                i = AUDIO_PICTURE_ENTRIES;
                }
                        }
                    }
                    else
                    {
                        for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                        {
                            if( 0!= gPicture_Pos[i] )                            //if there is an valid element
                              {
                  if( gPicture_Pos[i] > 0xff )
                  {
                    indexsize = TRUE;
                  }
                  valid_elements++;                                //increment elements
                            }
                else                                                //no valid element, loop finished
                {
                                i = AUDIO_PICTURE_ENTRIES;
                }
                        }
                    }
                }
            } //END: if( BACKWARD==direction )
        } //END: if( 0 == startelement )
      transmitpos = TRUE;
      if(( requested_startelement > 0xFF ) || (valid_startelement > 0xFF ) )
      {
        indexsize = TRUE;
      }
      mode = shift+ ( direction * 0x02 )+ ( transmitpos * 0x04 )+indexsize * 0x08;
      //send StatusArray
      Request_Picture( Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
    } // END: if( getvalue( env_NaviSD_AL_CA_switch ) )
  }//END: if( gNaviSD_PowerOnOff == POWER_ON && getvalue( env_NaviSD_Pic_Changed ) )
}

on envVar env_AudioSD_Pic_Status
{
  word requested_startelement, startelement, elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress, valid_startelement, valid_elements;
  int i, transSuppression;
  // Init local variables.
  mode                    = 0;
  shift                   = 0;
  direction               = 0;
  transmitpos             = 0;
  indexsize               = 0;
  recordaddress           = 0;
  requested_startelement  = 0;
  startelement            = 0;
  elements                = 0;
  valid_startelement      = 0;
  i                       = 0;
  valid_elements          = 0;
  transSuppression        = getvalue( env_AudioSD_Pic_StatusOFF );

  if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
    //get data from Panel
    gPicture_ASGID                 = getvalue( env_AudioSD_Pic_AsgId );
    gPicture_TAID                  = getvalue( env_AudioSD_Pic_TAID);
    gPicture_TotalNumListElements  = getvalue( env_AudioSD_Pic_TNLE );
    recordaddress   = getvalue( env_AudioSD_Pic_AH_RecordAdd );
    shift           = getvalue( env_AudioSD_Pic_AH_Shift );
    direction       = getvalue( env_AudioSD_Pic_AH_Dir );
    transmitpos     = getvalue( env_AudioSD_Pic_AH_TransPos );
    indexsize       = getvalue( env_AudioSD_Pic_AH_IndexSize );
    startelement    = getvalue( env_AudioSD_Pic_AH_Start );
    elements        = getvalue( env_AudioSD_Pic_AH_Elements );
    mode            = shift+ ( direction * 0x02 )+ ( transmitpos * 0x04 )+indexsize * 0x08;
    requested_startelement = startelement;

    /***Startelement = 0***/
    if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
        {
      if( FORWARD==direction )  //forward-start
            {
        valid_startelement = 0;
        if( AUDIO_PICTURE_ENTRIES <= elements ) //1. more elements requested, than in array
                {
          if( shift == FALSE )
          {
            for( i = 0; i < AUDIO_PICTURE_ENTRIES; i++ )
                        {
                        if( 0 != gPicture_ListEntryValidInformation[i] )    //if there is an valid element
              {
                            valid_elements++;                                //increment elements
              }
                        else                                                //no valid element, loop finished
              {
                            i = AUDIO_PICTURE_ENTRIES;
              }
                      }
          }
          else
          {
            valid_startelement  = startelement;
                    valid_elements      = 0;
          }
              }
        else    //2. number of requested elements < elements in array
                {
          if( shift == FALSE )
          {
                      for( i = 0; i < elements; i++ )
                        {
                        if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
              {
                            valid_elements++;                                //increment elements
              }
                        else                                                //no valid element, loop finished
              {
                          i = AUDIO_PICTURE_ENTRIES;
              }
                      }
          }
          else
          {
            valid_startelement  = startelement;
                  valid_elements      = 0;
          }
                }
      }  //forward ends
      else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
            {
              //searching for valid startelement
                for( i = ( AUDIO_PICTURE_ENTRIES-1 ); i>= 0; i--)
                {
                  if( 0!= gPicture_ListEntryValidInformation[i] )        //found valid startelement
                    {
                      valid_startelement = i;
                        i = 0;
                    }
                }
        //searching for valid elements
                if( 0xff ==valid_startelement )                                //Startelement-ID doesn't exist in SMSReceived-array
                {
                  valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else if( 0 ==valid_startelement )
        {
                  valid_elements= 1;                                       //only 1 element because valid startelement is on position 0
        }
                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                {
                  for( i =valid_startelement; i>= 0; i--)
                    {
                    if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
            {
                        valid_elements++;                                //increment elements
            }
                        else                                                //no valid element, loop finished
            {
                            i = 0;
            }
                  }
                }
        else    //enougth array-elements available
                {
                  for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                    {
                    if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
            {
                        valid_elements++;                                //increment elements
            }
                        else                                                //no valid element, loop finished
            {
                            i = 0;
            }
                    }
                }
        }  //backward-end
    }    //startelement == 0 -end
    /***Startelement!= 0***/
    else //searching for Startelement-ID
        {
          //searching for valid startelement
            for( i = 0; i < AUDIO_PICTURE_ENTRIES; i++ )
            {
                if( gPicture_Pos[i] == startelement )                        //found a valid element
                {
          if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                    {
                    if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
            {
                        valid_startelement = i + 1-2*direction;
            }
            else if( i == 0 && BACKWARD==direction )
            {
              valid_startelement = gPictureLine_sum;     //valid element is last element in Array
            }
            else if( i == 0 && FORWARD==direction )
            {
              valid_startelement = 0;                          //valid element is first element in Array
            }
          }
          else
          {
            valid_startelement = i;                              //found element is valid_startelement
          }
                    i = AUDIO_PICTURE_ENTRIES;
                }
        else
        {
          valid_startelement = 0xff;
        }
            }
            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
            {
                valid_startelement  = startelement;
                valid_elements      = 0;
            }
            else                                                                //found valid entry for startelement in array
            {
              //verify number of valid elements
                if( BACKWARD==direction )                                            //backward-start
                {
                if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
          {
                    valid_elements= 1;
          }
                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                  {
                      for( i =valid_startelement; i>= 0; i--)
                      {
                        if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
              {
                            valid_elements++;                                //increment elements
              }
              else                                                //no valid element, loop finished
              {
                            i = 0;
              }
                        }
                  }
                    else                                                        //enougth array-elements available
                    {
                      for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                        if( 0!= gPicture_ListEntryValidInformation[i] )    //if there is an valid element
              {
                            valid_elements++;                                //increment elements
              }
                            else                                                //no valid element, loop finished
              {
                                i = 0;
              }
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                  if((valid_startelement+elements )>= AUDIO_PICTURE_ENTRIES)
                    {
                      for( i =valid_startelement; i < AUDIO_PICTURE_ENTRIES; i++ )
                        {
                        if( 0!= gPicture_Pos[i] )                            //if there is an valid element
              {
                            valid_elements++;                                //increment elements
              }
                            else                                                //no valid element, loop finished
              {
                              i = AUDIO_PICTURE_ENTRIES;
              }
                        }
                    }
                    else
                    {
                      for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                        {
                        if( 0!= gPicture_Pos[i] )                            //if there is an valid element
              {
                            valid_elements++;                                //increment elements
              }
                            else                                                //no valid element, loop finished
              {
                              i = AUDIO_PICTURE_ENTRIES;
              }
                        }
                    }
                }
            }
        }
    putvalue( env_AudioSD_Pic_AH_Elements,valid_elements );
    //send StatusArray
    //writeEX( gBAP_Trace, 0, "StatusArray_valid_elements %x",valid_elements ); //debug
    if(!getvalue( env_AudioSD_Pic_StatusOFF ) )
        Request_Picture( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
  }
}

void Picture_init_static()
{
  byte j, i, PictureLine;
    j = 0;
  i = 0;
  //clear
  PictureLine         = 0;
  gPictureLine_sum    = 0;

    for( j = 0; j < AUDIO_PICTURE_ENTRIES; j++ ) //clear "Picture Array"
    {
    gPicture_ListEntryValidInformation[j]  = FALSE;
    gPicture_Pos[j]          = 0;
    gPicture_Type[j]         = 0;
    gPicture_TcpPort[j]         = 0;
    //reset IP-Address
    for( i = 0; i < AUDIO_PICTURE_IPADDRESS_LENGTH; i++ )
    {
          gPicture_IpAddress[j][i] = 0;
    }
    //reset URI
    strncpy( gPicture_Uri[j], "",AUDIO_PICTURE_URI_LENGTH);
  }

  //entry 0
    gPicture_ListEntryValidInformation[PictureLine] = TRUE;
    gPicture_Pos[PictureLine]                    = 0x01;
    gPicture_Type[PictureLine]                   = AUDIO_PICTURE_TYPE_STATIONART_NORMAL;
        gPicture_IpAddress[PictureLine][00] = 0x20;
    gPicture_IpAddress[PictureLine][01] = 0x01;
    gPicture_IpAddress[PictureLine][02] = 0x0D;
    gPicture_IpAddress[PictureLine][03] = 0xB8;
    gPicture_IpAddress[PictureLine][04] = 0x85;
    gPicture_IpAddress[PictureLine][05] = 0xA3;
    gPicture_IpAddress[PictureLine][06] = 0x08;
    gPicture_IpAddress[PictureLine][07] = 0xD3;
    gPicture_IpAddress[PictureLine][08] = 0x13;
    gPicture_IpAddress[PictureLine][09] = 0x19;
    gPicture_IpAddress[PictureLine][10] = 0x8A;
    gPicture_IpAddress[PictureLine][11] = 0x2E;
    gPicture_IpAddress[PictureLine][12] = 0x03;
    gPicture_IpAddress[PictureLine][13] = 0x70;
    gPicture_IpAddress[PictureLine][14] = 0x73;
    gPicture_IpAddress[PictureLine][15] = 0x44;
    gPicture_TcpPort[PictureLine]                 =69;
    strncpy( gPicture_Uri[PictureLine], "/URI_0",AUDIO_PICTURE_URI_LENGTH);
    PictureLine++;
    gPictureLine_sum++;
  //entry 1
    gPicture_ListEntryValidInformation[PictureLine] = TRUE;
    gPicture_Pos[PictureLine]                    = 0x02;
    gPicture_Type[PictureLine]                   = AUDIO_PICTURE_TYPE_COVERART_NORMAL;
    gPicture_IpAddress[PictureLine][00] = 0x20;
    gPicture_IpAddress[PictureLine][01] = 0x01;
    gPicture_IpAddress[PictureLine][02] = 0x0D;
    gPicture_IpAddress[PictureLine][03] = 0xB8;
    gPicture_IpAddress[PictureLine][04] = 0x85;
    gPicture_IpAddress[PictureLine][05] = 0xA3;
    gPicture_IpAddress[PictureLine][06] = 0x08;
    gPicture_IpAddress[PictureLine][07] = 0xD3;
    gPicture_IpAddress[PictureLine][08] = 0x13;
    gPicture_IpAddress[PictureLine][09] = 0x19;
    gPicture_IpAddress[PictureLine][10] = 0x8A;
    gPicture_IpAddress[PictureLine][11] = 0x2E;
    gPicture_IpAddress[PictureLine][12] = 0x03;
    gPicture_IpAddress[PictureLine][13] = 0x70;
    gPicture_IpAddress[PictureLine][14] = 0x73;
    gPicture_IpAddress[PictureLine][15] = 0x47;
    gPicture_TcpPort[PictureLine]                 =69;
    strncpy( gPicture_Uri[PictureLine], "/URI_1",AUDIO_PICTURE_URI_LENGTH);
    PictureLine++;
    gPictureLine_sum++;

  gPictureLine_sum               = PictureLine;
  gPicture_TotalNumListElements  = gPictureLine_sum;
  putvalue( env_AudioSD_Pic_TNLE, gPicture_TotalNumListElements );
}

on envVar env_AudioSD_Pic_CSV_Load
{
  if( getvalue( this ) )
  {
    if( getvalue( env_AudioSD_Pic_CSV_Default ) )
    {
      Picture_init_CSV();
    }
  }
}

void Picture_init_CSV () //Byte & file selection
{
    dword CSVfileHandle, ConfigFileHandle, i, j, Num_of_csv_byte, element, current_CSV_line, count1, count2;
    char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
    byte PictureLine, buffer_byte[AUDIO_BUFFERSIZE];
    char Picture_Pos_string [AUDIO_PICTURE_ENTRIES][AUDIO_TEXTLENGTH];           //help value ->"POS" is stored in the ASCII(UTF-8 ) code in the *.csv
    char Picture_Type_string [AUDIO_PICTURE_ENTRIES][AUDIO_TEXTLENGTH];       //help value ->"Picture Type" is stored in the ASCII(UTF-8 ) code in the *.csv
    char Picture_Handle_string [AUDIO_PICTURE_ENTRIES][AUDIO_TEXTLENGTH];       //help value ->"Handle" is stored in the ASCII(UTF-8 ) code in the *.csv
    char Picture_IpAddress_string [AUDIO_PICTURE_ENTRIES][AUDIO_TEXTLENGTH];           //help value ->"IP Address" is stored in the ASCII(UTF-8 ) code in the *.csv
    char Picture_TcpPort_string[AUDIO_PICTURE_ENTRIES][AUDIO_TEXTLENGTH];           //help value ->"TCP Port" is stored in the ASCII(UTF-8 ) code in the *.csv
    char Picture_Uri_string[AUDIO_PICTURE_ENTRIES][AUDIO_TEXTLENGTH_URI];           //help value ->"URI" is stored in the ASCII(UTF-8 ) code in the *.csv
    int CSV_Name_Size, stop;
    CSVfileHandle     = 0;
    ConfigFileHandle  = 0;
    i                 = 0;
    j                 = 0;
    Num_of_csv_byte   = 0;
    element           = 0;
    current_CSV_line  = 0;
    count1            = 0;
    count2            = 0;
    PictureLine  = 0;
    CSV_Name_Size     = 0;
    stop              = 0;


    if( getvalue( env_AudioSD_Pic_CSV_Default ) ) //output data in write window "FSG Picture"
    {
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "*******External Picture_List*******" );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "" );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "**********************Start load new Picture_List**********************" );

        for( j = 0; j < AUDIO_PICTURE_ENTRIES; j++ ) //clear "Picture Array"
        {
            gPicture_ListEntryValidInformation[j]  = FALSE;
            gPicture_Pos[j]          = 0;
            gPicture_Type[j]         = 0;
      gPicture_Handle[j]       = 0;
      gPicture_TcpPort[j]      = 0;
      for( i = 0; i < AUDIO_PICTURE_IPADDRESS_LENGTH; i++ )
      {
        gPicture_IpAddress[j][i] = 0;
      }
      for( i = 0; i < AUDIO_PICTURE_URI_LENGTH; i++ )
      {
        gPicture_Uri[j][i] = 0;
      }
    }
    for( i = 0; i < AUDIO_FILENAME_SIZE; i++ ) //clear "filename"
    {
        gPicture_CSV_filename[i] = 0;
    }
    for( j = 0; j < AUDIO_PICTURE_ENTRIES; j++ ) //clear "buffer"
    {
      buffer_string[j]    = 0;
      buffer_byte[j]      = 0;
      for( i = 0; i < AUDIO_TEXTLENGTH; i++ ) //clear help value
      {
        Picture_Pos_string[j][i]       = 0;
      }
    }
    for( i = 0; i < AUDIO_BUFFERSIZE; i++ )
    {
      Path_CSV[i] = 0;
    }

    getvalue( env_AudioSD_Pic_CSV_Path,Path_CSV);
    i = 0; j = 0; PictureLine = 0; current_CSV_line = 0; //reset values
    //       write( "complete path *.csv: %s", Path_CSV); //debug
    i = 0;

    while ( Path_CSV[i] != 0 ) //scan "path"
    {
      if( Path_CSV[i] == 0x5C) //count "/" to seperate later "path" & "filename"
      {
        count1++;
      }
      //write( "Path[%d] of *.csv: %x",i, Path_CSV[i] ); //debug
      i++;
    }
    i = 0; j = 0; //reset values

    while ( Path_CSV[i] != 0 ) //seperate "path" and "filename"
    {
      if( count2==count1 ) //get filename after last "\"
      {
        gPicture_CSV_filename[j] = Path_CSV[i];
        j++;
        Path_CSV[i] = 0;
      }
      if( Path_CSV[i] == 0x5C) //count "\" to get filename after last "\"
      {
        count2++;
      }
      i++;
    }
    if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "path of *.csv: %s", Path_CSV);        //output file path
    if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "filename of *.csv: '%s'", gPicture_CSV_filename );  //output filename
    putvalue( env_AudioSD_Pic_CSV_Current, gPicture_CSV_filename );
    setFilePath( Path_CSV, 0 ); //set path for *.csv file

    CSVfileHandle =openFileRead( gPicture_CSV_filename,1 ); //open *.csv ( binary-mode ->get the ASCII/UTF-8 code )
    if( CSVfileHandle!= 0 ) //*.csv file access successful
    {
      if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Dateizugriff auf '%s' erfolgreich", gPicture_CSV_filename );    //output result
      putValue( env_AudioSD_Pic_CSV_Result, "successful" );

      Num_of_csv_byte = fileGetBinaryBlock ( buffer_byte, elcount( buffer_byte ), CSVfileHandle );//get data from *.csv and store the total number of byte in *.csv-file
      for( i = 0; i <Num_of_csv_byte; i++ ) //copy data into "Picture"
      {
        if( buffer_byte[i] != 0x3B) //read data if no ";" is detected
        {
          if( buffer_byte[i] == 0x0D && buffer_byte[i + 1] == 0x0A) //nextline in *.csv (next "record element" in Picture ) -> "LF" and "CR" detected -> copy ( transform string -> long ) data from help values in global values
          {
            if( current_CSV_line> 0 && PictureLine < AUDIO_PICTURE_ENTRIES) //ignore first line in *.csv file
            {
              if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "" );
              if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "*******Element %d*******",PictureLine );

              //transform 'string' to 'long' for "POS", "PictureType", "Handle" and "TcpPort"
              gPicture_Pos[PictureLine]     =atol( Picture_Pos_string[PictureLine] );
              gPicture_Type[PictureLine]    =atol( Picture_Type_string[PictureLine] );
              gPicture_Handle[PictureLine]  =atol( Picture_Handle_string[PictureLine] );
              gPicture_TcpPort[PictureLine] =atol( Picture_TcpPort_string[PictureLine] );
              //gPicture_IpAddress[VideoStreamsLine] = Picture_IpAddress_string[PictureLine];
              //gPicture_Uri[VideoStreamsLine]      = Picture_Uri_string[PictureLine];

              writelineEx( gBAP_Trace, 0, "*******Element %d*******",  PictureLine );
              writelineEx( gBAP_Trace, 0, "Pos[%d]: 0x%x",             PictureLine, gPicture_Pos[PictureLine] );
              writelineEx( gBAP_Trace, 0, "PictureType[%d]: 0x%x",     PictureLine, gPicture_Type[PictureLine] );
              writelineEx( gBAP_Trace, 0, "Handle[%d]: 0x%x",          PictureLine, gPicture_Handle[PictureLine] );
              writelineEx( gBAP_Trace, 0, "IpAddress[%d]: %s",         PictureLine, gPicture_IpAddress[PictureLine] );
              writelineEx( gBAP_Trace, 0, "TcpPort[%d]: 0x%x",         PictureLine, gPicture_TcpPort[PictureLine] );
              writelineEx( gBAP_Trace, 0, "Uri[%d]: %s",               PictureLine, gPicture_Uri[PictureLine] );

              gPicture_ListEntryValidInformation[PictureLine]  = TRUE;

              PictureLine++; // -> next line in *.csv (next record element )
            }
            current_CSV_line++; //next line in *.csv file
            element = 0; //start at 'POS' ( first record element of "array data" )
            j = 0; //reset value
          }
          else if( current_CSV_line> 0 && PictureLine < AUDIO_PICTURE_ENTRIES) //copy data from "buffer_byte" ( data from *.csv file ) in help values and "name" until end of line is not detected
          {
            switch(  element )
            {
                case 0: //POS
                        Picture_Pos_string[PictureLine][j] =buffer_byte[i];
                        j++;
                break;
                case 1: //PictureType
                        Picture_Type_string[PictureLine][j] =buffer_byte[i];
                        j++;
                break;
                case 2: //Handle
                        Picture_Handle_string[PictureLine][j] =buffer_byte[i];
                        j++;
                break;
                case 3: //IP Address
                        gPicture_IpAddress[PictureLine][j] =buffer_byte[i];
                        j++;
                break;
                case 4: //TCP Port
                        Picture_TcpPort_string[PictureLine][j] =buffer_byte[i];
                        j++;
                break;
                case 5: //URI
                        gPicture_Uri[PictureLine][j] =buffer_byte[i];
                        j++;
                break;
                default:
                break;
            }
          }
        }
        else  // ";" is detected ->next record element of "array data"
        {
          element++;
          j = 0; //reset value
        }
      }
      gPicture_TotalNumListElements = gPictureLine_sum = PictureLine; //get "total number of list elements"
      putvalue( env_AudioSD_Pic_TNLE, gPicture_TotalNumListElements );
      if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "" );
      if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Anzahl der Listenelemente: %d", gPictureLine_sum); //output total number of list elements
      if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "" );
            if( fileClose ( CSVfileHandle ) != 0 ) //close *.csv file
                { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Datei '%s' geschlossen", gPicture_CSV_filename ); } //output result }
            else
                { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Fehler beim Schlieen der Datei '%s'", gPicture_CSV_filename ); }//output result }
        }
        else //*.csv file access not successful
        {
            writelineEx( gBAP_Trace, 0, "Fehler beim Dateizugriff auf '%s'", gPicture_CSV_filename ); //output result
            putValue( env_AudioSD_Pic_CSV_Result, "not successful" ); //output result
        }
    }
}

void FavoriteList_Indication( dword Indication_array [], int datalength )
{
    byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements;
    int i = 0, transSuppression;
    byte audioListDelFlg;
    word validStartElem_plusElem;
    byte fl_InValidStartElemFlg;

    // Init local variables.
    mode = 0;
    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    recordaddress = 0;
    requested_startelement = 0;
    startelement = 0;
    elements = 0;
    valid_startelement = 0xff;
    i = 0;
    valid_elements = 0;
    transSuppression = getvalue( env_AudioSD_FL_StatusOFF );


    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
        //MR 63336
        if( getvalue( env_AudioSD_FL_Error_Status ) )
        {
          FavoriteList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue( env_AudioSD_FL_ErrorCode ) );
        }
        else if( getvalue( env_AudioSD_FL_Timeout ) == TRUE )
        {
        /* NOP */
        }
        else
        {
            //getData
            gFL_ASGID = ( gBAP_Indication[3] & 0xF0 ) / 0x10;
            gFL_TAID = gBAP_Indication[3] & 0x0F;

            //decode BAP-ArrayHeader
            mode = ( gBAP_Indication[4] & 0xF0 ) / 0x10;

            // decode "mode -byte"
            shift = mode & 0x01;
            direction = ( mode & 0x02 ) / 0x02;
            transmitpos = ( mode & 0x04 ) / 0x04;
            indexsize = ( mode & 0x08 ) / 0x08;

            recordaddress = gBAP_Indication[4] & 0x0F;
            if( indexsize )
            {
                startelement = gBAP_Indication[5];
                startelement += gBAP_Indication[6] * 0x100;
                elements = gBAP_Indication[7];
                elements += gBAP_Indication[8] * 0x100;
            }
            else
            {
                startelement = gBAP_Indication[5];
                elements = gBAP_Indication[6];
            }

            requested_startelement = startelement;

            transmitpos = TRUE; //Position must always be sent in the case of *.GetArray.


            /***Startelement = 0***/
            if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
            {
                if( FORWARD == direction )  //forward-start
                {
                    valid_startelement = 0;

                    if( gFavoriteList_TotalNumListElements <= elements ) //1. more elements requested, than in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < gFavoriteList_TotalNumListElements; i++ )
                            {
                                if( 0 != gFL_ListEntryValidInformation[i] )    //if there is an valid element
                                {
                                    if( gFL_Pos[i] > 0xFF ) //check indexsize
                                        indexsize = TRUE;

                                    valid_elements++;                               //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = gFL_CSVtotalElem;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement = startelement;
                            valid_elements = 0;
                        }
                    }
                    else    //2. number of requested elements < elements in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < elements; i++ )
                            {
                                if( 0 != gFL_ListEntryValidInformation[i] )    //if there is an valid element
                                {
                                    if( gFL_Pos[i] > 0xFF ) //check indexsize
                                        indexsize = TRUE;

                                    valid_elements++;                               //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = gFL_CSVtotalElem;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement = startelement;
                            valid_elements = 0;
                        }
                    }
                }                                                               //forward ends

                else if( BACKWARD == direction && TRUE == shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                {
                    //searching for valid startelement
                    for( i = ( gFL_CSVtotalElem - 1 ); i >= 0; i--)
                    {
                        if( 0 != gFL_ListEntryValidInformation[i] )        //found valid startelement
                        {
                            valid_startelement = i;
                            i = 0;
                        }
                    }

                    //searching for valid elements
                    if( 0xFF == valid_startelement )                             //Startelement-ID doesn't exist in SMSReceived-array
                    {
                        valid_startelement = startelement;
                        valid_elements = 0;
                    }
                    else if( 0 == valid_startelement )
                        valid_elements = 1;                                       //only 1 element because valid startelement is on position 0

                    else if( elements > (valid_startelement + 1 ) )                   //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i = valid_startelement; i >= 0; i--)
                        {
                            if( 0 != gFL_ListEntryValidInformation[i] )    //if there is an valid element
                            {
                                if( gFL_Pos[i] > 0xFF ) //check indexsize
                                    indexsize = TRUE;

                                valid_elements++;                               //increment elements
                            }
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i = valid_startelement; i > (valid_startelement - elements ); i--)
                        {
                            if( 0 != gFL_ListEntryValidInformation[i] )    //if there is an valid element
                            {
                                if( gFL_Pos[i] > 0xFF ) //check indexsize
                                    indexsize = TRUE;

                                valid_elements++;                               //increment elements
                            }
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                               //backward-end
            }                                                                   //startelement == 0 -end

            /***Startelement!= 0***/
            else                                                                //searching for Startelement-ID
            {
				fl_InValidStartElemFlg = 0;
				for( i = 0; i < gFL_CSVtotalElem; i++ )
				{
					if( startelement == gFavoriteList_Pos_insDel[i][0] )
					{
						//check if Start is deleted then reply with 0 elements
						if( gFavoriteList_Pos_insDel[i][1] == 0x01 )
						{
							valid_startelement  = startelement;
							valid_elements      = 0;
							fl_InValidStartElemFlg = 1;
						}
					}
				}
				if( fl_InValidStartElemFlg == 0x00 )
				{
					//searching for valid startelement
					for( i = 0; i < gFL_CSVtotalElem; i++ )
					{
						if( gFL_Pos[i] == startelement )                       //found a valid element
						{
							if( shift == TRUE )                                          //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
							{
								if( i != 0 || BACKWARD != direction )                        //if valid_startelement is not the first array element or direction is not backwards
									valid_startelement = i + 1 - 2 * direction;

								else if( i == 0 && BACKWARD == direction )
									valid_startelement = gFL_sum - 1;     //valid element is last element in Array

								else if( i == 0 && FORWARD == direction )
									valid_startelement = 0;                          //valid element is first element in Array
							}

							else
								valid_startelement = i;                              //found element is valid_startelement

							i = gFL_CSVtotalElem;
						}
					}

					if( 0xFF == valid_startelement )                                     //Startelement-ID doesn't exist in array
					{
						valid_startelement = startelement;
						valid_elements = 0;
					}
					else                                                                //found valid entry for startelement in array
					{
						//verify number of valid elements
						if( BACKWARD == direction )                                          //backward-start
						{
							if( valid_startelement == 0 )
							{                                   
							    audioListDelFlg = 0x00;
							    audioListDelFlg = audioList_deleteCheck( gFL_Pos[0], gFavoriteList_Pos_insDel, gFL_CSVtotalElem );

								if( audioListDelFlg == 0x00 )                
									valid_elements = 1;
							}
							else if( elements > (valid_startelement + 1 ) )                   //not enougth array-elements available, because array endet at array-position 0
							{
								for( i = valid_startelement; i >= 0; i--)
								{
									if( 0 != gFL_ListEntryValidInformation[i] )    //if there is an valid element
									{
										if( gFL_Pos[i] > 0xFF ) //check indexsize
											indexsize = TRUE;

										valid_elements++;                               //increment elements
									}
									else                                                //no valid element, loop finished
										i = 0;
								}
							}
							else                                                        //enougth array-elements available
							{
								for( i = valid_startelement; i > (valid_startelement - elements ); i--)
								{
									if( 0 != gFL_ListEntryValidInformation[i] )    //if there is an valid element
									{
										if( gFL_Pos[i] > 0xFF ) //check indexsize
											indexsize = TRUE;

										valid_elements++;                               //increment elements
									}
									else                                                //no valid element, loop finished
										i = 0;
								}
							}
						}                                                               //backward-end
						else                                                            //forward-start
						{
							if( (valid_startelement + elements ) >= gFavoriteList_TotalNumListElements)
							{
								for( i = valid_startelement; i < gFL_CSVtotalElem; i++ )
								{
									if( 0 != gFL_Pos[i] )                      //if there is an valid element
									{
										if( gFL_Pos[i] > 0xFF ) //check indexsize
											indexsize = TRUE;

										audioListDelFlg = 0x00;
										audioListDelFlg = audioList_deleteCheck( gFL_Pos[i], gFavoriteList_Pos_insDel, gFL_CSVtotalElem );

									    if( audioListDelFlg == 0x00 && valid_elements < elements )
											valid_elements++;  
									}
									else                                                //no valid element, loop finished
										i = gFL_CSVtotalElem;
								}
							}
							else
							{
							    validStartElem_plusElem = valid_startelement + elements;
								for( i = valid_startelement; i < validStartElem_plusElem; i++ )
								{
									if( 0 != gFL_Pos[i] )                          //if there is an valid element
									{
										if( gFL_Pos[i] > 0xFF ) //check indexsize
											indexsize = TRUE;

										audioListDelFlg = 0x00;
									    audioListDelFlg = audioList_deleteCheck( gFL_Pos[i], gFavoriteList_Pos_insDel, gFL_CSVtotalElem);

										if( audioListDelFlg == 0x00 )
										{
											if( valid_elements < elements )      //guard check if valid elements < elements
												valid_elements++;                   //increment elements
										}
										else
										{
											if( valid_elements < elements )
												validStartElem_plusElem++;      //adjust the loop boundary based on number of deleted elements
										}
									}
									else                                                //no valid element, loop finished
										i = gFL_CSVtotalElem;
								}
							}
						}
					}
                }
            }

            if( (valid_startelement > 0xFF ) || ( requested_startelement > 0xFF ) ) //check indexsize
                indexsize = TRUE;

            mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + indexsize * 0x08;

            //send StatusArray
            if( !transSuppression )
                FavoriteList_Request( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );

            //Panel
            putvalue( env_AudioSD_FL_AsgId, gFL_ASGID);
            putvalue( env_AudioSD_FL_TAID, gFL_TAID);
            }
            break;

        case Error_IND:
            writelineEx( gError_Trace, 0, "FSG_AudioSD FavoriteList_Indication: received error, errorcode:0x%x", Indication_array[3] );
            break;

        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD FavoriteList_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

void FavoriteList_Request( byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word FavoriteListLine;
	byte audioListDelFlg;

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    FavoriteListLine = 0;
    current_element = 0;
    Offset = 0;

    // decode "mode -byte"
    shift = mode & 0x01;
    direction = ( mode & 0x02 ) / 0x02;
    transmitpos = ( mode & 0x04 ) / 0x04;
    indexsize = ( mode & 0x08 ) / 0x08;
	
	if( elements == 0 )
	{
	    transmitpos = 0;
		mode &= 0xFB;
	}

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_FavoriteList;    //Fct.-ID
    requestarray[2] = request;                  //request type
    Offset = 3;

    switch( request )
    {
        case Changed_REQ:
            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            FavoriteListLine = startelement;

            if( getvalue( env_AudioSD_MB_CA_switch ) )
            {
                //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                        while ( current_element < elements )
                        {
                            if( FavoriteListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD FavoriteList_Request: invalid FavoriteListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gFL_Pos[FavoriteListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gFL_Pos[FavoriteListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gFL_Pos[FavoriteListLine];
                                        Offset++;
                                    }
                                }

                                //PresentIndex
                                requestarray[Offset] = gFL_PresentIndex[FavoriteListLine];
                                Offset++;

                                //Waveband
                                requestarray[Offset] = gFL_Waveband[FavoriteListLine];
                                Offset++;

                                //Attributes
                                requestarray[Offset] = ( gFL_Attributes[FavoriteListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gFL_Attributes[FavoriteListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gFL_Name[FavoriteListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gFL_Name[FavoriteListLine] ); i++ )
                                {
                                    requestarray[Offset] = gFL_Name[FavoriteListLine][i];
                                    Offset++;
                                }

                                //Frequenz
                                requestarray[Offset] = strlen( gFL_Frequenz[FavoriteListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gFL_Frequenz[FavoriteListLine] ); i++ )
                                {
                                    requestarray[Offset] = gFL_Frequenz[FavoriteListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            FavoriteListLine = FavoriteList_nextvalidLine( FavoriteListLine, direction );

                        }//end while
                        break;

                    case 1: //Presentindex, Waveband,Attributes,Name,Frequency
                        while ( current_element < elements )
                        {
                            if( FavoriteListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD FavoriteList_Request: invalid FavoriteListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
							/***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gFL_Pos[FavoriteListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gFL_Pos[FavoriteListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gFL_Pos[FavoriteListLine];
                                        Offset++;
                                    }
                                }
								
                                /***Array Data***/
                                //PresentIndex
                                requestarray[Offset] = gFL_PresentIndex[FavoriteListLine];
                                Offset++;

                                //Waveband
                                requestarray[Offset] = gFL_Waveband[FavoriteListLine];
                                Offset++;

                                //Attributes
                                requestarray[Offset] = ( gFL_Attributes[FavoriteListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gFL_Attributes[FavoriteListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gFL_Name[FavoriteListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gFL_Name[FavoriteListLine] ); i++ )
                                {
                                    requestarray[Offset] = gFL_Name[FavoriteListLine][i];
                                    Offset++;
                                }

                                //Frequenz
                                requestarray[Offset] = strlen( gFL_Frequenz[FavoriteListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gFL_Frequenz[FavoriteListLine] ); i++ )
                                {
                                    requestarray[Offset] = gFL_Frequenz[FavoriteListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            FavoriteListLine = FavoriteList_nextvalidLine( FavoriteListLine, direction );

                        }//end while
                        break;

                    case 2: //PresentIndex,Waveband,Name
                        while ( current_element < elements )
                        {
                            if( FavoriteListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD FavoriteList_Request: invalid FavoriteListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
							/***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gFL_Pos[FavoriteListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gFL_Pos[FavoriteListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gFL_Pos[FavoriteListLine];
                                        Offset++;
                                    }
                                }
								
                                /***Array Data***/
                                //PresentIndex
                                requestarray[Offset] = gFL_PresentIndex[FavoriteListLine];
                                Offset++;

                                //Waveband
                                requestarray[Offset] = gFL_Waveband[FavoriteListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gFL_Name[FavoriteListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gFL_Name[FavoriteListLine] ); i++ )
                                {
                                    requestarray[Offset] = gFL_Name[FavoriteListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            FavoriteListLine = FavoriteList_nextvalidLine( FavoriteListLine, direction );

                        }//end while
                        break;
                    case 3://PresentIndex,Name,Frequency
                        while ( current_element < elements )
                        {
                            if( FavoriteListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD FavoriteList_Request: invalid FavoriteListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
							/***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gFL_Pos[FavoriteListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gFL_Pos[FavoriteListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gFL_Pos[FavoriteListLine];
                                        Offset++;
                                    }
                                }
                                /***Array Data***/
                                //PresentIndex
                                requestarray[Offset] = gFL_PresentIndex[FavoriteListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gFL_Name[FavoriteListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gFL_Name[FavoriteListLine] ); i++ )
                                {
                                    requestarray[Offset] = gFL_Name[FavoriteListLine][i];
                                    Offset++;
                                }

                                //Frequenz
                                requestarray[Offset] = strlen( gFL_Frequenz[FavoriteListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gFL_Frequenz[FavoriteListLine] ); i++ )
                                {
                                    requestarray[Offset] = gFL_Frequenz[FavoriteListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            FavoriteListLine = FavoriteList_nextvalidLine( FavoriteListLine, direction );

                        }//end while
                        break;
                    case 15: //Pos
                        while ( current_element < elements )
                        {
                            if( FavoriteListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD FavoriteList_Request: invalid FavoriteListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gFL_Pos[FavoriteListLine] & 0x00FF );
                                        Offset++;
                                        requestarray[Offset] = (( gFL_Pos[FavoriteListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gFL_Pos[FavoriteListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            FavoriteListLine = FavoriteList_nextvalidLine( FavoriteListLine, direction );

                        }//end while
                        break;
                    default:
                        write( "AudioSD FavoriteList_Request: invalid recordaddress %d", recordaddress );
                        break;
                } //end switch "recordaddress"
            // end 'ArrayData'
            }

            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

            break; //end Changed_REQ

        case Data_REQ:
            //VAGH-10511
            ASGID = gFL_ASGID;
            TAID = gFL_TAID;
            if( getvalue( env_AudioSD_FL_ASGID_Error ) != FALSE )
            {
                ASGID += 0x02;
            }
            if( getvalue( env_AudioSD_FL_TAID_Error ) != FALSE )
            {
                TAID += 0x02;
            }
            requestarray[Offset] = (( ASGID * 0x10 ) & 0xF0 ) + ( TAID & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = gFL_TNLE & 0xff;
                Offset++;
                requestarray[Offset] = ( gFL_TNLE & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = gFL_TNLE & 0xff;
                Offset++;
            }
            //requestarray[Offset] = gFL_ALP & 0xff;
            //Offset++;
            //requestarray[Offset] = ( gFL_ALP & 0xff00 ) / 0x100;
            //Offset++;


            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            FavoriteListLine = startelement;

            //copy data
            switch( recordaddress )
            {
                case 0: //complete record
                    while ( current_element < elements )
                    {
                        if( FavoriteListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD FavoriteList_Request: invalid FavoriteListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if( transmitpos ) // Pos  ->Array position transmitted
                            {
								//Updating the status array excluding the deleted elements
							    audioListDelFlg = 0x00;
							    audioListDelFlg = audioList_deleteCheck( gFL_Pos[FavoriteListLine], gFavoriteList_Pos_insDel, gFL_CSVtotalElem);
								
								if ( audioListDelFlg == 0x0 )
								{
									if( indexsize )
									{
										requestarray[Offset] = ( gFL_Pos[FavoriteListLine] & 0xFF );
										Offset++;
										requestarray[Offset] = (( gFL_Pos[FavoriteListLine] & 0xFF00 ) / 0x100 );
										Offset++;
									}
									else
									{
										requestarray[Offset] = gFL_Pos[FavoriteListLine];
										Offset++;
									}
								}
                            }
							
							if( audioListDelFlg == 0x00 )
							{
								//PresentIndex
								requestarray[Offset] = gFL_PresentIndex[FavoriteListLine];
								Offset++;

								//Waveband
								requestarray[Offset] = gFL_Waveband[FavoriteListLine];
								Offset++;

								//Attributes
								requestarray[Offset] = ( gFL_Attributes[FavoriteListLine] & 0x00ff );
								Offset++;
								requestarray[Offset] = ( gFL_Attributes[FavoriteListLine] & 0xFF00 ) / 0x100;
								Offset++;

								//Name
								requestarray[Offset] = strlen( gFL_Name[FavoriteListLine] );
								Offset++;
								for( i = 0; i < strlen( gFL_Name[FavoriteListLine] ); i++ )
								{
									requestarray[Offset] = gFL_Name[FavoriteListLine][i];
									Offset++;
								}

								//Frequenz
								requestarray[Offset] = strlen( gFL_Frequenz[FavoriteListLine] );
								Offset++;
								for( i = 0; i < strlen( gFL_Frequenz[FavoriteListLine] ); i++ )
								{
									requestarray[Offset] = gFL_Frequenz[FavoriteListLine][i];
									Offset++;
								}
							}
                        }
						if( audioListDelFlg == 0x00 )
							current_element++;
                        FavoriteListLine = FavoriteList_nextvalidLine( FavoriteListLine, direction );

                    }//end while
                    break;

                case 1: //Presentindex, Waveband,Attributes,Name,Frequency
                    while ( current_element < elements )
                    {
                        if( FavoriteListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD FavoriteList_Request: invalid FavoriteListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
							if( transmitpos ) // Pos  ->Array position transmitted
							{
								if( indexsize )
								{
									requestarray[Offset] = ( gFL_Pos[FavoriteListLine] & 0xFF );
									Offset++;
									requestarray[Offset] = (( gFL_Pos[FavoriteListLine] & 0xFF00 ) / 0x100 );
									Offset++;
								}
								else
								{
									requestarray[Offset] = gFL_Pos[FavoriteListLine];
									Offset++;
								}
							}
                            /***Array Data***/
                            //PresentIndex
                            requestarray[Offset] = gFL_PresentIndex[FavoriteListLine];
                            Offset++;

                            //Waveband
                            requestarray[Offset] = gFL_Waveband[FavoriteListLine];
                            Offset++;

                            //Attributes
                            requestarray[Offset] = ( gFL_Attributes[FavoriteListLine] & 0x00ff );
                            Offset++;
                            requestarray[Offset] = ( gFL_Attributes[FavoriteListLine] & 0xFF00 ) / 0x100;
                            Offset++;

                            //Name
                            requestarray[Offset] = strlen( gFL_Name[FavoriteListLine] );
                            Offset++;
                            for( i = 0; i < strlen( gFL_Name[FavoriteListLine] ); i++ )
                            {
                                requestarray[Offset] = gFL_Name[FavoriteListLine][i];
                                Offset++;
                            }

                            //Frequenz
                            requestarray[Offset] = strlen( gFL_Frequenz[FavoriteListLine] );
                            Offset++;
                            for( i = 0; i < strlen( gFL_Frequenz[FavoriteListLine] ); i++ )
                            {
                                requestarray[Offset] = gFL_Frequenz[FavoriteListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        FavoriteListLine = FavoriteList_nextvalidLine( FavoriteListLine, direction );

                    }//end while
                    break;

                case 2: //PresentIndex,Waveband,Name
                    while ( current_element < elements )
                    {
                        if( FavoriteListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD FavoriteList_Request: invalid FavoriteListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            //PresentIndex
                            requestarray[Offset] = gFL_PresentIndex[FavoriteListLine];
                            Offset++;

                            //Waveband
                            requestarray[Offset] = gFL_Waveband[FavoriteListLine];
                            Offset++;

                            //Name
                            requestarray[Offset] = strlen( gFL_Name[FavoriteListLine] );
                            Offset++;
                            for( i = 0; i < strlen( gFL_Name[FavoriteListLine] ); i++ )
                            {
                                requestarray[Offset] = gFL_Name[FavoriteListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        FavoriteListLine = FavoriteList_nextvalidLine( FavoriteListLine, direction );

                    }//end while
                    break;
                case 3://PresentIndex,Name,Frequency
                    while ( current_element < elements )
                    {
                        if( FavoriteListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD FavoriteList_Request: invalid FavoriteListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
							
                            /***Array Data***/
                            //PresentIndex
                            requestarray[Offset] = gFL_PresentIndex[FavoriteListLine];
                            Offset++;

                            //Name
                            requestarray[Offset] = strlen( gFL_Name[FavoriteListLine] );
                            Offset++;
                            for( i = 0; i < strlen( gFL_Name[FavoriteListLine] ); i++ )
                            {
                                requestarray[Offset] = gFL_Name[FavoriteListLine][i];
                                Offset++;
                            }

                            //Frequenz
                            requestarray[Offset] = strlen( gFL_Frequenz[FavoriteListLine] );
                            Offset++;
                            for( i = 0; i < strlen( gFL_Frequenz[FavoriteListLine] ); i++ )
                            {
                                requestarray[Offset] = gFL_Frequenz[FavoriteListLine][i];
                                Offset++;
                            }
                        }
                        current_element++;
                        FavoriteListLine = FavoriteList_nextvalidLine( FavoriteListLine, direction );

                    }//end while
                    break;
                case 15: //Pos
                    while ( current_element < elements )
                    {
                        if( FavoriteListLine == 0xFF ) //Invalid "list entry"
                        {
                            write( "AudioSD FavoriteList_Request: invalid FavoriteListLine" );
                            current_element = elements;
                        }
                        else //"list entry" valid
                        {
                            /***Array Data***/
                            if( transmitpos ) // Pos  ->Array position transmitted
                            {
								// Check if element is deleted
								audioListDelFlg = 0x00;
								audioListDelFlg = audioList_deleteCheck( gFL_Pos[FavoriteListLine], gFavoriteList_Pos_insDel, gFL_CSVtotalElem);
								if ( audioListDelFlg == 0x0 )
								{
									if( indexsize )
									{
										requestarray[Offset] = ( gFL_Pos[FavoriteListLine] & 0x00FF );
										Offset++;
										requestarray[Offset] = (( gFL_Pos[FavoriteListLine] & 0xFF00 ) / 0x100 );
										Offset++;
									}
									else
									{
										requestarray[Offset] = gFL_Pos[FavoriteListLine];
										Offset++;
									}
								}
                            }
                        }
						if ( audioListDelFlg == 0x0 )
							current_element++;
                        FavoriteListLine = FavoriteList_nextvalidLine( FavoriteListLine, direction );

                    }//end while
                    break;
                default:
                    write( "AudioSD FavoriteList_Request: invalid recordaddress %d", recordaddress );
                    break;
            } //end switch "recordaddress"
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            break; //end Data_REQ

          case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break; //end Error_REQ

    } //end switch "request"
}

void FavoriteList_init_CSV() //Byte & file selection
{
    dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, current_CSV_line = 0, count1 = 0, count2 = 0;
    char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
    byte FavoriteListLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
    char FavoriteList_Pos_string[AUDIO_FAVORITELIST_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8 ) code in the *.csv
    char FavoriteList_PIndex_string[AUDIO_FAVORITELIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"PresentIndex" is stored in the ASCII(UTF-8 ) code in the *.csv
    char FavoriteList_Name_string[AUDIO_FAVORITELIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Name" is stored in the ASCII(UTF-8 ) code in the *.csv
    char FavoriteList_Frequenz_string[AUDIO_FAVORITELIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Frequenz" is stored in the ASCII(UTF-8 ) code in the *.csv
    char FavoriteList_Waveband_string[AUDIO_FAVORITELIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Waveband" is stored in the ASCII(UTF-8 ) code in the *.csv
    char FavoriteList_Attributes_string[AUDIO_FAVORITELIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Attributes" is stored in the ASCII(UTF-8 ) code in the *.csv

    if( getvalue( env_AudioSD_FL_CSV_Default ) == AUDIO_EXTERNAL_LIST ) //output data in write window "FSGFavoriteList"
    {
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "*******External FavoriteList*******" );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "" );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "**********************Start load new FavoriteList**********************" );

    //clear
    for( j = 0; j < AUDIO_FAVORITELIST_ENTRIES; j++ )
    {
        gFL_Pos[j] = 0;
      gFL_PresentIndex[j]  = 0;
        gFL_Waveband[j] = 0;

      gFL_Attributes[j] = 0;
      gFL_Attribute_IBOC_Bit0[j] = 0;
      gFL_Attribute_DABsec_Bit1[j] = 0;
      gFL_Attribute_DABprim_Bit2[j] = 0;
      gFL_Attribute_OnlineRadioSec_Bit3[j] = 0;
      gFL_Attribute_OnlineRadioPrim_Bit4[j] = 0;
      gFL_Attribute_TP_Bit5[j] = 0;
      gFL_Attribute_TMC_Bit6[j] = 0;
      gFL_Attribute_SDARS_Bit7[j] = 0;
      gFL_Attribute_StationSelc_Bit8[j] = 0;
      gFL_Attribute_mute_Bit9[j] = 0;
      gFL_Attribute_StationLinkedORadio_Bit10[j] = 0;
      gFL_Attribute_StationLinkedFM_Bit11[j] = 0;

      for( i = 0; i < AUDIO_FAVORITE_NAME_LENGTH; i++ )
        gFL_Name[j][i] = 0;

      for( i = 0; i < AUDIO_FAVORITE_FREQUENZ_LENGTH; i++ )
        gFL_Frequenz[j][i] = 0;
    }

    for( i = 0; i < AUDIO_FILENAME_SIZE; i++ ) //clear "filename"
          gFL_CSV_filename[i] = 0;

    for( j = 0; j < AUDIO_FAVORITELIST_ENTRIES; j++ ) //clear "buffer"
    {
      buffer_string[j]    = 0;
      buffer_byte[j]      = 0;

      for( i = 0; i < AUDIO_TEXTLENGTH; i++ ) //clear help value
      {
        FavoriteList_Pos_string[j][i] = 0;
        FavoriteList_Name_string[j][i] = 0;
        FavoriteList_Frequenz_string[j][i] = 0;
      }
    }

    i = 0; j = 0; FavoriteListLine = 0; current_CSV_line = 0; //reset values

    getvalue( env_AudioSD_FL_CSV_Path, Path_CSV); //get filename & path of *.csv-file from Panel

    //write( "complete path *.csv: %s", Path_CSV); //debug

    i = 0;

    while ( Path_CSV[i] != 0 ) //scan "path"
    {
        if( Path_CSV[i] == 0x5C) //count "/" to seperate later "path" & "filename"
            count1++;

        //write( "Path[%d] of *.csv: %x",i, Path_CSV[i] ); //debug
        i++;
    }

    i = 0; j = 0; //reset values

    while ( Path_CSV[i] != 0 ) //seperate "path" and "filename"
    {
        if( count2==count1 ) //get filename after last "\"
        {
            gFL_CSV_filename[j] = Path_CSV[i];
            j++;

            Path_CSV[i] = 0;
        }

        if( Path_CSV[i] == 0x5C) //count "\" to get filename after last "\"
            count2++;

        i++;
    }

        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "path of *.csv: %s", Path_CSV);        //output file path

        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "filename of *.csv: '%s'", gFL_CSV_filename );  //output filename

    putvalue( env_AudioSD_FL_CSV_Current, gFL_CSV_filename ); //output current loaded *.csv-file on panel

    setFilePath( Path_CSV, 0 ); //set path for *.csv file

    CSVfileHandle =openFileRead( gFL_CSV_filename,1 ); //open *.csv ( binary-mode ->get the ASCII/UTF-8 code )

    if( CSVfileHandle!= 0 ) //*.csv file access successful
    {
          if( boTraceStatus_ON == 0x0 ) writelineEx( gBAP_Trace, 0, "Dateizugriff auf '%s' erfolgreich", gFL_CSV_filename );    //output result

      putvalue( env_AudioSD_FL_CSV_Result, "successful" );   //output result on panel

      Num_of_csv_byte = fileGetBinaryBlock( buffer_byte, elcount( buffer_byte ), CSVfileHandle );//get data from *.csv and store the total number of byte in *.csv-file

      for( i = 0; i <Num_of_csv_byte; i++ ) //copy data into "FavoriteList"
      {
        if( buffer_byte[i] != 0x3B) //read data if no ";" is detected
        {
          if( buffer_byte[i] == 0x0D && buffer_byte[i + 1] == 0x0A) //nextline in *.csv (next "record element" in LastStationList ) -> "LF" and "CR" detected -> copy ( transform string -> long ) data from help values in global values
          {
            if( current_CSV_line> 0 && FavoriteListLine < AUDIO_FAVORITELIST_ENTRIES) //ignore first line in *.csv file
            {
                  if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "" );
                  if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "*******Element %d*******", FavoriteListLine );

              //transform 'string' to 'long'
              gFL_Pos[FavoriteListLine] = atol( FavoriteList_Pos_string[FavoriteListLine] );
              gFL_PresentIndex[FavoriteListLine] = atol( FavoriteList_PIndex_string[FavoriteListLine] );
              gFL_Waveband[FavoriteListLine] = atol( FavoriteList_Waveband_string[FavoriteListLine] );
              gFL_Attributes[FavoriteListLine] = atol( FavoriteList_Attributes_string[FavoriteListLine] );

              if( boTraceStatus_ON ) 
              {
              writelineEx( gBAP_Trace, 0, "Pos[%d]: 0x%x", FavoriteListLine, gFL_Pos[FavoriteListLine] );
              writelineEx( gBAP_Trace, 0, "Presentindex[%d]: 0x%x", FavoriteListLine, gFL_PresentIndex[FavoriteListLine] );

              if( gFL_Waveband[FavoriteListLine] < 0xF )
                  writelineEx( gBAP_Trace, 0, "Waveband -> '%s'", gFL_Waveband_s[gFL_Waveband[FavoriteListLine]] );
              else
                  writelineEx( gBAP_Trace, 0, "Waveband -> '%s'", gstring_reserved );

              writelineEx( gBAP_Trace, 0, "Attributes[%d]: 0x%x", FavoriteListLine, gFL_Attributes[FavoriteListLine] );

              if( gFL_Attributes[FavoriteListLine] & 0x01 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit0[%d]: 'IBOC service'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit0[%d]: 'not an IBOC service'", FavoriteListLine );

              if( gFL_Attributes[FavoriteListLine] & 0x02 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit1[%d]: 'DAB secondary service'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit1[%d]: 'not a DAB secondary service'", FavoriteListLine );

              if( gFL_Attributes[FavoriteListLine] & 0x04 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit2[%d]: 'DAB primary service contains secondary service(s )'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit2[%d]: 'DAB primary service contains no secondary service(s ) / no DAB primary service'", FavoriteListLine );

              if( gFL_Attributes[FavoriteListLine] & 0x08 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit3[%d]: 'Online radio secondary service'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit3[%d]: 'not an online radio secondary service'", FavoriteListLine );

              if( gFL_Attributes[FavoriteListLine] & 0x10 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit4[%d]: 'Online radio primary service contains secondary service(s )'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit4[%d]: 'Online radio primary service contains no secondary service(s ) / no online radio primary service'", FavoriteListLine );

              if( gFL_Attributes[FavoriteListLine] & 0x20 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit5[%d]: 'TP available/supported by station'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit5[%d]: 'TP not available/not supported by station'", FavoriteListLine );

              if( gFL_Attributes[FavoriteListLine] & 0x40 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit6[%d]: 'TMC available/supported by station'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit6[%d]: 'TMC not supported/not available by station'", FavoriteListLine );

              if( gFL_Attributes[FavoriteListLine] & 0x80 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit7[%d]: 'SDARS station subscribed or not an SDARS station'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit7[%d]: 'SDARS station not subscribed'", FavoriteListLine );

              if( gFL_Attributes[FavoriteListLine] & 0x100 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit8[%d]: 'Station not selectable'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit8[%d]: 'Station selectable'", FavoriteListLine );

              if( gFL_Attributes[FavoriteListLine] & 0x200 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit9[%d]: 'muting / low signal'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit9[%d]: 'not muted / signal OK'", FavoriteListLine );

              if( gFL_Attributes[FavoriteListLine] & 0x400 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit10[%d]: 'Station linked to online radio'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit10[%d]: 'Station not linked to online radio'", FavoriteListLine );

              if( gFL_Attributes[FavoriteListLine] & 0x800 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit11[%d]: 'Station linked to FM'", FavoriteListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit11[%d]: 'Station not linked to FM'", FavoriteListLine );


              writelineEx( gBAP_Trace, 0, "Name[%d]: %s", FavoriteListLine, gFL_Name[FavoriteListLine] );
              writelineEx( gBAP_Trace, 0, "Frequenz[%d]: %s", FavoriteListLine, gFL_Frequenz[FavoriteListLine] );
              }
              gFL_ListEntryValidInformation[FavoriteListLine]  = TRUE;

              FavoriteListLine++; // -> next line in *.csv (next record element )
            }
            current_CSV_line++; //next line in *.csv file
            element = 0; //start at 'POS' ( first record element of "array data" )
            j = 0; //reset value
          }
          else if( current_CSV_line> 0 && FavoriteListLine < AUDIO_FAVORITELIST_ENTRIES) //copy data from "buffer_byte" ( data from *.csv file ) in help values and "name" until end of line is not detected
          {
            switch(  element )
            {
              case 0: //POS
                      FavoriteList_Pos_string[FavoriteListLine][j] =buffer_byte[i];
                      j++;
               break;

              case 1: //PresentIndex
                      FavoriteList_PIndex_string[FavoriteListLine][j] =buffer_byte[i];
                      j++;
               break;

              case 2: //Waveband
                      FavoriteList_Waveband_string[FavoriteListLine][j] =buffer_byte[i];
                      j++;
               break;

              case 3: //Attributes
                      FavoriteList_Attributes_string[FavoriteListLine][j] =buffer_byte[i];
                      j++;
               break;

              case 4: //Name
                      gFL_Name[FavoriteListLine][j] =buffer_byte[i];
                      j++;
               break;

              case 5: //Frequenz
                      gFL_Frequenz[FavoriteListLine][j] =buffer_byte[i];
                      j++;
               break;

              default:
               break;
            }
          }
        }
        else  // ";" is detected ->next record element of "array data"
        {
          element++;
          j = 0; //reset value
        }
      }
      gFL_TNLE = gFL_sum = gFL_CSVtotalElem = gFavoriteList_TotalNumListElements = FavoriteListLine; //get "total number of list elements"

      putvalue( env_AudioSD_FL_TNLE, gFL_TNLE );

      if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "" );

      if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Anzahl der Listenelemente: %d", gFL_sum); //output total number of list elements

      if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "" );

      if( fileClose( CSVfileHandle ) != 0 ) //close *.csv file
          { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Datei '%s' geschlossen", gFL_CSV_filename ); } //output result }
      else
          { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Fehler beim Schlieen der Datei '%s'", gFL_CSV_filename ); } //output result }
    }

    else //*.csv file access not successful
    {
      writelineEx( gBAP_Trace, 0, "Fehler beim Dateizugriff auf '%s'", gFL_CSV_filename ); //output result

      putvalue( env_AudioSD_FL_CSV_Result, "not successful" ); //output result
    }
	
	for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
	{
		gFavoriteList_Pos_insDel[i] [0] = 0;
		gFavoriteList_Pos_insDel[i] [1] = 0;
		gFavoriteList_Pos_insDel[i] [2] = 0;
	}
	
	gAudioSD_CSIhandle_FSGhandle = gFL_Pos[0];
	putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );

	gAudioSD_CSIhandle_FSGhandle_absolutePos = 0x01;
    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );

	for( i = 0; i < gFavoriteList_TotalNumListElements; i++ )
		gFavoriteList_Pos_insDel[i] [0] = gFL_Pos[i];

	if( getValue( env_AudioSD_FL_insert_UPD_button ) == 0x00 )
	{
		for( i = 0; i < gFavoriteList_TotalNumListElements; i++ )
			gFavoriteList_Pos_insDel[i] [2] = i + 1;

		gFL_totalDELctr = 0;
	}
  }
}

on envVar env_AudioSD_FL_Status
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i, transSuppression;

  // Init local variables.
  mode                    = 0;
  shift                   = 0;
  direction               = 0;
  transmitpos             = 0;
  indexsize               = 0;
  recordaddress           = 0;
  requested_startelement  = 0;
  startelement            = 0;
  elements                = 0;
  valid_startelement      = 0;
  i                       = 0;
  valid_elements          = 0;
  transSuppression        = getvalue( env_AudioSD_FL_StatusOFF );

  if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
    if( getvalue( env_AudioSD_FL_AH_Start ) >255 && getvalue( env_AudioSD_FL_AH_IndexSize ) == 0 ) // check if 8 or 16 bit
        putvalue( env_AudioSD_FL_AH_IndexSize,1 );

    //get data from Panel
    gFL_ASGID= getvalue( env_AudioSD_FL_AsgId );
    gFL_TAID = getvalue( env_AudioSD_FL_TAID);
    //gFL_ALP  = getvalue(Env_AudioSD_FL_ALP );
    gFL_TNLE = getvalue( env_AudioSD_FL_TNLE );

    recordaddress   = getvalue( env_AudioSD_FL_AH_RecordAdd );
    shift           = getvalue( env_AudioSD_FL_AH_Shift );
    direction       = getvalue( env_AudioSD_FL_AH_Dir );
    transmitpos     = getvalue( env_AudioSD_FL_AH_TransPos );
    indexsize       = getvalue( env_AudioSD_FL_AH_IndexSize );
    startelement    = getvalue( env_AudioSD_FL_AH_Start );
    elements        = getvalue( env_AudioSD_FL_AH_Elements );

    mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

    requested_startelement = startelement;

    /***Startelement = 0***/
    if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
        {
      if( FORWARD==direction )  //forward-start
            {
        valid_startelement = 0;

        if( AUDIO_FAVORITELIST_ENTRIES <= elements ) //1. more elements requested, than in array
                {
          if( shift == FALSE )
          {
            for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
                        {
                          if( 0 != gFL_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                              i = AUDIO_FAVORITELIST_ENTRIES;
                      }
          }
          else if( shift == TRUE )
          {
            valid_startelement  = startelement;
                  valid_elements      = 0;
          }
              }
        else    //2. number of requested elements < elements in array
                {
          if( shift == FALSE )
          {
                      for( i = 0; i < elements; i++ )
                        {
                          if( 0!= gFL_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                            i = AUDIO_FAVORITELIST_ENTRIES;
                      }
          }
          else if( shift == TRUE )
          {
            valid_startelement  = startelement;
                      valid_elements      = 0;
          }
                }
      }
      else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
            {
              //searching for valid startelement
                for( i = ( AUDIO_FAVORITELIST_ENTRIES-1 ); i>= 0; i--)
                {
                  if( 0!= gFL_ListEntryValidInformation[i] )        //found valid startelement
                    {
                      valid_startelement = i;
                        i = 0;
                    }
                }
        //searching for valid elements
                if( 0xff ==valid_startelement ) //Startelement-ID doesn't exist in SMSReceived-array
                {
                  valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else if( 0 ==valid_startelement )
                  valid_elements= 1;//only 1 element because valid startelement is on position 0
                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                {
                  for( i =valid_startelement; i>= 0; i--)
                    {
                      if( 0!= gFL_ListEntryValidInformation[i] )    //if there is an valid element
                          valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                          i = 0;
                  }
                }
        else                                                        //enougth array-elements available
                {
                  for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                    {
                      if( 0!= gFL_ListEntryValidInformation[i] )    //if there is an valid element
                          valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
        }                                                               //backward-end
    }
    /***Startelement!= 0***/
    else                                                                //searching for Startelement-ID
        {
          //searching for valid startelement
            for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
            {
                if( gFL_Pos[i] == startelement )                        //found a valid element
                {
          if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                    {
                      if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                          valid_startelement = i + 1-2* direction;
            else if( i == 0 && BACKWARD==direction )
              valid_startelement = gFL_sum;     //valid element is last element in Array
            else if( i == 0 && FORWARD==direction )
              valid_startelement = 0;                          //valid element is first element in Array
          }
          else
            valid_startelement = i;                              //found element is valid_startelement
                    i = AUDIO_FAVORITELIST_ENTRIES;
                }
        else
          valid_startelement = 0xff;
            }

            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
            {
                valid_startelement  = startelement;
                valid_elements      = 0;
            }
            else                                                                //found valid entry for startelement in array
            {
              //verify number of valid elements
                if( BACKWARD==direction )                                            //backward-start
                {
                  if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                      valid_elements= 1;
                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                  {
                      for( i =valid_startelement; i>= 0; i--)
                      {
                          if( 0!= gFL_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
              else                                                //no valid element, loop finished
                              i = 0;
                        }
                  }
                    else                                                        //enougth array-elements available
                    {
                      for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                          if( 0!= gFL_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                  if((valid_startelement+elements )>= AUDIO_FAVORITELIST_ENTRIES)
                    {
                      for( i =valid_startelement; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
                        {
                          if( 0!= gFL_Pos[i] )                            //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                              i = AUDIO_FAVORITELIST_ENTRIES;
                        }
                    }
                    else
                    {
                      for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                        {
                          if( 0!= gFL_Pos[i] )                            //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                              i = AUDIO_FAVORITELIST_ENTRIES;
                        }
                    }
                }
            }
        }
    putvalue( env_AudioSD_FL_AH_Elements, valid_elements );

    //send StatusArray
    if(!transSuppression )
        FavoriteList_Request( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
  }
}

byte FavoriteList_nextvalidLine( byte current_FavoriteListLine, byte direction )
{
  byte next_FavoriteListLine;
  int i;

  //init lokal variables
  next_FavoriteListLine = 0;
  i = 0;

  //search next "list entry"
  if( (( gFL_sum - 1 ) == current_FavoriteListLine && FORWARD == direction ) || ( 0 == current_FavoriteListLine && BACKWARD == direction ) )  //last-/fist-element of array reached
      next_FavoriteListLine = 0xFF;
  else
  {
      next_FavoriteListLine = current_FavoriteListLine + 1 - 2 * direction;       //increment or decrement array-line ( depends on direction );

      if( 0 == gFL_ListEntryValidInformation[next_FavoriteListLine] )    // check if next element is "valid"
          next_FavoriteListLine = 0xff;
  }
  return (next_FavoriteListLine );
}

void FavoriteList_init_static()
{
    byte j, i, FavoriteListLine;

    //clear
    FavoriteListLine = 0;
    gFL_sum = 0;

    for( j = 0; j < AUDIO_FAVORITELIST_ENTRIES; j++ )
    {
      gFL_Pos[j] = 0;
      gFL_PresentIndex[j] = 0;
      gFL_Waveband[j] = 0;
      gFL_Attributes[j] = 0;

      gFL_Attribute_IBOC_Bit0[j] = 0;
      gFL_Attribute_DABsec_Bit1[j] = 0;
      gFL_Attribute_DABprim_Bit2[j] = 0;
      gFL_Attribute_OnlineRadioSec_Bit3[j] = 0;
      gFL_Attribute_OnlineRadioPrim_Bit4[j] = 0;
      gFL_Attribute_TP_Bit5[j] = 0;
      gFL_Attribute_TMC_Bit6[j] = 0;
      gFL_Attribute_SDARS_Bit7[j] = 0;
      gFL_Attribute_StationSelc_Bit8[j] = 0;
      gFL_Attribute_mute_Bit9[j] = 0;
      gFL_Attribute_StationLinkedORadio_Bit10[j] = 0;
      gFL_Attribute_StationLinkedFM_Bit11[j] = 0;

      gFL_ListEntryValidInformation[j] = 0;

      for( i = 0; i < AUDIO_FAVORITE_NAME_LENGTH; i++ )
        gFL_Name[j][i] = 0;
      for( i = 0; i < AUDIO_FAVORITE_FREQUENZ_LENGTH; i++ )
        gFL_Frequenz[j][i] = 0;
    }

    //entry 0
    gFL_ListEntryValidInformation[FavoriteListLine] = TRUE;
    gFL_Pos[FavoriteListLine] = 0xF1;
    gFL_PresentIndex[FavoriteListLine] = 0xA;
    gFL_Waveband[FavoriteListLine] = 0x09;

    gFL_Attribute_IBOC_Bit0[FavoriteListLine] = TRUE;
    gFL_Attribute_DABsec_Bit1[FavoriteListLine] = FALSE;
    gFL_Attribute_DABprim_Bit2[FavoriteListLine] = FALSE;
    gFL_Attribute_OnlineRadioSec_Bit3[FavoriteListLine] = TRUE;
    gFL_Attribute_OnlineRadioPrim_Bit4[FavoriteListLine] = TRUE;
    gFL_Attribute_TP_Bit5[FavoriteListLine] = TRUE;
    gFL_Attribute_TMC_Bit6[FavoriteListLine] = FALSE;
    gFL_Attribute_SDARS_Bit7[FavoriteListLine] = FALSE;
    gFL_Attribute_StationSelc_Bit8[FavoriteListLine] = FALSE;
    gFL_Attribute_mute_Bit9[FavoriteListLine] = TRUE;
    gFL_Attribute_StationLinkedORadio_Bit10[FavoriteListLine] = TRUE;
    gFL_Attribute_StationLinkedFM_Bit11[FavoriteListLine] = TRUE;
    gFL_Attributes[FavoriteListLine] = gFL_Attribute_IBOC_Bit0[FavoriteListLine]
                                          + ( gFL_Attribute_DABsec_Bit1[FavoriteListLine] * 0x02 )
                                          + ( gFL_Attribute_DABprim_Bit2[FavoriteListLine] * 0x04 )
                                          + ( gFL_Attribute_OnlineRadioSec_Bit3[FavoriteListLine] * 0x08 )
                                          + ( gFL_Attribute_OnlineRadioPrim_Bit4[FavoriteListLine] * 0x10 )
                                          + ( gFL_Attribute_TP_Bit5[FavoriteListLine] * 0x20 )
                                          + ( gFL_Attribute_TMC_Bit6[FavoriteListLine] * 0x40 )
                                          + ( gFL_Attribute_SDARS_Bit7[FavoriteListLine] * 0x80 )
                                          + ( gFL_Attribute_StationSelc_Bit8[FavoriteListLine] * 0x100 )
                                          + ( gFL_Attribute_mute_Bit9[FavoriteListLine] * 0x200 )
                                          + ( gFL_Attribute_StationLinkedORadio_Bit10[FavoriteListLine] * 0x400 )
                                          + ( gFL_Attribute_StationLinkedFM_Bit11[FavoriteListLine] * 0x800 );

    strncpy( gFL_Name[FavoriteListLine], "Name_0", AUDIO_FAVORITE_NAME_LENGTH);
    strncpy( gFL_Frequenz[FavoriteListLine], "Name_0", AUDIO_FAVORITE_FREQUENZ_LENGTH);
    FavoriteListLine++;

    //entry 1
    gFL_ListEntryValidInformation[FavoriteListLine] = TRUE;
    gFL_Pos[FavoriteListLine] = 0x1B;
    gFL_PresentIndex[FavoriteListLine] = 0xA5;
    gFL_Waveband[FavoriteListLine] = 0x0B;

    gFL_Attribute_IBOC_Bit0[FavoriteListLine] = TRUE;
    gFL_Attribute_DABsec_Bit1[FavoriteListLine] = TRUE;
    gFL_Attribute_DABprim_Bit2[FavoriteListLine] = TRUE;
    gFL_Attribute_OnlineRadioSec_Bit3[FavoriteListLine] = TRUE;
    gFL_Attribute_OnlineRadioPrim_Bit4[FavoriteListLine] = TRUE;
    gFL_Attribute_TP_Bit5[FavoriteListLine] = TRUE;
    gFL_Attribute_TMC_Bit6[FavoriteListLine] = TRUE;
    gFL_Attribute_SDARS_Bit7[FavoriteListLine] = TRUE;
    gFL_Attribute_StationSelc_Bit8[FavoriteListLine] = TRUE;
    gFL_Attribute_mute_Bit9[FavoriteListLine] = TRUE;
    gFL_Attribute_StationLinkedORadio_Bit10[FavoriteListLine] = TRUE;
    gFL_Attribute_StationLinkedFM_Bit11[FavoriteListLine] = TRUE;
    gFL_Attributes[FavoriteListLine] = gFL_Attribute_IBOC_Bit0[FavoriteListLine]
                                          + ( gFL_Attribute_DABsec_Bit1[FavoriteListLine] * 0x02 )
                                          + ( gFL_Attribute_DABprim_Bit2[FavoriteListLine] * 0x04 )
                                          + ( gFL_Attribute_OnlineRadioSec_Bit3[FavoriteListLine] * 0x08 )
                                          + ( gFL_Attribute_OnlineRadioPrim_Bit4[FavoriteListLine] * 0x10 )
                                          + ( gFL_Attribute_TP_Bit5[FavoriteListLine] * 0x20 )
                                          + ( gFL_Attribute_TMC_Bit6[FavoriteListLine] * 0x40 )
                                          + ( gFL_Attribute_SDARS_Bit7[FavoriteListLine] * 0x80 )
                                          + ( gFL_Attribute_StationSelc_Bit8[FavoriteListLine] * 0x100 )
                                          + ( gFL_Attribute_mute_Bit9[FavoriteListLine] * 0x200 )
                                          + ( gFL_Attribute_StationLinkedORadio_Bit10[FavoriteListLine] * 0x400 )
                                          + ( gFL_Attribute_StationLinkedFM_Bit11[FavoriteListLine] * 0x800 );

    strncpy( gFL_Name[FavoriteListLine], "Name_1", AUDIO_FAVORITE_NAME_LENGTH);
    strncpy( gFL_Frequenz[FavoriteListLine], "Name_1", AUDIO_FAVORITE_FREQUENZ_LENGTH);
    FavoriteListLine++;

    //entry 2
    gFL_ListEntryValidInformation[FavoriteListLine] = FALSE;
    gFL_Pos[FavoriteListLine] = 0x1;
    gFL_PresentIndex[FavoriteListLine] = 0xF;
    gFL_Waveband[FavoriteListLine] = 0x00;

    gFL_Attribute_IBOC_Bit0[FavoriteListLine] = FALSE;
    gFL_Attribute_DABsec_Bit1[FavoriteListLine] = FALSE;
    gFL_Attribute_DABprim_Bit2[FavoriteListLine] = FALSE;
    gFL_Attribute_OnlineRadioSec_Bit3[FavoriteListLine] = FALSE;
    gFL_Attribute_OnlineRadioPrim_Bit4[FavoriteListLine] = FALSE;
    gFL_Attribute_TP_Bit5[FavoriteListLine] = FALSE;
    gFL_Attribute_TMC_Bit6[FavoriteListLine] = FALSE;
    gFL_Attribute_SDARS_Bit7[FavoriteListLine] = FALSE;
    gFL_Attribute_StationSelc_Bit8[FavoriteListLine] = FALSE;
    gFL_Attribute_mute_Bit9[FavoriteListLine] = FALSE;
    gFL_Attribute_StationLinkedORadio_Bit10[FavoriteListLine] = FALSE;
    gFL_Attribute_StationLinkedFM_Bit11[FavoriteListLine] = FALSE;
    gFL_Attributes[FavoriteListLine] = gFL_Attribute_IBOC_Bit0[FavoriteListLine]
                                          + ( gFL_Attribute_DABsec_Bit1[FavoriteListLine] * 0x02 )
                                          + ( gFL_Attribute_DABprim_Bit2[FavoriteListLine] * 0x04 )
                                          + ( gFL_Attribute_OnlineRadioSec_Bit3[FavoriteListLine] * 0x08 )
                                          + ( gFL_Attribute_OnlineRadioPrim_Bit4[FavoriteListLine] * 0x10 )
                                          + ( gFL_Attribute_TP_Bit5[FavoriteListLine] * 0x20 )
                                          + ( gFL_Attribute_TMC_Bit6[FavoriteListLine] * 0x40 )
                                          + ( gFL_Attribute_SDARS_Bit7[FavoriteListLine] * 0x80 )
                                          + ( gFL_Attribute_StationSelc_Bit8[FavoriteListLine] * 0x100 )
                                          + ( gFL_Attribute_mute_Bit9[FavoriteListLine] * 0x200 )
                                          + ( gFL_Attribute_StationLinkedORadio_Bit10[FavoriteListLine] * 0x400 )
                                          + ( gFL_Attribute_StationLinkedFM_Bit11[FavoriteListLine] * 0x800 );

    strncpy( gFL_Name[FavoriteListLine], "Name_2", AUDIO_FAVORITE_NAME_LENGTH);
    strncpy( gFL_Frequenz[FavoriteListLine], "Name_2", AUDIO_FAVORITE_FREQUENZ_LENGTH);
    FavoriteListLine++;

    //entry 3
    gFL_ListEntryValidInformation[FavoriteListLine] = TRUE;
    gFL_Pos[FavoriteListLine] = 0x12;
    gFL_PresentIndex[FavoriteListLine] = 0x5F;
    gFL_Waveband[FavoriteListLine] = 0x0C;

    gFL_Attribute_IBOC_Bit0[FavoriteListLine] = TRUE;
    gFL_Attribute_DABsec_Bit1[FavoriteListLine] = TRUE;
    gFL_Attribute_DABprim_Bit2[FavoriteListLine] = TRUE;
    gFL_Attribute_OnlineRadioSec_Bit3[FavoriteListLine] = FALSE;
    gFL_Attribute_OnlineRadioPrim_Bit4[FavoriteListLine] = FALSE;
    gFL_Attribute_TP_Bit5[FavoriteListLine] = TRUE;
    gFL_Attribute_TMC_Bit6[FavoriteListLine] = TRUE;
    gFL_Attribute_SDARS_Bit7[FavoriteListLine] = FALSE;
    gFL_Attribute_StationSelc_Bit8[FavoriteListLine] = FALSE;
    gFL_Attribute_mute_Bit9[FavoriteListLine] = TRUE;
    gFL_Attribute_StationLinkedORadio_Bit10[FavoriteListLine] = FALSE;
    gFL_Attribute_StationLinkedFM_Bit11[FavoriteListLine] = TRUE;
    gFL_Attributes[FavoriteListLine] = gFL_Attribute_IBOC_Bit0[FavoriteListLine]
                                          + ( gFL_Attribute_DABsec_Bit1[FavoriteListLine] * 0x02 )
                                          + ( gFL_Attribute_DABprim_Bit2[FavoriteListLine] * 0x04 )
                                          + ( gFL_Attribute_OnlineRadioSec_Bit3[FavoriteListLine] * 0x08 )
                                          + ( gFL_Attribute_OnlineRadioPrim_Bit4[FavoriteListLine] * 0x10 )
                                          + ( gFL_Attribute_TP_Bit5[FavoriteListLine] * 0x20 )
                                          + ( gFL_Attribute_TMC_Bit6[FavoriteListLine] * 0x40 )
                                          + ( gFL_Attribute_SDARS_Bit7[FavoriteListLine] * 0x80 )
                                          + ( gFL_Attribute_StationSelc_Bit8[FavoriteListLine] * 0x100 )
                                          + ( gFL_Attribute_mute_Bit9[FavoriteListLine] * 0x200 )
                                          + ( gFL_Attribute_StationLinkedORadio_Bit10[FavoriteListLine] * 0x400 )
                                          + ( gFL_Attribute_StationLinkedFM_Bit11[FavoriteListLine] * 0x800 );

    strncpy( gFL_Name[FavoriteListLine], "Name_3", AUDIO_FAVORITE_NAME_LENGTH);
    strncpy( gFL_Frequenz[FavoriteListLine], "Name_3", AUDIO_FAVORITE_FREQUENZ_LENGTH);
    FavoriteListLine++;

    //entry 4
    gFL_ListEntryValidInformation[FavoriteListLine] = TRUE;
    gFL_Pos[FavoriteListLine] = 0x12;
    gFL_PresentIndex[FavoriteListLine] = 0x5F;
    gFL_Waveband[FavoriteListLine] = 0x0A;

    gFL_Attribute_IBOC_Bit0[FavoriteListLine] = TRUE;
    gFL_Attribute_DABsec_Bit1[FavoriteListLine] = TRUE;
    gFL_Attribute_DABprim_Bit2[FavoriteListLine] = TRUE;
    gFL_Attribute_OnlineRadioSec_Bit3[FavoriteListLine] = FALSE;
    gFL_Attribute_OnlineRadioPrim_Bit4[FavoriteListLine] = FALSE;
    gFL_Attribute_TP_Bit5[FavoriteListLine] = TRUE;
    gFL_Attribute_TMC_Bit6[FavoriteListLine] = TRUE;
    gFL_Attribute_SDARS_Bit7[FavoriteListLine] = FALSE;
    gFL_Attribute_StationSelc_Bit8[FavoriteListLine] = FALSE;
    gFL_Attribute_mute_Bit9[FavoriteListLine] = TRUE;
    gFL_Attribute_StationLinkedORadio_Bit10[FavoriteListLine] = FALSE;
    gFL_Attribute_StationLinkedFM_Bit11[FavoriteListLine] = TRUE;
    gFL_Attributes[FavoriteListLine] = gFL_Attribute_IBOC_Bit0[FavoriteListLine]
                                          + ( gFL_Attribute_DABsec_Bit1[FavoriteListLine] * 0x02 )
                                          + ( gFL_Attribute_DABprim_Bit2[FavoriteListLine] * 0x04 )
                                          + ( gFL_Attribute_OnlineRadioSec_Bit3[FavoriteListLine] * 0x08 )
                                          + ( gFL_Attribute_OnlineRadioPrim_Bit4[FavoriteListLine] * 0x10 )
                                          + ( gFL_Attribute_TP_Bit5[FavoriteListLine] * 0x20 )
                                          + ( gFL_Attribute_TMC_Bit6[FavoriteListLine] * 0x40 )
                                          + ( gFL_Attribute_SDARS_Bit7[FavoriteListLine] * 0x80 )
                                          + ( gFL_Attribute_StationSelc_Bit8[FavoriteListLine] * 0x100 )
                                          + ( gFL_Attribute_mute_Bit9[FavoriteListLine] * 0x200 )
                                          + ( gFL_Attribute_StationLinkedORadio_Bit10[FavoriteListLine] * 0x400 )
                                          + ( gFL_Attribute_StationLinkedFM_Bit11[FavoriteListLine] * 0x800 );

    strncpy( gFL_Name[FavoriteListLine], "Name_4", AUDIO_FAVORITE_NAME_LENGTH);
    strncpy( gFL_Frequenz[FavoriteListLine], "Name_4", AUDIO_FAVORITE_FREQUENZ_LENGTH);
    FavoriteListLine++;

    gFL_sum = gFL_CSVtotalElem = gFavoriteList_TotalNumListElements = FavoriteListLine;
    gFL_TNLE = gFL_sum;
    if( boTraceStatus_ON )
    {
    for( i = 0; i < gFL_sum; i++ )
    {
        writelineEx( gBAP_Trace, 0, "*******Element %d*******", i);

        writelineEx( gBAP_Trace, 0, "Pos[%d]: 0x%x", i, gFL_Pos[i] );
        writelineEx( gBAP_Trace, 0, "PresentIndex[%d]: 0x%x", i, gFL_PresentIndex[i] );

        if( gFL_Waveband[i] < 0xD)
          writelineEx( gBAP_Trace, 0, "Waveband -> '%s'", gFL_Waveband_s[gFL_Waveband[i]] );
        else
          writelineEx( gBAP_Trace, 0, "Waveband -> '%s'", gstring_reserved );

        writelineEx( gBAP_Trace, 0, "Attributes[%d]: 0x%x", i, gFL_Attributes[i] );
        if( gFL_Attributes[i] & 0x01 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit0[%d]: 'IBOC service'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit0[%d]: 'not an IBOC service'", i);

        if( gFL_Attributes[i] & 0x02 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit1[%d]: 'DAB secondary service'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit1[%d]: 'not a DAB secondary service'", i);

        if( gFL_Attributes[i] & 0x04 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit2[%d]: 'DAB primary service contains secondary service(s )'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit2[%d]: 'DAB primary service contains no secondary service(s ) / no DAB primary service'", i);

        if( gFL_Attributes[i] & 0x08 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit3[%d]: 'Online radio secondary service'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit3[%d]: 'not an online radio secondary service'", i);

        if( gFL_Attributes[i] & 0x10 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit4[%d]: 'Online radio primary service contains secondary service(s )'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit4[%d]: 'Online radio primary service contains no secondary service(s ) / no online radio primary service'", i);

        if( gFL_Attributes[i] & 0x20 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit5[%d]: 'TP available/supported by station'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit5[%d]: 'TP not available/not supported by station'", i);

        if( gFL_Attributes[i] & 0x40 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit6[%d]: 'TMC available/supported by station'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit6[%d]: 'TMC not supported/not available by station'", i);

        if( gFL_Attributes[i] & 0x80 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit7[%d]: 'SDARS station subscribed or not an SDARS station'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit7[%d]: 'SDARS station not subscribed'", i);

        if( gFL_Attributes[i] & 0x100 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit8[%d]: 'Station not selectable'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit8[%d]: 'Station selectable'", i);

        if( gFL_Attributes[i] & 0x200 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit9[%d]: 'muting / low signal'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit9[%d]: 'not muted / signal OK'", i);

        if( gFL_Attributes[i] & 0x400 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit10[%d]: 'Station linked to online radio'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit10[%d]: 'Station not linked to online radio'", i);

        if( gFL_Attributes[i] & 0x800 )
            writelineEx( gBAP_Trace, 0, "Attributes_Bit11[%d]: 'Station linked to FM'", i);
        else
            writelineEx( gBAP_Trace, 0, "Attributes_Bit11[%d]: 'Station not linked to FM'", i);

        writelineEx( gBAP_Trace, 0, "Name[%d]: %s", i, gFL_Name[i] );
        writelineEx( gBAP_Trace, 0, "Frequenz[%d]: %s", i, gFL_Frequenz[i] );
    }
    }
	
	for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
	{
		gFavoriteList_Pos_insDel[i] [0] = 0;
		gFavoriteList_Pos_insDel[i] [1] = 0;
		gFavoriteList_Pos_insDel[i] [2] = 0;
	}
	
	//gAudioSD_CSIhandle_FSGhandle = gFL_Pos[0];
    //putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
     //IssueList #72
    gAudioSD_CSIhandle_FSGhandle_absolutePos = 0x01;
    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
	
    putvalue( env_AudioSD_FL_TNLE, gFL_TNLE );
    if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Anzahl der Listenelemente: %d", gFL_sum);
}

on envVar env_AudioSD_FL_Changed
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;

  // Init local variables.
  mode                    = 0;
  shift                   = 0;
  direction               = 0;
  transmitpos             = 0;
  indexsize               = 0;
  recordaddress           = 0;
  requested_startelement  = 0;
  startelement            = 0;
  elements                = 0;
  valid_startelement      = 0;
  i                       = 0;
  valid_elements          = 0;

  if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
    if( getvalue( env_AudioSD_FL_AH_Start ) >255 && getvalue( env_AudioSD_FL_AH_IndexSize ) == 0 ) // check if 8 or 16 bit
        putvalue( env_AudioSD_FL_AH_IndexSize,1 );

    //get data from Panel
    recordaddress   = getvalue( env_AudioSD_FL_AH_RecordAdd );
    shift           = getvalue( env_AudioSD_FL_AH_Shift );
    direction       = getvalue( env_AudioSD_FL_AH_Dir );
    transmitpos     = getvalue( env_AudioSD_FL_AH_TransPos );
    indexsize       = getvalue( env_AudioSD_FL_AH_IndexSize );
    startelement    = getvalue( env_AudioSD_FL_AH_Start );
    elements        = getvalue( env_AudioSD_FL_AH_Elements );
    mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

    requested_startelement = startelement;


    /***Startelement = 0***/
    if( getvalue( env_AudioSD_MB_CA_switch ) ) //ArrayData
    {
      if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
      {
        if( FORWARD==direction )  //forward-start
          {
          valid_startelement = 0;

          if( AUDIO_FAVORITELIST_ENTRIES <= elements ) //1. more elements requested, than in array
              {
            if( shift == FALSE )
            {
              for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
                      {
                          if( 0 != gFL_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                            i = AUDIO_FAVORITELIST_ENTRIES;
                        }
            }
            else if( shift == TRUE )
            {
              valid_startelement  = startelement;
                        valid_elements      = 0;
            }
                }
          else    //2. number of requested elements < elements in array
                  {
            if( shift == FALSE )
            {
                        for( i = 0; i < elements; i++ )
                          {
                            if( 0!= gFL_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                              i = AUDIO_FAVORITELIST_ENTRIES;
                        }
            }
            else if( shift == TRUE )
            {
              valid_startelement  = startelement;
                        valid_elements      = 0;
            }
                  }
        }//forward ends
        else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
              {
                //searching for valid startelement
                  for( i = ( AUDIO_FAVORITELIST_ENTRIES-1 ); i>= 0; i--)
                  {
                    if( 0!= gFL_ListEntryValidInformation[i] )        //found valid startelement
                      {
                        valid_startelement = i;
                          i = 0;
                      }
                  }
          //searching for valid elements
                  if( 0xff ==valid_startelement ) //Startelement-ID doesn't exist in SMSReceived-array
                  {
                    valid_startelement  = startelement;
                      valid_elements      = 0;
                  }
                  else if( 0 ==valid_startelement )
                    valid_elements= 1;//only 1 element because valid startelement is on position 0
                  else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                  {
                  for( i =valid_startelement; i>= 0; i--)
                      {
                        if( 0!= gFL_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                            i = 0;
                    }
                  }
          else                                                        //enougth array-elements available
                  {
                    for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                      {
                        if( 0!= gFL_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                              i = 0;
                      }
                  }
        }//backward-end
      }//startelement == 0 -end

      /***Startelement!= 0***/
      else                                                                //searching for Startelement-ID
          {
            //searching for valid startelement
              for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
              {
                  if( gFL_Pos[i] == startelement )                        //found a valid element
                  {
            if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                      {
                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement = i + 1-2* direction;
              else if( i == 0 && BACKWARD==direction )
                valid_startelement = gMediaBrowser_sum;     //valid element is last element in Array
              else if( i == 0 && FORWARD==direction )
                valid_startelement = 0;                          //valid element is first element in Array
            }
            else
              valid_startelement = i;                              //found element is valid_startelement
                      i = AUDIO_FAVORITELIST_ENTRIES;
                  }
          else
            valid_startelement = 0xff;
              }
              if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
              {
                  valid_startelement  = startelement;
                  valid_elements      = 0;
              }
              else                                                                //found valid entry for startelement in array
              {
                //verify number of valid elements
                  if( BACKWARD==direction )                                            //backward-start
                  {
                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                        valid_elements= 1;
                      else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                          {
                            if( 0!= gFL_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                else                                                //no valid element, loop finished
                                i = 0;
                          }
                    }
                      else                                                        //enougth array-elements available
                      {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                          {
                            if( 0!= gFL_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                              else                                                //no valid element, loop finished
                                  i = 0;
                          }
                      }
                  }                                                                //backward-end
                  else                                                            //forward-start
                  {
                    if((valid_startelement+elements )>= AUDIO_FAVORITELIST_ENTRIES)
                      {
                        for( i =valid_startelement; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
                          {
                            if( 0!= gFL_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                              else                                                //no valid element, loop finished
                                i = AUDIO_FAVORITELIST_ENTRIES;
                          }
                      }
                      else
                      {
                        for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                          {
                            if( 0!= gFL_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                              else                                                //no valid element, loop finished
                                i = AUDIO_FAVORITELIST_ENTRIES;
                          }
                      }
                  }
              }
          }
      putvalue( env_AudioSD_FL_AH_Elements, valid_elements );
      //send ChangedArray
      FavoriteList_Request( Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
    }
    else
    {
      //send ChangedArray
      FavoriteList_Request( Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0 );
    }
  }
}

on envVar env_AudioSD_FL_CSV_Default
{
    if( getvalue( this ) == AUDIO_DEFAULT_LIST )
    {
        FavoriteList_init_static();
        putvalue( env_AudioSD_FL_CSV_Current, empty_string );
        putvalue( env_AudioSD_FL_CSV_Result, empty_string );
    }
}

on envVar env_AudioSD_FL_CSV_Load //load external FavoriteList from *.csv
{
    if( getvalue( this ) && getvalue( env_AudioSD_FL_CSV_Default ) == AUDIO_EXTERNAL_LIST )

        FavoriteList_init_CSV();

    else if( getvalue( env_AudioSD_FL_CSV_Default ) != AUDIO_EXTERNAL_LIST )
        putvalue( env_AudioSD_FL_CSV_Result, "not successful, select 'external *.csv'" );
}

//*****************************

void SiriusAlertList_Indication( dword Indication_array [], int datalength )
{
    byte mode, shift, direction, recordaddress, indexsize, valid_elements, transmitpos;
    word valid_startelement, requested_startelement, startelement, elements;
    int i = 0, transSuppression;
	byte audioListDelFlg;
	byte sal_InValidStartElemFlg;
	word validStartElem_plusElem;

    // Init local variables.
    mode = 0;
    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    recordaddress = 0;
    requested_startelement = 0;
    startelement = 0;
    elements = 0;
    valid_startelement = 0xff;
    i = 0;
    valid_elements = 0;
    transSuppression = getvalue( env_AudioSD_SAL_StatusOFF );


    switch( Indication_array[2] ) // indication
    {
        case DataGet_IND:
        //MR 63336
        if( getvalue( env_AudioSD_SAL_Error_Status ) )
        {
          SiriusAlertList_Request(Error_REQ, 0, 0, 0, 0, 0, getvalue( env_AudioSD_SAL_ErrorCode ) );
        }
        else if( getvalue( env_AudioSD_SAL_Timeout ) == TRUE )
        {
        /* NOP */
        }
        else
        {
            //getData
            gSAL_ASGID = ( gBAP_Indication[3] & 0xF0 ) / 0x10;
            gSAL_TAID = gBAP_Indication[3] & 0x0F;

            //decode BAP-ArrayHeader
            mode = ( gBAP_Indication[4] & 0xF0 ) / 0x10;

            // decode "mode -byte"
            shift = mode & 0x01;
            direction = ( mode & 0x02 ) / 0x02;
            transmitpos = ( mode & 0x04 ) / 0x04;
            indexsize = ( mode & 0x08 ) / 0x08;

            recordaddress = gBAP_Indication[4] & 0x0F;
            if( indexsize )
            {
                startelement = gBAP_Indication[5];
                startelement += gBAP_Indication[6] * 0x100;
                elements = gBAP_Indication[7];
                elements += gBAP_Indication[8] * 0x100;
            }
            else
            {
                startelement = gBAP_Indication[5];
                elements = gBAP_Indication[6];
            }

            requested_startelement = startelement;

            transmitpos = TRUE; //Position must always be sent in the case of *.GetArray.


            /***Startelement = 0***/
            if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
            {
                if( FORWARD == direction )  //forward-start
                {
                    valid_startelement = 0;

                    if( AUDIO_SIRIUSALERTLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
                            {
                                if( 0 != gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                                {
                                    if( gSAL_Pos[i] > 0xFF ) //check indexsize
                                        indexsize = TRUE;

                                    valid_elements++;                               //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement = startelement;
                            valid_elements = 0;
                        }
                    }
                    else    //2. number of requested elements < elements in array
                    {
                        if( shift == FALSE )
                        {
                            for( i = 0; i < elements; i++ )
                            {
                                if( 0 != gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                                {
                                    if( gSAL_Pos[i] > 0xFF ) //check indexsize
                                        indexsize = TRUE;

                                    valid_elements++;                               //increment elements
                                }
                                else                                                //no valid element, loop finished
                                    i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                            }
                        }
                        else if( shift == TRUE )
                        {
                            valid_startelement = startelement;
                            valid_elements = 0;
                        }
                    }
                }                                                               //forward ends

                else if( BACKWARD == direction && TRUE == shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
                {
                    //searching for valid startelement
                    for( i = ( AUDIO_SIRIUSALERTLIST_ENTRIES - 1 ); i >= 0; i--)
                    {
                        if( 0 != gSAL_ListEntryValidInformation[i] )        //found valid startelement
                        {
                            valid_startelement = i;
                            i = 0;
                        }
                    }

                    //searching for valid elements
                    if( 0xFF == valid_startelement )                             //Startelement-ID doesn't exist in SMSReceived-array
                    {
                        valid_startelement = startelement;
                        valid_elements = 0;
                    }
                    else if( 0 == valid_startelement )
                        valid_elements = 1;                                       //only 1 element because valid startelement is on position 0

                    else if( elements > (valid_startelement + 1 ) )                   //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i = valid_startelement; i >= 0; i--)
                        {
                            if( 0 != gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                            {
                                if( gSAL_Pos[i] > 0xFF ) //check indexsize
                                    indexsize = TRUE;

                                valid_elements++;                               //increment elements
                            }
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                    else                                                        //enougth array-elements available
                    {
                        for( i = valid_startelement; i > (valid_startelement - elements ); i--)
                        {
                            if( 0 != gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                            {
                                if( gSAL_Pos[i] > 0xFF ) //check indexsize
                                    indexsize = TRUE;

                                valid_elements++;                               //increment elements
                            }
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                               //backward-end
            }                                                                   //startelement == 0 -end

            /***Startelement!= 0***/
            else                                                                //searching for Startelement-ID
            {
				sal_InValidStartElemFlg = 0;
				for( i = 0; i < gSAL_CSVtotalElem; i++ )
				{
					if( startelement == gSiriusAlertList_Pos_insDel[i][0] )
					{
						//check if Start is deleted then reply with 0 elements
						if( gSiriusAlertList_Pos_insDel[i][1] == 0x01 )
						{
							valid_startelement  = startelement;
							valid_elements      = 0;
							sal_InValidStartElemFlg = 1;
						}
					}
				}
				if(sal_InValidStartElemFlg == 0x0)
				{
					//searching for valid startelement
					for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
					{
						if( gSAL_Pos[i] == startelement )                       //found a valid element
						{
							if( shift == TRUE )                                          //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
							{
								if( i != 0 || BACKWARD != direction )                        //if valid_startelement is not the first array element or direction is not backwards
									valid_startelement = i + 1 - 2 * direction;

								else if( i == 0 && BACKWARD == direction )
									valid_startelement = gSAL_sum - 1;     //valid element is last element in Array

								else if( i == 0 && FORWARD == direction )
									valid_startelement = 0;                          //valid element is first element in Array
							}

							else
								valid_startelement = i;                              //found element is valid_startelement

							i = AUDIO_SIRIUSALERTLIST_ENTRIES;
						}
					}

					if( 0xFF == valid_startelement )                                     //Startelement-ID doesn't exist in array
					{
						valid_startelement = startelement;
						valid_elements = 0;
					}
					else                                                                //found valid entry for startelement in array
					{
						//verify number of valid elements
						if( BACKWARD == direction )                                          //backward-start
						{
							if( valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
							{    
								audioListDelFlg = 0x00;
								audioListDelFlg = audioList_deleteCheck( gSAL_Pos[0], gSiriusAlertList_Pos_insDel, gSAL_CSVtotalElem );

								if( audioListDelFlg == 0x00 )  
									valid_elements = 1;
							}
							else if( elements > (valid_startelement + 1 ) )                   //not enougth array-elements available, because array endet at array-position 0
							{
								for( i = valid_startelement; i >= 0; i--)
								{
									if( 0 != gSAL_ListEntryValidInformation[i] )    //if there is an valid element
									{
										if( gSAL_Pos[i] > 0xFF ) //check indexsize
											indexsize = TRUE;

										valid_elements++;                               //increment elements
									}
									else                                                //no valid element, loop finished
										i = 0;
								}
							}
							else                                                        //enougth array-elements available
							{
								for( i = valid_startelement; i > (valid_startelement - elements ); i--)
								{
									if( 0 != gSAL_ListEntryValidInformation[i] )    //if there is an valid element
									{
										if( gSAL_Pos[i] > 0xFF ) //check indexsize
											indexsize = TRUE;

										valid_elements++;                               //increment elements
									}
									else                                                //no valid element, loop finished
										i = 0;
								}
							}
						}                                                               //backward-end
						else                                                            //forward-start
						{
							if( (valid_startelement + elements ) >= AUDIO_SIRIUSALERTLIST_ENTRIES)
							{
								for( i = valid_startelement; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
								{
									if( 0 != gSAL_Pos[i] )                      //if there is an valid element
									{
										if( gSAL_Pos[i] > 0xFF ) //check indexsize
											indexsize = TRUE;
										
										audioListDelFlg = 0x00;
										audioListDelFlg = audioList_deleteCheck( gSAL_Pos[i], gSiriusAlertList_Pos_insDel, gSAL_CSVtotalElem );

										if( audioListDelFlg == 0x00 && valid_elements < elements )
											valid_elements++;                               //increment elements
									}
									else                                                //no valid element, loop finished
										i = AUDIO_SIRIUSALERTLIST_ENTRIES;
								}
							}
							else
							{
								validStartElem_plusElem = valid_startelement+elements;
								for( i = valid_startelement; i < validStartElem_plusElem; i++ )
								{
									if( 0 != gSAL_Pos[i] )                          //if there is an valid element
									{
										if( gSAL_Pos[i] > 0xFF ) //check indexsize
											indexsize = TRUE;

										audioListDelFlg = 0x00;
										audioListDelFlg = audioList_deleteCheck( gSAL_Pos[i], gSiriusAlertList_Pos_insDel, gSAL_CSVtotalElem);

										if( audioListDelFlg == 0x00 )
										{   
											if( valid_elements < elements ) 												
												valid_elements++;                               //increment elements
										}
										else
										{
											if( valid_elements < elements )
												validStartElem_plusElem++;  
										}
									}
									else                                                //no valid element, loop finished
										i = AUDIO_SIRIUSALERTLIST_ENTRIES;
								}
							}
						}
					}
                }
            }

            if( (valid_startelement > 0xFF ) || ( requested_startelement > 0xFF ) ) //check indexsize
                indexsize = TRUE;

            mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + indexsize * 0x08;

            //send StatusArray
            if( !transSuppression )
                SiriusAlertList_Request( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );

            //Panel
            putvalue( env_AudioSD_SAL_AsgId, gSAL_ASGID);
            putvalue( env_AudioSD_SAL_TAID, gSAL_TAID);
            }
            break;

        case Error_IND:
            writelineEx( gError_Trace, 0, "FSG_AudioSD SiriusAlertList_Indication: received error, errorcode:0x%x", Indication_array[3] );
            break;

        default:
            writelineEx( gError_Trace, 0, "FSG_AudioSD SiriusAlertList_Indication: invalid indication %d", Indication_array[2] );
            break;
    }
}

void SiriusAlertList_Request( byte request, byte mode, byte recordaddress, word requested_startelement, word startelement, word elements, byte errorcode )
{
    int i;
    dword requestarray[BAP_BUFFER_SIZE];
    byte shift, direction, transmitpos, indexsize, current_element, Offset;
    word SiriusAlertListLine;
	byte audioListDelFlg;

    // Init local variables.
    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

    shift = 0;
    direction = 0;
    transmitpos = 0;
    indexsize = 0;
    SiriusAlertListLine = 0;
    current_element = 0;
    Offset = 0;

    // decode "mode -byte"
    shift = mode & 0x01;
    direction = ( mode & 0x02 ) / 0x02;
    transmitpos = ( mode & 0x04 ) / 0x04;
    indexsize = ( mode & 0x08 ) / 0x08;
	
	
	if( elements == 0 )
	{
	    transmitpos = 0;
		mode &= 0xFB;
	}

    // Handle request.
    requestarray[0] = LSG_AudioSD;              //LSG-ID
    requestarray[1] = FctID_SiriusAlertList;    //Fct.-ID
    requestarray[2] = request;                  //request type
    Offset = 3;


    switch( request )
    {
        case Changed_REQ:
            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            SiriusAlertListLine = startelement;
    
	        if( getvalue( env_AudioSD_MB_CA_switch ) )
			{
                //copy data
                switch( recordaddress )
                {
                    case 0: //complete record
                        while ( current_element < elements )
                        {
                            if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gSAL_Pos[SiriusAlertListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gSAL_Pos[SiriusAlertListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSAL_Pos[SiriusAlertListLine];
                                        Offset++;
                                    }
                                }

                                //Attributes
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //PresentIndex
                                requestarray[Offset] = gSAL_PresentIndex[SiriusAlertListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gSAL_Name[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Name[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Name[SiriusAlertListLine][i];
                                    Offset++;
                                }

                                //Frequenz
                                requestarray[Offset] = strlen( gSAL_Frequenz[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Frequenz[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Frequenz[SiriusAlertListLine][i];
                                    Offset++;
                                }

                                //AlertType
                                requestarray[Offset] = gSAL_AlertType[SiriusAlertListLine];
                                Offset++;

                                //AlertName
                                requestarray[Offset] = strlen( gSAL_AlertName[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_AlertName[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_AlertName[SiriusAlertListLine][i];
                                    Offset++;
                                }
                                //Extension
                                requestarray[Offset] = strlen( gSAL_Extension[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Extension[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Extension[SiriusAlertListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                        }//end while
                        break;
                    case 1: //Attributes, Presentindex, Name,Frequency
                        while ( current_element < elements )
                        {
                            if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                //Attributes
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //PresentIndex
                                requestarray[Offset] = gSAL_PresentIndex[SiriusAlertListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gSAL_Name[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Name[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Name[SiriusAlertListLine][i];
                                    Offset++;
                                }

                                //Frequenz
                                requestarray[Offset] = strlen( gSAL_Frequenz[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Frequenz[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Frequenz[SiriusAlertListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                        }//end while
                        break;

                    case 2: //Attributes,PresentIndex,Name
                        while ( current_element < elements )
                        {
                            if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                //Attributes
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //PresentIndex
                                requestarray[Offset] = gSAL_PresentIndex[SiriusAlertListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gSAL_Name[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Name[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Name[SiriusAlertListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                        }//end while
                        break;
                    case 3://Name
                        while ( current_element < elements )
                        {
                            if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                //Name
                                requestarray[Offset] = strlen( gSAL_Name[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Name[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Name[SiriusAlertListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                        }//end while
                        break;
                    case 4: //Attributes,Frequency
                        while ( current_element < elements )
                        {
                            if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                //Attributes
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //Frequenz
                                requestarray[Offset] = strlen( gSAL_Frequenz[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Frequenz[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Frequenz[SiriusAlertListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );
                        }//end while
                        break;
                    case 5: //Attributes,PresetID,Name,Frequency,AlertType,AlertName
                        while ( current_element < elements )
                        {
                            if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                //Attributes
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //PresentIndex
                                requestarray[Offset] = gSAL_PresentIndex[SiriusAlertListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gSAL_Name[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Name[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Name[SiriusAlertListLine][i];
                                    Offset++;
                                }

                                //Frequenz
                                requestarray[Offset] = strlen( gSAL_Frequenz[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Frequenz[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Frequenz[SiriusAlertListLine][i];
                                    Offset++;
                                }

                                //AlertType
                                requestarray[Offset] = gSAL_AlertType[SiriusAlertListLine];
                                Offset++;

                                //AlertName
                                requestarray[Offset] = strlen( gSAL_AlertName[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_AlertName[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_AlertName[SiriusAlertListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                        }//end while
                        break;
                    case 15: //Pos
                        while ( current_element < elements )
                        {
                            if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gSAL_Pos[SiriusAlertListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gSAL_Pos[SiriusAlertListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSAL_Pos[SiriusAlertListLine];
                                        Offset++;
                                    }
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                        }//end while
                        break;
                    default:
                        write( "AudioSD SiriusAlertList_Request: invalid recordaddress %d", recordaddress );
                        break;
                } //end switch "recordaddress"
            }// end 'ArrayData'

            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

            break; //end Changed_REQ

        case Data_REQ:
            //VAGH-10511
            ASGID = gSAL_ASGID;
            TAID = gSAL_TAID;
            if( getvalue( env_AudioSD_SAL_ASGID_Error ) != FALSE )
            {
                ASGID += 0x02;
            }
            if( getvalue( env_AudioSD_SAL_TAID_Error ) != FALSE )
            {
                TAID += 0x02;
            }
            requestarray[Offset] = (( ASGID * 0x10 ) & 0xF0 ) + ( TAID & 0x0F );
                Offset++;
			requestarray[Offset] = gSAL_TNLE & 0xff;
                Offset++;
                requestarray[Offset] = ( gSAL_TNLE & 0xff00 ) / 0x100;
                Offset++;
			

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;
            if( indexsize )
            {
                requestarray[Offset] = requested_startelement & 0xff;
                Offset++;
                requestarray[Offset] = ( requested_startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;
            }
            else
            {
                requestarray[Offset] = requested_startelement;
                Offset++;
                requestarray[Offset] = elements;
                Offset++;
            }

            SiriusAlertListLine = startelement;

            //copy data
            switch( recordaddress )
            {
                case 0: //complete record
                    while ( current_element < elements )
                    {
                        if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
								    //Updating the status array excluding the deleted elements
								    audioListDelFlg = 0x00;
								    audioListDelFlg = audioList_deleteCheck( gSAL_Pos[SiriusAlertListLine], gSiriusAlertList_Pos_insDel, gSAL_CSVtotalElem);
								    if( audioListDelFlg == 0x0 )
									{
										if( indexsize )
										{
											requestarray[Offset] = ( gSAL_Pos[SiriusAlertListLine] & 0xFF );
											Offset++;
											requestarray[Offset] = (( gSAL_Pos[SiriusAlertListLine] & 0xFF00 ) / 0x100 );
											Offset++;
										}
										else
										{
											requestarray[Offset] = gSAL_Pos[SiriusAlertListLine];
											Offset++;
										}
									}
                                }
                                if( audioListDelFlg == 0x0 )
								{
									//Attributes
									requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0x00ff );
									Offset++;
									requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0xFF00 ) / 0x100;
									Offset++;

									//PresentIndex
									requestarray[Offset] = gSAL_PresentIndex[SiriusAlertListLine];
									Offset++;

									//Name
									requestarray[Offset] = strlen( gSAL_Name[SiriusAlertListLine] );
									Offset++;
									for( i = 0; i < strlen( gSAL_Name[SiriusAlertListLine] ); i++ )
									{
										requestarray[Offset] = gSAL_Name[SiriusAlertListLine][i];
										Offset++;
									}

									//Frequenz
									requestarray[Offset] = strlen( gSAL_Frequenz[SiriusAlertListLine] );
									Offset++;
									for( i = 0; i < strlen( gSAL_Frequenz[SiriusAlertListLine] ); i++ )
									{
										requestarray[Offset] = gSAL_Frequenz[SiriusAlertListLine][i];
										Offset++;
									}

									//AlertType
									requestarray[Offset] = gSAL_AlertType[SiriusAlertListLine];
									Offset++;

									//AlertName
									requestarray[Offset] = strlen( gSAL_AlertName[SiriusAlertListLine] );
									Offset++;
									for( i = 0; i < strlen( gSAL_AlertName[SiriusAlertListLine] ); i++ )
									{
										requestarray[Offset] = gSAL_AlertName[SiriusAlertListLine][i];
										Offset++;
									}
									//Extension
									requestarray[Offset] = strlen( gSAL_Extension[SiriusAlertListLine] );
									Offset++;
									for( i = 0; i < strlen( gSAL_Extension[SiriusAlertListLine] ); i++ )
									{
										requestarray[Offset] = gSAL_Extension[SiriusAlertListLine][i];
										Offset++;
									}
								}
                            }
							if( audioListDelFlg == 0x0 )
								current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                    }//end while
                    break;
                case 1: //Attributes,Presentindex,Name,Frequency
                    while ( current_element < elements )
                    {
                        if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
                                    if( indexsize )
                                    {
                                        requestarray[Offset] = ( gSAL_Pos[SiriusAlertListLine] & 0xFF );
                                        Offset++;
                                        requestarray[Offset] = (( gSAL_Pos[SiriusAlertListLine] & 0xFF00 ) / 0x100 );
                                        Offset++;
                                    }
                                    else
                                    {
                                        requestarray[Offset] = gSAL_Pos[SiriusAlertListLine];
                                        Offset++;
                                    }
                                }

                                //Attributes
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //PresentIndex
                                requestarray[Offset] = gSAL_PresentIndex[SiriusAlertListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gSAL_Name[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Name[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Name[SiriusAlertListLine][i];
                                    Offset++;
                                }

                                //Frequenz
                                requestarray[Offset] = strlen( gSAL_Frequenz[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Frequenz[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Frequenz[SiriusAlertListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                    }//end while
                    break;
                case 2: //Attributes,PresentIndex,Name
                    while ( current_element < elements )
                    {
                        if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                //Attributes
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //PresentIndex
                                requestarray[Offset] = gSAL_PresentIndex[SiriusAlertListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gSAL_Name[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Name[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Name[SiriusAlertListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                    }//end while
                    break;
                case 3://Name
                    while ( current_element < elements )
                    {
                        if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                //Name
                                requestarray[Offset] = strlen( gSAL_Name[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Name[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Name[SiriusAlertListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                    }//end while
                    break;
                case 4: //Attributes,Frequency
                    while ( current_element < elements )
                    {
                        if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                //Attributes
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //Frequenz
                                requestarray[Offset] = strlen( gSAL_Frequenz[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Frequenz[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Frequenz[SiriusAlertListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                    }//end while
                    break;
                case 5: //Attributes,PresetID,Name,Frequency,AlertType,AlertName
                    while ( current_element < elements )
                    {
                        if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                //Attributes
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0x00ff );
                                Offset++;
                                requestarray[Offset] = ( gSAL_Attributes[SiriusAlertListLine] & 0xFF00 ) / 0x100;
                                Offset++;

                                //PresentIndex
                                requestarray[Offset] = gSAL_PresentIndex[SiriusAlertListLine];
                                Offset++;

                                //Name
                                requestarray[Offset] = strlen( gSAL_Name[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Name[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Name[SiriusAlertListLine][i];
                                    Offset++;
                                }

                                //Frequenz
                                requestarray[Offset] = strlen( gSAL_Frequenz[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_Frequenz[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_Frequenz[SiriusAlertListLine][i];
                                    Offset++;
                                }

                                //AlertType
                                requestarray[Offset] = gSAL_AlertType[SiriusAlertListLine];
                                Offset++;

                                //AlertName
                                requestarray[Offset] = strlen( gSAL_AlertName[SiriusAlertListLine] );
                                Offset++;
                                for( i = 0; i < strlen( gSAL_AlertName[SiriusAlertListLine] ); i++ )
                                {
                                    requestarray[Offset] = gSAL_AlertName[SiriusAlertListLine][i];
                                    Offset++;
                                }
                            }
                            current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                    }//end while
                    break;
                case 15: //Pos
                    while ( current_element < elements )
                    {
                        if( SiriusAlertListLine == 0xFF ) //Invalid "list entry"
                            {
                                write( "AudioSD SiriusAlertList_Request: invalid SiriusAlertListLine" );
                                current_element = elements;
                            }
                            else //"list entry" valid
                            {
                                /***Array Data***/
                                if( transmitpos ) // Pos  ->Array position transmitted
                                {
								    audioListDelFlg = 0x00;
									audioListDelFlg = audioList_deleteCheck( gSAL_Pos[SiriusAlertListLine], gSiriusAlertList_Pos_insDel, gSAL_CSVtotalElem);
									if (audioListDelFlg == 0x0)
									{
										if( indexsize )
										{
											requestarray[Offset] = ( gSAL_Pos[SiriusAlertListLine] & 0xFF );
											Offset++;
											requestarray[Offset] = (( gSAL_Pos[SiriusAlertListLine] & 0xFF00 ) / 0x100 );
											Offset++;
										}
										else
										{
											requestarray[Offset] = gSAL_Pos[SiriusAlertListLine];
											Offset++;
										}
									}
                                }
                            }
							if( audioListDelFlg == 0x00 )
								current_element++;
                            SiriusAlertListLine = SiriusAlertList_nextvalidLine( SiriusAlertListLine, direction );

                    }//end while
                    break;
                default:
                    write( "AudioSD SiriusAlertList_Request: invalid recordaddress %d", recordaddress );
                    break;
            } //end switch "recordaddress"
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            break; //end Data_REQ
          case Error_REQ:
            requestarray[3] = errorcode;

            set_status_requestbuffer( requestarray, 4, Bap_Error );
            break; //end Error_REQ
    } //end switch "request"
}

void SiriusAlertList_init_CSV() //Byte & file selection
{
    dword CSVfileHandle = 0, ConfigFileHandle = 0, i = 0, j = 0, Num_of_csv_byte = 0, element = 0, current_CSV_line = 0, count1 = 0, count2 = 0;
    char buffer_string[AUDIO_BUFFERSIZE], Path_CSV[AUDIO_BUFFERSIZE], Path_Config[AUDIO_BUFFERSIZE];
    byte SiriusAlertListLine = 0, buffer_byte[AUDIO_BUFFERSIZE];
    char SiriusAlertList_Pos_string[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_TEXTLENGTH];        //help value ->"POS" is stored in the ASCII(UTF-8 ) code in the *.csv
    char SiriusAlertList_PIndex_string[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"PresentIndex" is stored in the ASCII(UTF-8 ) code in the *.csv
    char SiriusAlertList_Name_string[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Name" is stored in the ASCII(UTF-8 ) code in the *.csv
    char SiriusAlertList_Frequenz_string[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_TEXTLENGTH]; //help value ->"Frequenz" is stored in the ASCII(UTF-8 ) code in the *.csv
    char SiriusAlertList_AlertName_string[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"AlertName" is stored in the ASCII(UTF-8 ) code in the *.csv
    char SiriusAlertList_Extension_string[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Extension" is stored in the ASCII(UTF-8 ) code in the *.csv
    char SiriusAlertList_AlertType_string[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"AlertType" is stored in the ASCII(UTF-8 ) code in the *.csv
    char SiriusAlertList_Attributes_string[AUDIO_SIRIUSALERTLIST_ENTRIES][AUDIO_TEXTLENGTH];   //help value ->"Attributes" is stored in the ASCII(UTF-8 ) code in the *.csv

    if( getvalue( env_AudioSD_SAL_CSV_Default ) == AUDIO_EXTERNAL_LIST ) //output data in write window "FSGSiriusAlertList"
    {
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "*******External SiriusAlertList*******" );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "" );
        if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "**********************Start load new SiriusAlertList**********************" );

    //clear
    for( j = 0; j < AUDIO_SIRIUSALERTLIST_ENTRIES; j++ )
    {
        gSAL_Pos[j] = 0;
      gSAL_PresentIndex[j]  = 0;
        gSAL_AlertType[j] = 0;

      gSAL_Attributes[j] = 0;
      gSAL_Attribute_Available_Bit0[j] = 0;
      gSAL_Attribute_TP_Bit1[j] = 0;
      gSAL_Attribute_TMC_Bit2[j] = 0;
      gSAL_Attribute_SDARS_Bit3[j] = 0;
      gSAL_Attribute_StationSelect_Bit4[j] = 0;
      gSAL_Attribute_OnlineRadioMute_Bit5[j] = 0;
      gSAL_Attribute_StationLinked_Bit6[j] = 0;

      for( i = 0; i < AUDIO_SIRIUSALERT_NAME_LENGTH; i++ )
        gSAL_Name[j][i] = 0;

      for( i = 0; i < AUDIO_SIRIUSALERT_FREQUENZ_LENGTH; i++ )
        gSAL_Frequenz[j][i] = 0;

      for( i = 0; i < AUDIO_SIRIUSALERT_ALERTNAME_LENGTH; i++ )
        gSAL_AlertName[j][i] = 0;

      for( i = 0; i < AUDIO_SIRIUSALERT_EXTENSION_LENGTH; i++ )
        gSAL_Extension[j][i] = 0;
    }

    for( i = 0; i < AUDIO_FILENAME_SIZE; i++ ) //clear "filename"
          gSAL_CSV_filename[i] = 0;

    for( j = 0; j < AUDIO_SIRIUSALERTLIST_ENTRIES; j++ ) //clear "buffer"
    {
      buffer_string[j]    = 0;
      buffer_byte[j]      = 0;

      for( i = 0; i < AUDIO_TEXTLENGTH; i++ ) //clear help value
      {
        SiriusAlertList_Pos_string[j][i] = 0;
        SiriusAlertList_Name_string[j][i] = 0;
        SiriusAlertList_Frequenz_string[j][i] = 0;
        SiriusAlertList_AlertName_string[j][i] = 0;
        SiriusAlertList_Extension_string[j][i] = 0;
      }
    }

    i = 0; j = 0; SiriusAlertListLine = 0; current_CSV_line = 0; //reset values

    getvalue( env_AudioSD_SAL_CSV_Path, Path_CSV); //get filename & path of *.csv-file from Panel

    //write( "complete path *.csv: %s", Path_CSV); //debug

    i = 0;

    while ( Path_CSV[i] != 0 ) //scan "path"
    {
        if( Path_CSV[i] == 0x5C) //count "/" to seperate later "path" & "filename"
            count1++;

        //write( "Path[%d] of *.csv: %x",i, Path_CSV[i] ); //debug
        i++;
    }

    i = 0; j = 0; //reset values

    while ( Path_CSV[i] != 0 ) //seperate "path" and "filename"
    {
        if( count2==count1 ) //get filename after last "\"
        {
            gSAL_CSV_filename[j] = Path_CSV[i];
            j++;

            Path_CSV[i] = 0;
        }

        if( Path_CSV[i] == 0x5C) //count "\" to get filename after last "\"
            count2++;

        i++;
    }

    if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "path of *.csv: %s", Path_CSV);        //output file path

    if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "filename of *.csv: '%s'", gSAL_CSV_filename );  //output filename

    putvalue( env_AudioSD_SAL_CSV_Current, gSAL_CSV_filename ); //output current loaded *.csv-file on panel

    setFilePath( Path_CSV, 0 ); //set path for *.csv file

    CSVfileHandle =openFileRead( gSAL_CSV_filename,1 ); //open *.csv ( binary-mode ->get the ASCII/UTF-8 code )

    if( CSVfileHandle!= 0 ) //*.csv file access successful
    {
      if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Dateizugriff auf '%s' erfolgreich", gSAL_CSV_filename );    //output result

      putvalue( env_AudioSD_SAL_CSV_Result, "successful" );   //output result on panel

      Num_of_csv_byte = fileGetBinaryBlock( buffer_byte, elcount( buffer_byte ), CSVfileHandle );//get data from *.csv and store the total number of byte in *.csv-file

      for( i = 0; i <Num_of_csv_byte; i++ ) //copy data into "FavoriteList"
      {
        if( buffer_byte[i] != 0x3B) //read data if no ";" is detected
        {
          if( buffer_byte[i] == 0x0D && buffer_byte[i + 1] == 0x0A) //nextline in *.csv (next "record element" in LastStationList ) -> "LF" and "CR" detected -> copy ( transform string -> long ) data from help values in global values
          {
            if( current_CSV_line> 0 && SiriusAlertListLine < AUDIO_SIRIUSALERTLIST_ENTRIES) //ignore first line in *.csv file
            {
              if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "" );
              if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "*******Element %d*******", SiriusAlertListLine );

              //transform 'string' to 'long'
              gSAL_Pos[SiriusAlertListLine] = atol( SiriusAlertList_Pos_string[SiriusAlertListLine] );
              gSAL_PresentIndex[SiriusAlertListLine] = atol( SiriusAlertList_PIndex_string[SiriusAlertListLine] );
              gSAL_AlertType[SiriusAlertListLine] = atol( SiriusAlertList_AlertType_string[SiriusAlertListLine] );
              gSAL_Attributes[SiriusAlertListLine] = atol( SiriusAlertList_Attributes_string[SiriusAlertListLine] );

              if( boTraceStatus_ON )
              {
              writelineEx( gBAP_Trace, 0, "Pos[%d]: 0x%x", SiriusAlertListLine, gSAL_Pos[SiriusAlertListLine] );
              writelineEx( gBAP_Trace, 0, "Presentindex[%d]: 0x%x", SiriusAlertListLine, gSAL_PresentIndex[SiriusAlertListLine] );

              if( gSAL_AlertType[SiriusAlertListLine] < 0x8 )
                  writelineEx( gBAP_Trace, 0, "AlertType -> '%s'", gSAL_AlertType_s[gSAL_AlertType[SiriusAlertListLine]] );
              else
                  writelineEx( gBAP_Trace, 0, "AlertType -> '%s'", gstring_reserved );

              writelineEx( gBAP_Trace, 0, "Attributes[%d]: 0x%x", SiriusAlertListLine, gSAL_Attributes[SiriusAlertListLine] );

              if( gSAL_Attributes[SiriusAlertListLine] & 0x01 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit0[%d]: 'available'", SiriusAlertListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit0[%d]: 'not available'", SiriusAlertListLine );

              if( gSAL_Attributes[SiriusAlertListLine] & 0x02 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit1[%d]: 'TP available'", SiriusAlertListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit1[%d]: 'TP not available'", SiriusAlertListLine );

              if( gSAL_Attributes[SiriusAlertListLine] & 0x04 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit2[%d]: 'TMC available'", SiriusAlertListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit2[%d]: 'TMC not available'", SiriusAlertListLine );

              if( gSAL_Attributes[SiriusAlertListLine] & 0x08 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit3[%d]: 'SDARS subscribed'", SiriusAlertListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit3[%d]: 'SDARS not subscribed'", SiriusAlertListLine );

              if( gSAL_Attributes[SiriusAlertListLine] & 0x10 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit4[%d]: 'Station selectable'", SiriusAlertListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit4[%d]: 'Station not selectable'", SiriusAlertListLine );

              if( gSAL_Attributes[SiriusAlertListLine] & 0x20 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit5[%d]: 'Online Radio muting'", SiriusAlertListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit5[%d]: 'Online Radio not muted'", SiriusAlertListLine );

              if( gSAL_Attributes[SiriusAlertListLine] & 0x40 )
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit6[%d]: 'Station linked to Online Radio'", SiriusAlertListLine );
              else
                  writelineEx( gBAP_Trace, 0, "Attributes_Bit6[%d]: 'Station not linked to Online Radio'", SiriusAlertListLine );

              writelineEx( gBAP_Trace, 0, "Name[%d]: %s", SiriusAlertListLine, gSAL_Name[SiriusAlertListLine] );
              writelineEx( gBAP_Trace, 0, "Frequenz[%d]: %s", SiriusAlertListLine, gSAL_Frequenz[SiriusAlertListLine] );
              writelineEx( gBAP_Trace, 0, "AlertName[%d]: %s", SiriusAlertListLine, gSAL_AlertName[SiriusAlertListLine] );
              writelineEx( gBAP_Trace, 0, "Extension[%d]: %s", SiriusAlertListLine, gSAL_Extension[SiriusAlertListLine] );
              }
              gSAL_ListEntryValidInformation[SiriusAlertListLine]  = TRUE;

              SiriusAlertListLine++; // -> next line in *.csv (next record element )
            }
            current_CSV_line++; //next line in *.csv file
            element = 0; //start at 'POS' ( first record element of "array data" )
            j = 0; //reset value
          }
          else if( current_CSV_line> 0 && SiriusAlertListLine < AUDIO_SIRIUSALERTLIST_ENTRIES) //copy data from "buffer_byte" ( data from *.csv file ) in help values and "name" until end of line is not detected
          {
            switch(  element )
            {
              case 0: //POS
                      SiriusAlertList_Pos_string[SiriusAlertListLine][j] =buffer_byte[i];
                      j++;
               break;
              case 1: //PresentIndex
                      SiriusAlertList_PIndex_string[SiriusAlertListLine][j] =buffer_byte[i];
                      j++;
               break;
              case 2: //AlertType
                      SiriusAlertList_AlertType_string[SiriusAlertListLine][j] =buffer_byte[i];
                      j++;
               break;
              case 3: //Attributes
                      SiriusAlertList_Attributes_string[SiriusAlertListLine][j] =buffer_byte[i];
                      j++;
               break;
              case 4: //Name
                      gSAL_Name[SiriusAlertListLine][j] =buffer_byte[i];
                      j++;
               break;
              case 5: //Frequenz
                      gSAL_Frequenz[SiriusAlertListLine][j] =buffer_byte[i];
                      j++;
               break;
                case 6: //AlertName
                      gSAL_AlertName[SiriusAlertListLine][j] =buffer_byte[i];
                      j++;
               break;
                case 7: //Extension
                      gSAL_Extension[SiriusAlertListLine][j] =buffer_byte[i];
                      j++;
               break;
              default:
               break;
            }
          }
        }
        else  // ";" is detected ->next record element of "array data"
        {
          element++;
          j = 0; //reset value
        }
      }
      gSAL_TNLE = gSAL_sum = gSiriusAlertList_TotalNumListElements = gSAL_CSVtotalElem = SiriusAlertListLine; //get "total number of list elements"

      putvalue( env_AudioSD_SAL_TNLE, gSAL_TNLE );

      if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "" );

      if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Anzahl der Listenelemente: %d", gSAL_sum); //output total number of list elements

      writelineEx( gBAP_Trace, 0, "" );

      if( fileClose( CSVfileHandle ) != 0 ) //close *.csv file
          { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Datei '%s' geschlossen", gSAL_CSV_filename ); }  //output result }
      else
          { if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Fehler beim Schlieen der Datei '%s'", gSAL_CSV_filename ); } //output result }
    }

    else //*.csv file access not successful
    {
      writelineEx( gBAP_Trace, 0, "Fehler beim Dateizugriff auf '%s'", gSAL_CSV_filename ); //output result

      putvalue( env_AudioSD_SAL_CSV_Result, "not successful" ); //output result
    }
	
	
	for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
	{
		gSiriusAlertList_Pos_insDel[i] [0] = 0;
		gSiriusAlertList_Pos_insDel[i] [1] = 0;
		gSiriusAlertList_Pos_insDel[i] [2] = 0;
	}
	
	gAudioSD_CSIhandle_FSGhandle = gSAL_Pos[0];
	putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );

	gAudioSD_CSIhandle_FSGhandle_absolutePos = 0x01;
	putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );

	for( i = 0; i < gSiriusAlertList_TotalNumListElements; i++ )
		gSiriusAlertList_Pos_insDel[i] [0] = gSAL_Pos[i];

	if( getValue( env_AudioSD_SAL_insert_UPD_button ) == 0x00 )
	{
		for( i = 0; i < gSiriusAlertList_TotalNumListElements; i++ )
			gSiriusAlertList_Pos_insDel[i] [2] = i + 1;

		gSAL_totalDELctr = 0;
	}
  }
}

on envVar env_AudioSD_SAL_Status
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i, transSuppression;

  // Init local variables.
  mode                    = 0;
  shift                   = 0;
  direction               = 0;
  transmitpos             = 0;
  indexsize               = 0;
  recordaddress           = 0;
  requested_startelement  = 0;
  startelement            = 0;
  elements                = 0;
  valid_startelement      = 0;
  i                       = 0;
  valid_elements          = 0;
  transSuppression        = getvalue( env_AudioSD_SAL_StatusOFF );

  if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
    if( getvalue( env_AudioSD_SAL_AH_Start ) >255 && getvalue( env_AudioSD_SAL_AH_IndexSize ) == 0 ) // check if 8 or 16 bit
        putvalue( env_AudioSD_SAL_AH_IndexSize,1 );

    //get data from Panel
    gSAL_ASGID= getvalue( env_AudioSD_SAL_AsgId );
    gSAL_TAID = getvalue( env_AudioSD_SAL_TAID);
    gSAL_TNLE = getvalue( env_AudioSD_SAL_TNLE );

    recordaddress   = getvalue( env_AudioSD_SAL_AH_RecordAdd );
    shift           = getvalue( env_AudioSD_SAL_AH_Shift );
    direction       = getvalue( env_AudioSD_SAL_AH_Dir );
    transmitpos     = getvalue( env_AudioSD_SAL_AH_TransPos );
    indexsize       = getvalue( env_AudioSD_SAL_AH_IndexSize );
    startelement    = getvalue( env_AudioSD_SAL_AH_Start );
    elements        = getvalue( env_AudioSD_SAL_AH_Elements );

    mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

    requested_startelement = startelement;

    /***Startelement = 0***/
    if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
        {
      if( FORWARD==direction )  //forward-start
            {
        valid_startelement = 0;

        if( AUDIO_SIRIUSALERTLIST_ENTRIES <= elements ) //1. more elements requested, than in array
                {
          if( shift == FALSE )
          {
            for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
                        {
                          if( 0 != gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                              i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                      }
          }
          else if( shift == TRUE )
          {
            valid_startelement  = startelement;
                  valid_elements      = 0;
          }
              }
        else    //2. number of requested elements < elements in array
                {
          if( shift == FALSE )
          {
                      for( i = 0; i < elements; i++ )
                        {
                          if( 0!= gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                            i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                      }
          }
          else if( shift == TRUE )
          {
            valid_startelement  = startelement;
                      valid_elements      = 0;
          }
                }
      }
      else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
            {
              //searching for valid startelement
                for( i = ( AUDIO_SIRIUSALERTLIST_ENTRIES-1 ); i>= 0; i--)
                {
                  if( 0!= gSAL_ListEntryValidInformation[i] )        //found valid startelement
                    {
                      valid_startelement = i;
                        i = 0;
                    }
                }
        //searching for valid elements
                if( 0xff ==valid_startelement ) //Startelement-ID doesn't exist in SMSReceived-array
                {
                  valid_startelement  = startelement;
                    valid_elements      = 0;
                }
                else if( 0 ==valid_startelement )
                  valid_elements= 1;//only 1 element because valid startelement is on position 0
                else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                {
                  for( i =valid_startelement; i>= 0; i--)
                    {
                      if( 0!= gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                          valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                          i = 0;
                  }
                }
        else                                                        //enougth array-elements available
                {
                  for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                    {
                      if( 0!= gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                          valid_elements++;                                //increment elements
                        else                                                //no valid element, loop finished
                            i = 0;
                    }
                }
        }                                                               //backward-end
    }
    /***Startelement!= 0***/
    else                                                                //searching for Startelement-ID
        {
          //searching for valid startelement
            for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
            {
                if( gSAL_Pos[i] == startelement )                        //found a valid element
                {
          if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                    {
                      if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                          valid_startelement = i + 1-2* direction;
            else if( i == 0 && BACKWARD==direction )
              valid_startelement = gSAL_sum;     //valid element is last element in Array
            else if( i == 0 && FORWARD==direction )
              valid_startelement = 0;                          //valid element is first element in Array
          }
          else
            valid_startelement = i;                              //found element is valid_startelement
                    i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                }
        else
          valid_startelement = 0xff;
            }

            if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
            {
                valid_startelement  = startelement;
                valid_elements      = 0;
            }
            else                                                                //found valid entry for startelement in array
            {
              //verify number of valid elements
                if( BACKWARD==direction )                                            //backward-start
                {
                  if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                      valid_elements= 1;
                    else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                  {
                      for( i =valid_startelement; i>= 0; i--)
                      {
                          if( 0!= gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
              else                                                //no valid element, loop finished
                              i = 0;
                        }
                  }
                    else                                                        //enougth array-elements available
                    {
                      for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                        {
                          if( 0!= gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                                i = 0;
                        }
                    }
                }                                                                //backward-end
                else                                                            //forward-start
                {
                  if((valid_startelement+elements )>= AUDIO_SIRIUSALERTLIST_ENTRIES)
                    {
                      for( i =valid_startelement; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
                        {
                          if( 0!= gSAL_Pos[i] )                            //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                              i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                        }
                    }
                    else
                    {
                      for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                        {
                          if( 0!= gSAL_Pos[i] )                            //if there is an valid element
                              valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                              i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                        }
                    }
                }
            }
        }
    putvalue( env_AudioSD_SAL_AH_Elements, valid_elements );

    //send StatusArray
    if(!transSuppression )
    {
        SiriusAlertList_Request( Data_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
    }
  }
}

byte SiriusAlertList_nextvalidLine( byte current_SiriusAlertListLine, byte direction )
{
  byte next_SiriusAlertListLine;
  int i;

  //init lokal variables
  next_SiriusAlertListLine = 0;
  i = 0;

  //search next "list entry"
  if( (( gSAL_sum - 1 ) == current_SiriusAlertListLine && FORWARD == direction ) || ( 0 == current_SiriusAlertListLine && BACKWARD == direction ) )  //last-/fist-element of array reached
      next_SiriusAlertListLine = 0xFF;
  else
  {
      next_SiriusAlertListLine = current_SiriusAlertListLine + 1 - 2 * direction;       //increment or decrement array-line ( depends on direction );

      if( 0 == gSAL_ListEntryValidInformation[next_SiriusAlertListLine] )    // check if next element is "valid"
          next_SiriusAlertListLine = 0xff;
  }
  return (next_SiriusAlertListLine );
}

void SiriusAlertList_init_static()
{
    byte j, i, SiriusAlertListLine;

    //clear
    SiriusAlertListLine = 0;
    gSAL_sum = 0;

    for( j = 0; j < AUDIO_SIRIUSALERTLIST_ENTRIES; j++ )
    {
      gSAL_Pos[j] = 0;
      gSAL_PresentIndex[j] = 0;
      gSAL_AlertType[j] = 0;
      gSAL_Attributes[j] = 0;

      gSAL_Attribute_Available_Bit0[j] = 0;
      gSAL_Attribute_TP_Bit1[j] = 0;
      gSAL_Attribute_TMC_Bit2[j] = 0;
      gSAL_Attribute_SDARS_Bit3[j] = 0;
      gSAL_Attribute_StationSelect_Bit4[j] = 0;
      gSAL_Attribute_OnlineRadioMute_Bit5[j] = 0;
      gSAL_Attribute_StationLinked_Bit6[j] = 0;

      gSAL_ListEntryValidInformation[j] = 0;

      for( i = 0; i < AUDIO_SIRIUSALERT_NAME_LENGTH; i++ )
        gSAL_Name[j][i] = 0;
      for( i = 0; i < AUDIO_SIRIUSALERT_FREQUENZ_LENGTH; i++ )
        gSAL_Frequenz[j][i] = 0;
      for( i = 0; i < AUDIO_SIRIUSALERT_ALERTNAME_LENGTH; i++ )
        gSAL_AlertName[j][i] = 0;
      for( i = 0; i < AUDIO_SIRIUSALERT_EXTENSION_LENGTH; i++ )
        gSAL_Extension[j][i] = 0;
    }

    //entry 0
    gSAL_ListEntryValidInformation[SiriusAlertListLine] = TRUE;
    gSAL_Pos[SiriusAlertListLine] = 0xF1;
    gSAL_PresentIndex[SiriusAlertListLine] = 0xA;
    gSAL_AlertType[SiriusAlertListLine] = 0x02;

    gSAL_Attribute_Available_Bit0[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_TP_Bit1[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_TMC_Bit2[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_SDARS_Bit3[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_StationSelect_Bit4[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_OnlineRadioMute_Bit5[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_StationLinked_Bit6[SiriusAlertListLine] = FALSE;
    gSAL_Attributes[SiriusAlertListLine] = gSAL_Attribute_Available_Bit0[SiriusAlertListLine]
                                          + ( gSAL_Attribute_TP_Bit1[SiriusAlertListLine] * 0x02 )
                                          + ( gSAL_Attribute_TMC_Bit2[SiriusAlertListLine] * 0x04 )
                                          + ( gSAL_Attribute_SDARS_Bit3[SiriusAlertListLine] * 0x08 )
                                          + ( gSAL_Attribute_StationSelect_Bit4[SiriusAlertListLine] * 0x10 )
                                          + ( gSAL_Attribute_OnlineRadioMute_Bit5[SiriusAlertListLine] * 0x20 )
                                          + ( gSAL_Attribute_StationLinked_Bit6[SiriusAlertListLine] * 0x40 );

    strncpy( gSAL_Name[SiriusAlertListLine], "Name_0", AUDIO_SIRIUSALERT_NAME_LENGTH);
    strncpy( gSAL_Frequenz[SiriusAlertListLine], "Frequenz_0", AUDIO_SIRIUSALERT_FREQUENZ_LENGTH);
    strncpy( gSAL_AlertName[SiriusAlertListLine], "Alert_0", AUDIO_SIRIUSALERT_ALERTNAME_LENGTH);
    strncpy( gSAL_Extension[SiriusAlertListLine], "Extension_0", AUDIO_SIRIUSALERT_EXTENSION_LENGTH);
    SiriusAlertListLine++;

    //entry 1
    gSAL_ListEntryValidInformation[SiriusAlertListLine] = TRUE;
    gSAL_Pos[SiriusAlertListLine] = 0x1B;
    gSAL_PresentIndex[SiriusAlertListLine] = 0xA5;
    gSAL_AlertType[SiriusAlertListLine] = 0x01;

    gSAL_Attribute_Available_Bit0[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_TP_Bit1[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_TMC_Bit2[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_SDARS_Bit3[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_StationSelect_Bit4[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_OnlineRadioMute_Bit5[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_StationLinked_Bit6[SiriusAlertListLine] = TRUE;
    gSAL_Attributes[SiriusAlertListLine] = gSAL_Attribute_Available_Bit0[SiriusAlertListLine]
                                          + ( gSAL_Attribute_TP_Bit1[SiriusAlertListLine] * 0x02 )
                                          + ( gSAL_Attribute_TMC_Bit2[SiriusAlertListLine] * 0x04 )
                                          + ( gSAL_Attribute_SDARS_Bit3[SiriusAlertListLine] * 0x08 )
                                          + ( gSAL_Attribute_StationSelect_Bit4[SiriusAlertListLine] * 0x10 )
                                          + ( gSAL_Attribute_OnlineRadioMute_Bit5[SiriusAlertListLine] * 0x20 )
                                          + ( gSAL_Attribute_StationLinked_Bit6[SiriusAlertListLine] * 0x40 );

    strncpy( gSAL_Name[SiriusAlertListLine], "Name_1", AUDIO_SIRIUSALERT_NAME_LENGTH);
    strncpy( gSAL_Frequenz[SiriusAlertListLine], "Frequenz_1", AUDIO_SIRIUSALERT_FREQUENZ_LENGTH);
    strncpy( gSAL_AlertName[SiriusAlertListLine], "Alert_1", AUDIO_SIRIUSALERT_ALERTNAME_LENGTH);
    strncpy( gSAL_Extension[SiriusAlertListLine], "Extension_1", AUDIO_SIRIUSALERT_EXTENSION_LENGTH);
    SiriusAlertListLine++;

    //entry 2
    gSAL_ListEntryValidInformation[SiriusAlertListLine] = FALSE;
    gSAL_Pos[SiriusAlertListLine] = 0x1;
    gSAL_PresentIndex[SiriusAlertListLine] = 0xF;
    gSAL_AlertType[SiriusAlertListLine] = 0x00;

    gSAL_Attribute_Available_Bit0[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_TP_Bit1[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_TMC_Bit2[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_SDARS_Bit3[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_StationSelect_Bit4[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_OnlineRadioMute_Bit5[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_StationLinked_Bit6[SiriusAlertListLine] = FALSE;
    gSAL_Attributes[SiriusAlertListLine] = gSAL_Attribute_Available_Bit0[SiriusAlertListLine]
                                          + ( gSAL_Attribute_TP_Bit1[SiriusAlertListLine] * 0x02 )
                                          + ( gSAL_Attribute_TMC_Bit2[SiriusAlertListLine] * 0x04 )
                                          + ( gSAL_Attribute_SDARS_Bit3[SiriusAlertListLine] * 0x08 )
                                          + ( gSAL_Attribute_StationSelect_Bit4[SiriusAlertListLine] * 0x10 )
                                          + ( gSAL_Attribute_OnlineRadioMute_Bit5[SiriusAlertListLine] * 0x20 )
                                          + ( gSAL_Attribute_StationLinked_Bit6[SiriusAlertListLine] * 0x40 );

    strncpy( gSAL_Name[SiriusAlertListLine], "Name_2", AUDIO_SIRIUSALERT_NAME_LENGTH);
    strncpy( gSAL_Frequenz[SiriusAlertListLine], "Frequenz_2", AUDIO_SIRIUSALERT_FREQUENZ_LENGTH);
    strncpy( gSAL_AlertName[SiriusAlertListLine], "Alert_2", AUDIO_SIRIUSALERT_ALERTNAME_LENGTH);
    strncpy( gSAL_Extension[SiriusAlertListLine], "Extension_2", AUDIO_SIRIUSALERT_EXTENSION_LENGTH);
    SiriusAlertListLine++;

    //entry 3
    gSAL_ListEntryValidInformation[SiriusAlertListLine] = TRUE;
    gSAL_Pos[SiriusAlertListLine] = 0x12;
    gSAL_PresentIndex[SiriusAlertListLine] = 0x5F;
    gSAL_AlertType[SiriusAlertListLine] = 0x05;

    gSAL_Attribute_Available_Bit0[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_TP_Bit1[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_TMC_Bit2[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_SDARS_Bit3[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_StationSelect_Bit4[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_OnlineRadioMute_Bit5[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_StationLinked_Bit6[SiriusAlertListLine] = TRUE;
    gSAL_Attributes[SiriusAlertListLine] = gSAL_Attribute_Available_Bit0[SiriusAlertListLine]
                                          + ( gSAL_Attribute_TP_Bit1[SiriusAlertListLine] * 0x02 )
                                          + ( gSAL_Attribute_TMC_Bit2[SiriusAlertListLine] * 0x04 )
                                          + ( gSAL_Attribute_SDARS_Bit3[SiriusAlertListLine] * 0x08 )
                                          + ( gSAL_Attribute_StationSelect_Bit4[SiriusAlertListLine] * 0x10 )
                                          + ( gSAL_Attribute_OnlineRadioMute_Bit5[SiriusAlertListLine] * 0x20 )
                                          + ( gSAL_Attribute_StationLinked_Bit6[SiriusAlertListLine] * 0x40 );

    strncpy( gSAL_Name[SiriusAlertListLine], "Name_3", AUDIO_SIRIUSALERT_NAME_LENGTH);
    strncpy( gSAL_Frequenz[SiriusAlertListLine], "Frequenz_3", AUDIO_SIRIUSALERT_FREQUENZ_LENGTH);
    strncpy( gSAL_AlertName[SiriusAlertListLine], "Alert_3", AUDIO_SIRIUSALERT_ALERTNAME_LENGTH);
    strncpy( gSAL_Extension[SiriusAlertListLine], "Extension_3", AUDIO_SIRIUSALERT_EXTENSION_LENGTH);
    SiriusAlertListLine++;

    //entry 4
    gSAL_ListEntryValidInformation[SiriusAlertListLine] = TRUE;
    gSAL_Pos[SiriusAlertListLine] = 0x13;
    gSAL_PresentIndex[SiriusAlertListLine] = 0x3F;
    gSAL_AlertType[SiriusAlertListLine] = 0x03;

    gSAL_Attribute_Available_Bit0[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_TP_Bit1[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_TMC_Bit2[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_SDARS_Bit3[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_StationSelect_Bit4[SiriusAlertListLine] = FALSE;
    gSAL_Attribute_OnlineRadioMute_Bit5[SiriusAlertListLine] = TRUE;
    gSAL_Attribute_StationLinked_Bit6[SiriusAlertListLine] = FALSE;
    gSAL_Attributes[SiriusAlertListLine] = gSAL_Attribute_Available_Bit0[SiriusAlertListLine]
                                          + ( gSAL_Attribute_TP_Bit1[SiriusAlertListLine] * 0x02 )
                                          + ( gSAL_Attribute_TMC_Bit2[SiriusAlertListLine] * 0x04 )
                                          + ( gSAL_Attribute_SDARS_Bit3[SiriusAlertListLine] * 0x08 )
                                          + ( gSAL_Attribute_StationSelect_Bit4[SiriusAlertListLine] * 0x10 )
                                          + ( gSAL_Attribute_OnlineRadioMute_Bit5[SiriusAlertListLine] * 0x20 )
                                          + ( gSAL_Attribute_StationLinked_Bit6[SiriusAlertListLine] * 0x40 );

    strncpy( gSAL_Name[SiriusAlertListLine], "Name_4", AUDIO_SIRIUSALERT_NAME_LENGTH);
    strncpy( gSAL_Frequenz[SiriusAlertListLine], "Frequenz_4", AUDIO_SIRIUSALERT_FREQUENZ_LENGTH);
    strncpy( gSAL_AlertName[SiriusAlertListLine], "Alert_4", AUDIO_SIRIUSALERT_ALERTNAME_LENGTH);
    strncpy( gSAL_Extension[SiriusAlertListLine], "Extension_4", AUDIO_SIRIUSALERT_EXTENSION_LENGTH);
    SiriusAlertListLine++;

    gSAL_sum = gSiriusAlertList_TotalNumListElements = gSAL_CSVtotalElem = SiriusAlertListLine;
    gSAL_TNLE = gSAL_sum;

    for( i = 0; i < gSAL_sum; i++ )
    {
        if( boTraceStatus_ON ) 
        {
      writelineEx( gBAP_Trace, 0, "*******Element %d*******", i);

      writelineEx( gBAP_Trace, 0, "Pos[%d]: 0x%x", i, gSAL_Pos[i] );
      writelineEx( gBAP_Trace, 0, "PresentIndex[%d]: 0x%x", i, gSAL_PresentIndex[i] );

      if( gSAL_AlertType[i] < 0x8 )
        writelineEx( gBAP_Trace, 0, "AlertType -> '%s'", gSAL_AlertType_s[gSAL_AlertType[i]] );
      else
        writelineEx( gBAP_Trace, 0, "AlertType -> '%s'", gstring_reserved );

      writelineEx( gBAP_Trace, 0, "Attributes[%d]: 0x%x", i, gSAL_Attributes[i] );
      if( gSAL_Attributes[i] & 0x01 )
          writelineEx( gBAP_Trace, 0, "Attributes_Bit0[%d]: 'available'", i);
      else
          writelineEx( gBAP_Trace, 0, "Attributes_Bit0[%d]: 'not available'", i);

      if( gSAL_Attributes[i] & 0x02 )
          writelineEx( gBAP_Trace, 0, "Attributes_Bit1[%d]: 'TP available'", i);
      else
          writelineEx( gBAP_Trace, 0, "Attributes_Bit1[%d]: 'TP not available'", i);

      if( gSAL_Attributes[i] & 0x04 )
          writelineEx( gBAP_Trace, 0, "Attributes_Bit2[%d]: 'TMC available'", i);
      else
          writelineEx( gBAP_Trace, 0, "Attributes_Bit2[%d]: 'TMC not available'", i);

      if( gSAL_Attributes[i] & 0x08 )
          writelineEx( gBAP_Trace, 0, "Attributes_Bit3[%d]: 'SDARS subscribed'", i);
      else
          writelineEx( gBAP_Trace, 0, "Attributes_Bit3[%d]: 'SDARS not subscribed'", i);

      if( gSAL_Attributes[i] & 0x10 )
          writelineEx( gBAP_Trace, 0, "Attributes_Bit4[%d]: 'Station selectable'", i);
      else
          writelineEx( gBAP_Trace, 0, "Attributes_Bit4[%d]: 'Station not selectable'", i);

      if( gSAL_Attributes[i] & 0x20 )
          writelineEx( gBAP_Trace, 0, "Attributes_Bit5[%d]: 'Online Radio muting'", i);
      else
          writelineEx( gBAP_Trace, 0, "Attributes_Bit5[%d]: 'Online Radio not muted'", i);

            if( gSAL_Attributes[i] & 0x40 )
                writelineEx( gBAP_Trace, 0, "Attributes_Bit6[%d]: 'Station linked to Online Radio'", i);
            else
                writelineEx( gBAP_Trace, 0, "Attributes_Bit6[%d]: 'Station not linked to Online Radio'", i);

            writelineEx( gBAP_Trace, 0, "Name[%d]: %s", i, gSAL_Name[i] );
            writelineEx( gBAP_Trace, 0, "Frequenz[%d]: %s", i, gSAL_Frequenz[i] );
            writelineEx( gBAP_Trace, 0, "AlertName[%d]: %s", i, gSAL_AlertName[i] );
            writelineEx( gBAP_Trace, 0, "Extension[%d]: %s", i, gSAL_Extension[i] );
        }
    }
    putvalue( env_AudioSD_SAL_TNLE, gSAL_TNLE );
	
	for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
	{
		gSiriusAlertList_Pos_insDel[i] [0] = 0;
		gSiriusAlertList_Pos_insDel[i] [1] = 0;
		gSiriusAlertList_Pos_insDel[i] [2] = 0;
	}
	
	//gAudioSD_CSIhandle_FSGhandle = gSAL_Pos[0];
    //putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
     //IssueList #72
    gAudioSD_CSIhandle_FSGhandle_absolutePos = 0x01;
    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );

    if( boTraceStatus_ON ) writelineEx( gBAP_Trace, 0, "Anzahl der Listenelemente: %d", gSAL_sum);
}

on envVar env_AudioSD_SAL_Changed
{
  word requested_startelement, startelement, elements, valid_startelement, valid_elements;
  byte mode, shift, direction, transmitpos, indexsize, recordaddress;
  int i;

  // Init local variables.
  mode                    = 0;
  shift                   = 0;
  direction               = 0;
  transmitpos             = 0;
  indexsize               = 0;
  recordaddress           = 0;
  requested_startelement  = 0;
  startelement            = 0;
  elements                = 0;
  valid_startelement      = 0;
  i                       = 0;
  valid_elements          = 0;

  if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
    if( getvalue( env_AudioSD_SAL_AH_Start ) >255 && getvalue( env_AudioSD_SAL_AH_IndexSize ) == 0 ) // check if 8 or 16 bit
        putvalue( env_AudioSD_SAL_AH_IndexSize,1 );

    //get data from Panel
    recordaddress   = getvalue( env_AudioSD_SAL_AH_RecordAdd );
    shift           = getvalue( env_AudioSD_SAL_AH_Shift );
    direction       = getvalue( env_AudioSD_SAL_AH_Dir );
    transmitpos     = getvalue( env_AudioSD_SAL_AH_TransPos );
    indexsize       = getvalue( env_AudioSD_SAL_AH_IndexSize );
    startelement    = getvalue( env_AudioSD_SAL_AH_Start );
    elements        = getvalue( env_AudioSD_SAL_AH_Elements );
    mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

    requested_startelement = startelement;


    /***Startelement = 0***/
    if( getvalue( env_AudioSD_MB_CA_switch ) ) //ArrayData
    {
      if( 0 == startelement ) //Startelement-ID = 0 -> start at first array-entry
      {
        if( FORWARD==direction )  //forward-start
          {
          valid_startelement = 0;

          if( AUDIO_SIRIUSALERTLIST_ENTRIES <= elements ) //1. more elements requested, than in array
              {
            if( shift == FALSE )
            {
              for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
                      {
                          if( 0 != gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                            i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                        }
            }
            else if( shift == TRUE )
            {
              valid_startelement  = startelement;
                        valid_elements      = 0;
            }
                }
          else    //2. number of requested elements < elements in array
                  {
            if( shift == FALSE )
            {
                        for( i = 0; i < elements; i++ )
                          {
                            if( 0!= gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                            else                                                //no valid element, loop finished
                              i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                        }
            }
            else if( shift == TRUE )
            {
              valid_startelement  = startelement;
                        valid_elements      = 0;
            }
                  }
        }//forward ends
        else if( BACKWARD==direction && TRUE== shift )                        //backward-start, only if the shift bit is set ( this means starting with the last element of the array )
              {
                //searching for valid startelement
                  for( i = ( AUDIO_SIRIUSALERTLIST_ENTRIES-1 ); i>= 0; i--)
                  {
                    if( 0!= gSAL_ListEntryValidInformation[i] )        //found valid startelement
                      {
                        valid_startelement = i;
                          i = 0;
                      }
                  }
          //searching for valid elements
                  if( 0xff ==valid_startelement ) //Startelement-ID doesn't exist in SMSReceived-array
                  {
                    valid_startelement  = startelement;
                      valid_elements      = 0;
                  }
                  else if( 0 ==valid_startelement )
                    valid_elements= 1;//only 1 element because valid startelement is on position 0
                  else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                  {
                  for( i =valid_startelement; i>= 0; i--)
                      {
                        if( 0!= gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                            i = 0;
                    }
                  }
          else                                                        //enougth array-elements available
                  {
                    for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                      {
                        if( 0!= gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                            valid_elements++;                                //increment elements
                          else                                                //no valid element, loop finished
                              i = 0;
                      }
                  }
        }//backward-end
      }//startelement == 0 -end

      /***Startelement!= 0***/
      else                                                                //searching for Startelement-ID
          {
            //searching for valid startelement
              for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
              {
                  if( gSAL_Pos[i] == startelement )                        //found a valid element
                  {
            if(shift == TRUE )                                            //shift ist set, this means starting with the next/previous element ( depending on the direction-setting )
                      {
                        if( i!= 0 || BACKWARD!=direction )                        //if valid_startelement is not the first array element or direction is not backwards
                            valid_startelement = i + 1-2* direction;
              else if( i == 0 && BACKWARD==direction )
                valid_startelement = gMediaBrowser_sum;     //valid element is last element in Array
              else if( i == 0 && FORWARD==direction )
                valid_startelement = 0;                          //valid element is first element in Array
            }
            else
              valid_startelement = i;                              //found element is valid_startelement
                      i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                  }
          else
            valid_startelement = 0xff;
              }
              if( 0xff ==valid_startelement )                                        //Startelement-ID doesn't exist in array
              {
                  valid_startelement  = startelement;
                  valid_elements      = 0;
              }
              else                                                                //found valid entry for startelement in array
              {
                //verify number of valid elements
                  if( BACKWARD==direction )                                            //backward-start
                  {
                    if(valid_startelement == 0 )                                    //only 1 element because valid startelement is on position 0
                        valid_elements= 1;
                      else if( elements>(valid_startelement+ 1 ) )                    //not enougth array-elements available, because array endet at array-position 0
                    {
                        for( i =valid_startelement; i>= 0; i--)
                          {
                            if( 0!= gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                else                                                //no valid element, loop finished
                                i = 0;
                          }
                    }
                      else                                                        //enougth array-elements available
                      {
                        for( i =valid_startelement; i>(valid_startelement-elements ); i--)
                          {
                            if( 0!= gSAL_ListEntryValidInformation[i] )    //if there is an valid element
                                valid_elements++;                                //increment elements
                              else                                                //no valid element, loop finished
                                  i = 0;
                          }
                      }
                  }                                                                //backward-end
                  else                                                            //forward-start
                  {
                    if((valid_startelement+elements )>= AUDIO_SIRIUSALERTLIST_ENTRIES)
                      {
                        for( i =valid_startelement; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
                          {
                            if( 0!= gSAL_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                              else                                                //no valid element, loop finished
                                i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                          }
                      }
                      else
                      {
                        for( i =valid_startelement; i <(valid_startelement+elements ); i++ )
                          {
                            if( 0!= gSAL_Pos[i] )                            //if there is an valid element
                                valid_elements++;                                //increment elements
                              else                                                //no valid element, loop finished
                                i = AUDIO_SIRIUSALERTLIST_ENTRIES;
                          }
                      }
                  }
              }
          }
      putvalue( env_AudioSD_SAL_AH_Elements, valid_elements );
      //send ChangedArray
      SiriusAlertList_Request( Changed_REQ, mode, recordaddress, requested_startelement, valid_startelement, valid_elements, 0 );
    }
    else
    {
      //send ChangedArray
      SiriusAlertList_Request( Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0 );
    }
  }
}

on envVar env_AudioSD_SAL_CSV_Default
{
    if( getvalue( this ) == AUDIO_DEFAULT_LIST )
    {
        SiriusAlertList_init_static();
        putvalue( env_AudioSD_SAL_CSV_Current, empty_string );
        putvalue( env_AudioSD_SAL_CSV_Result, empty_string );
    }
}

on envVar env_AudioSD_SAL_CSV_Load //load external FavoriteList from *.csv
{
    if( getvalue( this ) && getvalue( env_AudioSD_SAL_CSV_Default ) == AUDIO_EXTERNAL_LIST )

        SiriusAlertList_init_CSV();

    else if( getvalue( env_AudioSD_SAL_CSV_Default ) != AUDIO_EXTERNAL_LIST )
        putvalue( env_AudioSD_SAL_CSV_Result, "not successful, select 'external *.csv'" );
}

//*****************************

//IssueList #32
on timer Station_Info_Timer
{
    putValue( env_AudioSD_CSI_update, 0x0 );
    cancelTimer( Station_Info_Timer );
}

on envVar BAPCFG_FSG_AudioSD_ProtocolMajor
{
    long temp[3];
    byte ret,i ;
    for( i = 0; i < 4; i++ )
    {
        temp[0] = 0x31;
        temp[1] = i;
        temp[2] = getValue( this );
        ret = Bap180_ChangeConfig( NODE_INDEX, 7, temp);
        if( ret != 0 )
        {
            writeLineEx( gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Major Protocol Version.",NODE_INDEX, ret );
        }
        else
        {
            writeLineEx( gBAP_Trace, 0, "Major Protocol version is set to %d.", getValue( this ) );
        }
    }

}

on envVar BAPCFG_FSG_AudioSD_ProtocolMinor
{
    long temp[3];
    byte ret,i ;
    for( i = 0; i < 4; i++ )
    {
        temp[0] = 0x31;
        temp[1] = i;
        temp[2] = getValue( this );
        ret = Bap180_ChangeConfig( NODE_INDEX, 8, temp);
        if( ret != 0 )
        {
            writeLineEx( gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor  Protocol Version.",NODE_INDEX, ret );
        }
        else
        {
            writeLineEx( gBAP_Trace, 0, "Minor Protocol version is set to %d node is %d.", getValue( this ), NODE_INDEX );
        }
    }
}

on envVar BAPCFG_FSG_AudioSD_LsgClassMajor
{
    long temp[3];
    byte ret,i ;
    for( i = 0; i < 4; i++ )
    {
        temp[0] = 0x31;
        temp[1] = i;
        temp[2] = getValue( this );
        ret = Bap180_ChangeConfig( NODE_INDEX, 5, temp);
        if( ret != 0 )
        {
            writeLineEx( gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Major LSG Class Version.",NODE_INDEX, ret );
        }
    }

}

on envVar BAPCFG_FSG_AudioSD_LsgClassMinor
{
    long temp[3];
    byte ret,i ;
    for( i = 0; i < 4; i++ )
    {
        temp[0] = 0x31;
        temp[1] = i;
        temp[2] = getValue( this );
        ret = Bap180_ChangeConfig( NODE_INDEX, 6, temp);
        if( ret != 0 )
        {
            writeLineEx( gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor LSG Class Version.",NODE_INDEX, ret );
        }
    }
}

on envVar BAPCFG_FSG_AudioSD_DFMajor
{
    long temp[3];
    byte ret,i ;
    for( i = 0; i < 4; i++ )
    {
        temp[0] = 0x31;
        temp[1] = i;
        temp[2] = getValue( this );
        ret = Bap180_ChangeConfig( NODE_INDEX, 9, temp);
        if( ret != 0 )
        {
            writeLineEx( gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Major DF Version.",NODE_INDEX, ret );
        }
    }

}

on envVar BAPCFG_FSG_AudioSD_DFMinor
{
    long temp[3];
    byte ret,i ;
    for( i = 0; i < 4; i++ )
    {
        temp[0] = 0x31;
        temp[1] = i;
        temp[2] = getValue( this );
        ret = Bap180_ChangeConfig( NODE_INDEX, 10, temp);
        if( ret != 0 )
        {
            writeLineEx( gBAP_Trace, 0, "NodeIndex: %d: Error %d occured during setting of Minor DF Version.",NODE_INDEX, ret );
        }
    }
}

//IssueList #34
on envVar env_FSG_Audio_HB_button
{
    long data[2];
    //IssueList #213
    data[0] = LSG_AudioSD;
    if( getValue( this ) )
    {
        data[1] = getValue( env_FSG_Audio_HB_input );
    }
    else
    {
        data[1] = 0;
    }
    ChangeConfig( 0x00, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x0E_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_FSG_Setup;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x0F_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_FSG_OperationState;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x10_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_ActiveSource;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x11_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_ActiveSourceName;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x12_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_CurrentVolume;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x13_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_Mute;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x14_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_SourceState;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x15_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_CurrentStationInfo;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x16_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_CurrentStation_Handle;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x19_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_GeneralInfoSwitches;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x1A_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_TPMemoInfo;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x1E_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_InfoStates;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x1C_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_AnnouncementInfo;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x1F_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_ReceptionListType;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x23_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_MediaBrowser_FolderLevel;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x25_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_MediaPath;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x28_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_PreferredList;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x29_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_SDS_State;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x2A_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_FunctionSynchronisation;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #34
on envVar env_AudioSD_FctList_0x2B_HB
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_ASG_Capabilities;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

//IssueList #68
on timer gAudioFctList_0x18_ProcessingTimer
{
    if( gAudioFctList_0x18_Processing_flg== 0x01 )
    {
        gAudioFctList_0x18_Processing_flg = 0x00;
        gAudioSD_DAC_Result = AUDIO_DAC_NOTSUCCESSFUL;
        DedicatedAudioControl_Request( Result_REQ, 0 );
        putValue( env_AudioSD_FctList_0x18_3min_TO, 0 );
    }
}

//IssueList #68
on timer gAudioFctList_0x1D_ProcessingTimer
{
    if( gAudioFctList_0x1D_Processing_flg== 0x01 )
    {
        gAudioFctList_0x1D_Processing_flg = 0x00;
        gAudioSD_AnnouncementEscape_Result = AUDIO_ANNOUNCEMENTESCAPE_NOTSUCCESSFUL;
        AnnouncementEscape_Request( Result_REQ, 0 );
        putValue( env_AudioSD_FctList_0x1D_3min_TO, 0 );
    }
}

//IssueList #68
on timer gAudioFctList_0x22_ProcessingTimer
{
    if( gAudioFctList_0x22_Processing_flg== 0x01 )
    {
        gAudioFctList_0x22_Processing_flg = 0x00;
        gAudioSD_SwitchSource_Result = AUDIO_SWITCHSOURCERESULT_NOT_SUCCESSFUL;
        SwitchSource_Request( Result_REQ, 0 );
        putValue( env_AudioSD_FctList_0x22_3min_TO, 0 );
    }
}

//IssueList #68
on timer gAudioFctList_0x27_ProcessingTimer
{
    if( gAudioFctList_0x27_Processing_flg== 0x01 )
    {
        gAudioFctList_0x27_Processing_flg = 0x00;
        gAudioSD_MediaFileInfo_Result = AUDIO_MEDIAFILEINFO_NOT_SUCCESSFUL;
        MediaFileInfo_Request( Result_REQ, 0 );
        putValue( env_AudioSD_FctList_0x27_3min_TO, 0 );
    }
}

//IssueList #68
on timer gAudioFctList_0x2C_ProcessingTimer
{
    if( gAudioFctList_0x2C_Processing_flg== 0x01 )
    {
        gAudioFctList_0x2C_Processing_flg = 0x00;
        gAudioSD_GetNextListPos_Result = AUDIO_GETNEXTLISTPOS_NOT_SUCCESSFUL;
        GetNextListPos_Request( Result_REQ, 0 );
        putValue( env_AudioSD_FctList_0x2C_3min_TO, 0 );

    }
}

//IssueList #68
on timer gAudioFctList_0x26_ProcessingTimer
{
    if( gAudioFctList_0x26_Processing_flg== 0x01 )
    {
        gAudioFctList_0x26_Processing_flg= 0x00;
        gAudioSD_MediaBrowserControl_Result = AUDIO_MEDIABROWSERCONTROL_NOT_SUCCESSFUL;
        MediaBrowserControl_Request( Result_REQ, 0 );
        putValue( env_AudioSD_FctList_0x26_3min_TO, 0 );
    }
}

//IssueList #72
void get_AbsolutePos ()
{
    int i = 0;
    switch( gAudioSD_DAC_ListType )
    {

       case AUDIO_DAC_RECEPTIONLIST:
        {
            //IssueList #76 - MR49870 : ReceptionList
            //for( i = 1; i <= gReceptionList_TotalNumListElements; i++ )
            for( i = 1; i <= gRL_CSVtotalElem; i++ )
            {
                //if( gReceptionList_Pos[i-1] == gAudioSD_CSIhandle_FSGhandle )
                if( gReceptionList_Pos_insDel[i-1][0] == gAudioSD_CSIhandle_FSGhandle )
                {
                    //IssueList #76 - MR49870 : ReceptionList
                    //gAudioSD_CSIhandle_FSGhandle_absolutePos = i;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gReceptionList_Pos_insDel[i-1][2];
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    break;
                }
            }
        }
        break;

        case AUDIO_DAC_RADIOTVPRESETLIST:

        {
            //IssueList #76 - MR49870 : RTPL
            //for( i = 1; i <= gRadioTVPresetList_TotalNumListElements; i++ )
            for( i = 1; i <= gRTPL_CSVtotalElem; i++ )
            {
                //if( gRadioTVPresetList_Pos[i-1] == gAudioSD_CSIhandle_PresetListRef )
                if( gRTPL_Pos_insDel[i-1][0] == gAudioSD_CSIhandle_PresetListRef )
                {

                    //IssueList #76 - MR49870 : ReceptionList
                    //gAudioSD_CSIhandle_PresetListabsolutePos = i;
                    gAudioSD_CSIhandle_PresetListabsolutePos = gRTPL_Pos_insDel[i-1][2];;
                    putValue( env_AudioSD_CSH_PresetListAbsPos, gAudioSD_CSIhandle_PresetListabsolutePos );
                    putValue( env_AudioSD_CSH_PresetListRef, gRadioTVPresetList_Pos[i-1] );
                    break;
                }
            }
        }
        break;

        //IssueList #103
        case AUDIO_DAC_MEDIABROWSER:
        {
            //IssueList #76 - MR49870 : MediaBrowser
            //for( i = 1; i <= gMediaBrowser_TotalNumListElements; i++ )
            for( i = 1; i <= gMB_CSVtotalElem; i++ )
            {
                //if( gMediaBrowser_Pos[i-1] == gAudioSD_CSIhandle_FSGhandle )
                if( gMediaBrowser_Pos_insDel[i-1][0] == gAudioSD_CSIhandle_FSGhandle )
                {

                    //gAudioSD_CSIhandle_FSGhandle_absolutePos = i;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos = i;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gMediaBrowser_Pos_insDel[i-1][2];
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    break;
                }
            }
        }
        break;
        default:
        break;
    }
}

//IssueList #86
sourceListType ()
{
    //BAP_MOST sync CoverArt

    switch(  getValue( env_AudioSD_activeSrc_Type ) )
    {
    case 0x01: putValue( env_AudioSD_RecListType_Type,1 );
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               //BAP_MOST sync StationArt
               if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
               {
                   putValue( env_AudioSD_activeSrc_MedBrList,1 );
               }
               else
                   putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x02: putValue( env_AudioSD_RecListType_Type,2 );
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               //BAP_MOST sync StationArt
               if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
               {
                   putValue( env_AudioSD_activeSrc_MedBrList,1 );
               }
               else
                   putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x03: putValue( env_AudioSD_RecListType_Type,3);
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               //BAP_MOST sync StationArt
               if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
               {
                   putValue( env_AudioSD_activeSrc_MedBrList,1 );
               }
               else
                   putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x04: putValue( env_AudioSD_RecListType_Type,4 );
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               //BAP_MOST sync StationArt
               if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
               {
                   putValue( env_AudioSD_activeSrc_MedBrList,1 );
               }
               else
                   putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x05: putValue( env_AudioSD_RecListType_Type,4 );
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               //BAP_MOST sync StationArt
               if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
               {
                   putValue( env_AudioSD_activeSrc_MedBrList,1 );
               }
               else
                   putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x09: putValue( env_AudioSD_RecListType_Type,6 );
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x11: putValue( env_AudioSD_RecListType_Type,2 );
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x17: putValue( env_AudioSD_RecListType_Type,5);
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               //BAP_MOST sync CoverArt
               if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
               {
                   putValue( env_AudioSD_activeSrc_MedBrList,1 );
               }
               else
               putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x18: putValue( env_AudioSD_RecListType_Type,5);
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
                //BAP_MOST sync CoverArt
                if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
               {
                   putValue( env_AudioSD_activeSrc_MedBrList,1 );
               }
               else
               putValue( env_AudioSD_activeSrc_MedBrList, 0 );

               break;

    case 0x19: putValue( env_AudioSD_RecListType_Type,7);
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               //BAP_MOST sync CoverArt
               if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
               {
                   putValue( env_AudioSD_activeSrc_MedBrList,1 );
               }
               else
                   putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x1A: putValue( env_AudioSD_RecListType_Type,8 );
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x1B:break;
    case 0x1C:break;

    //BAP_MOST sync CoverArt
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x25:
    case 0x26:
    case 0x27: if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
               {
                   putValue( env_AudioSD_activeSrc_MedBrList,1 );
               }
               else
                   putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x23: putValue( env_AudioSD_RecListType_Type,9);
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               //BAP_MOST sync StationArt
               if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
               {
                   putValue( env_AudioSD_activeSrc_MedBrList,1 );
               }
               else
                   putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    case 0x24: putValue( env_AudioSD_RecListType_Type,10 );
               putValue( env_AudioSD_activeSrc_ReceptList,1 );
               //BAP_MOST sync StationArt
               if( getValue( env_PIC_bapMOST_active_flag ) == 0x01 )
               {
                   putValue( env_AudioSD_activeSrc_MedBrList,1 );
               }
               else
                   putValue( env_AudioSD_activeSrc_MedBrList, 0 );
               break;

    default: putValue( env_AudioSD_RecListType_Type, 0 );
             putValue( env_AudioSD_activeSrc_ReceptList, 0 );
             putValue( env_AudioSD_activeSrc_MedBrList,1 );
             break;
    }
}

//IssueList #86
void getSourceListRef ()
{
byte i;

    for( i = 0; i <= gSourceList_TotalNumListElements; i++ )
    {
        if( gSourceList_Pos[i] == gAudioSD_SwitchSource_Reference )
        {
        putValue( env_AudioSD_activeSrc_Type, gSourceList_SourceType[i] );
        putValue( env_AudioSD_activeSrc_number, gSourceList_InstanceID[i] );
        break;
        }
    }
}

//IssueList #96
on envVar env_AudioSD_GNLP_Result
{
gAudioSD_GetNextListPos_Result = getValue( this );
}

//IssueList #68
on envVar env_AudioSD_FctList_0x1D_3min_TO
{
gAudioFctList_0x1D_Processing_flg = getValue( this );

    if( gAudioFctList_0x1D_Processing_flg == 0x00 )
    {
    cancelTimer( gAudioFctList_0x1D_ProcessingTimer );
    //IssueList #123
    gAudioSD_AnnouncementEscape_Result = AUDIO_ANNOUNCEMENTESCAPE_SUCCESSFUL;
    putValue( env_AudioSD_AnE_Res, gAudioSD_AnnouncementEscape_Result );
    }
    else
    {
    //IssueList #123
    gAudioSD_AnnouncementEscape_Result = AUDIO_ANNOUNCEMENTESCAPE_NOTSUCCESSFUL;
    putValue( env_AudioSD_AnE_Res, gAudioSD_AnnouncementEscape_Result );
    }
}

//IssueList #68
on envVar env_AudioSD_FctList_0x18_3min_TO
{
gAudioFctList_0x18_Processing_flg = getValue( this );

if( gAudioFctList_0x18_Processing_flg == 0x00 )
{
cancelTimer( gAudioFctList_0x18_ProcessingTimer );
//IssueList #108
gAudioSD_DAC_Result = AUDIO_DAC_SUCCESSFUL;
}
else
gAudioSD_DAC_Result = AUDIO_DAC_NOTSUCCESSFUL;

}

//IssueList #68
on envVar env_AudioSD_FctList_0x22_3min_TO
{
gAudioFctList_0x22_Processing_flg = getValue( this );

if( gAudioFctList_0x22_Processing_flg == 0x00 )
cancelTimer( gAudioFctList_0x22_ProcessingTimer );
}

//IssueList #68
on envVar env_AudioSD_FctList_0x27_3min_TO
{
gAudioFctList_0x27_Processing_flg = getValue( this );

if( gAudioFctList_0x27_Processing_flg == 0x00 )
cancelTimer( gAudioFctList_0x27_ProcessingTimer );
}

//IssueList #68
on envVar env_AudioSD_FctList_0x2C_3min_TO
{
gAudioFctList_0x2C_Processing_flg = getValue( this );

if( gAudioFctList_0x2C_Processing_flg == 0x00 )
cancelTimer( gAudioFctList_0x2C_ProcessingTimer );
}

//IssueList #68
on envVar env_AudioSD_FctList_0x26_3min_TO
{
gAudioFctList_0x26_Processing_flg = getValue( this );

if( gAudioFctList_0x26_Processing_flg == 0x00 )
cancelTimer( gAudioFctList_0x26_ProcessingTimer );
}

//IssueList #129
on envVar env_AudioSD_RL_delete_Auto
{

    if( getValue( this ) )
    {
    enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Hex8", FALSE );
    enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Hex16", FALSE );
        switch(  getValue( env_AudioSD_RL_delete_size ) )
        {
        case 0:
        enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar8", TRUE );
        enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar16", FALSE );
        break;

        case 1:
        enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar8", FALSE );
        enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar16", TRUE );
        break;

        default: break;
        }
    }
    else
    {
    enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar8", FALSE );
    enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar16", FALSE );
    enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Hex8", TRUE );
    enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Hex16", TRUE );

    }
}

//IssueList #129
on envVar env_AudioSD_RL_delete_size
{
    if( getValue( env_AudioSD_RL_delete_Auto)== 0x01 )

       if( getValue( this ) )
       {
        enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar8", FALSE );
        enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar16", TRUE );
        }
       else
       {
        enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar8", TRUE );
        enableControl( "FSG_AudioSD_0x17 - ReceptionList_delete", "FSG_0x17_ReceptionList_Envar16", FALSE );
        }

}

//IssueList #129
on envVar env_AudioSD_SL_delete_Auto
{

    if( getValue( this ) )
    {
    enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Hex8", FALSE );
    enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Hex16", FALSE );
        switch(  getValue( env_AudioSD_SL_delete_size ) )
        {
        case 0:
        enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar8", TRUE );
        enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar16", FALSE );
        break;

        case 1:
        enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar8", FALSE );
        enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar16", TRUE );
        break;

        default: break;
        }
    }
    else
    {
    enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar8", FALSE );
    enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar16", FALSE );
    enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Hex8", TRUE );
    enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Hex16", TRUE );

    }
}

//IssueList #129
on envVar env_AudioSD_SL_delete_size
{
    if( getValue( env_AudioSD_SL_delete_Auto)== 0x01 )

       if( getValue( this ) )
       {
        enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar8", FALSE );
        enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar16", TRUE );
        }
       else
       {
        enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar8", TRUE );
        enableControl( "FSG_AudioSD_0x20 - SourceList_delete", "FSG_0x20_SourceList_Envar16", FALSE );
        }

}

//IssueList #129
on envVar env_AudioSD_MB_delete_Auto
{

    if( getValue( this ) )
    {
    enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Hex8", FALSE );
    enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Hex16", FALSE );
        switch(  getValue( env_AudioSD_MB_delete_size ) )
        {
        case 0:
        enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar8", TRUE );
        enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar16", FALSE );
        break;

        case 1:
        enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar8", FALSE );
        enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar16", TRUE );
        break;

        default: break;
        }
    }
    else
    {
    enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar8", FALSE );
    enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar16", FALSE );
    enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Hex8", TRUE );
    enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Hex16", TRUE );

    }
}

//IssueList #129
on envVar env_AudioSD_MB_delete_size
{
    if( getValue( env_AudioSD_MB_delete_Auto)== 0x01 )

       if( getValue( this ) )
       {
        enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar8", FALSE );
        enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar16", TRUE );
        }
       else
       {
        enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar8", TRUE );
        enableControl( "FSG_AudioSD_0x24 - MediaBrowser_(array )_delete", "FSG_0x24_MediaBrowser_Envar16", FALSE );
        }

}

//IssueList #129
on envVar env_AudioSD_TML_delete_Auto
{

    if( getValue( this ) )
    {
    enableControl( "FSG_AudioSD_0x1B - TpMemoList_(array )_delete", "FSG_0x1B_TpMemoList_Hex8", FALSE );
    enableControl( "FSG_AudioSD_0x1B - TpMemoList_(array )_delete", "FSG_0x1B_TpMemoList_Envar8", TRUE );
    }

    else
    {
    enableControl( "FSG_AudioSD_0x1B - TpMemoList_(array )_delete", "FSG_0x1B_TpMemoList_Envar8", FALSE );
    enableControl( "FSG_AudioSD_0x1B - TpMemoList_(array )_delete", "FSG_0x1B_TpMemoList_Hex8", TRUE );

    }
}

//IssueList #129
on envVar env_AudioSD_RTPL_delete_Auto
{

    if( getValue( this ) )
    {
    enableControl( "FSG_AudioSD_0x21 - RadioTV_PresetList_(array )_delete", "FSG_0x21_RadioTV_PresetList_Hex8", FALSE );
    enableControl( "FSG_AudioSD_0x21 - RadioTV_PresetList_(array )_delete", "FSG_0x21_RadioTV_PresetList_Envar8", TRUE );
    }

    else
    {
    enableControl( "FSG_AudioSD_0x21 - RadioTV_PresetList_(array )_delete", "FSG_0x21_RadioTV_PresetList_Envar8", FALSE );
    enableControl( "FSG_AudioSD_0x21 - RadioTV_PresetList_(array )_delete", "FSG_0x21_RadioTV_PresetList_Hex8", TRUE );

    }
}

//IssueList #76 - MR49870 : ReceptionList
on envVar env_AudioSD_RL_insert
{
    word startelement, elements,successor, ctr, PosCtr,RLlistCtr,elemTemp,PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_RECEPTIONLIST_ENTRIES], startIndex, succIndex, posInBetweenCheck;
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,k,x;


    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;
    elemTemp                = 0;
    startIndex              = 0;
    succIndex               = 0;
    PosVal                  = 0;


    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
            POS[i] = 0;

        for( i = 0; i < BAP_BUFFER_SIZE; i++ )
            requestarray[i] = 0;

        for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
            gRL_InvalidIns[i] = 0;

        for( i = 0; i < AUDIO_RECEPTIONLIST_ENTRIES; i++ )
        {
            gReceptionList_Send[i][0] = 0;
            gReceptionList_Send[i][1] = 0;
        }


        putValue( env_AudioSD_RL_Insert_Invalid, gRL_InvalidIns );

        gRL_InsInvalidCtr = 0;
        gRL_InsValidCtr = 0;
        putValue( env_AudioSD_RL_Insert_Message, empty_string );

        //get data from Panel
        gReceptionList_ElementType          = getvalue( env_AudioSD_RL_ElementType );
        gReceptionList_ParentID             = getvalue( env_AudioSD_RL_ParentID);

        //Patch GB 11.07.2014 -commented
        //recordaddress   = 0x0F;

        putvalue ( env_AudioSD_RL_Insert_Message, empty_string );
        //MR 63332 #3   02.07.2014
        //gRL_TotalElem = getValue( env_AudioSD_RL_TotalNumLE );
        gRL_TotalElem = gReceptionList_TotalNumListElements;

        if( getValue( env_AudioSD_RL_insert_UPD_button )== 0x00 )
        {    shift        = 0x01; //insert
            gRL_InsertFlg = 0x01;

            //Patch GB 11.07.2014
            recordaddress   = 0x0F;
        }
        else
        {
            shift           = 0x0; //update

            //Patch GB 11.07.2014
            recordaddress   = getValue( env_AudioSD_RL_AH_RA);
        }


        direction       = 0x0;
        transmitpos     = 0x01;

        indexsize       = getvalue( env_AudioSD_RL_insert_size );
        //mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //message
        requestarray[0] = LSG_AudioSD;                //LSG-ID
        requestarray[1] = FctID_ReceptionList;        //Fct.-ID
        requestarray[2] =Changed_REQ;                  //request type

        requestarray[3] = gReceptionList_ElementType;
        requestarray[4] = gReceptionList_ParentID & 0xff;
        requestarray[5] = ( gReceptionList_ParentID & 0xff00 ) / 0x100;
        Offset =6;

        startelement    = getValue( env_AudioSD_RL_insert_start );

        successor = getValue( env_AudioSD_RL_insert_successor );


        switch( indexsize ) // POS size
        {
            case 0: //8Bit
                getvalue( env_AudioSD_RL_insert_POS_8, POS);
                ctr = getValueSize( env_AudioSD_RL_insert_POS_8 );

                if( getValue( env_AudioSD_RL_insert_ErrHandler )== 0x01 )
                {

                    if( ctr == 0 )   // if no data
                    {
                        putValue( env_AudioSD_RL_Insert_Message, "NO DATA TO SEND" );
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid for Insert
                        if( getvalue( env_AudioSD_RL_insert_start ) == 0x00 && getvalue( env_AudioSD_RL_insert_successor ) == 0x00 && getvalue( env_AudioSD_RL_insert_UPD_button ) == 0x00 )
                        {
                            //check if not all elements are deleted
                            if( gRL_totalDELctr < gRL_CSVtotalElem)
                            {
                            putValue( env_AudioSD_RL_Insert_Message, "INVALID START & SUCCESSOR" );
                            break;
                            }
                        }

                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                        posInBetweenCheck       = 0;
                        if( ctr >1 )
                        {
                            posInBetweenCheck =  rlPosSequence_check ( indexsize,POS, ctr );
                            if( posInBetweenCheck == 0x01 )
                            {
                                putValue( env_AudioSD_RL_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                break;
                            }
                        }


                        ReceptionList_insert_ErrHandler_8 ( POS, ctr );

                        //if update has invalid POS - do not send
                        if( getvalue( env_AudioSD_RL_insert_UPD_button ) == 0x01 )  //update
                        {
                            if( gRL_InsInvalidCtr > 0 )
                            {
                                putValue( env_AudioSD_RL_Insert_Message, "INVALID POS EXISTS" );
                                break;
                            }
                        }


                        //if all elements are INVALID for INSERT
                        if( ctr == gRL_InsInvalidCtr )
                        {
                            putValue( env_AudioSD_RL_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                        }
                        else
                        {
                            elements = gRL_InsValidCtr+ 1;
                            ctr = gRL_InsValidCtr;
                        }


                    }//else with data
                }
                else   // no error handling
                {
                    elements = ctr+ 1;
                    if( ctr == 0 )    // if no data
                    {
                        transmitpos     = 0x0;

                        if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                            elements = successor - startelement;
                    }
                 }

                //mode
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;

                //start
                requestarray[Offset] = startelement;
                Offset++;

                //elements
                requestarray[Offset] = elements;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if( getValue( env_AudioSD_RL_insert_ErrHandler )== 0x01 )
                {
                    //ARRAY DATA
                        for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                requestarray[Offset] = gReceptionList_Send[i][0];
                                Offset++;
                            }

                    //INDEXING FOR INSERT
                    if( getValue( env_AudioSD_RL_insert_UPD_button )== 0x00 )  //check if insert
                    {

                         // if all elements are deleted
                         if( gRL_totalDELctr == gRL_CSVtotalElem)
                         {

                                 //assign the first Insert element as handle and POS
                                 gAudioSD_CSIhandle_FSGhandle = gReceptionList_Send[0][0];
                                 gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;

                                  i = 0;
                                for( j = 0; j < gRL_CSVtotalElem; j++ )
                                {
                                    if( gReceptionList_Pos_insDel[j][1] == 0x01 )
                                    continue ;
                                    else
                                    {
                                    i++;
                                    gReceptionList_Pos_insDel[j][2] = i;
                                    }
                                } //for
                         } //if
                         else if( gRL_totalDELctr < gRL_CSVtotalElem)
                        {

                            //Get Start and Successor Index
                            for(  j = 0; j < gRL_CSVtotalElem; j++ )
                            {
                                //Start
                                if( getValue( env_AudioSD_RL_insert_start ) == gReceptionList_Pos_insDel[j][0] )
                                {
                                    startIndex = gReceptionList_Pos_insDel[j][2];
                                }
                                //Succ
                                if( getValue( env_AudioSD_RL_insert_successor ) == gReceptionList_Pos_insDel[j][0] )
                                {
                                    succIndex = gReceptionList_Pos_insDel[j][2];
                                }
                            }
                            //handling if inserted at the edges
                            if(succIndex == 0 )
                            {
                                succIndex = startIndex + 1;
                            }
                            if(startIndex == 0 )
                            {
                                startIndex = succIndex - 1;
                            }

                            //Increment indexes of items from the successor onwards ( by inserted items number )
                            for( j = 0; j < gRL_CSVtotalElem; j++ )
                            {
                                if( succIndex <= gReceptionList_Pos_insDel[j][2] )
                                {
                                    gReceptionList_Pos_insDel[j][2] = gReceptionList_Pos_insDel[j][2] + ctr;
                                }

                                if( getvalue( env_AudioSD_CSH_FSGhandle ) == gReceptionList_Pos_insDel[j][0] )
                                {
                                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gReceptionList_Pos_insDel[j][2];
                                }
                            }

                            //Store Index of inserted items
                            //Loop number of times as inserted items
                            for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                //requestarray[Offset] = gReceptionList_Send[i][0];
                                //Offset++;

                                //Loop through array to find POS matching inserted item
                                for(  k = 0; k < gRL_CSVtotalElem; k++ )
                                {
                                    if( gReceptionList_Send[i][0] == gReceptionList_Pos_insDel[k][0] )
                                    {
                                        gReceptionList_Pos_insDel[k][2] = startIndex + i + 1;
                                        break;
                                    } //if
                                } //for
                            } //for
                        }

                        //Update handle
                        //gAudioSD_CSIhandle_FSGhandle_absolutePos = gAudioSD_CSIhandle_FSGhandle_absolutePos + ctr;
                        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                    } //end if INSERT

                } //end if with ERROR handling

                //ArrayData WITHOUT error handling
                else
                {
                     for( i = 0; i <ctr; i++ )
                     {
                        requestarray[Offset] = POS[i];
                        Offset++;
                     }
                }

                //successor
                if( ctr > 0 )
                {
                    requestarray[Offset] = successor;
                    Offset++;
                }

            break;

            case 1:  //16Bit
                getvalue( env_AudioSD_RL_insert_POS_16, POS);
                elements = getValueSize( env_AudioSD_RL_insert_POS_16 );
                elemTemp = ( getValueSize( env_AudioSD_RL_insert_POS_16 ) /2 );

                if( getValue( env_AudioSD_RL_insert_ErrHandler )== 0x01 )
                {
                    if( elemTemp== 0 )   // if no data
                    {
                        putValue( env_AudioSD_RL_Insert_Message, "NO DATA TO SEND" );
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid
                        if( ( getvalue( env_AudioSD_RL_insert_start ) == 0x00 ) && ( getvalue( env_AudioSD_RL_insert_successor ) == 0x00 )&& ( getvalue( env_AudioSD_RL_insert_UPD_button ) == 0x00 ) )
                        {
                            //check if not all elements are deleted
                            if( gRL_totalDELctr < gRL_CSVtotalElem)
                            {
                            putValue( env_AudioSD_RL_Insert_Message, "INVALID START & SUCCESSOR" );
                            break;
                            }
                        }


                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                            if( ctr >1 )
                            {
                                posInBetweenCheck =  rlPosSequence_check ( indexsize,POS,elemTemp);
                                if( posInBetweenCheck == 0x01 )
                                {
                                    putValue( env_AudioSD_RL_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                    break;
                                }
                            }

                        ReceptionList_insert_ErrHandler_16 ( POS,elements );
                        //if all elements are INVALID

                        //if update has invalid POS - do not send
                        if( getvalue( env_AudioSD_RL_insert_UPD_button ) == 0x01 )  //update
                        {
                            if( gRL_InsInvalidCtr > 0 )
                            {
                                putValue( env_AudioSD_RL_Insert_Message, "INVALID POS EXISTS" );
                                break;
                            }
                        }

                        if( elemTemp == gRL_InsInvalidCtr )
                        {
                            putValue( env_AudioSD_RL_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                        }
                        else
                        {
                            elements = ( gRL_InsValidCtr/2 )+ 1;     //including successor
                            elemTemp = gRL_InsValidCtr/2;}
                        }

                    } //else with data
                else   // no error handling
                {
                    elements = elemTemp + 1;  //including successor
                    if( elemTemp== 0 )    // if no data
                    {
                        transmitpos = 0x0;
                         if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                        elements = successor - startelement;
                    }
                }

                //mode
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 )& 0xF0 ) + ( recordaddress& 0x0F );
                Offset++;

                requestarray[Offset] = startelement& 0xff;
                Offset++;
                requestarray[Offset] = (startelement& 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements& 0xff;
                Offset++;
                requestarray[Offset] = ( elements& 0xff00 ) / 0x100;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if( getValue( env_AudioSD_RL_insert_ErrHandler )== 0x01 )
                {
                    for(  i = 0; i < elemTemp; i++ )
                        {
                            PosVal = 0x00;

                            //store in array the inserted item
                            requestarray[Offset] = gReceptionList_Send[(2*i)+ 1][0];
                            PosVal = requestarray[Offset];
                            Offset++;
                            requestarray[Offset] = gReceptionList_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;
                         }

                    //INDEXING FOR INSERT

                    if( getValue( env_AudioSD_RL_insert_UPD_button )== 0x00 )  //check if insert
                    {
                         // if all elements are deleted
                         if( gRL_totalDELctr == gRL_CSVtotalElem)
                         {
                                 PosVal = 0x00;
                                 PosVal = gReceptionList_Send[0][0] << 8;
                                 PosVal = PosVal|gReceptionList_Send[1][0];

                                 gAudioSD_CSIhandle_FSGhandle = PosVal;
                                 gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;

                                 i = 0;
                                for( j = 0; j < gRL_CSVtotalElem; j++ )
                                {
                                    if( gReceptionList_Pos_insDel[j][1] == 0x01 )
                                    continue ;
                                    else
                                    {
                                    i++;
                                    gReceptionList_Pos_insDel[j][2] = i;
                                    }
                                }

                         }
                        else if( gRL_totalDELctr < gRL_CSVtotalElem)
                        {
                            //Get Start and Successor Index
                            for(  j = 0; j < gRL_CSVtotalElem; j++ )
                            {
                                //Start
                                if( getValue( env_AudioSD_RL_insert_start ) == gReceptionList_Pos_insDel[j][0] )
                                {
                                    startIndex = gReceptionList_Pos_insDel[j][2];
                                }
                                //Succ
                                if( getValue( env_AudioSD_RL_insert_successor ) == gReceptionList_Pos_insDel[j][0] )
                                {
                                    succIndex = gReceptionList_Pos_insDel[j][2];
                                }
                            }
                            //handling if inserted at the edges
                            if(succIndex == 0 )
                            {
                                succIndex = startIndex + 1;
                            }
                            if(startIndex == 0 )
                            {
                                startIndex = succIndex - 1;
                            }

                            //Increment indexes of items from the successor onwards ( by inserted items number )
                            for( j = 0; j < gRL_CSVtotalElem; j++ )
                            {
                                if( succIndex <= gReceptionList_Pos_insDel[j][2] )
                                {
                                    gReceptionList_Pos_insDel[j][2] = gReceptionList_Pos_insDel[j][2] + elemTemp;
                                }

                                if( getvalue( env_AudioSD_CSH_FSGhandle ) == gReceptionList_Pos_insDel[j][0] )
                                {
                                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gReceptionList_Pos_insDel[j][2];
                                }
                            }

                                 //Store Index of inserted items
                                //Loop number of times as inserted items
                                for(  i = 0; i < elemTemp; i++ )
                                {
                                    PosVal = 0x00;
                                    PosVal = gReceptionList_Send[(2*i)+ 1][0];
                                    PosVal = PosVal|gReceptionList_Send[(2*i)+0][0]<<8;

                                    //Loop through array to find POS matching inserted item
                                    for(  k = 0; k < gRL_CSVtotalElem; k++ )
                                    {
                                        if( PosVal == gReceptionList_Pos_insDel[k][0] )
                                        {
                                            gReceptionList_Pos_insDel[k][2] = startIndex + i + 1;
                                            break;
                                        }
                                    }//for
                                }//for
                        } //else if gRL_totalDELctr

                        //Update handle
                        //gAudioSD_CSIhandle_FSGhandle_absolutePos = gAudioSD_CSIhandle_FSGhandle_absolutePos + ctr;
                        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                    } // end if INSERT

                } // end if with Errorhandling
                //ArrayData WITHOUT error handling
                else
                {
                    for(  i = 0; i < elemTemp; i++ )
                    {
                        requestarray[Offset] = POS[(2*i)+ 1];
                        Offset++;
                        requestarray[Offset] = POS[(2*i)+0];
                        Offset++;
                    }
                }

                //successor
                if( elemTemp > 0 )
                {
                    requestarray[Offset] = successor& 0xff;
                    Offset++;
                    requestarray[Offset] = (successor& 0xff00 ) / 0x100;
                    Offset++;
                }
                break; //case 1:  16Bit

            default:
                break; //default

        }//switch

        //resetting LoadReload Flg after Insert
        gRL_loadReloadFlg = 0x00;



        if( indexsize== 0x01 )
        gRL_InsValidCtr = gRL_InsValidCtr/2;

        //updating the totalDeletedCtr;
           gRL_totalDELctr = gRL_totalDELctr - gRL_InsValidCtr;

        if( gRL_totalDELctr > gRL_CSVtotalElem)
        gRL_totalDELctr = 0;


        //just send the data when errorhandler is OFF
        if( getValue( env_AudioSD_RL_insert_ErrHandler )== 0x00 )
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else if( getValue( env_AudioSD_RL_insert_ErrHandler )== 0x01 )  //with ERROR HANDLER
        {
            if( getValue( env_AudioSD_RL_insert_UPD_button )== 0x00 )  //insert
            {
                // if there's a Valid POS and Sequence is correct
                if( gRL_InsValidCtr != 0x00 && posInBetweenCheck == 0x00 )
                {
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

                    if( gRL_TotalElem + gRL_InsValidCtr <= gRL_CSVtotalElem)
                    {
                        //MR 63332 #3   02.07.2014
                        //putValue( env_AudioSD_RL_TotalNumLE, gRL_TotalElem + gRL_InsValidCtr );
                        //gReceptionList_TotalNumListElements = getValue( env_AudioSD_RL_TotalNumLE );
                        gReceptionList_TotalNumListElements = gRL_TotalElem + gRL_InsValidCtr;
                        putValue( env_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements );
                    } //if


                }// if gRL_InsValidCtr
            }// if insert
            else
            {
                //send only UPDATE if all POS are valid and DATA!= 0
                if( gRL_InsInvalidCtr == 0x00 && gRL_InsValidCtr!= 0 )
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }// else UPD button
        } //else if
    }
    //else
    //putValue( env_AudioSD_RL_insert_UPD_button, 0 );
}

//IssueList #76 - MR49870 : ReceptionList
void ReceptionList_insert_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word RLlistCtr, PosCtr;

    result = 0x01;
    InsFlg= 0;


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {
         result = 0x00;
         InsFlg = 0x00;

      for(  RLlistCtr = 0;RLlistCtr < gRL_CSVtotalElem; RLlistCtr++ )
      {
           if( pos[PosCtr] == gReceptionList_Pos_insDel[RLlistCtr][0] )   //check if POS is valid
           {
            //UPDATE
                if  ( getValue( env_AudioSD_RL_insert_UPD_button ) == 0x01 )
                 {
                        if( gReceptionList_Pos_insDel[RLlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                        {
                        result = 0x01;
                        gReceptionList_Send[gRL_InsValidCtr][0] = pos[PosCtr];
                        gRL_InsValidCtr++;
                        }

                        else
                          {
                          putValue( env_AudioSD_RL_Insert_Message, "POS is already deleted!" );
                          gRL_InvalidIns[gRL_InsInvalidCtr] = pos[PosCtr];
                          gRL_InsInvalidCtr++;
                          InsFlg = 0x01;
                          break;
                          }

                }  //update

                 else   //INSERT
                 {
                     if( gReceptionList_Pos_insDel[RLlistCtr][1] == 0x01 )  //check if POS does not exist
                       {
                       gReceptionList_Pos_insDel[RLlistCtr][1] = 0x00;
                       gReceptionList_Send[gRL_InsValidCtr][0] = pos[PosCtr];
                       gReceptionList_Send[gRL_InsValidCtr][1] = gReceptionList_Pos_insDel[RLlistCtr][2];

                       gRL_InsValidCtr++;
                       result = 0x01;
                       }
                      else
                      {
                      putValue( env_AudioSD_RL_Insert_Message, "POS still exists!" );
                      gRL_InvalidIns[gRL_InsInvalidCtr] = pos[PosCtr];
                      gRL_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                      }
               }//if
            } //else
       }//for
        if( result == 0x00 && InsFlg == 0x00 )
           {
           gRL_InvalidIns[gRL_InsInvalidCtr] =pos[PosCtr];
            gRL_InsInvalidCtr++;
             putValue( env_AudioSD_RL_Insert_Message, "INVALID POS!" );
            }
     }//for RLlistCtr

     if( gRL_InsInvalidCtr!= 0 )
            putValue( env_AudioSD_RL_Insert_Invalid, gRL_InvalidIns );
}

//IssueList #76 - MR49870 : ReceptionList
//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_RL_insert_POS_8
{
byte INS_POS_8[AUDIO_RECEPTIONLIST_ENTRIES];
int inputCtr,i,j;
byte valid_INS_POS_8;
byte validInputFlg_start, validInputFlg_succ;

putvalue ( env_AudioSD_RL_Insert_Message, empty_string );


    //if( getValue( env_AudioSD_RL_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_RL_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_RL_insert_ErrHandler )== 0x01 )
    {
    getValue( this, INS_POS_8 );
    validInputFlg_start = 0;
    validInputFlg_succ = 0;

     inputCtr =  getValueSize( env_AudioSD_RL_insert_POS_8 );

     if( inputCtr > 0 )
     {
        //look for the valid reference for Start and successor
         for( j = 0; j < inputCtr; j++ )
         {
             valid_INS_POS_8 = INS_POS_8[j];

             for( i = 0; i < gRL_CSVtotalElem; i++ )
             {
             //check if input is valid and deleted
                 if( valid_INS_POS_8 == gReceptionList_Pos_insDel[i][0] && gReceptionList_Pos_insDel[i][1] == 0x01 )
                 {
                 validInputFlg_start = 1;
                 break;
                 }
             }
             if( validInputFlg_start == 0x01 )
             break;
          }

            if( validInputFlg_start == 0x01 )
            {
            //start
             if( valid_INS_POS_8== gReceptionList_Pos_insDel[0][0] )
                 putValue( env_AudioSD_RL_insert_start, 0 );

             else
             {
                ///look for the next existing element upwards
                 for( i = 0; i < gRL_CSVtotalElem; i++ )
                 {
                     if( valid_INS_POS_8== gReceptionList_Pos_insDel[i][0] )
                     {
                        for( j = i-1; j>= 0; j--)
                         {
                         if( gReceptionList_Pos_insDel[j][1]!= 0x01 )
                            {
                             putValue( env_AudioSD_RL_insert_start, gReceptionList_Pos_insDel[j][0] );
                             break;
                             }//if
                         }//for
                      }
                 }//for
             }//else
            } //validInputFlg

                //successor
                //look for the valid reference for Start and successor

                for( j = inputCtr-1; j>= 0; j--)
                {
                     valid_INS_POS_8 = INS_POS_8[j];

                     for( i = 0; i < gRL_CSVtotalElem; i++ )
                     {
                     //check if input is valid and deleted
                         if( valid_INS_POS_8 == gReceptionList_Pos_insDel[i][0] && gReceptionList_Pos_insDel[i][1] == 0x01 )
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     }
                     if( validInputFlg_succ == 0x01 )
                     break;
                }
                if( validInputFlg_succ == 0x01 )
                {
                    putValue( env_AudioSD_RL_insert_successor, 0 );

                    for( i = 0; i < gRL_CSVtotalElem; i++ )
                    {
                        if( valid_INS_POS_8== gReceptionList_Pos_insDel[i][0] )
                         {
                         if( i == gRL_CSVtotalElem-1 )
                         putValue( env_AudioSD_RL_insert_successor, 0 );
                         else
                            {
                                 //look for the next existing element downwards
                                 for( j = i + 1; j < gRL_CSVtotalElem; j++ )
                                 {
                                     if( gReceptionList_Pos_insDel[j][1]!= 0x01 )
                                     {
                                     putValue( env_AudioSD_RL_insert_successor, gReceptionList_Pos_insDel[j][0] );
                                     break;
                                     }
                                 }
                             }//else

                        }//if
                 }//for
               }

        } //inputCtr
    }

}

//IssueList #76 - MR49870 : ReceptionList
ReceptionList_delete_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word RLlistCtr, PosCtr;

    result = 0x01;
    delFlg= 0;
    gRL_DelInvalidCtr = 0;
    gRL_DelValidCtr = 0;
    putValue( env_AudioSD_RL_delete_Message, empty_string );


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {

         result = 0x00;
         delFlg = 0x00;

      for(  RLlistCtr = 0;RLlistCtr < gRL_CSVtotalElem; RLlistCtr++ )
      {

           if( pos[PosCtr] == gReceptionList_Pos_insDel[RLlistCtr][0] )   //check if POS is valid
           {
             if( gReceptionList_Pos_insDel[RLlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gReceptionList_Pos_insDel[RLlistCtr][1] = 0x01;    //tagging deleted Pos
               gReceptionList_Send[gRL_DelValidCtr][0] = pos[PosCtr];
               gReceptionList_Send[gRL_DelValidCtr][1] = gReceptionList_Pos_insDel[RLlistCtr][2];

               gRL_DelValidCtr++;
               gRL_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_RL_delete_Message, "POS already deleted!" );
              gRL_InvalidDel[gRL_DelInvalidCtr] = pos[PosCtr];
              gRL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
           {
           gRL_InvalidDel[gRL_DelInvalidCtr] =pos[PosCtr];
            gRL_DelInvalidCtr++;
             putValue( env_AudioSD_RL_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : ReceptionList
on envVar env_AudioSD_RL_delete_POS_8
{
byte DEL_POS_8[AUDIO_RECEPTIONLIST_ENTRIES];

putValue( env_AudioSD_RL_delete_Message, empty_string );

    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_RL_delete_ErrHandler )== 0x01 )
    {
    getValue( this, DEL_POS_8 );
    putValue( env_AudioSD_RL_delete_start, DEL_POS_8[0] );
    }

}

//IssueList #76 - MR49870
ReceptionList_FRU ()
{
word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;



        recordaddress   = 0;
        shift           = 0;
        direction       = 0;
        transmitpos     = 0;
        indexsize       = 0;
        startelement    = 0;
        elements        =65535;

        //MR 63332 #2 02.07.2014
        /*
        putvalue( env_AudioSD_RL_CA_switch, FALSE );


        putvalue( env_AudioSD_RL_AH_RA, recordaddress );
        putvalue( env_AudioSD_RL_AH_shift, shift );
        putvalue( env_AudioSD_RL_AH_dir, direction );
        putvalue( env_AudioSD_RL_AH_POS, transmitpos );
        putvalue( env_AudioSD_RL_AH_IS, indexsize );
        //MR49870
        //putvalue( env_AudioSD_RL_AH_start, startelement );
        putvalue( env_AudioSD_RL_AH_start, 1 );
        putvalue( env_AudioSD_RL_AH_elements, elements );
        */

        mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //send ChangedArray
        //MR 63667 11.07.2014 -TNLE with SA-button
        //ReceptionList_Request( Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0 );
        ReceptionList_Request( Changed_REQ, 0, mode, recordaddress, startelement, startelement, elements, 0 );

}

//IssueList #76 - MR49870 : ReceptionList
on envVar env_AudioSD_RL_delete_ErrHandler
{
if( getValue( this )== 0x00 )
putValue( env_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements );
}

//IssueList #76 - MR49870 : ReceptionList
on envVar env_AudioSD_RL_insert_ErrHandler
{
if( getValue( this )== 0x00 )
putValue( env_AudioSD_RL_TotalNumLE, gReceptionList_TotalNumListElements );
}

//IssueList #76 - MR49870 : ReceptionList
ReceptionList_delete_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word RLlistCtr, PosCtr,PosVal;

    result = 0x01;
    delFlg= 0;
    gRL_DelInvalidCtr = 0;
    gRL_DelValidCtr = 0;
    putValue( env_AudioSD_RL_delete_Message, empty_string );
    PosVal = 0;

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {

         result = 0x00;
         delFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+ 1];


      for(  RLlistCtr = 0;RLlistCtr < gRL_CSVtotalElem; RLlistCtr++ )
      {
           if( PosVal== gReceptionList_Pos_insDel[RLlistCtr][0] )   //check if POS is valid
           {

             if( gReceptionList_Pos_insDel[RLlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gReceptionList_Pos_insDel[RLlistCtr][1] = 0x01;    //tagging deleted Pos
               gReceptionList_Send[gRL_DelValidCtr][0] = pos[PosCtr];
               gRL_DelValidCtr++;
               gReceptionList_Send[gRL_DelValidCtr][0] = pos[PosCtr+ 1];
               gRL_DelValidCtr++;
               gRL_totalDELctr++;
                gReceptionList_Send[gRL_DelValidCtr][1] = gReceptionList_Pos_insDel[RLlistCtr][2];
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_RL_delete_Message, "POS already deleted!" );
              gRL_InvalidDel[gRL_DelInvalidCtr] = pos[PosCtr];
              gRL_DelInvalidCtr++;
              gRL_InvalidDel[gRL_DelInvalidCtr] = pos[PosCtr+ 1];
              gRL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
        {

            gRL_InvalidDel[gRL_DelInvalidCtr] = pos[PosCtr];
            gRL_DelInvalidCtr++;
            gRL_InvalidDel[gRL_DelInvalidCtr] = pos[PosCtr+ 1];
            gRL_DelInvalidCtr++;
             putValue( env_AudioSD_RL_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : ReceptionList
void ReceptionList_insert_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word PosVal,RLlistCtr, PosCtr;



    result = 0x01;
    InsFlg= 0;
    PosVal = 0;


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {

         result = 0x00;
         InsFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+ 1];

      for(  RLlistCtr = 0;RLlistCtr < gRL_CSVtotalElem; RLlistCtr++ )
      {

           if( PosVal== gReceptionList_Pos_insDel[RLlistCtr][0] )   //check if POS is valid
           {
            //UPDATE
            if  ( getValue( env_AudioSD_RL_insert_UPD_button ) == 0x01 )
             {
                if( gReceptionList_Pos_insDel[RLlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                    {
                    result = 0x01;
                    gReceptionList_Send[gRL_InsValidCtr][0] = pos[PosCtr];
                    gRL_InsValidCtr++;
                    gReceptionList_Send[gRL_InsValidCtr][0] = pos[PosCtr+ 1];
                    gRL_InsValidCtr++;
                    }
                        else
                      {
                      putValue( env_AudioSD_RL_Insert_Message, "POS is already deleted!" );
                      gRL_InvalidIns[gRL_InsInvalidCtr] = pos[PosCtr];
                      gRL_InsInvalidCtr++;
                      gRL_InvalidIns[gRL_InsInvalidCtr] = pos[PosCtr+ 1];
                      gRL_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                  }

            }  //update

             else   //INSERT
             {
                 if( gReceptionList_Pos_insDel[RLlistCtr][1] == 0x01 )  //check if POS does not exist
                   {
                   gReceptionList_Pos_insDel[RLlistCtr][1] = 0x00;
                   gReceptionList_Send[gRL_InsValidCtr][0] = pos[PosCtr];
                   gRL_InsValidCtr++;
                   gReceptionList_Send[gRL_InsValidCtr][0] = pos[PosCtr+ 1];
                   gRL_InsValidCtr++;
                   result = 0x01;

                   }
                  else
                  {
                  putValue( env_AudioSD_RL_Insert_Message, "POS still exists!" );
                  gRL_InvalidIns[gRL_InsInvalidCtr] = pos[PosCtr];
                  gRL_InsInvalidCtr++;
                  gRL_InvalidIns[gRL_InsInvalidCtr] = pos[PosCtr+ 1];
                  gRL_InsInvalidCtr++;
                  InsFlg = 0x01;
                  break;
                  }
               }//if
            } //else
       }//for
        if( result == 0x00 && InsFlg == 0x00 )
           {
            gRL_InvalidIns[gRL_InsInvalidCtr] =pos[PosCtr];
            gRL_InsInvalidCtr++;
            gRL_InvalidIns[gRL_InsInvalidCtr] = pos[PosCtr+ 1];
            gRL_InsInvalidCtr++;
             putValue( env_AudioSD_RL_Insert_Message, "INVALID POS!" );
            }
     }//for RLlistCtr

     if( gRL_InsInvalidCtr!= 0 )
            putValue( env_AudioSD_RL_Insert_Invalid, gRL_InvalidIns );
}

//IssueList #76 - MR49870 : AllList
byte audioList_deleteCheck (word currentPos, word audioList_Pos_insDel[][], word totalElem)
{
byte i, posDeletedFlg;

posDeletedFlg = 0;

    for( i = 0; i <totalElem; i++ )
    {
        if( currentPos == audioList_Pos_insDel[i][0] )
        {
            if( audioList_Pos_insDel[i][1] == 0x01 )  //check if POS is deleted
            {
            posDeletedFlg = 0x01;
            break;
            }
        }
    }
        return posDeletedFlg;
}

//IssueList #76 - MR49870 : SourceList
SourceList_delete_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word SLlistCtr, PosCtr;

    result = 0x01;
    delFlg= 0;
    gSL_DelInvalidCtr = 0;
    gSL_DelValidCtr = 0;
    putValue( env_AudioSD_SL_delete_Message, empty_string );


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {

         result = 0x00;
         delFlg = 0x00;

      for( SLlistCtr = 0;SLlistCtr < gSL_CSVtotalElem; SLlistCtr++ )
      {

           if( pos[PosCtr] == gSourceList_Pos_insDel[SLlistCtr][0] )   //check if POS is valid
           {

             if( gSourceList_Pos_insDel[SLlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gSourceList_Pos_insDel[SLlistCtr][1] = 0x01;    //tagging deleted Pos
               gSourceList_Send[gSL_DelValidCtr][0] = pos[PosCtr];
                gSourceList_Send[gSL_DelValidCtr][1] = gSourceList_Pos_insDel[SLlistCtr][2];

               gSL_DelValidCtr++;
            gSL_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_SL_delete_Message, "POS already deleted!" );
              gSL_InvalidDel[gSL_DelInvalidCtr] = pos[PosCtr];
              gSL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
           {
           gSL_InvalidDel[gSL_DelInvalidCtr] =pos[PosCtr];
            gSL_DelInvalidCtr++;
             putValue( env_AudioSD_SL_delete_Message, "INVALID POS!" );
            }

     }
}

//MR49870
SourceList_delete_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word SLlistCtr, PosCtr,PosVal;

    result = 0x01;
    delFlg= 0;
    gSL_DelInvalidCtr = 0;
    gSL_DelValidCtr = 0;
    putValue( env_AudioSD_SL_delete_Message, empty_string );
    PosVal = 0;

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {

         result = 0x00;
         delFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+ 1];


      for( SLlistCtr = 0;SLlistCtr < gSL_CSVtotalElem; SLlistCtr++ )
      {
           if( PosVal== gSourceList_Pos_insDel[SLlistCtr][0] )   //check if POS is valid
           {

             if( gSourceList_Pos_insDel[SLlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gSourceList_Pos_insDel[SLlistCtr][1] = 0x01;    //tagging deleted Pos
               gSourceList_Send[gSL_DelValidCtr][0] = pos[PosCtr];
               gSL_DelValidCtr++;
               gSourceList_Send[gSL_DelValidCtr][0] = pos[PosCtr+ 1];
               gSL_DelValidCtr++;
                gSL_totalDELctr++;
                gSourceList_Send[gSL_DelValidCtr][1] = gSourceList_Pos_insDel[SLlistCtr][2];
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_SL_delete_Message, "POS already deleted!" );
              gSL_InvalidDel[gSL_DelInvalidCtr] = pos[PosCtr];
              gSL_DelInvalidCtr++;
              gSL_InvalidDel[gSL_DelInvalidCtr] = pos[PosCtr+ 1];
              gSL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
        {

            gSL_InvalidDel[gSL_DelInvalidCtr] = pos[PosCtr];
            gSL_DelInvalidCtr++;
            gSL_InvalidDel[gSL_DelInvalidCtr] = pos[PosCtr+ 1];
            gSL_DelInvalidCtr++;
             putValue( env_AudioSD_SL_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : SourceList
on envVar env_AudioSD_SL_insert
{
    word startelement, elements,successor, ctr, PosCtr,SLlistCtr,elemTemp,PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_SOURCELIST_ENTRIES],startIndex, succIndex, posInBetweenCheck;;
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,k,x;


    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;
    elemTemp            = 0;
    startIndex              = 0;
    succIndex               = 0;
    PosVal                  = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        for( i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++ )
            POS[i] = 0;

        for( i = 0; i < BAP_BUFFER_SIZE; i++ )
            requestarray[i] = 0;


         for( i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++ )
            gSL_InvalidIns[i] = 0;

            for( i = 0; i < AUDIO_SOURCELIST_ENTRIES; i++ )
            {
                gSourceList_Send[i][0] = 0;  //pos
                gSourceList_Send[i][1] = 0;  //sourcetype
            }


    putValue( env_AudioSD_SL_Insert_Invalid, gSL_InvalidIns );

    gSL_InsInvalidCtr = 0;
    gSL_InsValidCtr = 0;
    putValue( env_AudioSD_SL_Insert_Message, empty_string );

        //get data from Panel
        //Patch GB 11.07.2014 -commented
        //recordaddress   = 0x0F;

        putvalue ( env_AudioSD_SL_Insert_Message, empty_string );
        //MR 63332 #3   02.07.2014
        //gSL_TotalElem = getValue( env_AudioSD_SL_TotalNumLE );
        gSL_TotalElem = gSourceList_TotalNumListElements;

        if( getValue( env_AudioSD_SL_insert_UPD_button )== 0x00 )
        {
         shift           = 0x01; //insert
         //Patch GB 11.07.2014
         recordaddress   = 0x0F;
         }

        else
        {
        shift           = 0x0; //update
        //Patch GB 11.07.2014
        recordaddress   = getValue( env_AudioSD_SL_AH_RA);
        }

        direction       = 0x0;
        transmitpos     = 0x01;

        indexsize       = getvalue( env_AudioSD_SL_insert_size );
        //mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //message
        requestarray[0] = LSG_AudioSD;                //LSG-ID
        requestarray[1] = FctID_SourceList;        //Fct.-ID
        requestarray[2] =Changed_REQ;                  //request type
        Offset = 3;

        startelement    = getValue( env_AudioSD_SL_insert_start );

        successor = getValue( env_AudioSD_SL_insert_successor );


            switch( indexsize ) // POS size
            {
                case 0: //8Bit
                    getvalue( env_AudioSD_SL_insert_POS_8, POS);
                    ctr      = getValueSize( env_AudioSD_SL_insert_POS_8 );

                    if( getValue( env_AudioSD_SL_insert_ErrHandler )== 0x01 )
                    {

                        if( ctr == 0 )   // if no data
                        {
                        putValue( env_AudioSD_SL_Insert_Message, "NO DATA TO SEND" );
                        break;
                        }

                        else     // with data
                        {
                            //if START and SUCC are invalid for Insert
                            if( getvalue( env_AudioSD_SL_insert_start ) == 0x00 && getvalue( env_AudioSD_SL_insert_successor ) == 0x00 && getvalue( env_AudioSD_SL_insert_UPD_button ) == 0x00 )
                            {
                                //check if not all elements are deleted
                                if( gSL_totalDELctr < gSL_CSVtotalElem)
                                {
                                putValue( env_AudioSD_SL_Insert_Message, "INVALID START & SUCCESSOR" );
                                break;
                                }
                            }

                            //checking for POS sequence for insert
                            //call this before ErrorHandler because of INS/DEL tagging
                            posInBetweenCheck       = 0;
                            if( ctr >1 )
                            {
                                posInBetweenCheck =  slPosSequence_check ( indexsize,POS, ctr );
                                if( posInBetweenCheck == 0x01 )
                                {
                                    putValue( env_AudioSD_SL_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                    break;
                                }
                            }
                        SourceList_insert_ErrHandler_8 ( POS, ctr );
                        //if update has invalid POS - do not send
                            if( getvalue( env_AudioSD_SL_insert_UPD_button ) == 0x01 )  //update
                            {
                                if( gSL_InsInvalidCtr > 0 )
                                {
                                    putValue( env_AudioSD_SL_Insert_Message, "INVALID POS EXISTS" );
                                    break;
                                }
                            }
                            //if all elements are INVALID for INSERT

                            if( ctr == gSL_InsInvalidCtr )
                            {
                            putValue( env_AudioSD_SL_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                            }
                            else
                            {
                                elements = gSL_InsValidCtr+ 1;
                                ctr = gSL_InsValidCtr;
                            }

                        }//else with data
                    }
                    else   // no error handling
                    {
                        elements = ctr+ 1;
                        if( ctr == 0 )    // if no data
                        {
                        transmitpos     = 0x0;

                            if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                            else
                                elements = successor - startelement;
                        }
                     }

                    //mode
                    mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                        /***ArrayHeader***/
                        requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                        Offset++;

                        //start
                        requestarray[Offset] = startelement;
                        Offset++;

                        //elements
                         requestarray[Offset] = elements;
                         Offset++;

                    /***ArrayData***/

                    //ArrayData with error handling
                    if( getValue( env_AudioSD_SL_insert_ErrHandler )== 0x01 )
                    {
                        //ARRAY DATA
                            for( i = 0; i <ctr; i++ )
                                {
                                    //store in array the inserted item
                                    requestarray[Offset] = gSourceList_Send[i][0];
                                    Offset++;
                                }


                    } //end if with ERROR handling

                    //ArrayData WITHOUT error handling
                    else
                    {
                         for( i = 0; i <ctr; i++ )
                         {
                            requestarray[Offset] = POS[i];
                            Offset++;
                         }
                    }

                    //successor
                    if( ctr > 0 )
                    {
                        requestarray[Offset] = successor;

                        Offset++;
                    }

                break;

             case 1:  //16Bit
               getvalue( env_AudioSD_SL_insert_POS_16, POS);
               elements      = getValueSize( env_AudioSD_SL_insert_POS_16 );
               elemTemp = ( getValueSize( env_AudioSD_SL_insert_POS_16 ) /2 );

                    if( getValue( env_AudioSD_SL_insert_ErrHandler )== 0x01 )
                    {
                        if( elemTemp== 0 )   // if no data
                        {
                            putValue( env_AudioSD_SL_Insert_Message, "NO DATA TO SEND" );
                            break;
                        }
                        else     // with data
                        {
                            //if START and SUCC are invalid
                            if( ( getvalue( env_AudioSD_SL_insert_start ) == 0x00 ) && ( getvalue( env_AudioSD_SL_insert_successor ) == 0x00 )&& ( getvalue( env_AudioSD_SL_insert_UPD_button ) == 0x00 ) )
                            {
                                //check if not all elements are deleted
                                if( gSL_totalDELctr < gSL_CSVtotalElem)
                                {
                                putValue( env_AudioSD_SL_Insert_Message, "INVALID START & SUCCESSOR" );
                                break;
                                }
                            }


                            //checking for POS sequence for insert
                            //call this before ErrorHandler because of INS/DEL tagging
                                if( ctr >1 )
                                {
                                    posInBetweenCheck =  slPosSequence_check ( indexsize,POS,elemTemp);
                                    if( posInBetweenCheck == 0x01 )
                                    {
                                        putValue( env_AudioSD_SL_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                        break;
                                    }
                                }

                            SourceList_insert_ErrHandler_16 ( POS,elements );
                            //if all elements are INVALID

                            //if update has invalid POS - do not send
                            if( getvalue( env_AudioSD_SL_insert_UPD_button ) == 0x01 )  //update
                            {
                                if( gSL_InsInvalidCtr > 0 )
                                {
                                    putValue( env_AudioSD_SL_Insert_Message, "INVALID POS EXISTS" );
                                    break;
                                }
                            }

                            if( elemTemp == gSL_InsInvalidCtr )
                            {
                                putValue( env_AudioSD_SL_Insert_Message, "POS INVALID / STILL EXIST" );
                                break;
                            }
                            else
                            {
                                elements = ( gSL_InsValidCtr/2 )+ 1;     //including successor
                                elemTemp = gSL_InsValidCtr/2;
                            }
                        } //else with data
                    }
                    else   // no error handling
                    {
                        elements = elemTemp+ 1;  //including successor
                        if( elemTemp== 0 )    // if no data
                        {
                            transmitpos = 0x0;
                             if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                                elements = 1;
                            else
                            elements = successor - startelement;
                        }
                    }

                    //mode
                    mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 )& 0xF0 ) + ( recordaddress& 0x0F );
                Offset++;

                requestarray[Offset] = startelement& 0xff;
                Offset++;
                requestarray[Offset] = (startelement& 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements& 0xff;
                Offset++;
                requestarray[Offset] = ( elements& 0xff00 ) / 0x100;
                Offset++;

                    /***ArrayData***/

                    //ArrayData with error handling
                    if( getValue( env_AudioSD_SL_insert_ErrHandler )== 0x01 )
                    {
                        for(  i = 0; i < elemTemp; i++ )
                            {
                                PosVal = 0x00;

                                //store in array the inserted item
                                requestarray[Offset] = gSourceList_Send[(2*i)+ 1][0];
                                PosVal = requestarray[Offset];
                                Offset++;
                                requestarray[Offset] = gSourceList_Send[(2*i)+0][0];
                                PosVal = PosVal|requestarray[Offset]<<8;
                                Offset++;
                             }

                        //INDEXING FOR INSERT

                        if( getValue( env_AudioSD_SL_insert_UPD_button )== 0x00 )  //check if insert
                        {
                             // if all elements are deleted
                             if( gSL_totalDELctr == gSL_CSVtotalElem)
                             {
                                     PosVal = 0x00;
                                     PosVal = gSourceList_Send[0][0] << 8;
                                     PosVal = PosVal|gSourceList_Send[1][0];

                                     gAudioSD_activeSource_SourceList_Reference  = PosVal;
                                     gAudioSD_activeSource_SourceType = 1;

                                     i = 0;
                                    for( j = 0; j < gSL_CSVtotalElem; j++ )
                                    {
                                        if( gSourceList_Pos_insDel[j][1] == 0x01 )
                                        continue ;
                                        else
                                        {
                                        i++;
                                        gSourceList_Pos_insDel[j][2] = i;
                                        }
                                    }

                             }
                            else if( gSL_totalDELctr < gSL_CSVtotalElem)
                            {
                                //Get Start and Successor Index
                                for(  j = 0; j < gSL_CSVtotalElem; j++ )
                                {
                                    //Start
                                    if( getValue( env_AudioSD_SL_insert_start ) == gSourceList_Pos_insDel[j][0] )
                                    {
                                        startIndex = gSourceList_Pos_insDel[j][2];
                                    }
                                    //Succ
                                    if( getValue( env_AudioSD_SL_insert_successor ) == gSourceList_Pos_insDel[j][0] )
                                    {
                                        succIndex = gSourceList_Pos_insDel[j][2];
                                    }
                                }
                                //handling if inserted at the edges
                                if(succIndex == 0 )
                                {
                                    succIndex = startIndex + 1;
                                }
                                if(startIndex == 0 )
                                {
                                    startIndex = succIndex - 1;
                                }

                                //Increment indexes of items from the successor onwards ( by inserted items number )
                                for( j = 0; j < gSL_CSVtotalElem; j++ )
                                {
                                    if( succIndex <= gSourceList_Pos_insDel[j][2] )
                                    {
                                        gSourceList_Pos_insDel[j][2] = gSourceList_Pos_insDel[j][2] + elemTemp;
                                    }

                                    if( getvalue( env_AudioSD_activeSrc_SLRef ) == gSourceList_Pos_insDel[j][0] )
                                    {
                                        gAudioSD_activeSource_SourceType = gSourceList_Pos_insDel[j][2];
                                    }
                                }

                                     //Store Index of inserted items
                                    //Loop number of times as inserted items
                                    for(  i = 0; i < elemTemp; i++ )
                                    {
                                        PosVal = 0x00;
                                        PosVal = gSourceList_Send[(2*i)+ 1][0];
                                        PosVal = PosVal|gSourceList_Send[(2*i)+0][0]<<8;

                                        //Loop through array to find POS matching inserted item
                                        for(  k = 0; k < gSL_CSVtotalElem; k++ )
                                        {
                                            if( PosVal == gSourceList_Pos_insDel[k][0] )
                                            {
                                                gSourceList_Pos_insDel[k][2] = startIndex + i + 1;
                                                break;
                                            }
                                        }//for
                                    }//for
                            } //else if gSL_totalDELctr

                            //Update handle
                            //gAudioSD_activeSource_SourceType = gAudioSD_activeSource_SourceType + ctr;
                            putvalue( env_AudioSD_activeSrc_Type, gAudioSD_activeSource_SourceType );
                            putvalue( env_AudioSD_activeSrc_SLRef, gAudioSD_activeSource_SourceList_Reference );
                            sourceListType ();
                            activeSource_Request( Data_REQ, 0 );   //send status

                        } // end if INSERT

                    } // end if with Errorhandling
                    //ArrayData WITHOUT error handling
                    else
                    {
                        for(  i = 0; i < elemTemp; i++ )
                        {
                            requestarray[Offset] = POS[(2*i)+ 1];
                            Offset++;
                            requestarray[Offset] = POS[(2*i)+0];
                            Offset++;
                        }
                    }

                //successor
                if( elemTemp > 0 )
                {
                requestarray[Offset] = successor& 0xff;
                Offset++;
                requestarray[Offset] = (successor& 0xff00 ) / 0x100;
                Offset++;
                }
                break;

                default:
                    break; //default

            }//switch

            if( indexsize== 0x01 )
            gSL_InsValidCtr = gSL_InsValidCtr/2;

            //updating the totalDeletedCtr;
            gSL_totalDELctr = gSL_totalDELctr - gSL_InsValidCtr;

            if( gSL_totalDELctr > gSL_CSVtotalElem)
            gSL_totalDELctr = 0;


            //just send the data when errorhandler is OFF
            if( getValue( env_AudioSD_SL_insert_ErrHandler )== 0x00 )
                set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

            else if( getValue( env_AudioSD_SL_insert_ErrHandler )== 0x01 )  //with ERROR HANDLER
            {
                if( getValue( env_AudioSD_SL_insert_UPD_button )== 0x00 )  //insert
                {
                    // if there's a Valid POS and Sequence is correct
                    if( gSL_InsValidCtr != 0x00 && posInBetweenCheck == 0x00 )
                    {
                        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

                        if( gSL_TotalElem + gSL_InsValidCtr <= gSL_CSVtotalElem)
                        {
                            //MR 63332 #3   02.07.2014
                                            //putValue( env_AudioSD_SL_TotalNumLE, gSL_TotalElem + gSL_InsValidCtr );
                            //gSourceList_TotalNumListElements = getValue( env_AudioSD_SL_TotalNumLE );
                                            gSourceList_TotalNumListElements = gSL_TotalElem + gSL_InsValidCtr;
                            putValue( env_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements );
                        } //if


                    }// if gSL_InsValidCtr
                }// if insert
                else
                {
                    //send only UPDATE if all POS are valid and DATA!= 0
                    if( gSL_InsInvalidCtr == 0x00 && gSL_InsValidCtr!= 0 )
                        set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                }// else UPD button
            } //else if

    }
        //else
        //putValue( env_AudioSD_SL_insert_UPD_button, 0 );

}

//IssueList #76 - MR49870 : SourceList
void SourceList_insert_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word SLlistCtr, PosCtr;

    result = 0x01;
    InsFlg= 0;

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {
             result = 0x00;
             InsFlg = 0x00;

            for( SLlistCtr = 0;SLlistCtr < gSL_CSVtotalElem; SLlistCtr++ )
            {
                if( pos[PosCtr] == gSourceList_Pos_insDel[SLlistCtr][0] )   //check if POS is valid
                {
                        //UPDATE
                        if  ( getValue( env_AudioSD_SL_insert_UPD_button ) == 0x01 )
                        {
                                if( gSourceList_Pos_insDel[SLlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                                    {
                                    result = 0x01;
                                    gSourceList_Send[gSL_InsValidCtr][0] = pos[PosCtr];
                                    gSL_InsValidCtr++;
                                    }
                                else
                                    {
                                    putValue( env_AudioSD_SL_Insert_Message, "POS is already deleted!" );
                                    gSL_InvalidIns[gSL_InsInvalidCtr] = pos[PosCtr];
                                    gSL_InsInvalidCtr++;
                                    InsFlg = 0x01;
                                    break;
                                    }
                        }
                        else   //INSERT
                        {
                            if( gSourceList_Pos_insDel[SLlistCtr][1] == 0x01 )  //check if POS does not exist
                               {
                                gSourceList_Pos_insDel[SLlistCtr][1] = 0x00;
                                gSourceList_Send[gSL_InsValidCtr][0] = pos[PosCtr];
                                gSourceList_Send[gSL_InsValidCtr][1] = gSourceList_Pos_insDel[SLlistCtr][2];
                                gSL_InsValidCtr++;
                               result = 0x01;
                               }
                              else
                              {
                              putValue( env_AudioSD_SL_Insert_Message, "POS still exists!" );
                              gSL_InvalidIns[gSL_InsInvalidCtr] = pos[PosCtr];
                              gSL_InsInvalidCtr++;
                              InsFlg = 0x01;
                              break;
                              }
                        }
                }//IF
            } //SLlistCtr
            if( result == 0x00 && InsFlg == 0x00 )
               {
                gSL_InvalidIns[gSL_InsInvalidCtr] =pos[PosCtr];
                gSL_InsInvalidCtr++;
                putValue( env_AudioSD_SL_Insert_Message, "INVALID POS!" );
                }
    }//for elementsCtr

         if( gSL_InsInvalidCtr!= 0 )
                putValue( env_AudioSD_SL_Insert_Invalid, gSL_InvalidIns );

}

//IssueList #76 - MR49870 : SourceList
on envVar env_AudioSD_SL_delete_POS_8
{
byte DEL_POS_8[AUDIO_SOURCELIST_ENTRIES];

putValue( env_AudioSD_SL_delete_Message, empty_string );

    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_SL_delete_ErrHandler )== 0x01 )
    {
    getValue( this, DEL_POS_8 );
    putValue( env_AudioSD_SL_delete_start, DEL_POS_8[0] );
    }

}

//IssueList #76 - MR49870 : SourceList
on envVar env_AudioSD_SL_delete_ErrHandler
{
if( getValue( this )== 0x00 )
putValue( env_AudioSD_SL_TotalNumLE, gSourceList_TotalNumListElements );
}

//IssueList #76 - MR49870 : ReceptionList
on envVar env_AudioSD_RL_delete_POS_16
{
byte DEL_POS_16[AUDIO_RECEPTIONLIST_ENTRIES];
word PosVal_16;

putValue( env_AudioSD_RL_delete_Message, empty_string );


    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_RL_delete_ErrHandler )== 0x01 )
    {
    getValue( this, DEL_POS_16 );
    PosVal_16 = DEL_POS_16[0] << 8;
    PosVal_16 = PosVal_16|DEL_POS_16[1];

    putValue( env_AudioSD_RL_delete_start, PosVal_16 );
    }

}

//IssueList #76 - MR49870 : ReceptionList
//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_RL_insert_POS_16
{
byte INS_POS_16[AUDIO_RECEPTIONLIST_ENTRIES];
int  inputCtr,i,j;
word PosVal_16_first,PosVal_16_last;
byte validInputFlg_start, validInputFlg_succ;

inputCtr = 0;
PosVal_16_first = 0;
PosVal_16_last = 0;
validInputFlg_start = 0;
validInputFlg_succ = 0;


putvalue ( env_AudioSD_RL_Insert_Message, empty_string );

    //if( getValue( env_AudioSD_RL_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_RL_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_RL_insert_ErrHandler )== 0x01 )
    {
    getValue( this, INS_POS_16 );

     inputCtr =  getValueSize( env_AudioSD_RL_insert_POS_16 );

         if( inputCtr > 1 )
         {
            //look for the valid reference for Start and successor
             for( j = 0; j < inputCtr; j++ )
             {
             //valid_INS_POS_8 = INS_POS_8[j];

             PosVal_16_first = INS_POS_16[j] << 8;
             PosVal_16_first = PosVal_16_first | INS_POS_16[j+ 1];


                for( i = 0; i < gRL_CSVtotalElem; i++ )
                 {
                 //check if input is valid and deleted
                     if( PosVal_16_first == gReceptionList_Pos_insDel[i][0] && gReceptionList_Pos_insDel[i][1] == 0x01 )
                     {
                     validInputFlg_start = 1;
                     break;
                     }
                 }
                 if( validInputFlg_start == 0x01 )
                 break;
               }

                if( validInputFlg_start == 0x01 )
                {
                    //start
                     if( PosVal_16_first == gReceptionList_Pos_insDel[0][0] )
                         putValue( env_AudioSD_RL_insert_start, 0 );

                     else
                     {
                        ///look for the next existing element upwards
                         for( i = 2; i < gRL_CSVtotalElem; i++ )
                         {
                             if( PosVal_16_first == gReceptionList_Pos_insDel[i][0] )
                             {
                                for( j = i-1; j> 0; j--)
                                 {
                                 if( gReceptionList_Pos_insDel[j][1]!= 0x01 )
                                    {
                                     putValue( env_AudioSD_RL_insert_start, gReceptionList_Pos_insDel[j][0] );
                                     break;
                                     }//if
                                 }//for
                              }
                         }//for
                     }//else
                }

                   //successor
                for( j = inputCtr; j> 0; j--)
                {

                     PosVal_16_last = INS_POS_16[j-1] << 8;
                     PosVal_16_last = PosVal_16_last | INS_POS_16[j];

                     for( i = 0; i < gRL_CSVtotalElem; i++ )
                     {
                     //check if input is valid and deleted
                         if( PosVal_16_last == gReceptionList_Pos_insDel[i][0] && gReceptionList_Pos_insDel[i][1] == 0x01 )
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     }
                     if( validInputFlg_succ == 0x01 )
                     break;
                }

                if( validInputFlg_succ == 0x01 )
                {

                   putValue( env_AudioSD_RL_insert_successor, 0 );
                    for( i = 0; i < gRL_CSVtotalElem; i++ )
                    {

                         if( PosVal_16_last == gReceptionList_Pos_insDel[i][0] )
                         {
                             if( i == gRL_CSVtotalElem-1 )
                             putValue( env_AudioSD_RL_insert_successor, 0 );
                             else
                             {
                                 //look for the next existing element downwards
                                 for( j = i + 1; j < gRL_CSVtotalElem; j++ )
                                 {
                                     if( gReceptionList_Pos_insDel[j][1]!= 0x01 )
                                     {
                                     putValue( env_AudioSD_RL_insert_successor, gReceptionList_Pos_insDel[j][0] );
                                     break;
                                     }
                                 }
                             }

                        }//if
                 }//for
               } //validInputFlg_succ
           }//inputCtr
    }

}

//IssueList #76 - MR49870 : ReceptionList
byte rlPosSequence_check ( byte Index, byte inputArray[],word inputCtr )
{
    byte posInBetween;
    word ctr, ctr1, ctr2,PosVal1_,PosVal2_;

    posInBetween = 0;

    for( ctr = 0; ctr < inputCtr; ctr++ )
    {
        // adjust for 8bit and 16bit handling
        if( Index== 0x00 )
        {
            PosVal1_ = inputArray[ctr];
            PosVal2_ = inputArray[ctr+ 1];
        }
        else
        {
            PosVal1_ = 0x0000;
            PosVal1_ = inputArray[(2*ctr )+ 1];
            PosVal1_ = PosVal1_|(( inputArray[(2*ctr )+0] )<<8 );
            PosVal2_ = 0x0000;
            PosVal2_ = inputArray[(2*ctr )+2+ 1];
            PosVal2_ = PosVal2_|(( inputArray[(2*ctr )+2+0] )<<8 );
        }

        // search send item in insdel array
        for( ctr1 = 0; ctr1 < gRL_CSVtotalElem; ctr1++ )
        {
            if( PosVal1_ == gReceptionList_Pos_insDel[ctr1][0] ) // 1st send item is found in array
            {
                break;
            }
        }

        // search insdel array for next send item
        for( ctr2 = ctr1+ 1; ctr2 < gRL_CSVtotalElem; ctr2++ ) // loop from 1st inserted item in insdel array
        {

            if( PosVal2_ == gReceptionList_Pos_insDel[ctr2][0] ) // 2nd send item immediately next to 1st send item
            {
                break;
            }
            else
            {
                if( gReceptionList_Pos_insDel[ctr2][1] == 0 && PosVal2_ != 0 )    // in between item is not deleted
                {
                    posInBetween = 0x01;
                    break;
                }
            }
        }

        if( posInBetween == 0x01 )
        {
            break;
        }
    }

    return posInBetween;

    }

//IssueList #76 - MR49870 : SourceList
on envVar env_AudioSD_SL_delete_POS_16
{
byte DEL_POS_16[AUDIO_SOURCELIST_ENTRIES];
word PosVal_16;

putValue( env_AudioSD_SL_delete_Message, empty_string );


    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_SL_delete_ErrHandler )== 0x01 )
    {
    getValue( this, DEL_POS_16 );
    PosVal_16 = DEL_POS_16[0] << 8;
    PosVal_16 = PosVal_16|DEL_POS_16[1];

    putValue( env_AudioSD_SL_delete_start, PosVal_16 );
    }

}

//IssueList #76 - MR49870 : SourceList
byte slPosSequence_check ( byte Index, byte inputArray[],word inputCtr )
{
    byte posInBetween;
    word ctr, ctr1, ctr2,PosVal1_,PosVal2_;

    posInBetween = 0;

    for( ctr = 0; ctr < inputCtr; ctr++ )
    {
        // adjust for 8bit and 16bit handling
        if( Index== 0x00 )
        {
            PosVal1_ = inputArray[ctr];
            PosVal2_ = inputArray[ctr+ 1];
        }
        else
        {
            PosVal1_ = 0x0000;
            PosVal1_ = inputArray[(2*ctr )+ 1];
            PosVal1_ = PosVal1_|(( inputArray[(2*ctr )+0] )<<8 );
            PosVal2_ = 0x0000;
            PosVal2_ = inputArray[(2*ctr )+2+ 1];
            PosVal2_ = PosVal2_|(( inputArray[(2*ctr )+2+0] )<<8 );
        }

        // search send item in insdel array
        for( ctr1 = 0; ctr1 < gSL_CSVtotalElem; ctr1++ )
        {
            if( PosVal1_ == gSourceList_Pos_insDel[ctr1][0] ) // 1st send item is found in array
            {
                break;
            }
        }

        // search insdel array for next send item
        for( ctr2 = ctr1+ 1; ctr2 < gSL_CSVtotalElem; ctr2++ ) // loop from 1st inserted item in insdel array
        {

            if( PosVal2_ == gSourceList_Pos_insDel[ctr2][0] ) // 2nd send item immediately next to 1st send item
            {
                break;
            }
            else
            {
                if( gSourceList_Pos_insDel[ctr2][1] == 0 && PosVal2_ != 0 )    // in between item is not deleted
                {
                    posInBetween = 0x01;
                    break;
                }
            }
        }

        if( posInBetween == 0x01 )
        {
            break;
        }
    }

    return posInBetween;

    }

//IssueList #76 - MR49870 : SourceList
void SourceList_insert_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word PosVal,SLlistCtr, PosCtr;



    result = 0x01;
    InsFlg= 0;
    PosVal = 0;


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {
         result = 0x00;
         InsFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+ 1];

      for( SLlistCtr = 0;SLlistCtr < gSL_CSVtotalElem; SLlistCtr++ )
      {
           if( PosVal== gSourceList_Pos_insDel[SLlistCtr][0] )   //check if POS is valid
           {
            //UPDATE
            if  ( getValue( env_AudioSD_SL_insert_UPD_button ) == 0x01 )
             {

                if( gSourceList_Pos_insDel[SLlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                    {
                    result = 0x01;
                    gSourceList_Send[gSL_InsValidCtr][0] = pos[PosCtr];
                    gSL_InsValidCtr++;
                    gSourceList_Send[gSL_InsValidCtr][0] = pos[PosCtr+ 1];
                    gSL_InsValidCtr++;
                    }
                     else
                      {
                      putValue( env_AudioSD_SL_Insert_Message, "POS is already deleted!" );
                      gSL_InvalidIns[gSL_InsInvalidCtr] = pos[PosCtr];
                      gSL_InsInvalidCtr++;
                      gSL_InvalidIns[gSL_InsInvalidCtr] = pos[PosCtr+ 1];
                      gSL_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                  }

            }  //update

             else   //INSERT
             {
                 if( gSourceList_Pos_insDel[SLlistCtr][1] == 0x01 )  //check if POS does not exist
                   {
                   gSourceList_Pos_insDel[SLlistCtr][1] = 0x00;
                   gSourceList_Send[gSL_InsValidCtr][0] = pos[PosCtr];
                   gSL_InsValidCtr++;
                   gSourceList_Send[gSL_InsValidCtr][0] = pos[PosCtr+ 1];
                   gSL_InsValidCtr++;
                   result = 0x01;

                   }
                  else
                  {
                  putValue( env_AudioSD_SL_Insert_Message, "POS still exists!" );
                  gSL_InvalidIns[gSL_InsInvalidCtr] = pos[PosCtr];
                  gSL_InsInvalidCtr++;
                  gSL_InvalidIns[gSL_InsInvalidCtr] = pos[PosCtr+ 1];
                  gSL_InsInvalidCtr++;
                  InsFlg = 0x01;
                  break;
                  }
               }//if
            } //else
       }//for
        if( result == 0x00 && InsFlg == 0x00 )
           {
            gSL_InvalidIns[gSL_InsInvalidCtr] =pos[PosCtr];
            gSL_InsInvalidCtr++;
            gSL_InvalidIns[gSL_InsInvalidCtr] = pos[PosCtr+ 1];
            gSL_InsInvalidCtr++;
             putValue( env_AudioSD_SL_Insert_Message, "INVALID POS!" );
            }
     }//for SLlistCtr

     if( gSL_InsInvalidCtr!= 0 )
            putValue( env_AudioSD_SL_Insert_Invalid, gSL_InvalidIns );
}

//IssueList #76 - MR49870 : RTPL
on envVar env_AudioSD_RTPL_insert
{
    word startelement, elements,successor, ctr, PosCtr,RTPLCtr,elemTemp,PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_RADIOTVPRESETLIST_ENTRIES ], startIndex, succIndex, posInBetweenCheck;
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,k,x;


    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;
    elemTemp                = 0;
    startIndex              = 0;
    succIndex               = 0;
    PosVal                  = 0;


    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES ; i++ )
            POS[i] = 0;

        for( i = 0; i < BAP_BUFFER_SIZE; i++ )
            requestarray[i] = 0;

        for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES ; i++ )
            gRTPL_InvalidIns[i] = 0;

        for( i = 0; i < AUDIO_RADIOTVPRESETLIST_ENTRIES ; i++ )
        {
            gRTPL_Send[i][0] = 0;
            gRTPL_Send[i][1] = 0;
        }


        putValue( env_AudioSD_RTPL_Insert_Invalid, gRTPL_InvalidIns );

        gRTPL_InsInvalidCtr = 0;
        gRTPL_InsValidCtr = 0;
        putValue( env_AudioSD_RTPL_Insert_Message, empty_string );

        //get data from Panel
        //Patch GB 11.07.2014 -commented
        //recordaddress   = 0x0F;

        putvalue ( env_AudioSD_RTPL_Insert_Message, empty_string );
        //MR 63332 #3   02.07.2014
        //gRTPL_TotalElem = getValue( env_AudioSD_RTPL_TotalNumLE );
        gRTPL_TotalElem = gRadioTVPresetList_TotalNumListElements;

        if( getValue( env_AudioSD_RTPL_insert_UPD_btn )== 0x00 )
        {    shift          = 0x01; //insert
            gRTPL_InsertFlg = 0x01;
            //Patch GB 11.07.2014
            recordaddress   = 0x0F;
        }
        else
        {
            shift           = 0x0; //update
            //Patch GB 11.07.2014
            recordaddress   = getValue( env_AudioSD_RTPL_AH_RA);
        }

        direction       = 0x0;
        transmitpos     = 0x01;


        indexsize       = getvalue( env_AudioSD_RTPL_insert_size );
        //mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //message
        requestarray[0] = LSG_AudioSD;                //LSG-ID
        requestarray[1] = FctID_RadioTV_PresetList;        //Fct.-ID
        requestarray[2] =Changed_REQ;                  //request type

        Offset = 3;

        startelement    = getValue( env_AudioSD_RTPL_insert_start );

        successor = getValue( env_AudioSD_RTPL_insert_succr );


        switch( indexsize ) // POS size
        {
            case 0: //8Bit
                getvalue( env_AudioSD_RTPL_insert_POS_8, POS);
                ctr = getValueSize( env_AudioSD_RTPL_insert_POS_8 );

                if( getValue( env_AudioSD_RTPL_insert_ErrHndlr )== 0x01 )
                {

                    if( ctr == 0 )   // if no data
                    {
                        putValue( env_AudioSD_RTPL_Insert_Message, "NO DATA TO SEND" );
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid for Insert
                        if( getvalue( env_AudioSD_RTPL_insert_start ) == 0x00 && getvalue( env_AudioSD_RTPL_insert_succr ) == 0x00 && getvalue( env_AudioSD_RTPL_insert_UPD_btn ) == 0x00 )
                        {
                            //check if not all elements are deleted
                            if( gRTPL_totalDELctr < gRTPL_CSVtotalElem)
                            {
                            putValue( env_AudioSD_RTPL_Insert_Message, "INVALID START & SUCCESSOR" );
                            break;
                            }
                        }

                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                        posInBetweenCheck       = 0;
                        if( ctr >1 )
                        {
                            posInBetweenCheck =  rtplPosSequence_check ( indexsize,POS, ctr );
                            if( posInBetweenCheck == 0x01 )
                            {
                                putValue( env_AudioSD_RTPL_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                break;
                            }
                        }

                        RTPL_insert_ErrHandler_8 ( POS, ctr );

                        //if update has invalid POS - do not send
                        if( getvalue( env_AudioSD_RTPL_insert_UPD_btn ) == 0x01 )  //update
                        {
                            if( gRTPL_InsInvalidCtr > 0 )
                            {
                                putValue( env_AudioSD_RTPL_Insert_Message, "INVALID POS EXISTS" );
                                break;
                            }
                        }


                        //if all elements are INVALID for INSERT
                        if( ctr == gRTPL_InsInvalidCtr )
                        {
                            putValue( env_AudioSD_RTPL_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                        }
                        else
                        {
                            elements = gRTPL_InsValidCtr+ 1;
                            ctr = gRTPL_InsValidCtr;
                        }


                    }//else with data
                }
                else   // no error handling
                {
                    elements = ctr+ 1;
                    if( ctr == 0 )    // if no data
                    {
                        transmitpos     = 0x0;

                        if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                            elements = successor - startelement;
                    }
                 }

                //mode
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;

                //start
                requestarray[Offset] = startelement;
                Offset++;

                //elements
                requestarray[Offset] = elements;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if( getValue( env_AudioSD_RTPL_insert_ErrHndlr )== 0x01 )
                {
                    //ARRAY DATA
                        for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                requestarray[Offset] = gRTPL_Send[i][0];
                                Offset++;
                            }

                    //INDEXING FOR INSERT
                    if( getValue( env_AudioSD_RTPL_insert_UPD_btn )== 0x00 )  //check if insert
                    {

                         // if all elements are deleted
                         if( gRTPL_totalDELctr == gRTPL_CSVtotalElem)
                         {

                                 //assign the first Insert element as handle and POS
                                 gAudioSD_CSIhandle_PresetListRef = gRTPL_Send[0][0];
                                 gAudioSD_CSIhandle_PresetListabsolutePos = 1;

                                  i = 0;
                                for( j = 0; j < gRTPL_CSVtotalElem; j++ )
                                {
                                    if( gRTPL_Pos_insDel[j][1] == 0x01 )
                                    continue ;
                                    else
                                    {
                                    i++;
                                    gRTPL_Pos_insDel[j][2] = i;
                                    }
                                } //for
                         } //if
                         else if( gRTPL_totalDELctr < gRTPL_CSVtotalElem)
                        {

                            //Get Start and Successor Index
                            for(  j = 0; j < gRTPL_CSVtotalElem; j++ )
                            {
                                //Start
                                if( getValue( env_AudioSD_RTPL_insert_start ) == gRTPL_Pos_insDel[j][0] )
                                {
                                    startIndex = gRTPL_Pos_insDel[j][2];
                                }
                                //Succ
                                if( getValue( env_AudioSD_RTPL_insert_succr ) == gRTPL_Pos_insDel[j][0] )
                                {
                                    succIndex = gRTPL_Pos_insDel[j][2];
                                }
                            }
                            //handling if inserted at the edges
                            if(succIndex == 0 )
                            {
                                succIndex = startIndex + 1;
                            }
                            if(startIndex == 0 )
                            {
                                startIndex = succIndex - 1;
                            }

                            //Increment indexes of items from the successor onwards ( by inserted items number )
                            for( j = 0; j < gRTPL_CSVtotalElem; j++ )
                            {
                                if( succIndex <= gRTPL_Pos_insDel[j][2] )
                                {
                                    gRTPL_Pos_insDel[j][2] = gRTPL_Pos_insDel[j][2] + ctr;
                                }

                                if( getvalue( env_AudioSD_CSH_PresetListRef ) == gRTPL_Pos_insDel[j][0] )
                                {
                                    gAudioSD_CSIhandle_PresetListabsolutePos = gRTPL_Pos_insDel[j][2];
                                }
                            }

                            //Store Index of inserted items
                            //Loop number of times as inserted items
                            for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                //requestarray[Offset] = gRTPL_Send[i][0];
                                //Offset++;

                                //Loop through array to find POS matching inserted item
                                for(  k = 0; k < gRTPL_CSVtotalElem; k++ )
                                {
                                    if( gRTPL_Send[i][0] == gRTPL_Pos_insDel[k][0] )
                                    {
                                        gRTPL_Pos_insDel[k][2] = startIndex + i + 1;
                                        break;
                                    } //if
                                } //for
                            } //for
                        }

                        //Update handle
                        //gAudioSD_CSIhandle_PresetListabsolutePos = gAudioSD_CSIhandle_PresetListabsolutePos + ctr;
                        putvalue( env_AudioSD_CSH_PresetListRef, gAudioSD_CSIhandle_PresetListRef );
                        putValue( env_AudioSD_CSH_PresetListAbsPos, gAudioSD_CSIhandle_PresetListabsolutePos );
                        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                    } //end if INSERT

                } //end if with ERROR handling

                //ArrayData WITHOUT error handling
                else
                {
                     for( i = 0; i <ctr; i++ )
                     {
                        requestarray[Offset] = POS[i];
                        Offset++;
                     }
                }

                //successor
                if( ctr > 0 )
                {
                    requestarray[Offset] = successor;
                    Offset++;
                }

            break;


            default:
                break; //default

        }//switch

        //resetting LoadReload Flg after Insert
        gRTPL_loadReloadFlg = 0x00;


        if( indexsize== 0x01 )
        gRTPL_InsValidCtr = gRTPL_InsValidCtr/2;

        //updating the totalDeletedCtr;
           gRTPL_totalDELctr = gRTPL_totalDELctr - gRTPL_InsValidCtr;

        if( gRTPL_totalDELctr > gRTPL_CSVtotalElem)
        gRTPL_totalDELctr = 0;


        //just send the data when errorhandler is OFF
        if( getValue( env_AudioSD_RTPL_insert_ErrHndlr )== 0x00 )
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else if( getValue( env_AudioSD_RTPL_insert_ErrHndlr )== 0x01 )  //with ERROR HANDLER
        {
            if( getValue( env_AudioSD_RTPL_insert_UPD_btn )== 0x00 )  //insert
            {
                // if there's a Valid POS and Sequence is correct
                if( gRTPL_InsValidCtr != 0x00 && posInBetweenCheck == 0x00 )
                {
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

                    if( gRTPL_TotalElem + gRTPL_InsValidCtr <= gRTPL_CSVtotalElem)
                    {
                        //MR 63332 #3   02.07.2014
                        //putValue( env_AudioSD_RTPL_TotalNumLE, gRTPL_TotalElem + gRTPL_InsValidCtr );
                        //gRadioTVPresetList_TotalNumListElements = getValue( env_AudioSD_RTPL_TotalNumLE );
                        gRadioTVPresetList_TotalNumListElements = gRTPL_TotalElem + gRTPL_InsValidCtr;
                        putValue( env_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements );
                    } //if


                }// if gRTPL_InsValidCtr
            }// if insert
            else
            {
                //send only UPDATE if all POS are valid and DATA!= 0
                if( gRTPL_InsInvalidCtr == 0x00 && gRTPL_InsValidCtr!= 0 )
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }// else UPD button
        } //else if
    }
    //else
    //putValue( env_AudioSD_RTPL_insert_UPD_btn, 0 );
}

//IssueList #76 - MR49870 : ReceptionList
on envVar env_AudioSD_RTPL_delete_POS_8
{
byte DEL_POS_8[AUDIO_RADIOTVPRESETLIST_ENTRIES ];

putValue( env_AudioSD_RTPL_delete_Message, empty_string );

    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_RTPL_del_ErrHandler )== 0x01 )
    {
    getValue( this, DEL_POS_8 );
    putValue( env_AudioSD_RTPL_delete_start, DEL_POS_8[0] );
    }

}

//IssueList #76 - MR49870 : RTPL
on envVar env_AudioSD_RTPL_del_ErrHandler
{
if( getValue( this )== 0x00 )
putValue( env_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements );
}

//IssueList #76 - MR49870 : RTPL
on envVar env_AudioSD_RTPL_insert_ErrHndlr
{
if( getValue( this )== 0x00 )
putValue( env_AudioSD_RTPL_TotalNumLE, gRadioTVPresetList_TotalNumListElements );
}

//IssueList #76 - MR49870 : RTPL
byte rtplPosSequence_check ( byte Index, byte inputArray[],word inputCtr )
{
    byte posInBetween;
    word ctr, ctr1, ctr2,PosVal1_,PosVal2_;

    posInBetween = 0;

    for( ctr = 0; ctr < inputCtr; ctr++ )
    {
        // adjust for 8bit and 16bit handling
        if( Index== 0x00 )
        {
            PosVal1_ = inputArray[ctr];
            PosVal2_ = inputArray[ctr+ 1];
        }
        else
        {
            PosVal1_ = 0x0000;
            PosVal1_ = inputArray[(2*ctr )+ 1];
            PosVal1_ = PosVal1_|(( inputArray[(2*ctr )+0] )<<8 );
            PosVal2_ = 0x0000;
            PosVal2_ = inputArray[(2*ctr )+2+ 1];
            PosVal2_ = PosVal2_|(( inputArray[(2*ctr )+2+0] )<<8 );
        }

        // search send item in insdel array
        for( ctr1 = 0; ctr1 < gRTPL_CSVtotalElem; ctr1++ )
        {
            if( PosVal1_ == gRTPL_Pos_insDel[ctr1][0] ) // 1st send item is found in array
            {
                break;
            }
        }

        // search insdel array for next send item
        for( ctr2 = ctr1+ 1; ctr2 < gRTPL_CSVtotalElem; ctr2++ ) // loop from 1st inserted item in insdel array
        {

            if( PosVal2_ == gRTPL_Pos_insDel[ctr2][0] ) // 2nd send item immediately next to 1st send item
            {
                break;
            }
            else
            {
                if( gRTPL_Pos_insDel[ctr2][1] == 0 && PosVal2_ != 0 )    // in between item is not deleted
                {
                    posInBetween = 0x01;
                    break;
                }
            }
        }

        if( posInBetween == 0x01 )
        {
            break;
        }
    }

    return posInBetween;

    }

//IssueList #76 - MR49870 : RTPL
void RTPL_insert_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word RTPLlistCtr, PosCtr;

    result = 0x01;
    InsFlg= 0;


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {
         result = 0x00;
         InsFlg = 0x00;

      for(  RTPLlistCtr = 0;RTPLlistCtr < gRTPL_CSVtotalElem; RTPLlistCtr++ )
      {
           if( pos[PosCtr] == gRTPL_Pos_insDel[RTPLlistCtr][0] )   //check if POS is valid
           {
            //UPDATE
                if  ( getValue( env_AudioSD_RTPL_insert_UPD_btn ) == 0x01 )
                 {
                        if( gRTPL_Pos_insDel[RTPLlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                        {
                        result = 0x01;
                        gRTPL_Send[gRTPL_InsValidCtr][0] = pos[PosCtr];
                        gRTPL_InsValidCtr++;
                        }

                        else
                          {
                          putValue( env_AudioSD_RTPL_Insert_Message, "POS is already deleted!" );
                          gRTPL_InvalidIns[gRTPL_InsInvalidCtr] = pos[PosCtr];
                          gRTPL_InsInvalidCtr++;
                          InsFlg = 0x01;
                          break;
                          }

                }  //update

                 else   //INSERT
                 {
                     if( gRTPL_Pos_insDel[RTPLlistCtr][1] == 0x01 )  //check if POS does not exist
                       {
                       gRTPL_Pos_insDel[RTPLlistCtr][1] = 0x00;
                       gRTPL_Send[gRTPL_InsValidCtr][0] = pos[PosCtr];
                       gRTPL_Send[gRTPL_InsValidCtr][1] = gRTPL_Pos_insDel[RTPLlistCtr][2];

                       gRTPL_InsValidCtr++;
                       result = 0x01;
                       }
                      else
                      {
                      putValue( env_AudioSD_RTPL_Insert_Message, "POS still exists!" );
                      gRTPL_InvalidIns[gRTPL_InsInvalidCtr] = pos[PosCtr];
                      gRTPL_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                      }
               }//if
            } //else
       }//for
        if( result == 0x00 && InsFlg == 0x00 )
           {
           gRTPL_InvalidIns[gRTPL_InsInvalidCtr] =pos[PosCtr];
            gRTPL_InsInvalidCtr++;
             putValue( env_AudioSD_RTPL_Insert_Message, "INVALID POS!" );
            }
     }//for RTPLlistCtr

     if( gRTPL_InsInvalidCtr!= 0 )
            putValue( env_AudioSD_RTPL_Insert_Invalid, gRTPL_InvalidIns );
}

//IssueList #76 - MR49870 : RTPLList
RTPL_delete_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word RTPLlistCtr, PosCtr;

    result = 0x01;
    delFlg= 0;
    gRTPL_DelInvalidCtr = 0;
    gRTPL_DelValidCtr = 0;
    putValue( env_AudioSD_RTPL_delete_Message, empty_string );


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {

         result = 0x00;
         delFlg = 0x00;

      for(  RTPLlistCtr = 0;RTPLlistCtr < gRTPL_CSVtotalElem; RTPLlistCtr++ )
      {

           if( pos[PosCtr] == gRTPL_Pos_insDel[RTPLlistCtr][0] )   //check if POS is valid
           {
             if( gRTPL_Pos_insDel[RTPLlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gRTPL_Pos_insDel[RTPLlistCtr][1] = 0x01;    //tagging deleted Pos
               gRTPL_Send[gRTPL_DelValidCtr][0] = pos[PosCtr];
               gRTPL_Send[gRTPL_DelValidCtr][1] = gRTPL_Pos_insDel[RTPLlistCtr][2];

               gRTPL_DelValidCtr++;
               gRTPL_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_RTPL_delete_Message, "POS already deleted!" );
              gRTPL_InvalidDel[gRTPL_DelInvalidCtr] = pos[PosCtr];
              gRTPL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
           {
           gRTPL_InvalidDel[gRTPL_DelInvalidCtr] =pos[PosCtr];
            gRTPL_DelInvalidCtr++;
             putValue( env_AudioSD_RTPL_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : RTPL
//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_RTPL_insert_POS_8
{
byte INS_POS_8[AUDIO_RADIOTVPRESETLIST_ENTRIES];
int inputCtr,i,j;
byte valid_INS_POS_8;
byte validInputFlg_start, validInputFlg_succ;

putvalue ( env_AudioSD_RTPL_Insert_Message, empty_string );


    //if( getValue( env_AudioSD_RTPL_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_RTPL_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_RTPL_insert_ErrHndlr )== 0x01 )
    {
    getValue( this, INS_POS_8 );
    validInputFlg_start = 0;
    validInputFlg_succ = 0;

     inputCtr =  getValueSize( env_AudioSD_RTPL_insert_POS_8 );

     if( inputCtr > 0 )
     {
        //look for the valid reference for Start and successor
         for( j = 0; j < inputCtr; j++ )
         {
             valid_INS_POS_8 = INS_POS_8[j];

             for( i = 0; i < gRTPL_CSVtotalElem; i++ )
             {
             //check if input is valid and deleted
                 if( valid_INS_POS_8 == gRTPL_Pos_insDel[i][0] && gRTPL_Pos_insDel[i][1] == 0x01 )
                 {
                 validInputFlg_start = 1;
                 break;
                 }
             }
             if( validInputFlg_start == 0x01 )
             break;
          }

            if( validInputFlg_start == 0x01 )
            {
            //start
             if( valid_INS_POS_8== gRTPL_Pos_insDel[0][0] )
                 putValue( env_AudioSD_RTPL_insert_start, 0 );

             else
             {
                ///look for the next existing element upwards
                 for( i = 0; i < gRTPL_CSVtotalElem; i++ )
                 {
                     if( valid_INS_POS_8== gRTPL_Pos_insDel[i][0] )
                     {
                        for( j = i-1; j>= 0; j--)
                         {
                         if( gRTPL_Pos_insDel[j][1]!= 0x01 )
                            {
                             putValue( env_AudioSD_RTPL_insert_start, gRTPL_Pos_insDel[j][0] );
                             break;
                             }//if
                         }//for
                      }
                 }//for
             }//else
            } //validInputFlg

                //successor
                //look for the valid reference for Start and successor

                for( j = inputCtr-1; j>= 0; j--)
                {
                     valid_INS_POS_8 = INS_POS_8[j];

                     for( i = 0; i < gRTPL_CSVtotalElem; i++ )
                     {
                     //check if input is valid and deleted
                         if( valid_INS_POS_8 == gRTPL_Pos_insDel[i][0] && gRTPL_Pos_insDel[i][1] == 0x01 )
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     }
                     if( validInputFlg_succ == 0x01 )
                     break;
                }
                if( validInputFlg_succ == 0x01 )
                {
                    putValue( env_AudioSD_RTPL_insert_succr, 0 );

                    for( i = 0; i < gRTPL_CSVtotalElem; i++ )
                    {
                        if( valid_INS_POS_8== gRTPL_Pos_insDel[i][0] )
                         {
                         if( i == gRTPL_CSVtotalElem-1 )
                         putValue( env_AudioSD_RTPL_insert_succr, 0 );
                         else
                            {
                                 //look for the next existing element downwards
                                 for( j = i + 1; j < gRTPL_CSVtotalElem; j++ )
                                 {
                                     if( gRTPL_Pos_insDel[j][1]!= 0x01 )
                                     {
                                     putValue( env_AudioSD_RTPL_insert_succr, gRTPL_Pos_insDel[j][0] );
                                     break;
                                     }
                                 }
                             }//else

                        }//if
                 }//for
               }

        } //inputCtr
    }

}

//IssueList #76 - MR49870 : SourceList
//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_SL_insert_POS_8
{
byte INS_POS_8[AUDIO_SOURCELIST_ENTRIES];
int inputCtr,i,j;
byte valid_INS_POS_8;
byte validInputFlg_start, validInputFlg_succ;

putvalue ( env_AudioSD_SL_Insert_Message, empty_string );


    //if( getValue( env_AudioSD_SL_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_SL_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_SL_insert_ErrHandler )== 0x01 )
    {
    getValue( this, INS_POS_8 );
    validInputFlg_start = 0;
    validInputFlg_succ = 0;

     inputCtr =  getValueSize( env_AudioSD_SL_insert_POS_8 );

     if( inputCtr > 0 )
     {
        //look for the valid reference for Start and successor
         for( j = 0; j < inputCtr; j++ )
         {
             valid_INS_POS_8 = INS_POS_8[j];

             for( i = 0; i < gSL_CSVtotalElem; i++ )
             {
             //check if input is valid and deleted
                 if( valid_INS_POS_8 == gSourceList_Pos_insDel[i][0] && gSourceList_Pos_insDel[i][1] == 0x01 )
                 {
                 validInputFlg_start = 1;
                 break;
                 }
             }
             if( validInputFlg_start == 0x01 )
             break;
          }

            if( validInputFlg_start == 0x01 )
            {
            //start
             if( valid_INS_POS_8== gSourceList_Pos_insDel[0][0] )
                 putValue( env_AudioSD_SL_insert_start, 0 );

             else
             {
                ///look for the next existing element upwards
                 for( i = 0; i < gSL_CSVtotalElem; i++ )
                 {
                     if( valid_INS_POS_8== gSourceList_Pos_insDel[i][0] )
                     {
                        for( j = i-1; j>= 0; j--)
                         {
                         if( gSourceList_Pos_insDel[j][1]!= 0x01 )
                            {
                             putValue( env_AudioSD_SL_insert_start, gSourceList_Pos_insDel[j][0] );
                             break;
                             }//if
                         }//for
                      }
                 }//for
             }//else
            } //validInputFlg

                //successor
                //look for the valid reference for Start and successor

                for( j = inputCtr-1; j>= 0; j--)
                {
                     valid_INS_POS_8 = INS_POS_8[j];

                     for( i = 0; i < gSL_CSVtotalElem; i++ )
                     {
                     //check if input is valid and deleted
                         if( valid_INS_POS_8 == gSourceList_Pos_insDel[i][0] && gSourceList_Pos_insDel[i][1] == 0x01 )
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     }
                     if( validInputFlg_succ == 0x01 )
                     break;
                }
                if( validInputFlg_succ == 0x01 )
                {
                    putValue( env_AudioSD_SL_insert_successor, 0 );

                    for( i = 0; i < gSL_CSVtotalElem; i++ )
                    {
                        if( valid_INS_POS_8== gSourceList_Pos_insDel[i][0] )
                         {
                         if( i == gSL_CSVtotalElem-1 )
                         putValue( env_AudioSD_SL_insert_successor, 0 );
                         else
                            {
                                 //look for the next existing element downwards
                                 for( j = i + 1; j < gSL_CSVtotalElem; j++ )
                                 {
                                     if( gSourceList_Pos_insDel[j][1]!= 0x01 )
                                     {
                                     putValue( env_AudioSD_SL_insert_successor, gSourceList_Pos_insDel[j][0] );
                                     break;
                                     }
                                 }
                             }//else

                        }//if
                 }//for
               }

        } //inputCtr
    }

}

//IssueList #76 - MR49870 : SourceList
//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_SL_insert_POS_16
{
byte INS_POS_16[AUDIO_SOURCELIST_ENTRIES];
int  inputCtr,i,j;
word PosVal_16_first,PosVal_16_last;
byte validInputFlg_start, validInputFlg_succ;

inputCtr = 0;
PosVal_16_first = 0;
PosVal_16_last = 0;
validInputFlg_start = 0;
validInputFlg_succ = 0;


putvalue ( env_AudioSD_SL_Insert_Message, empty_string );

    //if( getValue( env_AudioSD_SL_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_SL_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_SL_insert_ErrHandler )== 0x01 )
    {
    getValue( this, INS_POS_16 );

     inputCtr =  getValueSize( env_AudioSD_SL_insert_POS_16 );

         if( inputCtr > 1 )
         {
            //look for the valid reference for Start and successor
             for( j = 0; j < inputCtr; j++ )
             {
             //valid_INS_POS_8 = INS_POS_8[j];

             PosVal_16_first = INS_POS_16[j] << 8;
             PosVal_16_first = PosVal_16_first | INS_POS_16[j+ 1];


                for( i = 0; i < gSL_CSVtotalElem; i++ )
                 {
                 //check if input is valid and deleted
                     if( PosVal_16_first == gSourceList_Pos_insDel[i][0] && gSourceList_Pos_insDel[i][1] == 0x01 )
                     {
                     validInputFlg_start = 1;
                     break;
                     }
                 }
                 if( validInputFlg_start == 0x01 )
                 break;
               }

                if( validInputFlg_start == 0x01 )
                {
                    //start
                     if( PosVal_16_first == gSourceList_Pos_insDel[0][0] )
                         putValue( env_AudioSD_SL_insert_start, 0 );

                     else
                     {
                        ///look for the next existing element upwards
                         for( i = 2; i < gSL_CSVtotalElem; i++ )
                         {
                             if( PosVal_16_first == gSourceList_Pos_insDel[i][0] )
                             {
                                for( j = i-1; j> 0; j--)
                                 {
                                 if( gSourceList_Pos_insDel[j][1]!= 0x01 )
                                    {
                                     putValue( env_AudioSD_SL_insert_start, gSourceList_Pos_insDel[j][0] );
                                     break;
                                     }//if
                                 }//for
                              }
                         }//for
                     }//else
                }

                   //successor
                for( j = inputCtr; j> 0; j--)
                {

                     PosVal_16_last = INS_POS_16[j-1] << 8;
                     PosVal_16_last = PosVal_16_last | INS_POS_16[j];

                     for( i = 0; i < gSL_CSVtotalElem; i++ )
                     {
                     //check if input is valid and deleted
                         if( PosVal_16_last == gSourceList_Pos_insDel[i][0] && gSourceList_Pos_insDel[i][1] == 0x01 )
                         {
                         validInputFlg_succ = 1;
                         break;
                         }
                     }
                     if( validInputFlg_succ == 0x01 )
                     break;
                }

                if( validInputFlg_succ == 0x01 )
                {

                   putValue( env_AudioSD_SL_insert_successor, 0 );
                    for( i = 0; i < gSL_CSVtotalElem; i++ )
                    {

                         if( PosVal_16_last == gSourceList_Pos_insDel[i][0] )
                         {
                             if( i == gSL_CSVtotalElem-1 )
                             putValue( env_AudioSD_SL_insert_successor, 0 );
                             else
                             {
                                 //look for the next existing element downwards
                                 for( j = i + 1; j < gSL_CSVtotalElem; j++ )
                                 {
                                     if( gSourceList_Pos_insDel[j][1]!= 0x01 )
                                     {
                                     putValue( env_AudioSD_SL_insert_successor, gSourceList_Pos_insDel[j][0] );
                                     break;
                                     }
                                 }
                             }

                        }//if
                 }//for
               } //validInputFlg_succ
           }//inputCtr
    }

}

//IssueList #76 - MR49870 : MediaBrowser
on envVar env_AudioSD_MB_insert
{
    word startelement, elements,successor, ctr, PosCtr,MBlistCtr,elemTemp,PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_MEDIABROWSER_ENTRIES], startIndex, succIndex, posInBetweenCheck;
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,k,x;


    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;
    elemTemp                = 0;
    startIndex              = 0;
    succIndex               = 0;
    PosVal                  = 0;


    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
            POS[i] = 0;

        for( i = 0; i < BAP_BUFFER_SIZE; i++ )
            requestarray[i] = 0;

        for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
            gMB_InvalidIns[i] = 0;

        for( i = 0; i < AUDIO_MEDIABROWSER_ENTRIES; i++ )
        {
            gMediaBrowser_Send[i][0] = 0;
            gMediaBrowser_Send[i][1] = 0;
        }


        putValue( env_AudioSD_MB_Insert_Invalid, gMB_InvalidIns );

        gMB_InsInvalidCtr = 0;
        gMB_InsValidCtr = 0;
        putValue( env_AudioSD_MB_Insert_Message, empty_string );

        //get data from Panel
        //Patch GB 11.07.2014 -commented
        //recordaddress   = 0x0F;

        putvalue ( env_AudioSD_MB_Insert_Message, empty_string );
        //MR 63332 #3   02.07.2014
        //gMB_TotalElem = getValue( env_AudioSD_MB_TotalNumLE );
        gMB_TotalElem = gMediaBrowser_TotalNumListElements;

        if( getValue( env_AudioSD_MB_insert_UPD_button )== 0x00 )
        {    shift           = 0x01; //insert
             gMB_InsertFlg   = 0x01;

            //Patch GB 11.07.2014
            recordaddress   = 0x0F;
        }
        else
        {
            shift           = 0x0; //update

           //Patch GB 11.07.2014
            recordaddress   = getValue( env_AudioSD_MB_AH_RA);
        }

        direction       = 0x0;
        transmitpos     = 0x01;


        indexsize       = getvalue( env_AudioSD_MB_insert_size );
        //mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //message
        requestarray[0] = LSG_AudioSD;                //LSG-ID
        requestarray[1] = FctID_MediaBrowser;        //Fct.-ID
        requestarray[2] =Changed_REQ;               //request type
    Offset = 3;

        startelement    = getValue( env_AudioSD_MB_insert_start );

        successor = getValue( env_AudioSD_MB_insert_successor );


        switch( indexsize ) // POS size
        {
            case 0: //8Bit
                getvalue( env_AudioSD_MB_insert_POS_8, POS);
                ctr = getValueSize( env_AudioSD_MB_insert_POS_8 );

                if( getValue( env_AudioSD_MB_insert_ErrHandler )== 0x01 )
                {

                    if( ctr == 0 )   // if no data
                    {
                        putValue( env_AudioSD_MB_Insert_Message, "NO DATA TO SEND" );
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid for Insert
                        if( getvalue( env_AudioSD_MB_insert_start ) == 0x00 && getvalue( env_AudioSD_MB_insert_successor ) == 0x00 && getvalue( env_AudioSD_MB_insert_UPD_button ) == 0x00 )
                        {
                            //check if not all elements are deleted
                            if( gMB_totalDELctr < gMB_CSVtotalElem)
                            {
                            putValue( env_AudioSD_MB_Insert_Message, "INVALID START & SUCCESSOR" );
                            break;
                            }
                        }

                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                        posInBetweenCheck       = 0;
                        if( ctr >1 )
                        {
                            posInBetweenCheck =  mbPosSequence_check ( indexsize,POS, ctr );
                            if( posInBetweenCheck == 0x01 )
                            {
                                putValue( env_AudioSD_MB_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                break;
                            }
                        }


                        MediaBrowser_insert_ErrHandler_8 ( POS, ctr );

                        //if update has invalid POS - do not send
                        if( getvalue( env_AudioSD_MB_insert_UPD_button ) == 0x01 )  //update
                        {
                            if( gMB_InsInvalidCtr > 0 )
                            {
                                putValue( env_AudioSD_MB_Insert_Message, "INVALID POS EXISTS" );
                                break;
                            }
                        }


                        //if all elements are INVALID for INSERT
                        if( ctr == gMB_InsInvalidCtr )
                        {
                            putValue( env_AudioSD_MB_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                        }
                        else
                        {
                            elements = gMB_InsValidCtr+ 1;
                            ctr = gMB_InsValidCtr;
                        }


                    }//else with data
                }
                else   // no error handling
                {
                    elements = ctr+ 1;
                    if( ctr == 0 )    // if no data
                    {
                        transmitpos     = 0x0;

                        if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                            elements = successor - startelement;
                    }
                 }

                //mode
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;

                //start
                requestarray[Offset] = startelement;
                Offset++;

                //elements
                requestarray[Offset] = elements;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if( getValue( env_AudioSD_MB_insert_ErrHandler )== 0x01 )
                {
                    //ARRAY DATA
                        for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                requestarray[Offset] = gMediaBrowser_Send[i][0];
                                Offset++;
                            }

                    //INDEXING FOR INSERT
                    if( getValue( env_AudioSD_MB_insert_UPD_button )== 0x00 )  //check if insert
                    {

                         // if all elements are deleted
                         if( gMB_totalDELctr == gMB_CSVtotalElem)
                         {

                                 //assign the first Insert element as handle and POS
                                 gAudioSD_CSIhandle_FSGhandle = gMediaBrowser_Send[0][0];
                                 gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;

                                  i = 0;
                                for( j = 0; j < gMB_CSVtotalElem; j++ )
                                {
                                    if( gMediaBrowser_Pos_insDel[j][1] == 0x01 )
                                    continue ;
                                    else
                                    {
                                    i++;
                                    gMediaBrowser_Pos_insDel[j][2] = i;
                                    }
                                } //for
                         } //if
                         else if( gMB_totalDELctr < gMB_CSVtotalElem)
                        {

                            //Get Start and Successor Index
                            for(  j = 0; j < gMB_CSVtotalElem; j++ )
                            {
                                //Start
                                if( getValue( env_AudioSD_MB_insert_start ) == gMediaBrowser_Pos_insDel[j][0] )
                                {
                                    startIndex = gMediaBrowser_Pos_insDel[j][2];
                                }
                                //Succ
                                if( getValue( env_AudioSD_MB_insert_successor ) == gMediaBrowser_Pos_insDel[j][0] )
                                {
                                    succIndex = gMediaBrowser_Pos_insDel[j][2];
                                }
                            }
                            //handling if inserted at the edges
                            if(succIndex == 0 )
                            {
                                succIndex = startIndex + 1;
                            }
                            if(startIndex == 0 )
                            {
                                startIndex = succIndex - 1;
                            }

                            //Increment indexes of items from the successor onwards ( by inserted items number )
                            for( j = 0; j < gMB_CSVtotalElem; j++ )
                            {
                                if( succIndex <= gMediaBrowser_Pos_insDel[j][2] )
                                {
                                    gMediaBrowser_Pos_insDel[j][2] = gMediaBrowser_Pos_insDel[j][2] + ctr;
                                }

                                if( getvalue( env_AudioSD_CSH_FSGhandle ) == gMediaBrowser_Pos_insDel[j][0] )
                                {
                                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gMediaBrowser_Pos_insDel[j][2];
                                }
                            }

                            //Store Index of inserted items
                            //Loop number of times as inserted items
                            for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                //requestarray[Offset] = gMediaBrowser_Send[i][0];
                                //Offset++;

                                //Loop through array to find POS matching inserted item
                                for(  k = 0; k < gMB_CSVtotalElem; k++ )
                                {
                                    if( gMediaBrowser_Send[i][0] == gMediaBrowser_Pos_insDel[k][0] )
                                    {
                                        gMediaBrowser_Pos_insDel[k][2] = startIndex + i + 1;
                                        break;
                                    } //if
                                } //for
                            } //for
                        }

                        //Update handle
                        //gAudioSD_CSIhandle_FSGhandle_absolutePos = gAudioSD_CSIhandle_FSGhandle_absolutePos + ctr;
                        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                    } //end if INSERT

                } //end if with ERROR handling

                //ArrayData WITHOUT error handling
                else
                {
                     for( i = 0; i <ctr; i++ )
                     {
                        requestarray[Offset] = POS[i];
                        Offset++;
                     }
                }

                //successor
                if( ctr > 0 )
                {
                    requestarray[Offset] = successor;
                    Offset++;
                }

            break;

            case 1:  //16Bit
                getvalue( env_AudioSD_MB_insert_POS_16, POS);
                elements = getValueSize( env_AudioSD_MB_insert_POS_16 );
                elemTemp = ( getValueSize( env_AudioSD_MB_insert_POS_16 ) /2 );

                if( getValue( env_AudioSD_MB_insert_ErrHandler )== 0x01 )
                {
                    if( elemTemp== 0 )   // if no data
                    {
                        putValue( env_AudioSD_MB_Insert_Message, "NO DATA TO SEND" );
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid
                        if( ( getvalue( env_AudioSD_MB_insert_start ) == 0x00 ) && ( getvalue( env_AudioSD_MB_insert_successor ) == 0x00 )&& ( getvalue( env_AudioSD_MB_insert_UPD_button ) == 0x00 ) )
                        {
                            //check if not all elements are deleted
                            if( gMB_totalDELctr < gMB_CSVtotalElem)
                            {
                            putValue( env_AudioSD_MB_Insert_Message, "INVALID START & SUCCESSOR" );
                            break;
                            }
                        }


                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                            if( ctr >1 )
                            {
                                posInBetweenCheck =  mbPosSequence_check ( indexsize,POS,elemTemp);
                                if( posInBetweenCheck == 0x01 )
                                {
                                    putValue( env_AudioSD_MB_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                    break;
                                }
                            }

                        MediaBrowser_insert_ErrHandler_16 ( POS,elements );
                        //if all elements are INVALID

                        //if update has invalid POS - do not send
                        if( getvalue( env_AudioSD_MB_insert_UPD_button ) == 0x01 )  //update
                        {
                            if( gMB_InsInvalidCtr > 0 )
                            {
                                putValue( env_AudioSD_MB_Insert_Message, "INVALID POS EXISTS" );
                                break;
                            }
                        }

                        if( elemTemp == gMB_InsInvalidCtr )
                        {
                            putValue( env_AudioSD_MB_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                        }
                        else
                        {
                            elements = ( gMB_InsValidCtr/2 )+ 1;     //including successor
                            elemTemp = gMB_InsValidCtr/2;}
                        }

                    } //else with data
                else   // no error handling
                {
                    elements = elemTemp + 1;  //including successor
                    if( elemTemp== 0 )    // if no data
                    {
                        transmitpos = 0x0;
                         if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                        elements = successor - startelement;
                    }
                }

                //mode
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 )& 0xF0 ) + ( recordaddress& 0x0F );
                Offset++;

                requestarray[Offset] = startelement& 0xff;
                Offset++;
                requestarray[Offset] = (startelement& 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements& 0xff;
                Offset++;
                requestarray[Offset] = ( elements& 0xff00 ) / 0x100;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if( getValue( env_AudioSD_MB_insert_ErrHandler )== 0x01 )
                {
                    for(  i = 0; i < elemTemp; i++ )
                        {
                            PosVal = 0x00;

                            //store in array the inserted item
                            requestarray[Offset] = gMediaBrowser_Send[(2*i)+ 1][0];
                            PosVal = requestarray[Offset];
                            Offset++;
                            requestarray[Offset] = gMediaBrowser_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;
                         }

                    //INDEXING FOR INSERT

                    if( getValue( env_AudioSD_MB_insert_UPD_button )== 0x00 )  //check if insert
                    {
                         // if all elements are deleted
                         if( gMB_totalDELctr == gMB_CSVtotalElem)
                         {
                                 PosVal = 0x00;
                                 PosVal = gMediaBrowser_Send[0][0] << 8;
                                 PosVal = PosVal|gMediaBrowser_Send[1][0];

                                 gAudioSD_CSIhandle_FSGhandle = PosVal;
                                 gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;

                                 i = 0;
                                for( j = 0; j < gMB_CSVtotalElem; j++ )
                                {
                                    if( gMediaBrowser_Pos_insDel[j][1] == 0x01 )
                                    continue ;
                                    else
                                    {
                                    i++;
                                    gMediaBrowser_Pos_insDel[j][2] = i;
                                    }
                                }

                         }
                        else if( gMB_totalDELctr < gMB_CSVtotalElem)
                        {
                            //Get Start and Successor Index
                            for(  j = 0; j < gMB_CSVtotalElem; j++ )
                            {
                                //Start
                                if( getValue( env_AudioSD_MB_insert_start ) == gMediaBrowser_Pos_insDel[j][0] )
                                {
                                    startIndex = gMediaBrowser_Pos_insDel[j][2];
                                }
                                //Succ
                                if( getValue( env_AudioSD_MB_insert_successor ) == gMediaBrowser_Pos_insDel[j][0] )
                                {
                                    succIndex = gMediaBrowser_Pos_insDel[j][2];
                                }
                            }
                            //handling if inserted at the edges
                            if(succIndex == 0 )
                            {
                                succIndex = startIndex + 1;
                            }
                            if(startIndex == 0 )
                            {
                                startIndex = succIndex - 1;
                            }

                            //Increment indexes of items from the successor onwards ( by inserted items number )
                            for( j = 0; j < gMB_CSVtotalElem; j++ )
                            {
                                if( succIndex <= gMediaBrowser_Pos_insDel[j][2] )
                                {
                                    gMediaBrowser_Pos_insDel[j][2] = gMediaBrowser_Pos_insDel[j][2] + elemTemp;
                                }

                                if( getvalue( env_AudioSD_CSH_FSGhandle ) == gMediaBrowser_Pos_insDel[j][0] )
                                {
                                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gMediaBrowser_Pos_insDel[j][2];
                                }
                            }

                                 //Store Index of inserted items
                                //Loop number of times as inserted items
                                for(  i = 0; i < elemTemp; i++ )
                                {
                                    PosVal = 0x00;
                                    PosVal = gMediaBrowser_Send[(2*i)+ 1][0];
                                    PosVal = PosVal|gMediaBrowser_Send[(2*i)+0][0]<<8;

                                    //Loop through array to find POS matching inserted item
                                    for(  k = 0; k < gMB_CSVtotalElem; k++ )
                                    {
                                        if( PosVal == gMediaBrowser_Pos_insDel[k][0] )
                                        {
                                            gMediaBrowser_Pos_insDel[k][2] = startIndex + i + 1;
                                            break;
                                        }
                                    }//for
                                }//for
                        } //else if gMB_totalDELctr

                        //Update handle
                        //gAudioSD_CSIhandle_FSGhandle_absolutePos = gAudioSD_CSIhandle_FSGhandle_absolutePos + ctr;
                        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                    } // end if INSERT

                } // end if with Errorhandling
                //ArrayData WITHOUT error handling
                else
                {
                    for(  i = 0; i < elemTemp; i++ )
                    {
                        requestarray[Offset] = POS[(2*i)+ 1];
                        Offset++;
                        requestarray[Offset] = POS[(2*i)+0];
                        Offset++;
                    }
                }

                //successor
                if( elemTemp > 0 )
                {
                    requestarray[Offset] = successor& 0xff;
                    Offset++;
                    requestarray[Offset] = (successor& 0xff00 ) / 0x100;
                    Offset++;
                }
                break; //case 1:  16Bit

            default:
                break; //default

        }//switch

        //resetting LoadReload Flg after Insert
        gMB_loadReloadFlg = 0x00;



        if( indexsize== 0x01 )
        gMB_InsValidCtr = gMB_InsValidCtr/2;

        //updating the totalDeletedCtr;
           gMB_totalDELctr = gMB_totalDELctr - gMB_InsValidCtr;

        if( gMB_totalDELctr > gMB_CSVtotalElem)
        gMB_totalDELctr = 0;


        //just send the data when errorhandler is OFF
        if( getValue( env_AudioSD_MB_insert_ErrHandler )== 0x00 )
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else if( getValue( env_AudioSD_MB_insert_ErrHandler )== 0x01 )  //with ERROR HANDLER
        {
            if( getValue( env_AudioSD_MB_insert_UPD_button )== 0x00 )  //insert
            {
                // if there's a Valid POS and Sequence is correct
                if( gMB_InsValidCtr != 0x00 && posInBetweenCheck == 0x00 )
                {
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

                    if( gMB_TotalElem + gMB_InsValidCtr <= gMB_CSVtotalElem)
                    {
                        //MR 63332 #3   02.07.2014
                        //putValue( env_AudioSD_MB_TotalNumLE, gMB_TotalElem + gMB_InsValidCtr );
                        //gMediaBrowser_TotalNumListElements = getValue( env_AudioSD_MB_TotalNumLE );
                        gMediaBrowser_TotalNumListElements = gMB_TotalElem + gMB_InsValidCtr;
                        putValue( env_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements );
                    } //if


                }// if gMB_InsValidCtr
            }// if insert
            else
            {
                //send only UPDATE if all POS are valid and DATA!= 0
                if( gMB_InsInvalidCtr == 0x00 && gMB_InsValidCtr!= 0 )
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }// else UPD button
        } //else if
    }
    //else
    //putValue( env_AudioSD_MB_insert_UPD_button, 0 );
}

//IssueList #76 - MR49870 : MediaBrowser
on envVar env_AudioSD_MB_delete_POS_8
{
byte DEL_POS_8[AUDIO_MEDIABROWSER_ENTRIES];

putValue( env_AudioSD_MB_delete_Message, empty_string );

    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_MB_delete_ErrHandler )== 0x01 )
    {
    getValue( this, DEL_POS_8 );
    putValue( env_AudioSD_MB_delete_start, DEL_POS_8[0] );
    }

}

//IssueList #76 - MR49870 : MediaBrowser
on envVar env_AudioSD_MB_delete_POS_16
{
    byte DEL_POS_16[AUDIO_MEDIABROWSER_ENTRIES];
    word PosVal_16;

    putValue( env_AudioSD_MB_delete_Message, empty_string );


    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_MB_delete_ErrHandler )== 0x01 )
    {
        getValue( this, DEL_POS_16 );
        PosVal_16 = DEL_POS_16[0] << 8;
        PosVal_16 = PosVal_16|DEL_POS_16[1];

        putValue( env_AudioSD_MB_delete_start, PosVal_16 );
    }

}

//IssueList #76 - MR49870 : MediaBrowser
on envVar env_AudioSD_MB_delete_ErrHandler
{
    if( getValue( this )== 0x00 )
        putValue( env_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements );
}

//IssueList #76 - MR49870 : MediaBrowser
on envVar env_AudioSD_MB_insert_ErrHandler
{
    if( getValue( this )== 0x00 )
        putValue( env_AudioSD_MB_TotalNumLE, gMediaBrowser_TotalNumListElements );
}

//IssueList #76 - MR49870 : MediaBrowser
MediaBrowser_delete_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word MBlistCtr, PosCtr;

    result = 0x01;
    delFlg= 0;
    gMB_DelInvalidCtr = 0;
    gMB_DelValidCtr = 0;
    putValue( env_AudioSD_MB_delete_Message, empty_string );


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {

         result = 0x00;
         delFlg = 0x00;

      for( MBlistCtr = 0; MBlistCtr < gMB_CSVtotalElem; MBlistCtr++ )
      {

           if( pos[PosCtr] == gMediaBrowser_Pos_insDel[MBlistCtr][0] )   //check if POS is valid
           {
             if( gMediaBrowser_Pos_insDel[MBlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gMediaBrowser_Pos_insDel[MBlistCtr][1] = 0x01;    //tagging deleted Pos
               gMediaBrowser_Send[gMB_DelValidCtr][0] = pos[PosCtr];
               gMediaBrowser_Send[gMB_DelValidCtr][1] = gMediaBrowser_Pos_insDel[MBlistCtr][2];

               gMB_DelValidCtr++;
               gMB_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_MB_delete_Message, "POS already deleted!" );
              gMB_InvalidDel[gMB_DelInvalidCtr] = pos[PosCtr];
              gMB_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
           {
           gMB_InvalidDel[gMB_DelInvalidCtr] =pos[PosCtr];
            gMB_DelInvalidCtr++;
             putValue( env_AudioSD_MB_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : MediaBrowser
MediaBrowser_delete_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word MBlistCtr, PosCtr,PosVal;

    result = 0x01;
    delFlg= 0;
    gMB_DelInvalidCtr = 0;
    gMB_DelValidCtr = 0;
    putValue( env_AudioSD_MB_delete_Message, empty_string );
    PosVal = 0;

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {

         result = 0x00;
         delFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+ 1];


      for( MBlistCtr = 0; MBlistCtr < gMB_CSVtotalElem; MBlistCtr++ )
      {
           if( PosVal== gMediaBrowser_Pos_insDel[MBlistCtr][0] )   //check if POS is valid
           {

             if( gMediaBrowser_Pos_insDel[MBlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gMediaBrowser_Pos_insDel[MBlistCtr][1] = 0x01;    //tagging deleted Pos
               gMediaBrowser_Send[gMB_DelValidCtr][0] = pos[PosCtr];
               gMB_DelValidCtr++;
               gMediaBrowser_Send[gMB_DelValidCtr][0] = pos[PosCtr+ 1];
               gMB_DelValidCtr++;
               gMB_totalDELctr++;
                gMediaBrowser_Send[gMB_DelValidCtr][1] = gMediaBrowser_Pos_insDel[MBlistCtr][2];
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_MB_delete_Message, "POS already deleted!" );
              gMB_InvalidDel[gMB_DelInvalidCtr] = pos[PosCtr];
              gMB_DelInvalidCtr++;
              gMB_InvalidDel[gMB_DelInvalidCtr] = pos[PosCtr+ 1];
              gMB_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
        {

            gMB_InvalidDel[gMB_DelInvalidCtr] = pos[PosCtr];
            gMB_DelInvalidCtr++;
            gMB_InvalidDel[gMB_DelInvalidCtr] = pos[PosCtr+ 1];
            gMB_DelInvalidCtr++;
             putValue( env_AudioSD_MB_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : MediaBrowser
void MediaBrowser_insert_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word MBlistCtr, PosCtr;

    result = 0x01;
    InsFlg= 0;


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {
         result = 0x00;
         InsFlg = 0x00;

      for( MBlistCtr = 0; MBlistCtr < gMB_CSVtotalElem; MBlistCtr++ )
      {
           if( pos[PosCtr] == gMediaBrowser_Pos_insDel[MBlistCtr][0] )   //check if POS is valid
           {
            //UPDATE
                if  ( getValue( env_AudioSD_MB_insert_UPD_button ) == 0x01 )
                 {
                        if( gMediaBrowser_Pos_insDel[MBlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                        {
                        result = 0x01;
                        gMediaBrowser_Send[gMB_InsValidCtr][0] = pos[PosCtr];
                        gMB_InsValidCtr++;
                        }

                        else
                          {
                          putValue( env_AudioSD_MB_Insert_Message, "POS is already deleted!" );
                          gMB_InvalidIns[gMB_InsInvalidCtr] = pos[PosCtr];
                          gMB_InsInvalidCtr++;
                          InsFlg = 0x01;
                          break;
                          }

                }  //update

                 else   //INSERT
                 {
                     if( gMediaBrowser_Pos_insDel[MBlistCtr][1] == 0x01 )  //check if POS does not exist
                       {
                       gMediaBrowser_Pos_insDel[MBlistCtr][1] = 0x00;
                       gMediaBrowser_Send[gMB_InsValidCtr][0] = pos[PosCtr];
                       gMediaBrowser_Send[gMB_InsValidCtr][1] = gMediaBrowser_Pos_insDel[MBlistCtr][2];

                       gMB_InsValidCtr++;
                       result = 0x01;
                       }
                      else
                      {
                      putValue( env_AudioSD_MB_Insert_Message, "POS still exists!" );
                      gMB_InvalidIns[gMB_InsInvalidCtr] = pos[PosCtr];
                      gMB_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                      }
               }//if
            } //else
       }//for
        if( result == 0x00 && InsFlg == 0x00 )
           {
           gMB_InvalidIns[gMB_InsInvalidCtr] =pos[PosCtr];
            gMB_InsInvalidCtr++;
             putValue( env_AudioSD_MB_Insert_Message, "INVALID POS!" );
            }
     }//for MBlistCtr

     if( gMB_InsInvalidCtr!= 0 )
            putValue( env_AudioSD_MB_Insert_Invalid, gMB_InvalidIns );
}

void MediaBrowser_insert_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word PosVal,MBlistCtr, PosCtr;

    result = 0x01;
    InsFlg= 0;
    PosVal = 0;

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {
        result = 0x00;
        InsFlg = 0x00;
        PosVal = pos[PosCtr] << 8;
        PosVal = PosVal|pos[PosCtr+ 1];
        for( MBlistCtr = 0; MBlistCtr < gMB_CSVtotalElem; MBlistCtr++ )
        {
            if( PosVal== gMediaBrowser_Pos_insDel[MBlistCtr][0] )   //check if POS is valid
            {
                //UPDATE
                if  ( getValue( env_AudioSD_MB_insert_UPD_button ) == 0x01 )
                {
                    if( gMediaBrowser_Pos_insDel[MBlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                    {
                        result = 0x01;
                        gMediaBrowser_Send[gMB_InsValidCtr][0] = pos[PosCtr];
                        gMB_InsValidCtr++;
                        gMediaBrowser_Send[gMB_InsValidCtr][0] = pos[PosCtr+ 1];
                        gMB_InsValidCtr++;
                    }
                    else
                    {
                        putValue( env_AudioSD_MB_Insert_Message, "POS is already deleted!" );
                        gMB_InvalidIns[gMB_InsInvalidCtr] = pos[PosCtr];
                        gMB_InsInvalidCtr++;
                        gMB_InvalidIns[gMB_InsInvalidCtr] = pos[PosCtr+ 1];
                        gMB_InsInvalidCtr++;
                        InsFlg = 0x01;
                        break;
                    }
                }  //update
                else   //INSERT
                {
                    if( gMediaBrowser_Pos_insDel[MBlistCtr][1] == 0x01 )  //check if POS does not exist
                    {
                        gMediaBrowser_Pos_insDel[MBlistCtr][1] = 0x00;
                        gMediaBrowser_Send[gMB_InsValidCtr][0] = pos[PosCtr];
                        gMB_InsValidCtr++;
                        gMediaBrowser_Send[gMB_InsValidCtr][0] = pos[PosCtr+ 1];
                        gMB_InsValidCtr++;
                        result = 0x01;
                    }
                    else
                    {
                        putValue( env_AudioSD_MB_Insert_Message, "POS still exists!" );
                        gMB_InvalidIns[gMB_InsInvalidCtr] = pos[PosCtr];
                        gMB_InsInvalidCtr++;
                        gMB_InvalidIns[gMB_InsInvalidCtr] = pos[PosCtr+ 1];
                        gMB_InsInvalidCtr++;
                        InsFlg = 0x01;
                        break;
                    }
                }
            }
        }
        if( result == 0x00 && InsFlg == 0x00 )
        {
            gMB_InvalidIns[gMB_InsInvalidCtr] =pos[PosCtr];
            gMB_InsInvalidCtr++;
            gMB_InvalidIns[gMB_InsInvalidCtr] = pos[PosCtr+ 1];
            gMB_InsInvalidCtr++;
            putValue( env_AudioSD_MB_Insert_Message, "INVALID POS!" );
        }
    }
    if( gMB_InsInvalidCtr!= 0 )
        putValue( env_AudioSD_MB_Insert_Invalid, gMB_InvalidIns );
}

byte mbPosSequence_check ( byte Index, byte inputArray[],word inputCtr )
{
    byte posInBetween;
    word ctr, ctr1, ctr2,PosVal1_,PosVal2_;

    posInBetween = 0;

    for( ctr = 0; ctr < inputCtr; ctr++ )
    {
        // adjust for 8bit and 16bit handling
        if( Index== 0x00 )
        {
            PosVal1_ = inputArray[ctr];
            PosVal2_ = inputArray[ctr+ 1];
        }
        else
        {
            PosVal1_ = 0x0000;
            PosVal1_ = inputArray[(2*ctr )+ 1];
            PosVal1_ = PosVal1_|(( inputArray[(2*ctr )+0] )<<8 );
            PosVal2_ = 0x0000;
            PosVal2_ = inputArray[(2*ctr )+2+ 1];
            PosVal2_ = PosVal2_|(( inputArray[(2*ctr )+2+0] )<<8 );
        }
        // search send item in insdel array
        for( ctr1 = 0; ctr1 < gMB_CSVtotalElem; ctr1++ )
        {
            if( PosVal1_ == gMediaBrowser_Pos_insDel[ctr1][0] ) // 1st send item is found in array
            {
                break;
            }
        }
        // search insdel array for next send item
        for( ctr2 = ctr1+ 1; ctr2 < gMB_CSVtotalElem; ctr2++ ) // loop from 1st inserted item in insdel array
        {
            if( PosVal2_ == gMediaBrowser_Pos_insDel[ctr2][0] ) // 2nd send item immediately next to 1st send item
            {
                break;
            }
            else
            {
                if( gMediaBrowser_Pos_insDel[ctr2][1] == 0 && PosVal2_ != 0 )    // in between item is not deleted
                {
                    posInBetween = 0x01;
                    break;
                }
            }
        }
        if( posInBetween == 0x01 )
        {
            break;
        }
    }
    return posInBetween;
}

//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_MB_insert_POS_8
{
    byte INS_POS_8[AUDIO_MEDIABROWSER_ENTRIES];
    int inputCtr,i,j;
    byte valid_INS_POS_8;
    byte validInputFlg_start, validInputFlg_succ;

    putvalue ( env_AudioSD_MB_Insert_Message, empty_string );
    //if( getValue( env_AudioSD_MB_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_MB_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_MB_insert_ErrHandler )== 0x01 )
    {
        getValue( this, INS_POS_8 );
        validInputFlg_start = 0;
        validInputFlg_succ = 0;
        inputCtr =  getValueSize( env_AudioSD_MB_insert_POS_8 );
        if( inputCtr > 0 )
        {
            //look for the valid reference for Start and successor
            for( j = 0; j < inputCtr; j++ )
            {
                valid_INS_POS_8 = INS_POS_8[j];
                for( i = 0; i < gMB_CSVtotalElem; i++ )
                {
                //check if input is valid and deleted
                    if( valid_INS_POS_8 == gMediaBrowser_Pos_insDel[i][0] && gMediaBrowser_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_start = 1;
                        break;
                    }
                }
                if( validInputFlg_start == 0x01 )
                break;
            }
            if( validInputFlg_start == 0x01 )
            {
                //start
                if( valid_INS_POS_8== gMediaBrowser_Pos_insDel[0][0] )
                    putValue( env_AudioSD_MB_insert_start, 0 );
                else
                {
                    ///look for the next existing element upwards
                    for( i = 0; i < gMB_CSVtotalElem; i++ )
                    {
                        if( valid_INS_POS_8== gMediaBrowser_Pos_insDel[i][0] )
                        {
                            for( j = i-1; j>= 0; j--)
                            {
                                if( gMediaBrowser_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_MB_insert_start, gMediaBrowser_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            } //validInputFlg
            //successor
            //look for the valid reference for Start and successor
            for( j = inputCtr-1; j>= 0; j--)
            {
                valid_INS_POS_8 = INS_POS_8[j];
                for( i = 0; i < gMB_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( valid_INS_POS_8 == gMediaBrowser_Pos_insDel[i][0] && gMediaBrowser_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_succ = 1;
                        break;
                    }
                }
                if( validInputFlg_succ == 0x01 )
                break;
            }
            if( validInputFlg_succ == 0x01 )
            {
                putValue( env_AudioSD_MB_insert_successor, 0 );
                for( i = 0; i < gMB_CSVtotalElem; i++ )
                {
                    if( valid_INS_POS_8== gMediaBrowser_Pos_insDel[i][0] )
                    {
                        if( i == gMB_CSVtotalElem-1 )
                            putValue( env_AudioSD_MB_insert_successor, 0 );
                        else
                        {
                            //look for the next existing element downwards
                            for( j = i + 1; j < gMB_CSVtotalElem; j++ )
                            {
                                if( gMediaBrowser_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_MB_insert_successor, gMediaBrowser_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_MB_insert_POS_16
{
    byte INS_POS_16[AUDIO_MEDIABROWSER_ENTRIES];
    int  inputCtr,i,j;
    word PosVal_16_first,PosVal_16_last;
    byte validInputFlg_start, validInputFlg_succ;

    inputCtr = 0;
    PosVal_16_first = 0;
    PosVal_16_last = 0;
    validInputFlg_start = 0;
    validInputFlg_succ = 0;

    putvalue ( env_AudioSD_MB_Insert_Message, empty_string );
    //if( getValue( env_AudioSD_MB_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_MB_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_MB_insert_ErrHandler )== 0x01 )
    {
        getValue( this, INS_POS_16 );
        inputCtr =  getValueSize( env_AudioSD_MB_insert_POS_16 );
        if( inputCtr > 1 )
        {
            //look for the valid reference for Start and successor
            for( j = 0; j < inputCtr; j++ )
            {
                //valid_INS_POS_8 = INS_POS_8[j];
                PosVal_16_first = INS_POS_16[j] << 8;
                PosVal_16_first = PosVal_16_first | INS_POS_16[j+ 1];
                for( i = 0; i < gMB_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( PosVal_16_first == gMediaBrowser_Pos_insDel[i][0] && gMediaBrowser_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_start = 1;
                        break;
                    }
                }
                if( validInputFlg_start == 0x01 )
                break;
            }
            if( validInputFlg_start == 0x01 )
            {
                //start
                if( PosVal_16_first == gMediaBrowser_Pos_insDel[0][0] )
                    putValue( env_AudioSD_MB_insert_start, 0 );
                else
                {
                    ///look for the next existing element upwards
                    for( i = 2; i < gMB_CSVtotalElem; i++ )
                    {
                        if( PosVal_16_first == gMediaBrowser_Pos_insDel[i][0] )
                        {
                            for( j = i-1; j> 0; j--)
                            {
                                if( gMediaBrowser_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_MB_insert_start, gMediaBrowser_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            //successor
            for( j = inputCtr; j> 0; j--)
            {
                PosVal_16_last = INS_POS_16[j-1] << 8;
                PosVal_16_last = PosVal_16_last | INS_POS_16[j];
                for( i = 0; i < gMB_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( PosVal_16_last == gMediaBrowser_Pos_insDel[i][0] && gMediaBrowser_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_succ = 1;
                        break;
                    }
                }
                if( validInputFlg_succ == 0x01 )
                break;
            }
            if( validInputFlg_succ == 0x01 )
            {
                putValue( env_AudioSD_MB_insert_successor, 0 );
                for( i = 0; i < gMB_CSVtotalElem; i++ )
                {
                    if( PosVal_16_last == gMediaBrowser_Pos_insDel[i][0] )
                    {
                        if( i == gMB_CSVtotalElem-1 )
                            putValue( env_AudioSD_MB_insert_successor, 0 );
                        else
                        {
                            //look for the next existing element downwards
                            for( j = i + 1; j < gMB_CSVtotalElem; j++ )
                            {
                                if( gMediaBrowser_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_MB_insert_successor, gMediaBrowser_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            } //validInputFlg_succ
        }//inputCtr
    }
}

Request_error ( byte fctID, byte errorCode )
{
    word Offset;
    dword requestarray [BAP_BUFFER_SIZE];

    requestarray[0] = LSG_AudioSD;    //LSG-ID
    requestarray[1] = fctID;    //Fct.-ID
    requestarray[2] = Error_REQ;
    requestarray[3] = errorCode;
    Offset =4;
    set_status_requestbuffer( requestarray, Offset, Bap_Error );
}

on envVar env_FSG_AudioSD_GetAll_IntTlgEn
{
       if( getValue( this ) )
       {
           putValue( env_FSG_AudioSD_GetAll_SegmEn, 0 );
           intertelegram_err( FctID_GetAll);
       }
       else
       {
           intertelegram_err_off( FctID_GetAll);
       }
}

intertelegram_err( long fctId )
{
    long data[4];
    data[0] = LSG_AudioSD;
    data[1] = fctId;
    data[2] = 1;
    data[3] = 940;
    ChangeConfig( 0x0020, data );
}

intertelegram_err_off( long fctId )
{
    long data[4];
    data[0] = LSG_AudioSD;
    data[1] = fctId;
    data[2] = 5000;
    data[3] = 0;
    ChangeConfig( 0x0020, data );
}

on envVar env_FSG_AudioSD_GetAll_SegmEn
{
       if( getValue( this ) )
       {
           putValue( env_FSG_AudioSD_GetAll_IntTlgEn, 0 );
           sequence_err( FctID_GetAll,154 );
       }
       else
       {
              sequence_err_off( FctID_GetAll);
       }
}

sequence_err_off( long fctId )
{
    long data[5];

    data[0] = LSG_AudioSD;
    data[1] = fctId;
    data[2] = 5000;
    data[3] = 0;
    data[4] = 0;
    ChangeConfig( 0x0021, data );
}

sequence_err( long fctId, long size )
{
    long data[5];
    long lastSeg;

    lastSeg = size -5;

    data[0] = LSG_AudioSD;
    data[1] = fctId;
    data[2] = lastSeg / 7 + 1;
    data[3] = 1;
    data[4] = ( lastSeg / 7 + 4 ) & 15;
    ChangeConfig( 0x0021, data );
}

on envVar env_FSG_AudioSD_FctList_SegmEn
{
       if( getValue( this ) )
       {
           putValue( env_FSG_AudioSD_FctList_IntTlgEn, 0 );
           sequence_err( FctID_FunctionList,8 );
       }
       else
       {
              sequence_err_off( FctID_FunctionList );
       }
}

on envVar env_FSG_AudioSD_FctList_IntTlgEn
{
       if( getValue( this ) )
       {
           putValue( env_FSG_AudioSD_FctList_SegmEn, 0 );
           intertelegram_err( FctID_FunctionList );
       }
       else
       {
           intertelegram_err_off( FctID_FunctionList );
       }
}

//resending BAPconfig when this button is pressed
on envVar env_FSG_AudioSD_BAPCFG_ResetSet
{
   message 0x100 _mBAPconfig;

    if( getValue( this ) )
    {
        //for BAPconfig Set/Reset button
         _mBAPconfig.CAN= 1;
         _mBAPconfig.ID= 0x97333110;
         _mBAPconfig.DLC=8;

         _mBAPconfig.byte( 0 ) = 0x0c;
         _mBAPconfig.byte(1 ) = 0x42;
         _mBAPconfig.byte(2 ) = getValue( BAPCFG_FSG_AudioSD_ProtocolMajor );
         _mBAPconfig.byte(3) = getValue( BAPCFG_FSG_AudioSD_ProtocolMinor );
         _mBAPconfig.byte(4 ) = getValue( BAPCFG_FSG_AudioSD_LsgClassMajor );
         _mBAPconfig.byte(5) = getValue( BAPCFG_FSG_AudioSD_LsgClassMinor );
         _mBAPconfig.byte(6 ) = getValue( BAPCFG_FSG_AudioSD_DFMajor );
         _mBAPconfig.byte(7) = getValue( BAPCFG_FSG_AudioSD_DFMinor );

        output( _mBAPconfig );
   }
}

on envVar env_FSG_AudioSD_GetAll_ErrEn
{
    if( getValue( this ) )
        putValue( env_FSG_AudioSD_GetAll_FctEn, 0 );
}

on envVar env_FSG_AudioSD_FctList_ErrEn
{
    if( getValue( this ) )
        putValue( env_FSG_AudioSD_FctList_FctEn, 0 );
}

on envVar env_BAPCFG_FSG_AudioSD_FctEn
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_BAP_Config;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

on envVar env_FSG_AudioSD_GetAll_FctEn
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_GetAll;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

on envVar env_FSG_AudioSD_FctList_FctEn
{
    long data[3];
    data[0] = LSG_AudioSD;
    data[1] = FctID_FunctionList;
    data[2] = getValue( this );
    ChangeConfig( 0x0031, data );
}

on envvar env_FSG_Panel_Audio
{
    if( @this )
    {
        OpenPanel( "FSG_AudioSD_MainPanel" );
    }
}

on envVar env_AudioSD_FL_FullRangeUpd
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        recordaddress   = 1;
        shift           = 0;
        direction       = 0;
        transmitpos     = 0;
        indexsize       = 0;
        startelement    = 0;
        elements        = 255;
        mode= shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //send ChangedArray
        FavoriteList_Request( Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0 );
    }
}

on envVar Env_FSG_LSL_fullRange
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i,j;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        recordaddress   = 1;
        shift           = 0;
        direction       = 0;
        transmitpos     = 0;
        indexsize       = 0;
        startelement    = 0;
        elements        = 255;
        mode= shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;
		
		j = 0;

       

        //send ChangedArray
        LastStationList_Request( Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0 );
    }
}

on envVar env_AudioSD_SAL_FullRangeUpd
{
    word requested_startelement, startelement, elements, valid_startelement, valid_elements;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress;
    int i;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    requested_startelement  = 0;
    startelement            = 0;
    elements                = 0;
    valid_startelement      = 0;
    i                       = 0;
    valid_elements          = 0;

    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {
        recordaddress   = 1;
        shift           = 0;
        direction       = 0;
        transmitpos     = 0;
        indexsize       = 0;
        startelement    = 0;
        elements        = 255;
        mode= shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //send ChangedArray
        SiriusAlertList_Request( Changed_REQ, mode, recordaddress, startelement, startelement, elements, 0 );
    }
}

on envVar env_AudioSD_LSL_insert
{
    word startelement, elements,successor, ctr, PosCtr,LSLlistCtr,elemTemp,PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_LASTSTATIONLIST_ENTRIES], startIndex, succIndex, posInBetweenCheck;
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,k,x;


    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;
    elemTemp                = 0;
    startIndex              = 0;
    succIndex               = 0;
    PosVal                  = 0;


    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
            POS[i] = 0;

        for( i = 0; i < BAP_BUFFER_SIZE; i++ )
            requestarray[i] = 0;

        for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
            gLSL_InvalidIns[i] = 0;

        for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
        {
            gLastStationList_Send[i][0] = 0;
            gLastStationList_Send[i][1] = 0;
        }


        putValue( env_AudioSD_LSL_Insert_Invalid, gLSL_InvalidIns );

        gLSL_InsInvalidCtr = 0;
        gLSL_InsValidCtr = 0;
        putValue( env_AudioSD_LSL_Insert_Message, empty_string );

        //get data from Panel
        //Patch GB 11.07.2014 -commented
        //recordaddress   = 0x0F;

        putvalue ( env_AudioSD_LSL_Insert_Message, empty_string );
        //MR 63332 #3   02.07.2014
        //gLSL_TotalElem = getValue( env_AudioSD_LSL_TotalNumLE );
        gLSL_TotalElem = gLastStationList_TotalNumListElements;

        if( getValue( env_AudioSD_LSL_insert_UPD_button )== 0x00 )
        {    shift           = 0x01; //insert
             gLSL_InsertFlg   = 0x01;

            //Patch GB 11.07.2014
            recordaddress   = 0x0F;
        }
        else
        {
            shift           = 0x0; //update

           //Patch GB 11.07.2014
            recordaddress   = getValue( env_AudioSD_LSL_AH_RA);
        }

        direction       = 0x0;
        transmitpos     = 0x01;


        indexsize       = getvalue( env_AudioSD_LSL_insert_size );
        //mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //message
        requestarray[0] = LSG_AudioSD;                //LSG-ID
        requestarray[1] = FctID_LastStationList;        //Fct.-ID
        requestarray[2] =Changed_REQ;               //request type
    Offset = 3;

        startelement    = getValue( env_AudioSD_LSL_insert_start );

        successor = getValue( env_AudioSD_LSL_insert_successor );


        switch( indexsize ) // POS size
        {
            case 0: //8Bit
                getvalue( env_AudioSD_LSL_insert_POS_8, POS);
                ctr = getValueSize( env_AudioSD_LSL_insert_POS_8 );

                if( getValue( env_AudioSD_LSL_insert_ErrHandler )== 0x01 )
                {

                    if( ctr == 0 )   // if no data
                    {
                        putValue( env_AudioSD_LSL_Insert_Message, "NO DATA TO SEND" );
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid for Insert
                        if( getvalue( env_AudioSD_LSL_insert_start ) == 0x00 && getvalue( env_AudioSD_LSL_insert_successor ) == 0x00 && getvalue( env_AudioSD_LSL_insert_UPD_button ) == 0x00 )
                        {
                            //check if not all elements are deleted
                            if( gLSL_totalDELctr < gLSL_CSVtotalElem)
                            {
                            putValue( env_AudioSD_LSL_Insert_Message, "INVALID START & SUCCESSOR" );
                            break;
                            }
                        }

                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                        posInBetweenCheck       = 0;
                        if( ctr >1 )
                        {
                            posInBetweenCheck =  lslPosSequence_check ( indexsize,POS, ctr );
                            if( posInBetweenCheck == 0x01 )
                            {
                                putValue( env_AudioSD_LSL_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                break;
                            }
                        }


                        LastStationList_insert_ErrHandler_8 ( POS, ctr );

                        //if update has invalid POS - do not send
                        if( getvalue( env_AudioSD_LSL_insert_UPD_button ) == 0x01 )  //update
                        {
                            if( gLSL_InsInvalidCtr > 0 )
                            {
                                putValue( env_AudioSD_LSL_Insert_Message, "INVALID POS EXISTS" );
                                break;
                            }
                        }


                        //if all elements are INVALID for INSERT
                        if( ctr == gLSL_InsInvalidCtr )
                        {
                            putValue( env_AudioSD_LSL_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                        }
                        else
                        {
                            elements = gLSL_InsValidCtr+ 1;
                            ctr = gLSL_InsValidCtr;
                        }


                    }//else with data
                }
                else   // no error handling
                {
                    elements = ctr+ 1;
                    if( ctr == 0 )    // if no data
                    {
                        transmitpos     = 0x0;

                        if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                            elements = successor - startelement;
                    }
                 }

                //mode
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;

                //start
                requestarray[Offset] = startelement;
                Offset++;

                //elements
                requestarray[Offset] = elements;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if( getValue( env_AudioSD_LSL_insert_ErrHandler )== 0x01 )
                {
                    //ARRAY DATA
                        for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                requestarray[Offset] = gLastStationList_Send[i][0];
                                Offset++;
                            }

                    //INDEXING FOR INSERT
                    if( getValue( env_AudioSD_LSL_insert_UPD_button )== 0x00 )  //check if insert
                    {

                         // if all elements are deleted
                         if( gLSL_totalDELctr == gLSL_CSVtotalElem)
                         {

                                 //assign the first Insert element as handle and POS
                                 gAudioSD_CSIhandle_FSGhandle = gLastStationList_Send[0][0];
                                 gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;

                                  i = 0;
                                for( j = 0; j < gLSL_CSVtotalElem; j++ )
                                {
                                    if( gLastStationList_Pos_insDel[j][1] == 0x01 )
                                    continue ;
                                    else
                                    {
                                    i++;
                                    gLastStationList_Pos_insDel[j][2] = i;
                                    }
                                } //for
                         } //if
                         else if( gLSL_totalDELctr < gLSL_CSVtotalElem)
                        {

                            //Get Start and Successor Index
                            for(  j = 0; j < gLSL_CSVtotalElem; j++ )
                            {
                                //Start
                                if( getValue( env_AudioSD_LSL_insert_start ) == gLastStationList_Pos_insDel[j][0] )
                                {
                                    startIndex = gLastStationList_Pos_insDel[j][2];
                                }
                                //Succ
                                if( getValue( env_AudioSD_LSL_insert_successor ) == gLastStationList_Pos_insDel[j][0] )
                                {
                                    succIndex = gLastStationList_Pos_insDel[j][2];
                                }
                            }
                            //handling if inserted at the edges
                            if(succIndex == 0 )
                            {
                                succIndex = startIndex + 1;
                            }
                            if(startIndex == 0 )
                            {
                                startIndex = succIndex - 1;
                            }

                            //Increment indexes of items from the successor onwards ( by inserted items number )
                            for( j = 0; j < gLSL_CSVtotalElem; j++ )
                            {
                                if( succIndex <= gLastStationList_Pos_insDel[j][2] )
                                {
                                    gLastStationList_Pos_insDel[j][2] = gLastStationList_Pos_insDel[j][2] + ctr;
                                }

                                if( getvalue( env_AudioSD_CSH_FSGhandle ) == gLastStationList_Pos_insDel[j][0] )
                                {
                                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gLastStationList_Pos_insDel[j][2];
                                }
                            }

                            //Store Index of inserted items
                            //Loop number of times as inserted items
                            for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                //requestarray[Offset] = gLastStationList_Send[i][0];
                                //Offset++;

                                //Loop through array to find POS matching inserted item
                                for(  k = 0; k < gLSL_CSVtotalElem; k++ )
                                {
                                    if( gLastStationList_Send[i][0] == gLastStationList_Pos_insDel[k][0] )
                                    {
                                        gLastStationList_Pos_insDel[k][2] = startIndex + i + 1;
                                        break;
                                    } //if
                                } //for
                            } //for
                        }

                        //Update handle
                        //gAudioSD_CSIhandle_FSGhandle_absolutePos = gAudioSD_CSIhandle_FSGhandle_absolutePos + ctr;
                        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                    } //end if INSERT

                } //end if with ERROR handling

                //ArrayData WITHOUT error handling
                else
                {
                     for( i = 0; i <ctr; i++ )
                     {
                        requestarray[Offset] = POS[i];
                        Offset++;
                     }
                }

                //successor
                if( ctr > 0 )
                {
                    requestarray[Offset] = successor;
                    Offset++;
                }

            break;

            case 1:  //16Bit
                getvalue( env_AudioSD_LSL_insert_POS_16, POS);
                elements = getValueSize( env_AudioSD_LSL_insert_POS_16 );
                elemTemp = ( getValueSize( env_AudioSD_LSL_insert_POS_16 ) /2 );

                if( getValue( env_AudioSD_LSL_insert_ErrHandler )== 0x01 )
                {
                    if( elemTemp== 0 )   // if no data
                    {
                        putValue( env_AudioSD_LSL_Insert_Message, "NO DATA TO SEND" );
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid
                        if( ( getvalue( env_AudioSD_LSL_insert_start ) == 0x00 ) && ( getvalue( env_AudioSD_LSL_insert_successor ) == 0x00 )&& ( getvalue( env_AudioSD_LSL_insert_UPD_button ) == 0x00 ) )
                        {
                            //check if not all elements are deleted
                            if( gLSL_totalDELctr < gLSL_CSVtotalElem)
                            {
                            putValue( env_AudioSD_LSL_Insert_Message, "INVALID START & SUCCESSOR" );
                            break;
                            }
                        }


                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                            if( ctr >1 )
                            {
                                posInBetweenCheck =  lslPosSequence_check ( indexsize,POS,elemTemp);
                                if( posInBetweenCheck == 0x01 )
                                {
                                    putValue( env_AudioSD_LSL_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                    break;
                                }
                            }

                        LastStationList_insert_ErrHandler_16 ( POS,elements );
                        //if all elements are INVALID

                        //if update has invalid POS - do not send
                        if( getvalue( env_AudioSD_LSL_insert_UPD_button ) == 0x01 )  //update
                        {
                            if( gLSL_InsInvalidCtr > 0 )
                            {
                                putValue( env_AudioSD_LSL_Insert_Message, "INVALID POS EXISTS" );
                                break;
                            }
                        }

                        if( elemTemp == gLSL_InsInvalidCtr )
                        {
                            putValue( env_AudioSD_LSL_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                        }
                        else
                        {
                            elements = ( gLSL_InsValidCtr/2 )+ 1;     //including successor
                            elemTemp = gLSL_InsValidCtr/2;}
                        }

                    } //else with data
                else   // no error handling
                {
                    elements = elemTemp + 1;  //including successor
                    if( elemTemp== 0 )    // if no data
                    {
                        transmitpos = 0x0;
                         if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                        elements = successor - startelement;
                    }
                }

                //mode
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 )& 0xF0 ) + ( recordaddress& 0x0F );
                Offset++;

                requestarray[Offset] = startelement& 0xff;
                Offset++;
                requestarray[Offset] = (startelement& 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements& 0xff;
                Offset++;
                requestarray[Offset] = ( elements& 0xff00 ) / 0x100;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if( getValue( env_AudioSD_LSL_insert_ErrHandler )== 0x01 )
                {
                    for(  i = 0; i < elemTemp; i++ )
                        {
                            PosVal = 0x00;

                            //store in array the inserted item
                            requestarray[Offset] = gLastStationList_Send[(2*i)+ 1][0];
                            PosVal = requestarray[Offset];
                            Offset++;
                            requestarray[Offset] = gLastStationList_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;
                         }

                    //INDEXING FOR INSERT

                    if( getValue( env_AudioSD_LSL_insert_UPD_button )== 0x00 )  //check if insert
                    {
                         // if all elements are deleted
                         if( gLSL_totalDELctr == gLSL_CSVtotalElem)
                         {
                                 PosVal = 0x00;
                                 PosVal = gLastStationList_Send[0][0] << 8;
                                 PosVal = PosVal|gLastStationList_Send[1][0];

                                 gAudioSD_CSIhandle_FSGhandle = PosVal;
                                 gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;

                                 i = 0;
                                for( j = 0; j < gLSL_CSVtotalElem; j++ )
                                {
                                    if( gLastStationList_Pos_insDel[j][1] == 0x01 )
                                    continue ;
                                    else
                                    {
                                    i++;
                                    gLastStationList_Pos_insDel[j][2] = i;
                                    }
                                }

                         }
                        else if( gLSL_totalDELctr < gLSL_CSVtotalElem)
                        {
                            //Get Start and Successor Index
                            for(  j = 0; j < gLSL_CSVtotalElem; j++ )
                            {
                                //Start
                                if( getValue( env_AudioSD_LSL_insert_start ) == gLastStationList_Pos_insDel[j][0] )
                                {
                                    startIndex = gLastStationList_Pos_insDel[j][2];
                                }
                                //Succ
                                if( getValue( env_AudioSD_LSL_insert_successor ) == gLastStationList_Pos_insDel[j][0] )
                                {
                                    succIndex = gLastStationList_Pos_insDel[j][2];
                                }
                            }
                            //handling if inserted at the edges
                            if(succIndex == 0 )
                            {
                                succIndex = startIndex + 1;
                            }
                            if(startIndex == 0 )
                            {
                                startIndex = succIndex - 1;
                            }

                            //Increment indexes of items from the successor onwards ( by inserted items number )
                            for( j = 0; j < gLSL_CSVtotalElem; j++ )
                            {
                                if( succIndex <= gLastStationList_Pos_insDel[j][2] )
                                {
                                    gLastStationList_Pos_insDel[j][2] = gLastStationList_Pos_insDel[j][2] + elemTemp;
                                }

                                if( getvalue( env_AudioSD_CSH_FSGhandle ) == gLastStationList_Pos_insDel[j][0] )
                                {
                                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gLastStationList_Pos_insDel[j][2];
                                }
                            }

                                 //Store Index of inserted items
                                //Loop number of times as inserted items
                                for(  i = 0; i < elemTemp; i++ )
                                {
                                    PosVal = 0x00;
                                    PosVal = gLastStationList_Send[(2*i)+ 1][0];
                                    PosVal = PosVal|gLastStationList_Send[(2*i)+0][0]<<8;

                                    //Loop through array to find POS matching inserted item
                                    for(  k = 0; k < gLSL_CSVtotalElem; k++ )
                                    {
                                        if( PosVal == gLastStationList_Pos_insDel[k][0] )
                                        {
                                            gLastStationList_Pos_insDel[k][2] = startIndex + i + 1;
                                            break;
                                        }
                                    }//for
                                }//for
                        } //else if gLSL_totalDELctr

                        //Update handle
                        //gAudioSD_CSIhandle_FSGhandle_absolutePos = gAudioSD_CSIhandle_FSGhandle_absolutePos + ctr;
                        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                    } // end if INSERT

                } // end if with Errorhandling
                //ArrayData WITHOUT error handling
                else
                {
                    for(  i = 0; i < elemTemp; i++ )
                    {
                        requestarray[Offset] = POS[(2*i)+ 1];
                        Offset++;
                        requestarray[Offset] = POS[(2*i)+0];
                        Offset++;
                    }
                }

                //successor
                if( elemTemp > 0 )
                {
                    requestarray[Offset] = successor& 0xff;
                    Offset++;
                    requestarray[Offset] = (successor& 0xff00 ) / 0x100;
                    Offset++;
                }
                break; //case 1:  16Bit

            default:
                break; //default

        }//switch

        //resetting LoadReload Flg after Insert
        gLSL_loadReloadFlg = 0x00;



        if( indexsize== 0x01 )
        gLSL_InsValidCtr = gLSL_InsValidCtr/2;

        //updating the totalDeletedCtr;
           gLSL_totalDELctr = gLSL_totalDELctr - gLSL_InsValidCtr;

        if( gLSL_totalDELctr > gLSL_CSVtotalElem)
        gLSL_totalDELctr = 0;


        //just send the data when errorhandler is OFF
        if( getValue( env_AudioSD_LSL_insert_ErrHandler )== 0x00 )
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else if( getValue( env_AudioSD_LSL_insert_ErrHandler )== 0x01 )  //with ERROR HANDLER
        {
            if( getValue( env_AudioSD_LSL_insert_UPD_button )== 0x00 )  //insert
            {
                // if there's a Valid POS and Sequence is correct
                if( gLSL_InsValidCtr != 0x00 && posInBetweenCheck == 0x00 )
                {
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

                    if( gLSL_TotalElem + gLSL_InsValidCtr <= gLSL_CSVtotalElem)
                    {
                        //MR 63332 #3   02.07.2014
                        //putValue( env_AudioSD_LSL_TotalNumLE, gLSL_TotalElem + gLSL_InsValidCtr );
                        //gLastStationList_TotalNumListElements = getValue( env_AudioSD_LSL_TotalNumLE );
                        gLastStationList_TotalNumListElements = gLSL_TotalElem + gLSL_InsValidCtr;
                        putValue( env_AudioSD_LSL_TotalNumLE, gLastStationList_TotalNumListElements );
                    } //if


                }// if gLSL_InsValidCtr
            }// if insert
            else
            {
                //send only UPDATE if all POS are valid and DATA!= 0
                if( gLSL_InsInvalidCtr == 0x00 && gLSL_InsValidCtr!= 0 )
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }// else UPD button
        } //else if
    }
    //else
    //putValue( env_AudioSD_LSL_insert_UPD_button, 0 );
}
on envVar env_AudioSD_FL_insert
{
    word startelement, elements,successor, ctr, PosCtr,FLlistCtr,elemTemp,PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_FAVORITELIST_ENTRIES], startIndex, succIndex, posInBetweenCheck;
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,k,x;


    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;
    elemTemp                = 0;
    startIndex              = 0;
    succIndex               = 0;
    PosVal                  = 0;


    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
            POS[i] = 0;

        for( i = 0; i < BAP_BUFFER_SIZE; i++ )
            requestarray[i] = 0;

        for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
            gFL_InvalidIns[i] = 0;

        for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
        {
            gFavoriteList_Send[i][0] = 0;
            gFavoriteList_Send[i][1] = 0;
        }


        putValue( env_AudioSD_FL_Insert_Invalid, gFL_InvalidIns );

        gFL_InsInvalidCtr = 0;
        gFL_InsValidCtr = 0;
        putValue( env_AudioSD_FL_Insert_Message, empty_string );

        //get data from Panel
        //Patch GB 11.07.2014 -commented
        //recordaddress   = 0x0F;

        putvalue ( env_AudioSD_FL_Insert_Message, empty_string );
        //MR 63332 #3   02.07.2014
        //gFL_TotalElem = getValue( env_AudioSD_FL_TotalNumLE );
        gFL_TotalElem = gFavoriteList_TotalNumListElements;

        if( getValue( env_AudioSD_FL_insert_UPD_button )== 0x00 )
        {    shift           = 0x01; //insert
             gFL_InsertFlg   = 0x01;

            //Patch GB 11.07.2014
            recordaddress   = 0x0F;
        }
        else
        {
            shift           = 0x0; //update

           //Patch GB 11.07.2014
            recordaddress   = getValue( env_AudioSD_FL_AH_RA);
        }

        direction       = 0x0;
        transmitpos     = 0x01;


        indexsize       = getvalue( env_AudioSD_FL_insert_size );
        //mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //message
        requestarray[0] = LSG_AudioSD;                //LSG-ID
        requestarray[1] = FctID_FavoriteList;        //Fct.-ID
        requestarray[2] =Changed_REQ;               //request type
    Offset = 3;

        startelement    = getValue( env_AudioSD_FL_insert_start );

        successor = getValue( env_AudioSD_FL_insert_successor );


        switch( indexsize ) // POS size
        {
            case 0: //8Bit
                getvalue( env_AudioSD_FL_insert_POS_8, POS);
                ctr = getValueSize( env_AudioSD_FL_insert_POS_8 );

                if( getValue( env_AudioSD_FL_insert_ErrHandler )== 0x01 )
                {

                    if( ctr == 0 )   // if no data
                    {
                        putValue( env_AudioSD_FL_Insert_Message, "NO DATA TO SEND" );
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid for Insert
                        if( getvalue( env_AudioSD_FL_insert_start ) == 0x00 && getvalue( env_AudioSD_FL_insert_successor ) == 0x00 && getvalue( env_AudioSD_FL_insert_UPD_button ) == 0x00 )
                        {
                            //check if not all elements are deleted
                            if( gFL_totalDELctr < gFL_CSVtotalElem)
                            {
                            putValue( env_AudioSD_FL_Insert_Message, "INVALID START & SUCCESSOR" );
                            break;
                            }
                        }

                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                        posInBetweenCheck       = 0;
                        if( ctr >1 )
                        {
                            posInBetweenCheck =  flPosSequence_check ( indexsize,POS, ctr );
                            if( posInBetweenCheck == 0x01 )
                            {
                                putValue( env_AudioSD_FL_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                break;
                            }
                        }


                        FavoriteList_insert_ErrHandler_8 ( POS, ctr );

                        //if update has invalid POS - do not send
                        if( getvalue( env_AudioSD_FL_insert_UPD_button ) == 0x01 )  //update
                        {
                            if( gFL_InsInvalidCtr > 0 )
                            {
                                putValue( env_AudioSD_FL_Insert_Message, "INVALID POS EXISTS" );
                                break;
                            }
                        }


                        //if all elements are INVALID for INSERT
                        if( ctr == gFL_InsInvalidCtr )
                        {
                            putValue( env_AudioSD_FL_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                        }
                        else
                        {
                            elements = gFL_InsValidCtr+ 1;
                            ctr = gFL_InsValidCtr;
                        }


                    }//else with data
                }
                else   // no error handling
                {
                    elements = ctr+ 1;
                    if( ctr == 0 )    // if no data
                    {
                        transmitpos     = 0x0;

                        if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                            elements = successor - startelement;
                    }
                 }

                //mode
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;

                //start
                requestarray[Offset] = startelement;
                Offset++;

                //elements
                requestarray[Offset] = elements;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if( getValue( env_AudioSD_FL_insert_ErrHandler )== 0x01 )
                {
                    //ARRAY DATA
                        for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                requestarray[Offset] = gFavoriteList_Send[i][0];
                                Offset++;
                            }

                    //INDEXING FOR INSERT
                    if( getValue( env_AudioSD_FL_insert_UPD_button )== 0x00 )  //check if insert
                    {

                         // if all elements are deleted
                         if( gFL_totalDELctr == gFL_CSVtotalElem)
                         {

                                 //assign the first Insert element as handle and POS
                                 gAudioSD_CSIhandle_FSGhandle = gFavoriteList_Send[0][0];
                                 gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;

                                  i = 0;
                                for( j = 0; j < gFL_CSVtotalElem; j++ )
                                {
                                    if( gFavoriteList_Pos_insDel[j][1] == 0x01 )
                                    continue ;
                                    else
                                    {
                                    i++;
                                    gFavoriteList_Pos_insDel[j][2] = i;
                                    }
                                } //for
                         } //if
                         else if( gFL_totalDELctr < gFL_CSVtotalElem)
                        {

                            //Get Start and Successor Index
                            for(  j = 0; j < gFL_CSVtotalElem; j++ )
                            {
                                //Start
                                if( getValue( env_AudioSD_FL_insert_start ) == gFavoriteList_Pos_insDel[j][0] )
                                {
                                    startIndex = gFavoriteList_Pos_insDel[j][2];
                                }
                                //Succ
                                if( getValue( env_AudioSD_FL_insert_successor ) == gFavoriteList_Pos_insDel[j][0] )
                                {
                                    succIndex = gFavoriteList_Pos_insDel[j][2];
                                }
                            }
                            //handling if inserted at the edges
                            if(succIndex == 0 )
                            {
                                succIndex = startIndex + 1;
                            }
                            if(startIndex == 0 )
                            {
                                startIndex = succIndex - 1;
                            }

                            //Increment indexes of items from the successor onwards ( by inserted items number )
                            for( j = 0; j < gFL_CSVtotalElem; j++ )
                            {
                                if( succIndex <= gFavoriteList_Pos_insDel[j][2] )
                                {
                                    gFavoriteList_Pos_insDel[j][2] = gFavoriteList_Pos_insDel[j][2] + ctr;
                                }

                                if( getvalue( env_AudioSD_CSH_FSGhandle ) == gFavoriteList_Pos_insDel[j][0] )
                                {
                                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gFavoriteList_Pos_insDel[j][2];
                                }
                            }

                            //Store Index of inserted items
                            //Loop number of times as inserted items
                            for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                //requestarray[Offset] = gFavoriteList_Send[i][0];
                                //Offset++;

                                //Loop through array to find POS matching inserted item
                                for(  k = 0; k < gFL_CSVtotalElem; k++ )
                                {
                                    if( gFavoriteList_Send[i][0] == gFavoriteList_Pos_insDel[k][0] )
                                    {
                                        gFavoriteList_Pos_insDel[k][2] = startIndex + i + 1;
                                        break;
                                    } //if
                                } //for
                            } //for
                        }

                        //Update handle
                        //gAudioSD_CSIhandle_FSGhandle_absolutePos = gAudioSD_CSIhandle_FSGhandle_absolutePos + ctr;
                        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                    } //end if INSERT

                } //end if with ERROR handling

                //ArrayData WITHOUT error handling
                else
                {
                     for( i = 0; i <ctr; i++ )
                     {
                        requestarray[Offset] = POS[i];
                        Offset++;
                     }
                }

                //successor
                if( ctr > 0 )
                {
                    requestarray[Offset] = successor;
                    Offset++;
                }

            break;

            case 1:  //16Bit
                getvalue( env_AudioSD_FL_insert_POS_16, POS);
                elements = getValueSize( env_AudioSD_FL_insert_POS_16 );
                elemTemp = ( getValueSize( env_AudioSD_FL_insert_POS_16 ) /2 );

                if( getValue( env_AudioSD_FL_insert_ErrHandler )== 0x01 )
                {
                    if( elemTemp== 0 )   // if no data
                    {
                        putValue( env_AudioSD_FL_Insert_Message, "NO DATA TO SEND" );
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid
                        if( ( getvalue( env_AudioSD_FL_insert_start ) == 0x00 ) && ( getvalue( env_AudioSD_FL_insert_successor ) == 0x00 )&& ( getvalue( env_AudioSD_FL_insert_UPD_button ) == 0x00 ) )
                        {
                            //check if not all elements are deleted
                            if( gFL_totalDELctr < gFL_CSVtotalElem)
                            {
                            putValue( env_AudioSD_FL_Insert_Message, "INVALID START & SUCCESSOR" );
                            break;
                            }
                        }


                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                            if( ctr >1 )
                            {
                                posInBetweenCheck =  flPosSequence_check ( indexsize,POS,elemTemp);
                                if( posInBetweenCheck == 0x01 )
                                {
                                    putValue( env_AudioSD_FL_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                    break;
                                }
                            }

                        FavoriteList_insert_ErrHandler_16 ( POS,elements );
                        //if all elements are INVALID

                        //if update has invalid POS - do not send
                        if( getvalue( env_AudioSD_FL_insert_UPD_button ) == 0x01 )  //update
                        {
                            if( gFL_InsInvalidCtr > 0 )
                            {
                                putValue( env_AudioSD_FL_Insert_Message, "INVALID POS EXISTS" );
                                break;
                            }
                        }

                        if( elemTemp == gFL_InsInvalidCtr )
                        {
                            putValue( env_AudioSD_FL_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                        }
                        else
                        {
                            elements = ( gFL_InsValidCtr/2 )+ 1;     //including successor
                            elemTemp = gFL_InsValidCtr/2;}
                        }

                    } //else with data
                else   // no error handling
                {
                    elements = elemTemp + 1;  //including successor
                    if( elemTemp== 0 )    // if no data
                    {
                        transmitpos = 0x0;
                         if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                        elements = successor - startelement;
                    }
                }

                //mode
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 )& 0xF0 ) + ( recordaddress& 0x0F );
                Offset++;

                requestarray[Offset] = startelement& 0xff;
                Offset++;
                requestarray[Offset] = (startelement& 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements& 0xff;
                Offset++;
                requestarray[Offset] = ( elements& 0xff00 ) / 0x100;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if( getValue( env_AudioSD_FL_insert_ErrHandler )== 0x01 )
                {
                    for(  i = 0; i < elemTemp; i++ )
                        {
                            PosVal = 0x00;

                            //store in array the inserted item
                            requestarray[Offset] = gFavoriteList_Send[(2*i)+ 1][0];
                            PosVal = requestarray[Offset];
                            Offset++;
                            requestarray[Offset] = gFavoriteList_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;
                         }

                    //INDEXING FOR INSERT

                    if( getValue( env_AudioSD_FL_insert_UPD_button )== 0x00 )  //check if insert
                    {
                         // if all elements are deleted
                         if( gFL_totalDELctr == gFL_CSVtotalElem)
                         {
                                 PosVal = 0x00;
                                 PosVal = gFavoriteList_Send[0][0] << 8;
                                 PosVal = PosVal|gFavoriteList_Send[1][0];

                                 gAudioSD_CSIhandle_FSGhandle = PosVal;
                                 gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;

                                 i = 0;
                                for( j = 0; j < gFL_CSVtotalElem; j++ )
                                {
                                    if( gFavoriteList_Pos_insDel[j][1] == 0x01 )
                                    continue ;
                                    else
                                    {
                                    i++;
                                    gFavoriteList_Pos_insDel[j][2] = i;
                                    }
                                }

                         }
                        else if( gFL_totalDELctr < gFL_CSVtotalElem)
                        {
                            //Get Start and Successor Index
                            for(  j = 0; j < gFL_CSVtotalElem; j++ )
                            {
                                //Start
                                if( getValue( env_AudioSD_FL_insert_start ) == gFavoriteList_Pos_insDel[j][0] )
                                {
                                    startIndex = gFavoriteList_Pos_insDel[j][2];
                                }
                                //Succ
                                if( getValue( env_AudioSD_FL_insert_successor ) == gFavoriteList_Pos_insDel[j][0] )
                                {
                                    succIndex = gFavoriteList_Pos_insDel[j][2];
                                }
                            }
                            //handling if inserted at the edges
                            if(succIndex == 0 )
                            {
                                succIndex = startIndex + 1;
                            }
                            if(startIndex == 0 )
                            {
                                startIndex = succIndex - 1;
                            }

                            //Increment indexes of items from the successor onwards ( by inserted items number )
                            for( j = 0; j < gFL_CSVtotalElem; j++ )
                            {
                                if( succIndex <= gFavoriteList_Pos_insDel[j][2] )
                                {
                                    gFavoriteList_Pos_insDel[j][2] = gFavoriteList_Pos_insDel[j][2] + elemTemp;
                                }

                                if( getvalue( env_AudioSD_CSH_FSGhandle ) == gFavoriteList_Pos_insDel[j][0] )
                                {
                                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gFavoriteList_Pos_insDel[j][2];
                                }
                            }

                                 //Store Index of inserted items
                                //Loop number of times as inserted items
                                for(  i = 0; i < elemTemp; i++ )
                                {
                                    PosVal = 0x00;
                                    PosVal = gFavoriteList_Send[(2*i)+ 1][0];
                                    PosVal = PosVal|gFavoriteList_Send[(2*i)+0][0]<<8;

                                    //Loop through array to find POS matching inserted item
                                    for(  k = 0; k < gFL_CSVtotalElem; k++ )
                                    {
                                        if( PosVal == gFavoriteList_Pos_insDel[k][0] )
                                        {
                                            gFavoriteList_Pos_insDel[k][2] = startIndex + i + 1;
                                            break;
                                        }
                                    }//for
                                }//for
                        } //else if gFL_totalDELctr

                        //Update handle
                        //gAudioSD_CSIhandle_FSGhandle_absolutePos = gAudioSD_CSIhandle_FSGhandle_absolutePos + ctr;
                        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                    } // end if INSERT

                } // end if with Errorhandling
                //ArrayData WITHOUT error handling
                else
                {
                    for(  i = 0; i < elemTemp; i++ )
                    {
                        requestarray[Offset] = POS[(2*i)+ 1];
                        Offset++;
                        requestarray[Offset] = POS[(2*i)+0];
                        Offset++;
                    }
                }

                //successor
                if( elemTemp > 0 )
                {
                    requestarray[Offset] = successor& 0xff;
                    Offset++;
                    requestarray[Offset] = (successor& 0xff00 ) / 0x100;
                    Offset++;
                }
                break; //case 1:  16Bit

            default:
                break; //default

        }//switch

        //resetting LoadReload Flg after Insert
        gFL_loadReloadFlg = 0x00;



        if( indexsize== 0x01 )
        gFL_InsValidCtr = gFL_InsValidCtr/2;

        //updating the totalDeletedCtr;
           gFL_totalDELctr = gFL_totalDELctr - gFL_InsValidCtr;

        if( gFL_totalDELctr > gFL_CSVtotalElem)
        gFL_totalDELctr = 0;


        //just send the data when errorhandler is OFF
        if( getValue( env_AudioSD_FL_insert_ErrHandler )== 0x00 )
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else if( getValue( env_AudioSD_FL_insert_ErrHandler )== 0x01 )  //with ERROR HANDLER
        {
            if( getValue( env_AudioSD_FL_insert_UPD_button )== 0x00 )  //insert
            {
                // if there's a Valid POS and Sequence is correct
                if( gFL_InsValidCtr != 0x00 && posInBetweenCheck == 0x00 )
                {
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

                    if( gFL_TotalElem + gFL_InsValidCtr <= gFL_CSVtotalElem)
                    {
                        //MR 63332 #3   02.07.2014
                        //putValue( env_AudioSD_FL_TotalNumLE, gFL_TotalElem + gFL_InsValidCtr );
                        //gFavoriteList_TotalNumListElements = getValue( env_AudioSD_FL_TotalNumLE );
                        gFavoriteList_TotalNumListElements = gFL_TotalElem + gFL_InsValidCtr;
                        putValue( env_AudioSD_FL_TotalNumLE, gFavoriteList_TotalNumListElements );
                    } //if


                }// if gFL_InsValidCtr
            }// if insert
            else
            {
                //send only UPDATE if all POS are valid and DATA!= 0
                if( gFL_InsInvalidCtr == 0x00 && gFL_InsValidCtr!= 0 )
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }// else UPD button
        } //else if
    }
    //else
    //putValue( env_AudioSD_FL_insert_UPD_button, 0 );
}
on envVar env_AudioSD_SAL_insert
{
    word startelement, elements,successor, ctr, PosCtr,SALlistCtr,elemTemp,PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_SIRIUSALERTLIST_ENTRIES], startIndex, succIndex, posInBetweenCheck;
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,k,x;


    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;
    elemTemp                = 0;
    startIndex              = 0;
    succIndex               = 0;
    PosVal                  = 0;


    if( gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
    {

        for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
            POS[i] = 0;

        for( i = 0; i < BAP_BUFFER_SIZE; i++ )
            requestarray[i] = 0;

        for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
            gSAL_InvalidIns[i] = 0;

        for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
        {
            gSiriusAlertList_Send[i][0] = 0;
            gSiriusAlertList_Send[i][1] = 0;
        }


        putValue( env_AudioSD_SAL_Insert_Invalid, gSAL_InvalidIns );

        gSAL_InsInvalidCtr = 0;
        gSAL_InsValidCtr = 0;
        putValue( env_AudioSD_SAL_Insert_Message, empty_string );

        //get data from Panel
        //Patch GB 11.07.2014 -commented
        //recordaddress   = 0x0F;

        putvalue ( env_AudioSD_SAL_Insert_Message, empty_string );
        //MR 63332 #3   02.07.2014
        //gSAL_TotalElem = getValue( env_AudioSD_SAL_TotalNumLE );
        gSAL_TotalElem = gSiriusAlertList_TotalNumListElements;

        if( getValue( env_AudioSD_SAL_insert_UPD_button )== 0x00 )
        {    shift           = 0x01; //insert
             gSAL_InsertFlg   = 0x01;

            //Patch GB 11.07.2014
            recordaddress   = 0x0F;
        }
        else
        {
            shift           = 0x0; //update

           //Patch GB 11.07.2014
            recordaddress   = getValue( env_AudioSD_SAL_AH_RA);
        }

        direction       = 0x0;
        transmitpos     = 0x01;


        indexsize       = getvalue( env_AudioSD_SAL_insert_size );
        //mode            = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

        //message
        requestarray[0] = LSG_AudioSD;                //LSG-ID
        requestarray[1] = FctID_SiriusAlertList;        //Fct.-ID
        requestarray[2] =Changed_REQ;               //request type
    Offset = 3;

        startelement    = getValue( env_AudioSD_SAL_insert_start );

        successor = getValue( env_AudioSD_SAL_insert_successor );


        switch( indexsize ) // POS size
        {
            case 0: //8Bit
                getvalue( env_AudioSD_SAL_insert_POS_8, POS);
                ctr = getValueSize( env_AudioSD_SAL_insert_POS_8 );

                if( getValue( env_AudioSD_SAL_insert_ErrHandler )== 0x01 )
                {

                    if( ctr == 0 )   // if no data
                    {
                        putValue( env_AudioSD_SAL_Insert_Message, "NO DATA TO SEND" );
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid for Insert
                        if( getvalue( env_AudioSD_SAL_insert_start ) == 0x00 && getvalue( env_AudioSD_SAL_insert_successor ) == 0x00 && getvalue( env_AudioSD_SAL_insert_UPD_button ) == 0x00 )
                        {
                            //check if not all elements are deleted
                            if( gSAL_totalDELctr < gSAL_CSVtotalElem)
                            {
                            putValue( env_AudioSD_SAL_Insert_Message, "INVALID START & SUCCESSOR" );
                            break;
                            }
                        }

                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                        posInBetweenCheck       = 0;
                        if( ctr >1 )
                        {
                            posInBetweenCheck =  salPosSequence_check ( indexsize,POS, ctr );
                            if( posInBetweenCheck == 0x01 )
                            {
                                putValue( env_AudioSD_SAL_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                break;
                            }
                        }


                        SiriusAlertList_insert_ErrHandler_8 ( POS, ctr );

                        //if update has invalid POS - do not send
                        if( getvalue( env_AudioSD_SAL_insert_UPD_button ) == 0x01 )  //update
                        {
                            if( gSAL_InsInvalidCtr > 0 )
                            {
                                putValue( env_AudioSD_SAL_Insert_Message, "INVALID POS EXISTS" );
                                break;
                            }
                        }


                        //if all elements are INVALID for INSERT
                        if( ctr == gSAL_InsInvalidCtr )
                        {
                            putValue( env_AudioSD_SAL_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                        }
                        else
                        {
                            elements = gSAL_InsValidCtr+ 1;
                            ctr = gSAL_InsValidCtr;
                        }


                    }//else with data
                }
                else   // no error handling
                {
                    elements = ctr+ 1;
                    if( ctr == 0 )    // if no data
                    {
                        transmitpos     = 0x0;

                        if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                            elements = successor - startelement;
                    }
                 }

                //mode
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;

                //start
                requestarray[Offset] = startelement;
                Offset++;

                //elements
                requestarray[Offset] = elements;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if( getValue( env_AudioSD_SAL_insert_ErrHandler )== 0x01 )
                {
                    //ARRAY DATA
                        for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                requestarray[Offset] = gSiriusAlertList_Send[i][0];
                                Offset++;
                            }

                    //INDEXING FOR INSERT
                    if( getValue( env_AudioSD_SAL_insert_UPD_button )== 0x00 )  //check if insert
                    {

                         // if all elements are deleted
                         if( gSAL_totalDELctr == gSAL_CSVtotalElem)
                         {

                                 //assign the first Insert element as handle and POS
                                 gAudioSD_CSIhandle_FSGhandle = gSiriusAlertList_Send[0][0];
                                 gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;

                                  i = 0;
                                for( j = 0; j < gSAL_CSVtotalElem; j++ )
                                {
                                    if( gSiriusAlertList_Pos_insDel[j][1] == 0x01 )
                                    continue ;
                                    else
                                    {
                                    i++;
                                    gSiriusAlertList_Pos_insDel[j][2] = i;
                                    }
                                } //for
                         } //if
                         else if( gSAL_totalDELctr < gSAL_CSVtotalElem)
                        {

                            //Get Start and Successor Index
                            for(  j = 0; j < gSAL_CSVtotalElem; j++ )
                            {
                                //Start
                                if( getValue( env_AudioSD_SAL_insert_start ) == gSiriusAlertList_Pos_insDel[j][0] )
                                {
                                    startIndex = gSiriusAlertList_Pos_insDel[j][2];
                                }
                                //Succ
                                if( getValue( env_AudioSD_SAL_insert_successor ) == gSiriusAlertList_Pos_insDel[j][0] )
                                {
                                    succIndex = gSiriusAlertList_Pos_insDel[j][2];
                                }
                            }
                            //handling if inserted at the edges
                            if(succIndex == 0 )
                            {
                                succIndex = startIndex + 1;
                            }
                            if(startIndex == 0 )
                            {
                                startIndex = succIndex - 1;
                            }

                            //Increment indexes of items from the successor onwards ( by inserted items number )
                            for( j = 0; j < gSAL_CSVtotalElem; j++ )
                            {
                                if( succIndex <= gSiriusAlertList_Pos_insDel[j][2] )
                                {
                                    gSiriusAlertList_Pos_insDel[j][2] = gSiriusAlertList_Pos_insDel[j][2] + ctr;
                                }

                                if( getvalue( env_AudioSD_CSH_FSGhandle ) == gSiriusAlertList_Pos_insDel[j][0] )
                                {
                                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gSiriusAlertList_Pos_insDel[j][2];
                                }
                            }

                            //Store Index of inserted items
                            //Loop number of times as inserted items
                            for( i = 0; i <ctr; i++ )
                            {
                                //store in array the inserted item
                                //requestarray[Offset] = gSiriusAlertList_Send[i][0];
                                //Offset++;

                                //Loop through array to find POS matching inserted item
                                for(  k = 0; k < gSAL_CSVtotalElem; k++ )
                                {
                                    if( gSiriusAlertList_Send[i][0] == gSiriusAlertList_Pos_insDel[k][0] )
                                    {
                                        gSiriusAlertList_Pos_insDel[k][2] = startIndex + i + 1;
                                        break;
                                    } //if
                                } //for
                            } //for
                        }

                        //Update handle
                        //gAudioSD_CSIhandle_FSGhandle_absolutePos = gAudioSD_CSIhandle_FSGhandle_absolutePos + ctr;
                        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                    } //end if INSERT

                } //end if with ERROR handling

                //ArrayData WITHOUT error handling
                else
                {
                     for( i = 0; i <ctr; i++ )
                     {
                        requestarray[Offset] = POS[i];
                        Offset++;
                     }
                }

                //successor
                if( ctr > 0 )
                {
                    requestarray[Offset] = successor;
                    Offset++;
                }

            break;

            case 1:  //16Bit
                getvalue( env_AudioSD_SAL_insert_POS_16, POS);
                elements = getValueSize( env_AudioSD_SAL_insert_POS_16 );
                elemTemp = ( getValueSize( env_AudioSD_SAL_insert_POS_16 ) /2 );

                if( getValue( env_AudioSD_SAL_insert_ErrHandler )== 0x01 )
                {
                    if( elemTemp== 0 )   // if no data
                    {
                        putValue( env_AudioSD_SAL_Insert_Message, "NO DATA TO SEND" );
                        break;
                    }
                    else     // with data
                    {
                        //if START and SUCC are invalid
                        if( ( getvalue( env_AudioSD_SAL_insert_start ) == 0x00 ) && ( getvalue( env_AudioSD_SAL_insert_successor ) == 0x00 )&& ( getvalue( env_AudioSD_SAL_insert_UPD_button ) == 0x00 ) )
                        {
                            //check if not all elements are deleted
                            if( gSAL_totalDELctr < gSAL_CSVtotalElem)
                            {
                            putValue( env_AudioSD_SAL_Insert_Message, "INVALID START & SUCCESSOR" );
                            break;
                            }
                        }


                        //checking for POS sequence for insert
                        //call this before ErrorHandler because of INS/DEL tagging
                            if( ctr >1 )
                            {
                                posInBetweenCheck =  salPosSequence_check ( indexsize,POS,elemTemp);
                                if( posInBetweenCheck == 0x01 )
                                {
                                    putValue( env_AudioSD_SAL_Insert_Message, "INCORRECT POS SEQUENCE!" );
                                    break;
                                }
                            }

                        SiriusAlertList_insert_ErrHandler_16 ( POS,elements );
                        //if all elements are INVALID

                        //if update has invalid POS - do not send
                        if( getvalue( env_AudioSD_SAL_insert_UPD_button ) == 0x01 )  //update
                        {
                            if( gSAL_InsInvalidCtr > 0 )
                            {
                                putValue( env_AudioSD_SAL_Insert_Message, "INVALID POS EXISTS" );
                                break;
                            }
                        }

                        if( elemTemp == gSAL_InsInvalidCtr )
                        {
                            putValue( env_AudioSD_SAL_Insert_Message, "POS INVALID / STILL EXIST" );
                            break;
                        }
                        else
                        {
                            elements = ( gSAL_InsValidCtr/2 )+ 1;     //including successor
                            elemTemp = gSAL_InsValidCtr/2;}
                        }

                    } //else with data
                else   // no error handling
                {
                    elements = elemTemp + 1;  //including successor
                    if( elemTemp== 0 )    // if no data
                    {
                        transmitpos = 0x0;
                         if( successor == 0x00 )  //element = 1  if successor = 0 & no data
                            elements = 1;
                        else
                        elements = successor - startelement;
                    }
                }

                //mode
                mode = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) +indexsize * 0x08;

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 )& 0xF0 ) + ( recordaddress& 0x0F );
                Offset++;

                requestarray[Offset] = startelement& 0xff;
                Offset++;
                requestarray[Offset] = (startelement& 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements& 0xff;
                Offset++;
                requestarray[Offset] = ( elements& 0xff00 ) / 0x100;
                Offset++;

                /***ArrayData***/

                //ArrayData with error handling
                if( getValue( env_AudioSD_SAL_insert_ErrHandler )== 0x01 )
                {
                    for(  i = 0; i < elemTemp; i++ )
                        {
                            PosVal = 0x00;

                            //store in array the inserted item
                            requestarray[Offset] = gSiriusAlertList_Send[(2*i)+ 1][0];
                            PosVal = requestarray[Offset];
                            Offset++;
                            requestarray[Offset] = gSiriusAlertList_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;
                         }

                    //INDEXING FOR INSERT

                    if( getValue( env_AudioSD_SAL_insert_UPD_button )== 0x00 )  //check if insert
                    {
                         // if all elements are deleted
                         if( gSAL_totalDELctr == gSAL_CSVtotalElem)
                         {
                                 PosVal = 0x00;
                                 PosVal = gSiriusAlertList_Send[0][0] << 8;
                                 PosVal = PosVal|gSiriusAlertList_Send[1][0];

                                 gAudioSD_CSIhandle_FSGhandle = PosVal;
                                 gAudioSD_CSIhandle_FSGhandle_absolutePos = 1;

                                 i = 0;
                                for( j = 0; j < gSAL_CSVtotalElem; j++ )
                                {
                                    if( gSiriusAlertList_Pos_insDel[j][1] == 0x01 )
                                    continue ;
                                    else
                                    {
                                    i++;
                                    gSiriusAlertList_Pos_insDel[j][2] = i;
                                    }
                                }

                         }
                        else if( gSAL_totalDELctr < gSAL_CSVtotalElem)
                        {
                            //Get Start and Successor Index
                            for(  j = 0; j < gSAL_CSVtotalElem; j++ )
                            {
                                //Start
                                if( getValue( env_AudioSD_SAL_insert_start ) == gSiriusAlertList_Pos_insDel[j][0] )
                                {
                                    startIndex = gSiriusAlertList_Pos_insDel[j][2];
                                }
                                //Succ
                                if( getValue( env_AudioSD_SAL_insert_successor ) == gSiriusAlertList_Pos_insDel[j][0] )
                                {
                                    succIndex = gSiriusAlertList_Pos_insDel[j][2];
                                }
                            }
                            //handling if inserted at the edges
                            if(succIndex == 0 )
                            {
                                succIndex = startIndex + 1;
                            }
                            if(startIndex == 0 )
                            {
                                startIndex = succIndex - 1;
                            }

                            //Increment indexes of items from the successor onwards ( by inserted items number )
                            for( j = 0; j < gSAL_CSVtotalElem; j++ )
                            {
                                if( succIndex <= gSiriusAlertList_Pos_insDel[j][2] )
                                {
                                    gSiriusAlertList_Pos_insDel[j][2] = gSiriusAlertList_Pos_insDel[j][2] + elemTemp;
                                }

                                if( getvalue( env_AudioSD_CSH_FSGhandle ) == gSiriusAlertList_Pos_insDel[j][0] )
                                {
                                    gAudioSD_CSIhandle_FSGhandle_absolutePos = gSiriusAlertList_Pos_insDel[j][2];
                                }
                            }

                                 //Store Index of inserted items
                                //Loop number of times as inserted items
                                for(  i = 0; i < elemTemp; i++ )
                                {
                                    PosVal = 0x00;
                                    PosVal = gSiriusAlertList_Send[(2*i)+ 1][0];
                                    PosVal = PosVal|gSiriusAlertList_Send[(2*i)+0][0]<<8;

                                    //Loop through array to find POS matching inserted item
                                    for(  k = 0; k < gSAL_CSVtotalElem; k++ )
                                    {
                                        if( PosVal == gSiriusAlertList_Pos_insDel[k][0] )
                                        {
                                            gSiriusAlertList_Pos_insDel[k][2] = startIndex + i + 1;
                                            break;
                                        }
                                    }//for
                                }//for
                        } //else if gSAL_totalDELctr

                        //Update handle
                        //gAudioSD_CSIhandle_FSGhandle_absolutePos = gAudioSD_CSIhandle_FSGhandle_absolutePos + ctr;
                        putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                        putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                        CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                    } // end if INSERT

                } // end if with Errorhandling
                //ArrayData WITHOUT error handling
                else
                {
                    for(  i = 0; i < elemTemp; i++ )
                    {
                        requestarray[Offset] = POS[(2*i)+ 1];
                        Offset++;
                        requestarray[Offset] = POS[(2*i)+0];
                        Offset++;
                    }
                }

                //successor
                if( elemTemp > 0 )
                {
                    requestarray[Offset] = successor& 0xff;
                    Offset++;
                    requestarray[Offset] = (successor& 0xff00 ) / 0x100;
                    Offset++;
                }
                break; //case 1:  16Bit

            default:
                break; //default

        }//switch

        //resetting LoadReload Flg after Insert
        gSAL_loadReloadFlg = 0x00;



        if( indexsize== 0x01 )
        gSAL_InsValidCtr = gSAL_InsValidCtr/2;

        //updating the totalDeletedCtr;
           gSAL_totalDELctr = gSAL_totalDELctr - gSAL_InsValidCtr;

        if( gSAL_totalDELctr > gSAL_CSVtotalElem)
        gSAL_totalDELctr = 0;


        //just send the data when errorhandler is OFF
        if( getValue( env_AudioSD_SAL_insert_ErrHandler )== 0x00 )
            set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else if( getValue( env_AudioSD_SAL_insert_ErrHandler )== 0x01 )  //with ERROR HANDLER
        {
            if( getValue( env_AudioSD_SAL_insert_UPD_button )== 0x00 )  //insert
            {
                // if there's a Valid POS and Sequence is correct
                if( gSAL_InsValidCtr != 0x00 && posInBetweenCheck == 0x00 )
                {
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

                    if( gSAL_TotalElem + gSAL_InsValidCtr <= gSAL_CSVtotalElem)
                    {
                        //MR 63332 #3   02.07.2014
                        //putValue( env_AudioSD_SAL_TotalNumLE, gSAL_TotalElem + gSAL_InsValidCtr );
                        //gSiriusAlertList_TotalNumListElements = getValue( env_AudioSD_SAL_TotalNumLE );
                        gSiriusAlertList_TotalNumListElements = gSAL_TotalElem + gSAL_InsValidCtr;
                        putValue( env_AudioSD_SAL_TotalNumLE, gSiriusAlertList_TotalNumListElements );
                    } //if


                }// if gSAL_InsValidCtr
            }// if insert
            else
            {
                //send only UPDATE if all POS are valid and DATA!= 0
                if( gSAL_InsInvalidCtr == 0x00 && gSAL_InsValidCtr!= 0 )
                    set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
            }// else UPD button
        } //else if
    }
    //else
    //putValue( env_AudioSD_SAL_insert_UPD_button, 0 );
}
on envVar env_AudioSD_LSL_delete
{
    //IssueList #76 - MR49870 : LastStationList
    word startelement, elements, PosCtr,LSLlistCtr, PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_LASTSTATIONLIST_ENTRIES];
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,z,x,y, csHandlectr;
    byte SHReqSent, c,posHandleFlg, handleDeletedFlg;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;

    for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
        POS[i] = 0;

    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

  // do action
  if(  gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
  {
    gLSL_DelInvalidCtr = 0;
    gLSL_DelValidCtr = 0;
    csHandlectr = 0;
    SHReqSent = 0;
    posHandleFlg= 0;
    PosVal = 0x00;
    handleDeletedFlg = 0;

    for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
        gLSL_InvalidDel[i] = 0;

    for( i = 0; i < AUDIO_LASTSTATIONLIST_ENTRIES; i++ )
        {
        gLastStationList_Send[i][0] = 0;
        gLastStationList_Send[i][1] = 0;
        }

    putvalue ( env_AudioSD_LSL_Insert_Message, empty_string );
    //MR 63332 #3   02.07.2014
    //gLSL_TotalElem = getValue( env_AudioSD_LSL_TotalNumLE );
    gLSL_TotalElem = gLastStationList_TotalNumListElements;

    //get data from Panel
    recordaddress               = 0x0F;

    //changes from Gerd Bewersdorf
    shift           = 0x1;
    direction       = 0x1;
    transmitpos     = 0x1;
    indexsize       = getvalue( env_AudioSD_LSL_delete_size );

    //message
    requestarray[0] = LSG_AudioSD;                //LSG-ID
    requestarray[1] = FctID_LastStationList;        //Fct.-ID
    requestarray[2] =Changed_REQ;               //request type
    Offset = 3;

    switch(  indexsize ) // POS size
    {
        case 0: //8Bit
            getvalue( env_AudioSD_LSL_delete_POS_8, POS);
            //startelement = POS[0];
            startelement = getvalue( env_AudioSD_LSL_delete_start );
            elements     = getValueSize( env_AudioSD_LSL_delete_POS_8 );

            //ErrHandler = ON
            if( getValue( env_AudioSD_LSL_delete_ErrHandler )== 0x01 )
            {
                if( elements== 0x00 )   // if no data
                {
                    putValue( env_AudioSD_LSL_delete_Message, "NO DATA TO SEND" );
                    break;
                }
                else     // with data
                {
                    LastStationList_delete_ErrHandler_8 ( POS,elements );
                    //if all elements are invalid
                    if( elements == gLSL_DelInvalidCtr )
                    {
                        putValue( env_AudioSD_LSL_delete_Message, "POS INVALID" );
                        break;
                    }
                    else
                        elements = gLSL_DelValidCtr;
                }
            }
            else  // no errorhandling
            {
                if( elements== 0x00 )   // if no data
                    transmitpos     = 0x0;
            }

            //mode
            mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;

            requestarray[Offset] = startelement;
            Offset++;

            requestarray[Offset] = elements;
            Offset++;

            /***ArrayData***/
            //IssueList #129  if-else condition
            if( getValue( env_AudioSD_LSL_delete_Auto)== 0x00 )
            {
                if( getValue( env_AudioSD_LSL_delete_ErrHandler )== 0x00 )
                {
                    for(  i = 0; i < elements; i++ )
                    {
                        requestarray[Offset] = POS[i];
                        Offset++;
                    }
                }
                else    // with error handling
                {
                    //check if handle is deleted
                    for( i = 0; i < gLSL_DelValidCtr; i++ )
                    {
                        if( gLastStationList_Send[i][0] == gAudioSD_CSIhandle_FSGhandle )
                            handleDeletedFlg = 0x01;
                    }

                    //set FFFF, 0 as handle if all elements are deleted
                     if( gLSL_totalDELctr == gLSL_CSVtotalElem)
                     {
                    gAudioSD_CSIhandle_FSGhandle= 0xFFFF;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos= 0;

                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    //CurrentStationHandle_Request( Data_REQ, 0 );//sendstatus
                    }

                    for( i = 0; i < gLSL_DelValidCtr; i++ )
                    {
                        requestarray[Offset] = gLastStationList_Send[i][0];
                        Offset++;

                        //UPDATING HANDLE VALUE
                    // if not all elements are deleted
                     if( gLSL_totalDELctr < gLSL_CSVtotalElem)
                     {
                        if( gLastStationList_Send[i][1]<= gAudioSD_CSIhandle_FSGhandle_absolutePos )
                        {

                            for( j = 0; j < gLSL_CSVtotalElem; j++ )
                            {
                                if( gLastStationList_Pos_insDel[j][1] == 0x01 )
                                    csHandlectr++;

                                if( gLastStationList_Pos_insDel[j][0] == gLastStationList_Send[i][0] )
                                {
                                    for( z=j;z< gLSL_CSVtotalElem;z++ )
                                    {
                                        if( gLastStationList_Pos_insDel[z][1] == 0x01 && z!=j)
                                            csHandlectr++;

                                        //if handle is deleted
                                        if( handleDeletedFlg == 0x01 )
                                        {
                                            if( gLastStationList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                gAudioSD_CSIhandle_FSGhandle = gLastStationList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gLastStationList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            }
                                        }
                                        //if handle is not deleted
                                        else if( gLastStationList_Pos_insDel[z][0] == gAudioSD_CSIhandle_FSGhandle )
                                        {
                                            gAudioSD_CSIhandle_FSGhandle = gLastStationList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gLastStationList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                        }
                                    }//for
                                }
                            }//for

                            csHandlectr = 0; // Reset deleted counter

                            //if new handle is not found moving forward, move backwards
                            if( SHReqSent == 0 )
                            {
                                for( j = gLSL_CSVtotalElem-1; j>= 0; j--)
                                {

                                    //if( gLastStationListPos_insDel[j][1] == 0x01 )
                                    //csHandlectr++;

                                    if( gLastStationList_Pos_insDel[j][0] == gLastStationList_Send[i][0] )
                                    {
                                        for( z=j;z>= 0;z--)
                                        {
                                            if( gLastStationList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                for( c = 0; c<z; c++ )
                                                {
                                                    if( gLastStationList_Pos_insDel[c][1] == 0x01 )
                                                    {
                                                        csHandlectr++;
                                                    }
                                                }
                                                gAudioSD_CSIhandle_FSGhandle = gLastStationList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gLastStationList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            } //if( gLastStationList_Pos_insDel[z][1] != 0x01 )
                                        } //for( z=j;z>= 0;z--)
                                    } //if( gLastStationList_Pos_insDel[j][0] == gLastStationList_Send[i] )
                                } //for( j = gLSL_CSVtotalElem-1; j>= 0; j--)
                            } //if( SHReqSent == 0 )
                        } //if( gLastStationList_Send[i] == gAudioSD_CSIhandle_FSGhandle )

                         //UPDATING THE HANDLE below the deleted element
                        x= 0;
                        for( y= 0;y< gLSL_CSVtotalElem;y++ )
                        {

                            if( gLastStationList_Pos_insDel[y][1] == 0x01 )
                            continue ;
                            else
                            {
                            x++;
                            gLastStationList_Pos_insDel[y][2] = x;
                            }//else
                        }//for

                       } //gLSL_totalDELctr
                    } //for( i = 0; i < gLSL_DelValidCtr; i++ )

                   //send STATUS
                   CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                }//else // with error handling
            }
            else
            {
            requestarray[Offset] = getValue( env_AudioSD_LSL_delete_POS_8_A);
            Offset++;
            }

            break;

      case 1:  //16Bit
        // Note:
        // - POS[]: MSB,LSB,...
        // - RequestArray[]: LSB,MSB,...
        getvalue( env_AudioSD_LSL_delete_POS_16, POS);
        startelement  = getvalue( env_AudioSD_LSL_delete_start );
        elements      = getValueSize( env_AudioSD_LSL_delete_POS_16 ) /2;

        if( getValue( env_AudioSD_LSL_delete_ErrHandler )== 0x01 )
          {
                    if( elements== 0 )   // if insufficient data
                    {
                    putValue( env_AudioSD_LSL_delete_Message, "NO DATA TO SEND" );
                    break;
                    }
                    else     // with data
                    {
                    LastStationList_delete_ErrHandler_16 ( POS,elements *2 );
                        //if all elements are invalid
                        if( elements == gLSL_DelInvalidCtr/2 )
                        {
                        putValue( env_AudioSD_LSL_delete_Message, "ALL POS INVALID" );
                        break;
                        }

                        else
                       elements = gLSL_DelValidCtr/2;
                    }
            }
        else  // no errorhandling
            {
            if( elements== 0x00 )   // if no data
            transmitpos     = 0x0;
            }

                //mode
                mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;

                requestarray[Offset] = startelement & 0xff;
                Offset++;
                requestarray[Offset] = (startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;

                /***ArrayData***/

                if( getValue( env_AudioSD_LSL_delete_ErrHandler )== 0x00 )
                {
                    for(  i = 0; i < elements; i++ )    //2 elements are inserted to the array below
                    {
                       requestarray[Offset] = POS[(2*i)+ 1];
                       Offset++;

                       requestarray[Offset] = POS[(2*i)];
                       Offset++;
                    }
                }
                 else    // with error handling
                 {
                    //check if handle is deleted
                    for( i = 0; i < gLSL_DelValidCtr; i++ )
                    {
                     PosVal= 0x00;
                     PosVal = gLastStationList_Send[i][0] << 8;
                     PosVal = PosVal|gLastStationList_Send[i + 1][0];

                    if( PosVal== gAudioSD_CSIhandle_FSGhandle )
                    handleDeletedFlg = 0x01;
                    }

                     //set FFFF, 0 as handle if all elements are deleted
                     if( gLSL_totalDELctr == gLSL_CSVtotalElem)
                    {
                    gAudioSD_CSIhandle_FSGhandle= 0xFFFF;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos= 0;

                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    //CurrentStationHandle_Request( Data_REQ, 0 );//sendstatus
                    }


                    for( i = 0; i < elements; i++ )
                    {
                           PosVal = 0x00;

                           requestarray[Offset] = gLastStationList_Send[(2*i)+ 1][0];
                           PosVal = requestarray[Offset];
                           Offset++;

                            requestarray[Offset] = gLastStationList_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;

                     //updating the handle value if not all elements are deleted
                     if( gLSL_totalDELctr < gLSL_CSVtotalElem)
                     {
                        if( PosVal<= gAudioSD_CSIhandle_FSGhandle )
                        {
                            for( j = 0; j < gLSL_CSVtotalElem; j++ )
                            {
                                if( gLastStationList_Pos_insDel[j][1] == 0x01 )
                                    csHandlectr++;

                                //if( gLastStationList_Pos_insDel[j][0] == gLastStationList_Send[i] )
                                if( gLastStationList_Pos_insDel[j][0] == PosVal)
                                {
                                    for( z=j;z< gLSL_CSVtotalElem;z++ )
                                    {
                                        if( gLastStationList_Pos_insDel[z][1] == 0x01 && z!=j)
                                            csHandlectr++;

                                        //if handle is deleted
                                        if( handleDeletedFlg == 0x01 )
                                        {

                                            if( gLastStationList_Pos_insDel[z][1] != 0x01 )
                                            {
                                            gAudioSD_CSIhandle_FSGhandle = gLastStationList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gLastStationList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index
                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                            }
                                        }
                                            //if handle is not deleted
                                        else if( gLastStationList_Pos_insDel[z][0] == gAudioSD_CSIhandle_FSGhandle )
                                        {
                                            gAudioSD_CSIhandle_FSGhandle = gLastStationList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gLastStationList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index
                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                         }
                                    }//for
                                }
                            }//for

                            csHandlectr = 0; // Reset deleted counter

                            //if new handle is not found moving forward, move backwards
                            if( SHReqSent == 0 )
                            {
                                for( j = gLSL_CSVtotalElem-1; j>= 0; j--)
                                {

                                    //if( gLastStationList_Pos_insDel[j][1] == 0x01 )
                                        //csHandlectr++;

                                   //if( gLastStationList_Pos_insDel[j][0] == gLastStationList_Send[i] )
                                    if( gLastStationList_Pos_insDel[j][0] == PosVal)
                                    {
                                        for( z=j;z>= 0;z--)
                                        {

                                            if( gLastStationList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                for( c = 0; c<z; c++ )
                                                {
                                                    if( gLastStationList_Pos_insDel[c][1] == 0x01 )
                                                    {
                                                        csHandlectr++;
                                                    }
                                                }
                                                gAudioSD_CSIhandle_FSGhandle = gLastStationList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gLastStationList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            } //if( gLastStationList_Pos_insDel[z][1] != 0x01 )
                                        } //for( z=j;z>= 0;z--)
                                    } //if( gLastStationList_Pos_insDel[j][0] == gLastStationList_Send[i] )
                                } //for( j = gLSL_CSVtotalElem-1; j>= 0; j--)
                            } //if( SHReqSent == 0 )
                        } //if( gLastStationList_Send[i] == gAudioSD_CSIhandle_FSGhandle )

                         //UPDATING THE HANDLE below the deleted element
                        /*for( j = 0; j < gLSL_CSVtotalElem; j++ )
                        {
                            if( gLastStationList_Pos_insDel[j][2] > gAudioSD_CSIhandle_FSGhandle_absolutePos )
                            {
                                gLastStationList_Pos_insDel[j][2] = gLastStationList_Pos_insDel[j][2] -1;
                            }
                        }*///for

                        x= 0;
                        for( y= 0;y< gLSL_CSVtotalElem;y++ )
                        {

                            if( gLastStationList_Pos_insDel[y][1] == 0x01 )
                            continue ;
                            else
                            {
                            x++;
                            gLastStationList_Pos_insDel[y][2] = x;

                            }//else
                        } //for

                       } //gLSL_totalDELctr
                    } //for( i = 0; i < gLSL_DelValidCtr; i++ )

                    //send STATUS
                   CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                } //else ERRORHANDLING

        break;

      default:
        break;
    }

    //resetting LoadReload Flg after Delete
    gLSL_loadReloadFlg = 0x00;
    putValue( env_AudioSD_LSL_insert_UPD_button, 0 );

        //DATA SENDING
        if( getValue( env_AudioSD_LSL_delete_ErrHandler )== 0x00 )
       set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else
        {
            if( gLSL_DelInvalidCtr!= 0 )
                putValue( env_AudioSD_LSL_delete_Invalid, gLSL_InvalidDel);

            if( gLSL_DelValidCtr != 0x00 )
            {
                set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                //if( indexsize == 0x00 )
                //putValue( env_AudioSD_LSL_TotalNumLE, gLSL_TotalElem -gLSL_DelValidCtr );
                //else
                //putValue( env_AudioSD_LSL_TotalNumLE, gLSL_TotalElem -( gLSL_DelValidCtr/2 ) );
                //gLastStationList_TotalNumListElements = getValue( env_AudioSD_LSL_TotalNumLE );

                if( indexsize == 0x00 )
                gLastStationList_TotalNumListElements =  gLSL_TotalElem - gLSL_DelValidCtr;
                else
                gLastStationList_TotalNumListElements =  gLSL_TotalElem -( gLSL_DelValidCtr/2 );

                putValue( env_AudioSD_LSL_TotalNumLE, gLastStationList_TotalNumListElements );
            }//if
        } //else

    } //if do action
}
on envVar env_AudioSD_FL_delete
{
    //IssueList #76 - MR49870 : FavoriteList
    word startelement, elements, PosCtr,FLlistCtr, PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_FAVORITELIST_ENTRIES];
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,z,x,y, csHandlectr;
    byte SHReqSent, c,posHandleFlg, handleDeletedFlg;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;

    for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
        POS[i] = 0;

    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

  // do action
  if(  gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
  {
    gFL_DelInvalidCtr = 0;
    gFL_DelValidCtr = 0;
    csHandlectr = 0;
    SHReqSent = 0;
    posHandleFlg= 0;
    PosVal = 0x00;
    handleDeletedFlg = 0;

    for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
        gFL_InvalidDel[i] = 0;

    for( i = 0; i < AUDIO_FAVORITELIST_ENTRIES; i++ )
        {
        gFavoriteList_Send[i][0] = 0;
        gFavoriteList_Send[i][1] = 0;
        }

    putvalue ( env_AudioSD_FL_Insert_Message, empty_string );
    //MR 63332 #3   02.07.2014
    //gFL_TotalElem = getValue( env_AudioSD_FL_TotalNumLE );
    gFL_TotalElem = gFavoriteList_TotalNumListElements;

    //get data from Panel
    recordaddress               = 0x0F;

    //changes from Gerd Bewersdorf
    shift           = 0x1;
    direction       = 0x1;
    transmitpos     = 0x1;
    indexsize       = getvalue( env_AudioSD_FL_delete_size );

    //message
    requestarray[0] = LSG_AudioSD;                //LSG-ID
    requestarray[1] = FctID_FavoriteList;        //Fct.-ID
    requestarray[2] =Changed_REQ;               //request type
	
    Offset = 3;

    switch(  indexsize ) // POS size
    {
        case 0: //8Bit
            getvalue( env_AudioSD_FL_delete_POS_8, POS);

            //startelement = POS[0];
            startelement = getvalue( env_AudioSD_FL_delete_start );
            elements     = getValueSize( env_AudioSD_FL_delete_POS_8 );

            //ErrHandler = ON
            if( getValue( env_AudioSD_FL_delete_ErrHandler )== 0x01 )
            {
                if( elements== 0x00 )   // if no data
                {
                    putValue( env_AudioSD_FL_delete_Message, "NO DATA TO SEND" );
                    break;
                }
                else     // with data
                {
                    FavoriteList_delete_ErrHandler_8 ( POS,elements );
                    //if all elements are invalid
                    if( elements == gFL_DelInvalidCtr )
                    {
                        putValue( env_AudioSD_FL_delete_Message, "POS INVALID" );
                        break;
                    }
                    else
                        elements = gFL_DelValidCtr;
                }
            }
            else  // no errorhandling
            {
                if( elements== 0x00 )   // if no data
                    transmitpos     = 0x0;
            }

            //mode
            mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;

            requestarray[Offset] = startelement;
            Offset++;

            requestarray[Offset] = elements;
            Offset++;

            /***ArrayData***/
            //IssueList #129  if-else condition
            if( getValue( env_AudioSD_FL_delete_Auto)== 0x00 )
            {
                if( getValue( env_AudioSD_FL_delete_ErrHandler )== 0x00 )
                {
                    for(  i = 0; i < elements; i++ )
                    {
                        requestarray[Offset] = POS[i];
                        Offset++;
                    }
                }
                else    // with error handling
                {
                    //check if handle is deleted
                    for( i = 0; i < gFL_DelValidCtr; i++ )
                    {
                        if( gFavoriteList_Send[i][0] == gAudioSD_CSIhandle_FSGhandle )
                            handleDeletedFlg = 0x01;
                    }

                    //set FFFF, 0 as handle if all elements are deleted
                     if( gFL_totalDELctr == gFL_CSVtotalElem)
                     {
                    gAudioSD_CSIhandle_FSGhandle= 0xFFFF;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos= 0;

                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    //CurrentStationHandle_Request( Data_REQ, 0 );//sendstatus
                    }

                    for( i = 0; i < gFL_DelValidCtr; i++ )
                    {
                        requestarray[Offset] = gFavoriteList_Send[i][0];
                        Offset++;

                        //UPDATING HANDLE VALUE
                    // if not all elements are deleted
                     if( gFL_totalDELctr < gFL_CSVtotalElem)
                     {
                        if( gFavoriteList_Send[i][1]<= gAudioSD_CSIhandle_FSGhandle_absolutePos )
                        {

                            for( j = 0; j < gFL_CSVtotalElem; j++ )
                            {
                                if( gFavoriteList_Pos_insDel[j][1] == 0x01 )
                                    csHandlectr++;

                                if( gFavoriteList_Pos_insDel[j][0] == gFavoriteList_Send[i][0] )
                                {
                                    for( z=j;z< gFL_CSVtotalElem;z++ )
                                    {
                                        if( gFavoriteList_Pos_insDel[z][1] == 0x01 && z!=j)
                                            csHandlectr++;

                                        //if handle is deleted
                                        if( handleDeletedFlg == 0x01 )
                                        {
                                            if( gFavoriteList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                gAudioSD_CSIhandle_FSGhandle = gFavoriteList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gFavoriteList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            }
                                        }
                                        //if handle is not deleted
                                        else if( gFavoriteList_Pos_insDel[z][0] == gAudioSD_CSIhandle_FSGhandle )
                                        {
                                            gAudioSD_CSIhandle_FSGhandle = gFavoriteList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gFavoriteList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                        }
                                    }//for
                                }
                            }//for

                            csHandlectr = 0; // Reset deleted counter

                            //if new handle is not found moving forward, move backwards
                            if( SHReqSent == 0 )
                            {
                                for( j = gFL_CSVtotalElem-1; j>= 0; j--)
                                {

                                    //if( gFavoriteListPos_insDel[j][1] == 0x01 )
                                    //csHandlectr++;

                                    if( gFavoriteList_Pos_insDel[j][0] == gFavoriteList_Send[i][0] )
                                    {
                                        for( z=j;z>= 0;z--)
                                        {
                                            if( gFavoriteList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                for( c = 0; c<z; c++ )
                                                {
                                                    if( gFavoriteList_Pos_insDel[c][1] == 0x01 )
                                                    {
                                                        csHandlectr++;
                                                    }
                                                }
                                                gAudioSD_CSIhandle_FSGhandle = gFavoriteList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gFavoriteList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            } //if( gFavoriteList_Pos_insDel[z][1] != 0x01 )
                                        } //for( z=j;z>= 0;z--)
                                    } //if( gFavoriteList_Pos_insDel[j][0] == gFavoriteList_Send[i] )
                                } //for( j = gFL_CSVtotalElem-1; j>= 0; j--)
                            } //if( SHReqSent == 0 )
                        } //if( gFavoriteList_Send[i] == gAudioSD_CSIhandle_FSGhandle )

                         //UPDATING THE HANDLE below the deleted element
                        x= 0;
                        for( y= 0;y< gFL_CSVtotalElem;y++ )
                        {

                            if( gFavoriteList_Pos_insDel[y][1] == 0x01 )
                            continue ;
                            else
                            {
                            x++;
                            gFavoriteList_Pos_insDel[y][2] = x;
                            }//else
                        }//for

                       } //gFL_totalDELctr
                    } //for( i = 0; i < gFL_DelValidCtr; i++ )

                   //send STATUS
                   CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                }//else // with error handling
            }
            else
            {
            requestarray[Offset] = getValue( env_AudioSD_FL_delete_POS_8_A);
            Offset++;
            }

            break;

      case 1:  //16Bit
        // Note:
        // - POS[]: MSB,LSB,...
        // - RequestArray[]: LSB,MSB,...
        getvalue( env_AudioSD_FL_delete_POS_16, POS);
        startelement  = getvalue( env_AudioSD_FL_delete_start );
        elements      = getValueSize( env_AudioSD_FL_delete_POS_16 ) /2;

        if( getValue( env_AudioSD_FL_delete_ErrHandler )== 0x01 )
          {
                    if( elements== 0 )   // if insufficient data
                    {
                    putValue( env_AudioSD_FL_delete_Message, "NO DATA TO SEND" );
                    break;
                    }
                    else     // with data
                    {
                    FavoriteList_delete_ErrHandler_16 ( POS,elements *2 );
                        //if all elements are invalid
                        if( elements == gFL_DelInvalidCtr/2 )
                        {
                        putValue( env_AudioSD_FL_delete_Message, "ALL POS INVALID" );
                        break;
                        }

                        else
                       elements = gFL_DelValidCtr/2;
                    }
            }
        else  // no errorhandling
            {
            if( elements== 0x00 )   // if no data
            transmitpos     = 0x0;
            }

                //mode
                mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;

                requestarray[Offset] = startelement & 0xff;
                Offset++;
                requestarray[Offset] = (startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;

                /***ArrayData***/

                if( getValue( env_AudioSD_FL_delete_ErrHandler )== 0x00 )
                {
                    for(  i = 0; i < elements; i++ )    //2 elements are inserted to the array below
                    {
                       requestarray[Offset] = POS[(2*i)+ 1];
                       Offset++;

                       requestarray[Offset] = POS[(2*i)];
                       Offset++;
                    }
                }
                 else    // with error handling
                 {
                    //check if handle is deleted
                    for( i = 0; i < gFL_DelValidCtr; i++ )
                    {
                     PosVal= 0x00;
                     PosVal = gFavoriteList_Send[i][0] << 8;
                     PosVal = PosVal|gFavoriteList_Send[i + 1][0];

                    if( PosVal== gAudioSD_CSIhandle_FSGhandle )
                    handleDeletedFlg = 0x01;
                    }

                     //set FFFF, 0 as handle if all elements are deleted
                     if( gFL_totalDELctr == gFL_CSVtotalElem)
                    {
                    gAudioSD_CSIhandle_FSGhandle= 0xFFFF;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos= 0;

                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    //CurrentStationHandle_Request( Data_REQ, 0 );//sendstatus
                    }


                    for( i = 0; i < elements; i++ )
                    {
                           PosVal = 0x00;

                           requestarray[Offset] = gFavoriteList_Send[(2*i)+ 1][0];
                           PosVal = requestarray[Offset];
                           Offset++;

                            requestarray[Offset] = gFavoriteList_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;

                     //updating the handle value if not all elements are deleted
                     if( gFL_totalDELctr < gFL_CSVtotalElem)
                     {
                        if( PosVal<= gAudioSD_CSIhandle_FSGhandle )
                        {
                            for( j = 0; j < gFL_CSVtotalElem; j++ )
                            {
                                if( gFavoriteList_Pos_insDel[j][1] == 0x01 )
                                    csHandlectr++;

                                //if( gFavoriteList_Pos_insDel[j][0] == gFavoriteList_Send[i] )
                                if( gFavoriteList_Pos_insDel[j][0] == PosVal)
                                {
                                    for( z=j;z< gFL_CSVtotalElem;z++ )
                                    {
                                        if( gFavoriteList_Pos_insDel[z][1] == 0x01 && z!=j)
                                            csHandlectr++;

                                        //if handle is deleted
                                        if( handleDeletedFlg == 0x01 )
                                        {

                                            if( gFavoriteList_Pos_insDel[z][1] != 0x01 )
                                            {
                                            gAudioSD_CSIhandle_FSGhandle = gFavoriteList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gFavoriteList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index
                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                            }
                                        }
                                            //if handle is not deleted
                                        else if( gFavoriteList_Pos_insDel[z][0] == gAudioSD_CSIhandle_FSGhandle )
                                        {
                                            gAudioSD_CSIhandle_FSGhandle = gFavoriteList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gFavoriteList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index
                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                         }
                                    }//for
                                }
                            }//for

                            csHandlectr = 0; // Reset deleted counter

                            //if new handle is not found moving forward, move backwards
                            if( SHReqSent == 0 )
                            {
                                for( j = gFL_CSVtotalElem-1; j>= 0; j--)
                                {

                                    //if( gFavoriteList_Pos_insDel[j][1] == 0x01 )
                                        //csHandlectr++;

                                   //if( gFavoriteList_Pos_insDel[j][0] == gFavoriteList_Send[i] )
                                    if( gFavoriteList_Pos_insDel[j][0] == PosVal)
                                    {
                                        for( z=j;z>= 0;z--)
                                        {

                                            if( gFavoriteList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                for( c = 0; c<z; c++ )
                                                {
                                                    if( gFavoriteList_Pos_insDel[c][1] == 0x01 )
                                                    {
                                                        csHandlectr++;
                                                    }
                                                }
                                                gAudioSD_CSIhandle_FSGhandle = gFavoriteList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gFavoriteList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            } //if( gFavoriteList_Pos_insDel[z][1] != 0x01 )
                                        } //for( z=j;z>= 0;z--)
                                    } //if( gFavoriteList_Pos_insDel[j][0] == gFavoriteList_Send[i] )
                                } //for( j = gFL_CSVtotalElem-1; j>= 0; j--)
                            } //if( SHReqSent == 0 )
                        } //if( gFavoriteList_Send[i] == gAudioSD_CSIhandle_FSGhandle )

                         //UPDATING THE HANDLE below the deleted element
                        /*for( j = 0; j < gFL_CSVtotalElem; j++ )
                        {
                            if( gFavoriteList_Pos_insDel[j][2] > gAudioSD_CSIhandle_FSGhandle_absolutePos )
                            {
                                gFavoriteList_Pos_insDel[j][2] = gFavoriteList_Pos_insDel[j][2] -1;
                            }
                        }*///for

                        x= 0;
                        for( y= 0;y< gFL_CSVtotalElem;y++ )
                        {

                            if( gFavoriteList_Pos_insDel[y][1] == 0x01 )
                            continue ;
                            else
                            {
                            x++;
                            gFavoriteList_Pos_insDel[y][2] = x;

                            }//else
                        } //for

                       } //gFL_totalDELctr
                    } //for( i = 0; i < gFL_DelValidCtr; i++ )

                    //send STATUS
                   CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                } //else ERRORHANDLING

        break;

      default:
        break;
    }

    //resetting LoadReload Flg after Delete
    gFL_loadReloadFlg = 0x00;
    putValue( env_AudioSD_FL_insert_UPD_button, 0 );

        //DATA SENDING
        if( getValue( env_AudioSD_FL_delete_ErrHandler )== 0x00 )
       set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else
        {
            if( gFL_DelInvalidCtr!= 0 )
                putValue( env_AudioSD_FL_delete_Invalid, gFL_InvalidDel);

            if( gFL_DelValidCtr != 0x00 )
            {
                set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                //if( indexsize == 0x00 )
                //putValue( env_AudioSD_FL_TotalNumLE, gFL_TotalElem -gFL_DelValidCtr );
                //else
                //putValue( env_AudioSD_FL_TotalNumLE, gFL_TotalElem -( gFL_DelValidCtr/2 ) );
                //gFavoriteList_TotalNumListElements = getValue( env_AudioSD_FL_TotalNumLE );

                if( indexsize == 0x00 )
                gFavoriteList_TotalNumListElements =  gFL_TotalElem - gFL_DelValidCtr;
                else
                gFavoriteList_TotalNumListElements =  gFL_TotalElem -( gFL_DelValidCtr/2 );

                putValue( env_AudioSD_FL_TotalNumLE, gFavoriteList_TotalNumListElements );
            }//if
        } //else

    } //if do action
}
on envVar env_AudioSD_SAL_delete
{
    //IssueList #76 - MR49870 : SiriusAlertList
    word startelement, elements, PosCtr,SALlistCtr, PosVal;
    byte mode, shift, direction, transmitpos, indexsize, recordaddress, POS[AUDIO_SIRIUSALERTLIST_ENTRIES];
    dword requestarray [BAP_BUFFER_SIZE], Offset, i,j,z,x,y, csHandlectr;
    byte SHReqSent, c,posHandleFlg, handleDeletedFlg;

    // Init local variables.
    mode                    = 0;
    shift                   = 0;
    direction               = 0;
    transmitpos             = 0;
    indexsize               = 0;
    recordaddress           = 0;
    startelement            = 0;
    elements                = 0;
    i                       = 0;
    Offset                  = 0;

    for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
        POS[i] = 0;

    for( i = 0; i < BAP_BUFFER_SIZE; i++ )
        requestarray[i] = 0;

  // do action
  if(  gAudioSD_PowerOnOff == POWER_ON && getvalue( this ) )
  {
    gSAL_DelInvalidCtr = 0;
    gSAL_DelValidCtr = 0;
    csHandlectr = 0;
    SHReqSent = 0;
    posHandleFlg= 0;
    PosVal = 0x00;
    handleDeletedFlg = 0;

    for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
        gSAL_InvalidDel[i] = 0;

    for( i = 0; i < AUDIO_SIRIUSALERTLIST_ENTRIES; i++ )
        {
        gSiriusAlertList_Send[i][0] = 0;
        gSiriusAlertList_Send[i][1] = 0;
        }

    putvalue ( env_AudioSD_SAL_Insert_Message, empty_string );
    //MR 63332 #3   02.07.2014
    //gSAL_TotalElem = getValue( env_AudioSD_SAL_TotalNumLE );
    gSAL_TotalElem = gSiriusAlertList_TotalNumListElements;

    //get data from Panel
    recordaddress               = 0x0F;

    //changes from Gerd Bewersdorf
    shift           = 0x1;
    direction       = 0x1;
    transmitpos     = 0x1;
    indexsize       = getvalue( env_AudioSD_SAL_delete_size );

    //message
    requestarray[0] = LSG_AudioSD;                //LSG-ID
    requestarray[1] = FctID_SiriusAlertList;        //Fct.-ID
    requestarray[2] =Changed_REQ;               //request type
    Offset = 3;

    switch(  indexsize ) // POS size
    {
        case 0: //8Bit
            getvalue( env_AudioSD_SAL_delete_POS_8, POS);
            //startelement = POS[0];
            startelement = getvalue( env_AudioSD_SAL_delete_start );
            elements     = getValueSize( env_AudioSD_SAL_delete_POS_8 );

            //ErrHandler = ON
            if( getValue( env_AudioSD_SAL_delete_ErrHandler )== 0x01 )
            {
                if( elements== 0x00 )   // if no data
                {
                    putValue( env_AudioSD_SAL_delete_Message, "NO DATA TO SEND" );
                    break;
                }
                else     // with data
                {
                    SiriusAlertList_delete_ErrHandler_8 ( POS,elements );
                    //if all elements are invalid
                    if( elements == gSAL_DelInvalidCtr )
                    {
                        putValue( env_AudioSD_SAL_delete_Message, "POS INVALID" );
                        break;
                    }
                    else
                        elements = gSAL_DelValidCtr;
                }
            }
            else  // no errorhandling
            {
                if( elements== 0x00 )   // if no data
                    transmitpos     = 0x0;
            }

            //mode
            mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

            /***ArrayHeader***/
            requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
            Offset++;

            requestarray[Offset] = startelement;
            Offset++;

            requestarray[Offset] = elements;
            Offset++;

            /***ArrayData***/
            //IssueList #129  if-else condition
            if( getValue( env_AudioSD_SAL_delete_Auto)== 0x00 )
            {
                if( getValue( env_AudioSD_SAL_delete_ErrHandler )== 0x00 )
                {
                    for(  i = 0; i < elements; i++ )
                    {
                        requestarray[Offset] = POS[i];
                        Offset++;
                    }
                }
                else    // with error handling
                {
                    //check if handle is deleted
                    for( i = 0; i < gSAL_DelValidCtr; i++ )
                    {
                        if( gSiriusAlertList_Send[i][0] == gAudioSD_CSIhandle_FSGhandle )
                            handleDeletedFlg = 0x01;
                    }

                    //set FFFF, 0 as handle if all elements are deleted
                     if( gSAL_totalDELctr == gSAL_CSVtotalElem)
                     {
                    gAudioSD_CSIhandle_FSGhandle= 0xFFFF;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos= 0;

                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    //CurrentStationHandle_Request( Data_REQ, 0 );//sendstatus
                    }

                    for( i = 0; i < gSAL_DelValidCtr; i++ )
                    {
                        requestarray[Offset] = gSiriusAlertList_Send[i][0];
                        Offset++;

                        //UPDATING HANDLE VALUE
                    // if not all elements are deleted
                     if( gSAL_totalDELctr < gSAL_CSVtotalElem)
                     {
                        if( gSiriusAlertList_Send[i][1]<= gAudioSD_CSIhandle_FSGhandle_absolutePos )
                        {

                            for( j = 0; j < gSAL_CSVtotalElem; j++ )
                            {
                                if( gSiriusAlertList_Pos_insDel[j][1] == 0x01 )
                                    csHandlectr++;

                                if( gSiriusAlertList_Pos_insDel[j][0] == gSiriusAlertList_Send[i][0] )
                                {
                                    for( z=j;z< gSAL_CSVtotalElem;z++ )
                                    {
                                        if( gSiriusAlertList_Pos_insDel[z][1] == 0x01 && z!=j)
                                            csHandlectr++;

                                        //if handle is deleted
                                        if( handleDeletedFlg == 0x01 )
                                        {
                                            if( gSiriusAlertList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                gAudioSD_CSIhandle_FSGhandle = gSiriusAlertList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gSiriusAlertList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            }
                                        }
                                        //if handle is not deleted
                                        else if( gSiriusAlertList_Pos_insDel[z][0] == gAudioSD_CSIhandle_FSGhandle )
                                        {
                                            gAudioSD_CSIhandle_FSGhandle = gSiriusAlertList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gSiriusAlertList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                        }
                                    }//for
                                }
                            }//for

                            csHandlectr = 0; // Reset deleted counter

                            //if new handle is not found moving forward, move backwards
                            if( SHReqSent == 0 )
                            {
                                for( j = gSAL_CSVtotalElem-1; j>= 0; j--)
                                {

                                    //if( gSiriusAlertListPos_insDel[j][1] == 0x01 )
                                    //csHandlectr++;

                                    if( gSiriusAlertList_Pos_insDel[j][0] == gSiriusAlertList_Send[i][0] )
                                    {
                                        for( z=j;z>= 0;z--)
                                        {
                                            if( gSiriusAlertList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                for( c = 0; c<z; c++ )
                                                {
                                                    if( gSiriusAlertList_Pos_insDel[c][1] == 0x01 )
                                                    {
                                                        csHandlectr++;
                                                    }
                                                }
                                                gAudioSD_CSIhandle_FSGhandle = gSiriusAlertList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gSiriusAlertList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos;

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            } //if( gSiriusAlertList_Pos_insDel[z][1] != 0x01 )
                                        } //for( z=j;z>= 0;z--)
                                    } //if( gSiriusAlertList_Pos_insDel[j][0] == gSiriusAlertList_Send[i] )
                                } //for( j = gSAL_CSVtotalElem-1; j>= 0; j--)
                            } //if( SHReqSent == 0 )
                        } //if( gSiriusAlertList_Send[i] == gAudioSD_CSIhandle_FSGhandle )

                         //UPDATING THE HANDLE below the deleted element
                        x= 0;
                        for( y= 0;y< gSAL_CSVtotalElem;y++ )
                        {

                            if( gSiriusAlertList_Pos_insDel[y][1] == 0x01 )
                            continue ;
                            else
                            {
                            x++;
                            gSiriusAlertList_Pos_insDel[y][2] = x;
                            }//else
                        }//for

                       } //gSAL_totalDELctr
                    } //for( i = 0; i < gSAL_DelValidCtr; i++ )

                   //send STATUS
                   CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                }//else // with error handling
            }
            else
            {
            requestarray[Offset] = getValue( env_AudioSD_SAL_delete_POS_8_A);
            Offset++;
            }

            break;

      case 1:  //16Bit
        // Note:
        // - POS[]: MSB,LSB,...
        // - RequestArray[]: LSB,MSB,...
        getvalue( env_AudioSD_SAL_delete_POS_16, POS);
        startelement  = getvalue( env_AudioSD_SAL_delete_start );
        elements      = getValueSize( env_AudioSD_SAL_delete_POS_16 ) /2;

        if( getValue( env_AudioSD_SAL_delete_ErrHandler )== 0x01 )
          {
                    if( elements== 0 )   // if insufficient data
                    {
                    putValue( env_AudioSD_SAL_delete_Message, "NO DATA TO SEND" );
                    break;
                    }
                    else     // with data
                    {
                    SiriusAlertList_delete_ErrHandler_16 ( POS,elements *2 );
                        //if all elements are invalid
                        if( elements == gSAL_DelInvalidCtr/2 )
                        {
                        putValue( env_AudioSD_SAL_delete_Message, "ALL POS INVALID" );
                        break;
                        }

                        else
                       elements = gSAL_DelValidCtr/2;
                    }
            }
        else  // no errorhandling
            {
            if( elements== 0x00 )   // if no data
            transmitpos     = 0x0;
            }

                //mode
                mode  = shift + ( direction * 0x02 ) + ( transmitpos * 0x04 ) + ( indexsize * 0x08 );

                /***ArrayHeader***/
                requestarray[Offset] = (( mode * 0x10 ) & 0xF0 ) + ( recordaddress & 0x0F );
                Offset++;

                requestarray[Offset] = startelement & 0xff;
                Offset++;
                requestarray[Offset] = (startelement & 0xff00 ) / 0x100;
                Offset++;

                requestarray[Offset] = elements & 0xff;
                Offset++;
                requestarray[Offset] = ( elements & 0xff00 ) / 0x100;
                Offset++;

                /***ArrayData***/

                if( getValue( env_AudioSD_SAL_delete_ErrHandler )== 0x00 )
                {
                    for(  i = 0; i < elements; i++ )    //2 elements are inserted to the array below
                    {
                       requestarray[Offset] = POS[(2*i)+ 1];
                       Offset++;

                       requestarray[Offset] = POS[(2*i)];
                       Offset++;
                    }
                }
                 else    // with error handling
                 {
                    //check if handle is deleted
                    for( i = 0; i < gSAL_DelValidCtr; i++ )
                    {
                     PosVal= 0x00;
                     PosVal = gSiriusAlertList_Send[i][0] << 8;
                     PosVal = PosVal|gSiriusAlertList_Send[i + 1][0];

                    if( PosVal== gAudioSD_CSIhandle_FSGhandle )
                    handleDeletedFlg = 0x01;
                    }

                     //set FFFF, 0 as handle if all elements are deleted
                     if( gSAL_totalDELctr == gSAL_CSVtotalElem)
                    {
                    gAudioSD_CSIhandle_FSGhandle= 0xFFFF;
                    gAudioSD_CSIhandle_FSGhandle_absolutePos= 0;

                    putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                    putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                    //CurrentStationHandle_Request( Data_REQ, 0 );//sendstatus
                    }


                    for( i = 0; i < elements; i++ )
                    {
                           PosVal = 0x00;

                           requestarray[Offset] = gSiriusAlertList_Send[(2*i)+ 1][0];
                           PosVal = requestarray[Offset];
                           Offset++;

                            requestarray[Offset] = gSiriusAlertList_Send[(2*i)+0][0];
                            PosVal = PosVal|requestarray[Offset]<<8;
                            Offset++;

                     //updating the handle value if not all elements are deleted
                     if( gSAL_totalDELctr < gSAL_CSVtotalElem)
                     {
                        if( PosVal<= gAudioSD_CSIhandle_FSGhandle )
                        {
                            for( j = 0; j < gSAL_CSVtotalElem; j++ )
                            {
                                if( gSiriusAlertList_Pos_insDel[j][1] == 0x01 )
                                    csHandlectr++;

                                //if( gSiriusAlertList_Pos_insDel[j][0] == gSiriusAlertList_Send[i] )
                                if( gSiriusAlertList_Pos_insDel[j][0] == PosVal)
                                {
                                    for( z=j;z< gSAL_CSVtotalElem;z++ )
                                    {
                                        if( gSiriusAlertList_Pos_insDel[z][1] == 0x01 && z!=j)
                                            csHandlectr++;

                                        //if handle is deleted
                                        if( handleDeletedFlg == 0x01 )
                                        {

                                            if( gSiriusAlertList_Pos_insDel[z][1] != 0x01 )
                                            {
                                            gAudioSD_CSIhandle_FSGhandle = gSiriusAlertList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gSiriusAlertList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index
                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                            }
                                        }
                                            //if handle is not deleted
                                        else if( gSiriusAlertList_Pos_insDel[z][0] == gAudioSD_CSIhandle_FSGhandle )
                                        {
                                            gAudioSD_CSIhandle_FSGhandle = gSiriusAlertList_Pos_insDel[z][0];
                                            gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                            gSiriusAlertList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index
                                            putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                            putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                            //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                            SHReqSent = 1;
                                            break;
                                         }
                                    }//for
                                }
                            }//for

                            csHandlectr = 0; // Reset deleted counter

                            //if new handle is not found moving forward, move backwards
                            if( SHReqSent == 0 )
                            {
                                for( j = gSAL_CSVtotalElem-1; j>= 0; j--)
                                {

                                    //if( gSiriusAlertList_Pos_insDel[j][1] == 0x01 )
                                        //csHandlectr++;

                                   //if( gSiriusAlertList_Pos_insDel[j][0] == gSiriusAlertList_Send[i] )
                                    if( gSiriusAlertList_Pos_insDel[j][0] == PosVal)
                                    {
                                        for( z=j;z>= 0;z--)
                                        {

                                            if( gSiriusAlertList_Pos_insDel[z][1] != 0x01 )
                                            {
                                                for( c = 0; c<z; c++ )
                                                {
                                                    if( gSiriusAlertList_Pos_insDel[c][1] == 0x01 )
                                                    {
                                                        csHandlectr++;
                                                    }
                                                }
                                                gAudioSD_CSIhandle_FSGhandle = gSiriusAlertList_Pos_insDel[z][0];
                                                gAudioSD_CSIhandle_FSGhandle_absolutePos = (z-csHandlectr )+ 1;
                                                gSiriusAlertList_Pos_insDel[z][2] = gAudioSD_CSIhandle_FSGhandle_absolutePos; //index

                                                putvalue( env_AudioSD_CSH_FSGhandle, gAudioSD_CSIhandle_FSGhandle );
                                                putValue( env_AudioSD_CSH_FSGAbsPos, gAudioSD_CSIhandle_FSGhandle_absolutePos );
                                                //CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                                                SHReqSent = 1;
                                                break;
                                            } //if( gSiriusAlertList_Pos_insDel[z][1] != 0x01 )
                                        } //for( z=j;z>= 0;z--)
                                    } //if( gSiriusAlertList_Pos_insDel[j][0] == gSiriusAlertList_Send[i] )
                                } //for( j = gSAL_CSVtotalElem-1; j>= 0; j--)
                            } //if( SHReqSent == 0 )
                        } //if( gSiriusAlertList_Send[i] == gAudioSD_CSIhandle_FSGhandle )

                         //UPDATING THE HANDLE below the deleted element
                        /*for( j = 0; j < gSAL_CSVtotalElem; j++ )
                        {
                            if( gSiriusAlertList_Pos_insDel[j][2] > gAudioSD_CSIhandle_FSGhandle_absolutePos )
                            {
                                gSiriusAlertList_Pos_insDel[j][2] = gSiriusAlertList_Pos_insDel[j][2] -1;
                            }
                        }*///for

                        x= 0;
                        for( y= 0;y< gSAL_CSVtotalElem;y++ )
                        {

                            if( gSiriusAlertList_Pos_insDel[y][1] == 0x01 )
                            continue ;
                            else
                            {
                            x++;
                            gSiriusAlertList_Pos_insDel[y][2] = x;

                            }//else
                        } //for

                       } //gSAL_totalDELctr
                    } //for( i = 0; i < gSAL_DelValidCtr; i++ )

                    //send STATUS
                   CurrentStationHandle_Request( Data_REQ, 0 );    //send status
                } //else ERRORHANDLING

        break;

      default:
        break;
    }

    //resetting LoadReload Flg after Delete
    gSAL_loadReloadFlg = 0x00;
    putValue( env_AudioSD_SAL_insert_UPD_button, 0 );

        //DATA SENDING
        if( getValue( env_AudioSD_SAL_delete_ErrHandler )== 0x00 )
       set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );

        else
        {
            if( gSAL_DelInvalidCtr!= 0 )
                putValue( env_AudioSD_SAL_delete_Invalid, gSAL_InvalidDel);

            if( gSAL_DelValidCtr != 0x00 )
            {
                set_status_requestbuffer( requestarray, Offset, Bap_ByteSequence );
                //if( indexsize == 0x00 )
                //putValue( env_AudioSD_SAL_TotalNumLE, gSAL_TotalElem -gSAL_DelValidCtr );
                //else
                //putValue( env_AudioSD_SAL_TotalNumLE, gSAL_TotalElem -( gSAL_DelValidCtr/2 ) );
                //gSiriusAlertList_TotalNumListElements = getValue( env_AudioSD_SAL_TotalNumLE );

                if( indexsize == 0x00 )
                gSiriusAlertList_TotalNumListElements =  gSAL_TotalElem - gSAL_DelValidCtr;
                else
                gSiriusAlertList_TotalNumListElements =  gSAL_TotalElem -( gSAL_DelValidCtr/2 );

                putValue( env_AudioSD_SAL_TotalNumLE, gSiriusAlertList_TotalNumListElements );
            }//if
        } //else

    } //if do action
}
//IssueList #76 - MR49870 : LastStationList
on envVar env_AudioSD_LSL_delete_POS_8
{
byte DEL_POS_8[AUDIO_LASTSTATIONLIST_ENTRIES];

putValue( env_AudioSD_LSL_delete_Message, empty_string );

    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_LSL_delete_ErrHandler )== 0x01 )
    {
    getValue( this, DEL_POS_8 );
    putValue( env_AudioSD_LSL_delete_start, DEL_POS_8[0] );
    }

}

//IssueList #76 - MR49870 : LastStationList
on envVar env_AudioSD_LSL_delete_POS_16
{
    byte DEL_POS_16[AUDIO_LASTSTATIONLIST_ENTRIES];
    word PosVal_16;

    putValue( env_AudioSD_LSL_delete_Message, empty_string );


    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_LSL_delete_ErrHandler )== 0x01 )
    {
        getValue( this, DEL_POS_16 );
        PosVal_16 = DEL_POS_16[0] << 8;
        PosVal_16 = PosVal_16|DEL_POS_16[1];

        putValue( env_AudioSD_LSL_delete_start, PosVal_16 );
    }

}

//IssueList #76 - MR49870 : LastStationList
on envVar env_AudioSD_LSL_delete_ErrHandler
{
    if( getValue( this )== 0x00 )
        putValue( env_AudioSD_LSL_TotalNumLE, gLastStationList_TotalNumListElements );
}

//IssueList #76 - MR49870 : LastStationList
on envVar env_AudioSD_LSL_insert_ErrHandler
{
    if( getValue( this )== 0x00 )
        putValue( env_AudioSD_LSL_TotalNumLE, gLastStationList_TotalNumListElements );
}

//IssueList #76 - MR49870 : LastStationList
LastStationList_delete_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word LSLlistCtr, PosCtr;

    result = 0x01;
    delFlg= 0;
    gLSL_DelInvalidCtr = 0;
    gLSL_DelValidCtr = 0;
    putValue( env_AudioSD_LSL_delete_Message, empty_string );


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {

         result = 0x00;
         delFlg = 0x00;

      for( LSLlistCtr = 0; LSLlistCtr < gLSL_CSVtotalElem; LSLlistCtr++ )
      {

           if( pos[PosCtr] == gLastStationList_Pos_insDel[LSLlistCtr][0] )   //check if POS is valid
           {
             if( gLastStationList_Pos_insDel[LSLlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gLastStationList_Pos_insDel[LSLlistCtr][1] = 0x01;    //tagging deleted Pos
               gLastStationList_Send[gLSL_DelValidCtr][0] = pos[PosCtr];
               gLastStationList_Send[gLSL_DelValidCtr][1] = gLastStationList_Pos_insDel[LSLlistCtr][2];

               gLSL_DelValidCtr++;
               gLSL_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_LSL_delete_Message, "POS already deleted!" );
              gLSL_InvalidDel[gLSL_DelInvalidCtr] = pos[PosCtr];
              gLSL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
           {
           gLSL_InvalidDel[gLSL_DelInvalidCtr] =pos[PosCtr];
            gLSL_DelInvalidCtr++;
             putValue( env_AudioSD_LSL_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : LastStationList
LastStationList_delete_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word LSLlistCtr, PosCtr,PosVal;

    result = 0x01;
    delFlg= 0;
    gLSL_DelInvalidCtr = 0;
    gLSL_DelValidCtr = 0;
    putValue( env_AudioSD_LSL_delete_Message, empty_string );
    PosVal = 0;

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {

         result = 0x00;
         delFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+ 1];


      for( LSLlistCtr = 0; LSLlistCtr < gLSL_CSVtotalElem; LSLlistCtr++ )
      {
           if( PosVal== gLastStationList_Pos_insDel[LSLlistCtr][0] )   //check if POS is valid
           {

             if( gLastStationList_Pos_insDel[LSLlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gLastStationList_Pos_insDel[LSLlistCtr][1] = 0x01;    //tagging deleted Pos
               gLastStationList_Send[gLSL_DelValidCtr][0] = pos[PosCtr];
               gLSL_DelValidCtr++;
               gLastStationList_Send[gLSL_DelValidCtr][0] = pos[PosCtr+ 1];
               gLSL_DelValidCtr++;
               gLSL_totalDELctr++;
                gLastStationList_Send[gLSL_DelValidCtr][1] = gLastStationList_Pos_insDel[LSLlistCtr][2];
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_LSL_delete_Message, "POS already deleted!" );
              gLSL_InvalidDel[gLSL_DelInvalidCtr] = pos[PosCtr];
              gLSL_DelInvalidCtr++;
              gLSL_InvalidDel[gLSL_DelInvalidCtr] = pos[PosCtr+ 1];
              gLSL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
        {

            gLSL_InvalidDel[gLSL_DelInvalidCtr] = pos[PosCtr];
            gLSL_DelInvalidCtr++;
            gLSL_InvalidDel[gLSL_DelInvalidCtr] = pos[PosCtr+ 1];
            gLSL_DelInvalidCtr++;
             putValue( env_AudioSD_LSL_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : LastStationList
void LastStationList_insert_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word LSLlistCtr, PosCtr;

    result = 0x01;
    InsFlg= 0;


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {
         result = 0x00;
         InsFlg = 0x00;

      for( LSLlistCtr = 0; LSLlistCtr < gLSL_CSVtotalElem; LSLlistCtr++ )
      {
           if( pos[PosCtr] == gLastStationList_Pos_insDel[LSLlistCtr][0] )   //check if POS is valid
           {
            //UPDATE
                if  ( getValue( env_AudioSD_LSL_insert_UPD_button ) == 0x01 )
                 {
                        if( gLastStationList_Pos_insDel[LSLlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                        {
                        result = 0x01;
                        gLastStationList_Send[gLSL_InsValidCtr][0] = pos[PosCtr];
                        gLSL_InsValidCtr++;
                        }

                        else
                          {
                          putValue( env_AudioSD_LSL_Insert_Message, "POS is already deleted!" );
                          gLSL_InvalidIns[gLSL_InsInvalidCtr] = pos[PosCtr];
                          gLSL_InsInvalidCtr++;
                          InsFlg = 0x01;
                          break;
                          }

                }  //update

                 else   //INSERT
                 {
                     if( gLastStationList_Pos_insDel[LSLlistCtr][1] == 0x01 )  //check if POS does not exist
                       {
                       gLastStationList_Pos_insDel[LSLlistCtr][1] = 0x00;
                       gLastStationList_Send[gLSL_InsValidCtr][0] = pos[PosCtr];
                       gLastStationList_Send[gLSL_InsValidCtr][1] = gLastStationList_Pos_insDel[LSLlistCtr][2];

                       gLSL_InsValidCtr++;
                       result = 0x01;
                       }
                      else
                      {
                      putValue( env_AudioSD_LSL_Insert_Message, "POS still exists!" );
                      gLSL_InvalidIns[gLSL_InsInvalidCtr] = pos[PosCtr];
                      gLSL_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                      }
               }//if
            } //else
       }//for
        if( result == 0x00 && InsFlg == 0x00 )
           {
           gLSL_InvalidIns[gLSL_InsInvalidCtr] =pos[PosCtr];
            gLSL_InsInvalidCtr++;
             putValue( env_AudioSD_LSL_Insert_Message, "INVALID POS!" );
            }
     }//for MBlistCtr

     if( gLSL_InsInvalidCtr!= 0 )
            putValue( env_AudioSD_LSL_Insert_Invalid, gLSL_InvalidIns );
}

void LastStationList_insert_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word PosVal,LSLlistCtr, PosCtr;

    result = 0x01;
    InsFlg= 0;
    PosVal = 0;

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {
        result = 0x00;
        InsFlg = 0x00;
        PosVal = pos[PosCtr] << 8;
        PosVal = PosVal|pos[PosCtr+ 1];
        for( LSLlistCtr = 0; LSLlistCtr < gLSL_CSVtotalElem; LSLlistCtr++ )
        {
            if( PosVal== gLastStationList_Pos_insDel[LSLlistCtr][0] )   //check if POS is valid
            {
                //UPDATE
                if  ( getValue( env_AudioSD_LSL_insert_UPD_button ) == 0x01 )
                {
                    if( gLastStationList_Pos_insDel[LSLlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                    {
                        result = 0x01;
                        gLastStationList_Send[gLSL_InsValidCtr][0] = pos[PosCtr];
                        gLSL_InsValidCtr++;
                        gLastStationList_Send[gLSL_InsValidCtr][0] = pos[PosCtr+ 1];
                        gLSL_InsValidCtr++;
                    }
                    else
                    {
                        putValue( env_AudioSD_LSL_Insert_Message, "POS is already deleted!" );
                        gLSL_InvalidIns[gLSL_InsInvalidCtr] = pos[PosCtr];
                        gLSL_InsInvalidCtr++;
                        gLSL_InvalidIns[gLSL_InsInvalidCtr] = pos[PosCtr+ 1];
                        gLSL_InsInvalidCtr++;
                        InsFlg = 0x01;
                        break;
                    }
                }  //update
                else   //INSERT
                {
                    if( gLastStationList_Pos_insDel[LSLlistCtr][1] == 0x01 )  //check if POS does not exist
                    {
                        gLastStationList_Pos_insDel[LSLlistCtr][1] = 0x00;
                        gLastStationList_Send[gLSL_InsValidCtr][0] = pos[PosCtr];
                        gLSL_InsValidCtr++;
                        gLastStationList_Send[gLSL_InsValidCtr][0] = pos[PosCtr+ 1];
                        gLSL_InsValidCtr++;
                        result = 0x01;
                    }
                    else
                    {
                        putValue( env_AudioSD_LSL_Insert_Message, "POS still exists!" );
                        gLSL_InvalidIns[gLSL_InsInvalidCtr] = pos[PosCtr];
                        gLSL_InsInvalidCtr++;
                        gLSL_InvalidIns[gLSL_InsInvalidCtr] = pos[PosCtr+ 1];
                        gLSL_InsInvalidCtr++;
                        InsFlg = 0x01;
                        break;
                    }
                }
            }
        }
        if( result == 0x00 && InsFlg == 0x00 )
        {
            gLSL_InvalidIns[gLSL_InsInvalidCtr] =pos[PosCtr];
            gLSL_InsInvalidCtr++;
            gLSL_InvalidIns[gLSL_InsInvalidCtr] = pos[PosCtr+ 1];
            gLSL_InsInvalidCtr++;
            putValue( env_AudioSD_LSL_Insert_Message, "INVALID POS!" );
        }
    }
    if( gLSL_InsInvalidCtr!= 0 )
        putValue( env_AudioSD_LSL_Insert_Invalid, gLSL_InvalidIns );
}

byte lslPosSequence_check ( byte Index, byte inputArray[],word inputCtr )
{
    byte posInBetween;
    word ctr, ctr1, ctr2,PosVal1_,PosVal2_;

    posInBetween = 0;

    for( ctr = 0; ctr < inputCtr; ctr++ )
    {
        // adjust for 8bit and 16bit handling
        if( Index== 0x00 )
        {
            PosVal1_ = inputArray[ctr];
            PosVal2_ = inputArray[ctr+ 1];
        }
        else
        {
            PosVal1_ = 0x0000;
            PosVal1_ = inputArray[(2*ctr )+ 1];
            PosVal1_ = PosVal1_|(( inputArray[(2*ctr )+0] )<<8 );
            PosVal2_ = 0x0000;
            PosVal2_ = inputArray[(2*ctr )+2+ 1];
            PosVal2_ = PosVal2_|(( inputArray[(2*ctr )+2+0] )<<8 );
        }
        // search send item in insdel array
        for( ctr1 = 0; ctr1 < gLSL_CSVtotalElem; ctr1++ )
        {
            if( PosVal1_ == gLastStationList_Pos_insDel[ctr1][0] ) // 1st send item is found in array
            {
                break;
            }
        }
        // search insdel array for next send item
        for( ctr2 = ctr1+ 1; ctr2 < gLSL_CSVtotalElem; ctr2++ ) // loop from 1st inserted item in insdel array
        {
            if( PosVal2_ == gLastStationList_Pos_insDel[ctr2][0] ) // 2nd send item immediately next to 1st send item
            {
                break;
            }
            else
            {
                if( gLastStationList_Pos_insDel[ctr2][1] == 0 && PosVal2_ != 0 )    // in between item is not deleted
                {
                    posInBetween = 0x01;
                    break;
                }
            }
        }
        if( posInBetween == 0x01 )
        {
            break;
        }
    }
    return posInBetween;
}

//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_LSL_insert_POS_8
{
    byte INS_POS_8[AUDIO_LASTSTATIONLIST_ENTRIES];
    int inputCtr,i,j;
    byte valid_INS_POS_8;
    byte validInputFlg_start, validInputFlg_succ;

    putvalue ( env_AudioSD_LSL_Insert_Message, empty_string );
    //if( getValue( env_AudioSD_LSL_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_LSL_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_LSL_insert_ErrHandler )== 0x01 )
    {
        getValue( this, INS_POS_8 );
        validInputFlg_start = 0;
        validInputFlg_succ = 0;
        inputCtr =  getValueSize( env_AudioSD_LSL_insert_POS_8 );
        if( inputCtr > 0 )
        {
            //look for the valid reference for Start and successor
            for( j = 0; j < inputCtr; j++ )
            {
                valid_INS_POS_8 = INS_POS_8[j];
                for( i = 0; i < gLSL_CSVtotalElem; i++ )
                {
                //check if input is valid and deleted
                    if( valid_INS_POS_8 == gLastStationList_Pos_insDel[i][0] && gLastStationList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_start = 1;
                        break;
                    }
                }
                if( validInputFlg_start == 0x01 )
                break;
            }
            if( validInputFlg_start == 0x01 )
            {
                //start
                if( valid_INS_POS_8== gLastStationList_Pos_insDel[0][0] )
                    putValue( env_AudioSD_LSL_insert_start, 0 );
                else
                {
                    ///look for the next existing element upwards
                    for( i = 0; i < gLSL_CSVtotalElem; i++ )
                    {
                        if( valid_INS_POS_8== gLastStationList_Pos_insDel[i][0] )
                        {
                            for( j = i-1; j>= 0; j--)
                            {
                                if( gLastStationList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_LSL_insert_start, gLastStationList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            } //validInputFlg
            //successor
            //look for the valid reference for Start and successor
            for( j = inputCtr-1; j>= 0; j--)
            {
                valid_INS_POS_8 = INS_POS_8[j];
                for( i = 0; i < gLSL_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( valid_INS_POS_8 == gLastStationList_Pos_insDel[i][0] && gLastStationList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_succ = 1;
                        break;
                    }
                }
                if( validInputFlg_succ == 0x01 )
                break;
            }
            if( validInputFlg_succ == 0x01 )
            {
                putValue( env_AudioSD_LSL_insert_successor, 0 );
                for( i = 0; i < gLSL_CSVtotalElem; i++ )
                {
                    if( valid_INS_POS_8== gLastStationList_Pos_insDel[i][0] )
                    {
                        if( i == gLSL_CSVtotalElem-1 )
                            putValue( env_AudioSD_LSL_insert_successor, 0 );
                        else
                        {
                            //look for the next existing element downwards
                            for( j = i + 1; j < gLSL_CSVtotalElem; j++ )
                            {
                                if( gLastStationList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_LSL_insert_successor, gLastStationList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_LSL_insert_POS_16
{
    byte INS_POS_16[AUDIO_LASTSTATIONLIST_ENTRIES];
    int  inputCtr,i,j;
    word PosVal_16_first,PosVal_16_last;
    byte validInputFlg_start, validInputFlg_succ;

    inputCtr = 0;
    PosVal_16_first = 0;
    PosVal_16_last = 0;
    validInputFlg_start = 0;
    validInputFlg_succ = 0;

    putvalue ( env_AudioSD_LSL_Insert_Message, empty_string );
    //if( getValue( env_AudioSD_LSL_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_LSL_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_LSL_insert_ErrHandler )== 0x01 )
    {
        getValue( this, INS_POS_16 );
        inputCtr =  getValueSize( env_AudioSD_LSL_insert_POS_16 );
        if( inputCtr > 1 )
        {
            //look for the valid reference for Start and successor
            for( j = 0; j < inputCtr; j++ )
            {
                //valid_INS_POS_8 = INS_POS_8[j];
                PosVal_16_first = INS_POS_16[j] << 8;
                PosVal_16_first = PosVal_16_first | INS_POS_16[j+ 1];
                for( i = 0; i < gLSL_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( PosVal_16_first == gLastStationList_Pos_insDel[i][0] && gLastStationList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_start = 1;
                        break;
                    }
                }
                if( validInputFlg_start == 0x01 )
                break;
            }
            if( validInputFlg_start == 0x01 )
            {
                //start
                if( PosVal_16_first == gLastStationList_Pos_insDel[0][0] )
                    putValue( env_AudioSD_LSL_insert_start, 0 );
                else
                {
                    ///look for the next existing element upwards
                    for( i = 2; i < gLSL_CSVtotalElem; i++ )
                    {
                        if( PosVal_16_first == gLastStationList_Pos_insDel[i][0] )
                        {
                            for( j = i-1; j> 0; j--)
                            {
                                if( gLastStationList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_LSL_insert_start, gLastStationList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            //successor
            for( j = inputCtr; j> 0; j--)
            {
                PosVal_16_last = INS_POS_16[j-1] << 8;
                PosVal_16_last = PosVal_16_last | INS_POS_16[j];
                for( i = 0; i < gLSL_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( PosVal_16_last == gLastStationList_Pos_insDel[i][0] && gLastStationList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_succ = 1;
                        break;
                    }
                }
                if( validInputFlg_succ == 0x01 )
                break;
            }
            if( validInputFlg_succ == 0x01 )
            {
                putValue( env_AudioSD_LSL_insert_successor, 0 );
                for( i = 0; i < gLSL_CSVtotalElem; i++ )
                {
                    if( PosVal_16_last == gLastStationList_Pos_insDel[i][0] )
                    {
                        if( i == gLSL_CSVtotalElem-1 )
                            putValue( env_AudioSD_LSL_insert_successor, 0 );
                        else
                        {
                            //look for the next existing element downwards
                            for( j = i + 1; j < gLSL_CSVtotalElem; j++ )
                            {
                                if( gLastStationList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_LSL_insert_successor, gLastStationList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            } //validInputFlg_succ
        }//inputCtr
    }
}
//IssueList #76 - MR49870 : FavoriteList
on envVar env_AudioSD_FL_delete_POS_8
{
byte DEL_POS_8[AUDIO_FAVORITELIST_ENTRIES];

putValue( env_AudioSD_FL_delete_Message, empty_string );

    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_FL_delete_ErrHandler )== 0x01 )
    {
    getValue( this, DEL_POS_8 );
    putValue( env_AudioSD_FL_delete_start, DEL_POS_8[0] );
    }

}

//IssueList #76 - MR49870 : FavoriteList
on envVar env_AudioSD_FL_delete_POS_16
{
    byte DEL_POS_16[AUDIO_FAVORITELIST_ENTRIES];
    word PosVal_16;

    putValue( env_AudioSD_FL_delete_Message, empty_string );


    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_FL_delete_ErrHandler )== 0x01 )
    {
        getValue( this, DEL_POS_16 );
        PosVal_16 = DEL_POS_16[0] << 8;
        PosVal_16 = PosVal_16|DEL_POS_16[1];

        putValue( env_AudioSD_FL_delete_start, PosVal_16 );
    }

}

//IssueList #76 - MR49870 : FavoriteList
on envVar env_AudioSD_FL_delete_ErrHandler
{
    if( getValue( this )== 0x00 )
        putValue( env_AudioSD_FL_TotalNumLE, gFavoriteList_TotalNumListElements );
}

//IssueList #76 - MR49870 : FavoriteList
on envVar env_AudioSD_FL_insert_ErrHandler
{
    if( getValue( this )== 0x00 )
        putValue( env_AudioSD_FL_TotalNumLE, gFavoriteList_TotalNumListElements );
}

//IssueList #76 - MR49870 : FavoriteList
FavoriteList_delete_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word FLlistCtr, PosCtr;

    result = 0x01;
    delFlg= 0;
    gFL_DelInvalidCtr = 0;
    gFL_DelValidCtr = 0;
    putValue( env_AudioSD_FL_delete_Message, empty_string );

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {

         result = 0x00;
         delFlg = 0x00;

      for( FLlistCtr = 0; FLlistCtr < gFL_CSVtotalElem; FLlistCtr++ )
      {

           if( pos[PosCtr] == gFavoriteList_Pos_insDel[FLlistCtr][0] )   //check if POS is valid
           {
             if( gFavoriteList_Pos_insDel[FLlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gFavoriteList_Pos_insDel[FLlistCtr][1] = 0x01;    //tagging deleted Pos
               gFavoriteList_Send[gFL_DelValidCtr][0] = pos[PosCtr];
               gFavoriteList_Send[gFL_DelValidCtr][1] = gFavoriteList_Pos_insDel[FLlistCtr][2];

               gFL_DelValidCtr++;
               gFL_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_FL_delete_Message, "POS already deleted!" );
              gFL_InvalidDel[gFL_DelInvalidCtr] = pos[PosCtr];
              gFL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
           {
           gFL_InvalidDel[gFL_DelInvalidCtr] =pos[PosCtr];
            gFL_DelInvalidCtr++;
             putValue( env_AudioSD_FL_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : FavoriteList
FavoriteList_delete_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word FLlistCtr, PosCtr,PosVal;

    result = 0x01;
    delFlg= 0;
    gFL_DelInvalidCtr = 0;
    gFL_DelValidCtr = 0;
    putValue( env_AudioSD_FL_delete_Message, empty_string );
    PosVal = 0;

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {

         result = 0x00;
         delFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+ 1];


      for( FLlistCtr = 0; FLlistCtr < gFL_CSVtotalElem; FLlistCtr++ )
      {
           if( PosVal== gFavoriteList_Pos_insDel[FLlistCtr][0] )   //check if POS is valid
           {

             if( gFavoriteList_Pos_insDel[FLlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gFavoriteList_Pos_insDel[FLlistCtr][1] = 0x01;    //tagging deleted Pos
               gFavoriteList_Send[gFL_DelValidCtr][0] = pos[PosCtr];
               gFL_DelValidCtr++;
               gFavoriteList_Send[gFL_DelValidCtr][0] = pos[PosCtr+ 1];
               gFL_DelValidCtr++;
               gFL_totalDELctr++;
                gFavoriteList_Send[gFL_DelValidCtr][1] = gFavoriteList_Pos_insDel[FLlistCtr][2];
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_FL_delete_Message, "POS already deleted!" );
              gFL_InvalidDel[gFL_DelInvalidCtr] = pos[PosCtr];
              gFL_DelInvalidCtr++;
              gFL_InvalidDel[gFL_DelInvalidCtr] = pos[PosCtr+ 1];
              gFL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
        {

            gFL_InvalidDel[gFL_DelInvalidCtr] = pos[PosCtr];
            gFL_DelInvalidCtr++;
            gFL_InvalidDel[gFL_DelInvalidCtr] = pos[PosCtr+ 1];
            gFL_DelInvalidCtr++;
             putValue( env_AudioSD_FL_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : FavoriteList
void FavoriteList_insert_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word FLlistCtr, PosCtr;

    result = 0x01;
    InsFlg= 0;


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {
         result = 0x00;
         InsFlg = 0x00;

      for( FLlistCtr = 0; FLlistCtr < gFL_CSVtotalElem; FLlistCtr++ )
      {
           if( pos[PosCtr] == gFavoriteList_Pos_insDel[FLlistCtr][0] )   //check if POS is valid
           {
            //UPDATE
                if  ( getValue( env_AudioSD_FL_insert_UPD_button ) == 0x01 )
                 {
                        if( gFavoriteList_Pos_insDel[FLlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                        {
                        result = 0x01;
                        gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr];
                        gFL_InsValidCtr++;
                        }

                        else
                          {
                          putValue( env_AudioSD_FL_Insert_Message, "POS is already deleted!" );
                          gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr];
                          gFL_InsInvalidCtr++;
                          InsFlg = 0x01;
                          break;
                          }

                }  //update

                 else   //INSERT
                 {
                     if( gFavoriteList_Pos_insDel[FLlistCtr][1] == 0x01 )  //check if POS does not exist
                       {
                       gFavoriteList_Pos_insDel[FLlistCtr][1] = 0x00;
                       gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr];
                       gFavoriteList_Send[gFL_InsValidCtr][1] = gFavoriteList_Pos_insDel[FLlistCtr][2];

                       gFL_InsValidCtr++;
                       result = 0x01;
                       }
                      else
                      {
                      putValue( env_AudioSD_FL_Insert_Message, "POS still exists!" );
                      gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr];
                      gFL_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                      }
               }//if
            } //else
       }//for
        if( result == 0x00 && InsFlg == 0x00 )
           {
           gFL_InvalidIns[gFL_InsInvalidCtr] =pos[PosCtr];
            gFL_InsInvalidCtr++;
             putValue( env_AudioSD_FL_Insert_Message, "INVALID POS!" );
            }
     }//for MBlistCtr

     if( gFL_InsInvalidCtr!= 0 )
            putValue( env_AudioSD_FL_Insert_Invalid, gFL_InvalidIns );
}

void FavoriteList_insert_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word PosVal,FLlistCtr, PosCtr;

    result = 0x01;
    InsFlg= 0;
    PosVal = 0;

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {
        result = 0x00;
        InsFlg = 0x00;
        PosVal = pos[PosCtr] << 8;
        PosVal = PosVal|pos[PosCtr+ 1];
        for( FLlistCtr = 0; FLlistCtr < gFL_CSVtotalElem; FLlistCtr++ )
        {
            if( PosVal== gFavoriteList_Pos_insDel[FLlistCtr][0] )   //check if POS is valid
            {
                //UPDATE
                if  ( getValue( env_AudioSD_FL_insert_UPD_button ) == 0x01 )
                {
                    if( gFavoriteList_Pos_insDel[FLlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                    {
                        result = 0x01;
                        gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr];
                        gFL_InsValidCtr++;
                        gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr+ 1];
                        gFL_InsValidCtr++;
                    }
                    else
                    {
                        putValue( env_AudioSD_FL_Insert_Message, "POS is already deleted!" );
                        gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr];
                        gFL_InsInvalidCtr++;
                        gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr+ 1];
                        gFL_InsInvalidCtr++;
                        InsFlg = 0x01;
                        break;
                    }
                }  //update
                else   //INSERT
                {
                    if( gFavoriteList_Pos_insDel[FLlistCtr][1] == 0x01 )  //check if POS does not exist
                    {
                        gFavoriteList_Pos_insDel[FLlistCtr][1] = 0x00;
                        gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr];
                        gFL_InsValidCtr++;
                        gFavoriteList_Send[gFL_InsValidCtr][0] = pos[PosCtr+ 1];
                        gFL_InsValidCtr++;
                        result = 0x01;
                    }
                    else
                    {
                        putValue( env_AudioSD_FL_Insert_Message, "POS still exists!" );
                        gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr];
                        gFL_InsInvalidCtr++;
                        gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr+ 1];
                        gFL_InsInvalidCtr++;
                        InsFlg = 0x01;
                        break;
                    }
                }
            }
        }
        if( result == 0x00 && InsFlg == 0x00 )
        {
            gFL_InvalidIns[gFL_InsInvalidCtr] =pos[PosCtr];
            gFL_InsInvalidCtr++;
            gFL_InvalidIns[gFL_InsInvalidCtr] = pos[PosCtr+ 1];
            gFL_InsInvalidCtr++;
            putValue( env_AudioSD_FL_Insert_Message, "INVALID POS!" );
        }
    }
    if( gFL_InsInvalidCtr!= 0 )
        putValue( env_AudioSD_FL_Insert_Invalid, gFL_InvalidIns );
}

byte flPosSequence_check ( byte Index, byte inputArray[],word inputCtr )
{
    byte posInBetween;
    word ctr, ctr1, ctr2,PosVal1_,PosVal2_;

    posInBetween = 0;

    for( ctr = 0; ctr < inputCtr; ctr++ )
    {
        // adjust for 8bit and 16bit handling
        if( Index== 0x00 )
        {
            PosVal1_ = inputArray[ctr];
            PosVal2_ = inputArray[ctr+ 1];
        }
        else
        {
            PosVal1_ = 0x0000;
            PosVal1_ = inputArray[(2*ctr )+ 1];
            PosVal1_ = PosVal1_|(( inputArray[(2*ctr )+0] )<<8 );
            PosVal2_ = 0x0000;
            PosVal2_ = inputArray[(2*ctr )+2+ 1];
            PosVal2_ = PosVal2_|(( inputArray[(2*ctr )+2+0] )<<8 );
        }
        // search send item in insdel array
        for( ctr1 = 0; ctr1 < gFL_CSVtotalElem; ctr1++ )
        {
            if( PosVal1_ == gFavoriteList_Pos_insDel[ctr1][0] ) // 1st send item is found in array
            {
                break;
            }
        }
        // search insdel array for next send item
        for( ctr2 = ctr1+ 1; ctr2 < gFL_CSVtotalElem; ctr2++ ) // loop from 1st inserted item in insdel array
        {
            if( PosVal2_ == gFavoriteList_Pos_insDel[ctr2][0] ) // 2nd send item immediately next to 1st send item
            {
                break;
            }
            else
            {
                if( gFavoriteList_Pos_insDel[ctr2][1] == 0 && PosVal2_ != 0 )    // in between item is not deleted
                {
                    posInBetween = 0x01;
                    break;
                }
            }
        }
        if( posInBetween == 0x01 )
        {
            break;
        }
    }
    return posInBetween;
}

//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_FL_insert_POS_8
{
    byte INS_POS_8[AUDIO_FAVORITELIST_ENTRIES];
    int inputCtr,i,j;
    byte valid_INS_POS_8;
    byte validInputFlg_start, validInputFlg_succ;

    putvalue ( env_AudioSD_FL_Insert_Message, empty_string );
    //if( getValue( env_AudioSD_FL_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_FL_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_FL_insert_ErrHandler )== 0x01 )
    {
        getValue( this, INS_POS_8 );
        validInputFlg_start = 0;
        validInputFlg_succ = 0;
        inputCtr =  getValueSize( env_AudioSD_FL_insert_POS_8 );
        if( inputCtr > 0 )
        {
            //look for the valid reference for Start and successor
            for( j = 0; j < inputCtr; j++ )
            {
                valid_INS_POS_8 = INS_POS_8[j];
                for( i = 0; i < gFL_CSVtotalElem; i++ )
                {
                //check if input is valid and deleted
                    if( valid_INS_POS_8 == gFavoriteList_Pos_insDel[i][0] && gFavoriteList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_start = 1;
                        break;
                    }
                }
                if( validInputFlg_start == 0x01 )
                break;
            }
            if( validInputFlg_start == 0x01 )
            {
                //start
                if( valid_INS_POS_8== gFavoriteList_Pos_insDel[0][0] )
                    putValue( env_AudioSD_FL_insert_start, 0 );
                else
                {
                    ///look for the next existing element upwards
                    for( i = 0; i < gFL_CSVtotalElem; i++ )
                    {
                        if( valid_INS_POS_8== gFavoriteList_Pos_insDel[i][0] )
                        {
                            for( j = i-1; j>= 0; j--)
                            {
                                if( gFavoriteList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_FL_insert_start, gFavoriteList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            } //validInputFlg
            //successor
            //look for the valid reference for Start and successor
            for( j = inputCtr-1; j>= 0; j--)
            {
                valid_INS_POS_8 = INS_POS_8[j];
                for( i = 0; i < gFL_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( valid_INS_POS_8 == gFavoriteList_Pos_insDel[i][0] && gFavoriteList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_succ = 1;
                        break;
                    }
                }
                if( validInputFlg_succ == 0x01 )
                break;
            }
            if( validInputFlg_succ == 0x01 )
            {
                putValue( env_AudioSD_FL_insert_successor, 0 );
                for( i = 0; i < gFL_CSVtotalElem; i++ )
                {
                    if( valid_INS_POS_8== gFavoriteList_Pos_insDel[i][0] )
                    {
                        if( i == gFL_CSVtotalElem-1 )
                            putValue( env_AudioSD_FL_insert_successor, 0 );
                        else
                        {
                            //look for the next existing element downwards
                            for( j = i + 1; j < gFL_CSVtotalElem; j++ )
                            {
                                if( gFavoriteList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_FL_insert_successor, gFavoriteList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_FL_insert_POS_16
{
    byte INS_POS_16[AUDIO_FAVORITELIST_ENTRIES];
    int  inputCtr,i,j;
    word PosVal_16_first,PosVal_16_last;
    byte validInputFlg_start, validInputFlg_succ;

    inputCtr = 0;
    PosVal_16_first = 0;
    PosVal_16_last = 0;
    validInputFlg_start = 0;
    validInputFlg_succ = 0;

    putvalue ( env_AudioSD_FL_Insert_Message, empty_string );
    //if( getValue( env_AudioSD_FL_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_FL_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_FL_insert_ErrHandler )== 0x01 )
    {
        getValue( this, INS_POS_16 );
        inputCtr =  getValueSize( env_AudioSD_FL_insert_POS_16 );
        if( inputCtr > 1 )
        {
            //look for the valid reference for Start and successor
            for( j = 0; j < inputCtr; j++ )
            {
                //valid_INS_POS_8 = INS_POS_8[j];
                PosVal_16_first = INS_POS_16[j] << 8;
                PosVal_16_first = PosVal_16_first | INS_POS_16[j+ 1];
                for( i = 0; i < gFL_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( PosVal_16_first == gFavoriteList_Pos_insDel[i][0] && gFavoriteList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_start = 1;
                        break;
                    }
                }
                if( validInputFlg_start == 0x01 )
                break;
            }
            if( validInputFlg_start == 0x01 )
            {
                //start
                if( PosVal_16_first == gFavoriteList_Pos_insDel[0][0] )
                    putValue( env_AudioSD_FL_insert_start, 0 );
                else
                {
                    ///look for the next existing element upwards
                    for( i = 2; i < gFL_CSVtotalElem; i++ )
                    {
                        if( PosVal_16_first == gFavoriteList_Pos_insDel[i][0] )
                        {
                            for( j = i-1; j> 0; j--)
                            {
                                if( gFavoriteList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_FL_insert_start, gFavoriteList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            //successor
            for( j = inputCtr; j> 0; j--)
            {
                PosVal_16_last = INS_POS_16[j-1] << 8;
                PosVal_16_last = PosVal_16_last | INS_POS_16[j];
                for( i = 0; i < gFL_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( PosVal_16_last == gFavoriteList_Pos_insDel[i][0] && gFavoriteList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_succ = 1;
                        break;
                    }
                }
                if( validInputFlg_succ == 0x01 )
                break;
            }
            if( validInputFlg_succ == 0x01 )
            {
                putValue( env_AudioSD_FL_insert_successor, 0 );
                for( i = 0; i < gFL_CSVtotalElem; i++ )
                {
                    if( PosVal_16_last == gFavoriteList_Pos_insDel[i][0] )
                    {
                        if( i == gFL_CSVtotalElem-1 )
                            putValue( env_AudioSD_FL_insert_successor, 0 );
                        else
                        {
                            //look for the next existing element downwards
                            for( j = i + 1; j < gFL_CSVtotalElem; j++ )
                            {
                                if( gFavoriteList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_FL_insert_successor, gFavoriteList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            } //validInputFlg_succ
        }//inputCtr
    }
}
//IssueList #76 - MR49870 : SiriusAlertList
on envVar env_AudioSD_SAL_delete_POS_8
{
byte DEL_POS_8[AUDIO_SIRIUSALERTLIST_ENTRIES];

putValue( env_AudioSD_SAL_delete_Message, empty_string );

    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_SAL_delete_ErrHandler )== 0x01 )
    {
    getValue( this, DEL_POS_8 );
    putValue( env_AudioSD_SAL_delete_start, DEL_POS_8[0] );
    }

}

//IssueList #76 - MR49870 : SiriusAlertList
on envVar env_AudioSD_SAL_delete_POS_16
{
    byte DEL_POS_16[AUDIO_SIRIUSALERTLIST_ENTRIES];
    word PosVal_16;

    putValue( env_AudioSD_SAL_delete_Message, empty_string );


    //AUTOMATIC START VALUE
    if( getValue( env_AudioSD_SAL_delete_ErrHandler )== 0x01 )
    {
        getValue( this, DEL_POS_16 );
        PosVal_16 = DEL_POS_16[0] << 8;
        PosVal_16 = PosVal_16|DEL_POS_16[1];

        putValue( env_AudioSD_SAL_delete_start, PosVal_16 );
    }

}

//IssueList #76 - MR49870 : SiriusAlertList
on envVar env_AudioSD_SAL_delete_ErrHandler
{
    if( getValue( this )== 0x00 )
        putValue( env_AudioSD_SAL_TotalNumLE, gSiriusAlertList_TotalNumListElements );
}

//IssueList #76 - MR49870 : SiriusAlertList
on envVar env_AudioSD_SAL_insert_ErrHandler
{
    if( getValue( this )== 0x00 )
        putValue( env_AudioSD_SAL_TotalNumLE, gSiriusAlertList_TotalNumListElements );
}

//IssueList #76 - MR49870 : SiriusAlertList
SiriusAlertList_delete_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word SALlistCtr, PosCtr;

    result = 0x01;
    delFlg= 0;
    gSAL_DelInvalidCtr = 0;
    gSAL_DelValidCtr = 0;
    putValue( env_AudioSD_SAL_delete_Message, empty_string );


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {

         result = 0x00;
         delFlg = 0x00;

      for( SALlistCtr = 0; SALlistCtr < gSAL_CSVtotalElem; SALlistCtr++ )
      {

           if( pos[PosCtr] == gSiriusAlertList_Pos_insDel[SALlistCtr][0] )   //check if POS is valid
           {
             if( gSiriusAlertList_Pos_insDel[SALlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gSiriusAlertList_Pos_insDel[SALlistCtr][1] = 0x01;    //tagging deleted Pos
               gSiriusAlertList_Send[gSAL_DelValidCtr][0] = pos[PosCtr];
               gSiriusAlertList_Send[gSAL_DelValidCtr][1] = gSiriusAlertList_Pos_insDel[SALlistCtr][2];

               gSAL_DelValidCtr++;
               gSAL_totalDELctr++;
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_SAL_delete_Message, "POS already deleted!" );
              gSAL_InvalidDel[gSAL_DelInvalidCtr] = pos[PosCtr];
              gSAL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
           {
           gSAL_InvalidDel[gSAL_DelInvalidCtr] =pos[PosCtr];
            gSAL_DelInvalidCtr++;
             putValue( env_AudioSD_SAL_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : SiriusAlertList
SiriusAlertList_delete_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result, delFlg;
    word SALlistCtr, PosCtr,PosVal;

    result = 0x01;
    delFlg= 0;
    gSAL_DelInvalidCtr = 0;
    gSAL_DelValidCtr = 0;
    putValue( env_AudioSD_SAL_delete_Message, empty_string );
    PosVal = 0;

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {

         result = 0x00;
         delFlg = 0x00;
         PosVal = pos[PosCtr] << 8;
         PosVal = PosVal|pos[PosCtr+ 1];


      for( SALlistCtr = 0; SALlistCtr < gSAL_CSVtotalElem; SALlistCtr++ )
      {
           if( PosVal== gSiriusAlertList_Pos_insDel[SALlistCtr][0] )   //check if POS is valid
           {

             if( gSiriusAlertList_Pos_insDel[SALlistCtr][1]!= 0x01 )  //check if POS still exists
               {
               gSiriusAlertList_Pos_insDel[SALlistCtr][1] = 0x01;    //tagging deleted Pos
               gSiriusAlertList_Send[gSAL_DelValidCtr][0] = pos[PosCtr];
               gSAL_DelValidCtr++;
               gSiriusAlertList_Send[gSAL_DelValidCtr][0] = pos[PosCtr+ 1];
               gSAL_DelValidCtr++;
               gSAL_totalDELctr++;
                gSiriusAlertList_Send[gSAL_DelValidCtr][1] = gSiriusAlertList_Pos_insDel[SALlistCtr][2];
               result = 0x01;
               }
              else
              {
              putValue( env_AudioSD_SAL_delete_Message, "POS already deleted!" );
              gSAL_InvalidDel[gSAL_DelInvalidCtr] = pos[PosCtr];
              gSAL_DelInvalidCtr++;
              gSAL_InvalidDel[gSAL_DelInvalidCtr] = pos[PosCtr+ 1];
              gSAL_DelInvalidCtr++;
              delFlg = 0x01;
              break;
              }

           }//if

       }//for
        if( result == 0x00 && delFlg == 0x00 )
        {

            gSAL_InvalidDel[gSAL_DelInvalidCtr] = pos[PosCtr];
            gSAL_DelInvalidCtr++;
            gSAL_InvalidDel[gSAL_DelInvalidCtr] = pos[PosCtr+ 1];
            gSAL_DelInvalidCtr++;
             putValue( env_AudioSD_SAL_delete_Message, "INVALID POS!" );
            }

     }
}

//IssueList #76 - MR49870 : SiriusAlertList
void SiriusAlertList_insert_ErrHandler_8 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word SALlistCtr, PosCtr;

    result = 0x01;
    InsFlg= 0;


    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr++ )
    {
         result = 0x00;
         InsFlg = 0x00;

      for( SALlistCtr = 0; SALlistCtr < gSAL_CSVtotalElem; SALlistCtr++ )
      {
           if( pos[PosCtr] == gSiriusAlertList_Pos_insDel[SALlistCtr][0] )   //check if POS is valid
           {
            //UPDATE
                if  ( getValue( env_AudioSD_SAL_insert_UPD_button ) == 0x01 )
                 {
                        if( gSiriusAlertList_Pos_insDel[SALlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                        {
                        result = 0x01;
                        gSiriusAlertList_Send[gSAL_InsValidCtr][0] = pos[PosCtr];
                        gSAL_InsValidCtr++;
                        }

                        else
                          {
                          putValue( env_AudioSD_SAL_Insert_Message, "POS is already deleted!" );
                          gSAL_InvalidIns[gSAL_InsInvalidCtr] = pos[PosCtr];
                          gSAL_InsInvalidCtr++;
                          InsFlg = 0x01;
                          break;
                          }

                }  //update

                 else   //INSERT
                 {
                     if( gSiriusAlertList_Pos_insDel[SALlistCtr][1] == 0x01 )  //check if POS does not exist
                       {
                       gSiriusAlertList_Pos_insDel[SALlistCtr][1] = 0x00;
                       gSiriusAlertList_Send[gSAL_InsValidCtr][0] = pos[PosCtr];
                       gSiriusAlertList_Send[gSAL_InsValidCtr][1] = gSiriusAlertList_Pos_insDel[SALlistCtr][2];

                       gSAL_InsValidCtr++;
                       result = 0x01;
                       }
                      else
                      {
                      putValue( env_AudioSD_SAL_Insert_Message, "POS still exists!" );
                      gSAL_InvalidIns[gSAL_InsInvalidCtr] = pos[PosCtr];
                      gSAL_InsInvalidCtr++;
                      InsFlg = 0x01;
                      break;
                      }
               }//if
            } //else
       }//for
        if( result == 0x00 && InsFlg == 0x00 )
           {
           gSAL_InvalidIns[gSAL_InsInvalidCtr] =pos[PosCtr];
            gSAL_InsInvalidCtr++;
             putValue( env_AudioSD_SAL_Insert_Message, "INVALID POS!" );
            }
     }//for MBlistCtr

     if( gSAL_InsInvalidCtr!= 0 )
            putValue( env_AudioSD_SAL_Insert_Invalid, gSAL_InvalidIns );
}

void SiriusAlertList_insert_ErrHandler_16 ( byte pos[],word elementsCtr )
{
    byte i, result,InsFlg;
    word PosVal,SALlistCtr, PosCtr;

    result = 0x01;
    InsFlg= 0;
    PosVal = 0;

    for( PosCtr = 0; PosCtr < elementsCtr; PosCtr = PosCtr+2 )
    {
        result = 0x00;
        InsFlg = 0x00;
        PosVal = pos[PosCtr] << 8;
        PosVal = PosVal|pos[PosCtr+ 1];
        for( SALlistCtr = 0; SALlistCtr < gSAL_CSVtotalElem; SALlistCtr++ )
        {
            if( PosVal== gSiriusAlertList_Pos_insDel[SALlistCtr][0] )   //check if POS is valid
            {
                //UPDATE
                if  ( getValue( env_AudioSD_SAL_insert_UPD_button ) == 0x01 )
                {
                    if( gSiriusAlertList_Pos_insDel[SALlistCtr][1] == 0x00 )  //check if POS is not deleted            {
                    {
                        result = 0x01;
                        gSiriusAlertList_Send[gSAL_InsValidCtr][0] = pos[PosCtr];
                        gSAL_InsValidCtr++;
                        gSiriusAlertList_Send[gSAL_InsValidCtr][0] = pos[PosCtr+ 1];
                        gSAL_InsValidCtr++;
                    }
                    else
                    {
                        putValue( env_AudioSD_SAL_Insert_Message, "POS is already deleted!" );
                        gSAL_InvalidIns[gSAL_InsInvalidCtr] = pos[PosCtr];
                        gSAL_InsInvalidCtr++;
                        gSAL_InvalidIns[gSAL_InsInvalidCtr] = pos[PosCtr+ 1];
                        gSAL_InsInvalidCtr++;
                        InsFlg = 0x01;
                        break;
                    }
                }  //update
                else   //INSERT
                {
                    if( gSiriusAlertList_Pos_insDel[SALlistCtr][1] == 0x01 )  //check if POS does not exist
                    {
                        gSiriusAlertList_Pos_insDel[SALlistCtr][1] = 0x00;
                        gSiriusAlertList_Send[gSAL_InsValidCtr][0] = pos[PosCtr];
                        gSAL_InsValidCtr++;
                        gSiriusAlertList_Send[gSAL_InsValidCtr][0] = pos[PosCtr+ 1];
                        gSAL_InsValidCtr++;
                        result = 0x01;
                    }
                    else
                    {
                        putValue( env_AudioSD_SAL_Insert_Message, "POS still exists!" );
                        gSAL_InvalidIns[gSAL_InsInvalidCtr] = pos[PosCtr];
                        gSAL_InsInvalidCtr++;
                        gSAL_InvalidIns[gSAL_InsInvalidCtr] = pos[PosCtr+ 1];
                        gSAL_InsInvalidCtr++;
                        InsFlg = 0x01;
                        break;
                    }
                }
            }
        }
        if( result == 0x00 && InsFlg == 0x00 )
        {
            gSAL_InvalidIns[gSAL_InsInvalidCtr] =pos[PosCtr];
            gSAL_InsInvalidCtr++;
            gSAL_InvalidIns[gSAL_InsInvalidCtr] = pos[PosCtr+ 1];
            gSAL_InsInvalidCtr++;
            putValue( env_AudioSD_SAL_Insert_Message, "INVALID POS!" );
        }
    }
    if( gSAL_InsInvalidCtr!= 0 )
        putValue( env_AudioSD_SAL_Insert_Invalid, gSAL_InvalidIns );
}

byte salPosSequence_check ( byte Index, byte inputArray[],word inputCtr )
{
    byte posInBetween;
    word ctr, ctr1, ctr2,PosVal1_,PosVal2_;

    posInBetween = 0;

    for( ctr = 0; ctr < inputCtr; ctr++ )
    {
        // adjust for 8bit and 16bit handling
        if( Index== 0x00 )
        {
            PosVal1_ = inputArray[ctr];
            PosVal2_ = inputArray[ctr+ 1];
        }
        else
        {
            PosVal1_ = 0x0000;
            PosVal1_ = inputArray[(2*ctr )+ 1];
            PosVal1_ = PosVal1_|(( inputArray[(2*ctr )+0] )<<8 );
            PosVal2_ = 0x0000;
            PosVal2_ = inputArray[(2*ctr )+2+ 1];
            PosVal2_ = PosVal2_|(( inputArray[(2*ctr )+2+0] )<<8 );
        }
        // search send item in insdel array
        for( ctr1 = 0; ctr1 < gSAL_CSVtotalElem; ctr1++ )
        {
            if( PosVal1_ == gSiriusAlertList_Pos_insDel[ctr1][0] ) // 1st send item is found in array
            {
                break;
            }
        }
        // search insdel array for next send item
        for( ctr2 = ctr1+ 1; ctr2 < gSAL_CSVtotalElem; ctr2++ ) // loop from 1st inserted item in insdel array
        {
            if( PosVal2_ == gSiriusAlertList_Pos_insDel[ctr2][0] ) // 2nd send item immediately next to 1st send item
            {
                break;
            }
            else
            {
                if( gSiriusAlertList_Pos_insDel[ctr2][1] == 0 && PosVal2_ != 0 )    // in between item is not deleted
                {
                    posInBetween = 0x01;
                    break;
                }
            }
        }
        if( posInBetween == 0x01 )
        {
            break;
        }
    }
    return posInBetween;
}

//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_SAL_insert_POS_8
{
    byte INS_POS_8[AUDIO_SIRIUSALERTLIST_ENTRIES];
    int inputCtr,i,j;
    byte valid_INS_POS_8;
    byte validInputFlg_start, validInputFlg_succ;

    putvalue ( env_AudioSD_SAL_Insert_Message, empty_string );
    //if( getValue( env_AudioSD_SAL_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_SAL_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_SAL_insert_ErrHandler )== 0x01 )
    {
        getValue( this, INS_POS_8 );
        validInputFlg_start = 0;
        validInputFlg_succ = 0;
        inputCtr =  getValueSize( env_AudioSD_SAL_insert_POS_8 );
        if( inputCtr > 0 )
        {
            //look for the valid reference for Start and successor
            for( j = 0; j < inputCtr; j++ )
            {
                valid_INS_POS_8 = INS_POS_8[j];
                for( i = 0; i < gSAL_CSVtotalElem; i++ )
                {
                //check if input is valid and deleted
                    if( valid_INS_POS_8 == gSiriusAlertList_Pos_insDel[i][0] && gSiriusAlertList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_start = 1;
                        break;
                    }
                }
                if( validInputFlg_start == 0x01 )
                break;
            }
            if( validInputFlg_start == 0x01 )
            {
                //start
                if( valid_INS_POS_8== gSiriusAlertList_Pos_insDel[0][0] )
                    putValue( env_AudioSD_SAL_insert_start, 0 );
                else
                {
                    ///look for the next existing element upwards
                    for( i = 0; i < gSAL_CSVtotalElem; i++ )
                    {
                        if( valid_INS_POS_8== gSiriusAlertList_Pos_insDel[i][0] )
                        {
                            for( j = i-1; j>= 0; j--)
                            {
                                if( gSiriusAlertList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_SAL_insert_start, gSiriusAlertList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            } //validInputFlg
            //successor
            //look for the valid reference for Start and successor
            for( j = inputCtr-1; j>= 0; j--)
            {
                valid_INS_POS_8 = INS_POS_8[j];
                for( i = 0; i < gSAL_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( valid_INS_POS_8 == gSiriusAlertList_Pos_insDel[i][0] && gSiriusAlertList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_succ = 1;
                        break;
                    }
                }
                if( validInputFlg_succ == 0x01 )
                break;
            }
            if( validInputFlg_succ == 0x01 )
            {
                putValue( env_AudioSD_SAL_insert_successor, 0 );
                for( i = 0; i < gSAL_CSVtotalElem; i++ )
                {
                    if( valid_INS_POS_8== gSiriusAlertList_Pos_insDel[i][0] )
                    {
                        if( i == gSAL_CSVtotalElem-1 )
                            putValue( env_AudioSD_SAL_insert_successor, 0 );
                        else
                        {
                            //look for the next existing element downwards
                            for( j = i + 1; j < gSAL_CSVtotalElem; j++ )
                            {
                                if( gSiriusAlertList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_SAL_insert_successor, gSiriusAlertList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

//Automatic START AND SUCCESSOR VALUES
on envVar env_AudioSD_SAL_insert_POS_16
{
    byte INS_POS_16[AUDIO_SIRIUSALERTLIST_ENTRIES];
    int  inputCtr,i,j;
    word PosVal_16_first,PosVal_16_last;
    byte validInputFlg_start, validInputFlg_succ;

    inputCtr = 0;
    PosVal_16_first = 0;
    PosVal_16_last = 0;
    validInputFlg_start = 0;
    validInputFlg_succ = 0;

    putvalue ( env_AudioSD_SAL_Insert_Message, empty_string );
    //if( getValue( env_AudioSD_SAL_insert_ErrHandler )== 0x01 && getValue( env_AudioSD_SAL_insert_UPD_button )== 0x00 )
    if( getValue( env_AudioSD_SAL_insert_ErrHandler )== 0x01 )
    {
        getValue( this, INS_POS_16 );
        inputCtr =  getValueSize( env_AudioSD_SAL_insert_POS_16 );
        if( inputCtr > 1 )
        {
            //look for the valid reference for Start and successor
            for( j = 0; j < inputCtr; j++ )
            {
                //valid_INS_POS_8 = INS_POS_8[j];
                PosVal_16_first = INS_POS_16[j] << 8;
                PosVal_16_first = PosVal_16_first | INS_POS_16[j+ 1];
                for( i = 0; i < gSAL_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( PosVal_16_first == gSiriusAlertList_Pos_insDel[i][0] && gSiriusAlertList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_start = 1;
                        break;
                    }
                }
                if( validInputFlg_start == 0x01 )
                break;
            }
            if( validInputFlg_start == 0x01 )
            {
                //start
                if( PosVal_16_first == gSiriusAlertList_Pos_insDel[0][0] )
                    putValue( env_AudioSD_SAL_insert_start, 0 );
                else
                {
                    ///look for the next existing element upwards
                    for( i = 2; i < gSAL_CSVtotalElem; i++ )
                    {
                        if( PosVal_16_first == gSiriusAlertList_Pos_insDel[i][0] )
                        {
                            for( j = i-1; j> 0; j--)
                            {
                                if( gSiriusAlertList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_SAL_insert_start, gSiriusAlertList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            //successor
            for( j = inputCtr; j> 0; j--)
            {
                PosVal_16_last = INS_POS_16[j-1] << 8;
                PosVal_16_last = PosVal_16_last | INS_POS_16[j];
                for( i = 0; i < gSAL_CSVtotalElem; i++ )
                {
                    //check if input is valid and deleted
                    if( PosVal_16_last == gSiriusAlertList_Pos_insDel[i][0] && gSiriusAlertList_Pos_insDel[i][1] == 0x01 )
                    {
                        validInputFlg_succ = 1;
                        break;
                    }
                }
                if( validInputFlg_succ == 0x01 )
                break;
            }
            if( validInputFlg_succ == 0x01 )
            {
                putValue( env_AudioSD_SAL_insert_successor, 0 );
                for( i = 0; i < gSAL_CSVtotalElem; i++ )
                {
                    if( PosVal_16_last == gSiriusAlertList_Pos_insDel[i][0] )
                    {
                        if( i == gSAL_CSVtotalElem-1 )
                            putValue( env_AudioSD_SAL_insert_successor, 0 );
                        else
                        {
                            //look for the next existing element downwards
                            for( j = i + 1; j < gSAL_CSVtotalElem; j++ )
                            {
                                if( gSiriusAlertList_Pos_insDel[j][1]!= 0x01 )
                                {
                                    putValue( env_AudioSD_SAL_insert_successor, gSiriusAlertList_Pos_insDel[j][0] );
                                    break;
                                }
                            }
                        }
                    }
                }
            } //validInputFlg_succ
        }//inputCtr
    }
}
