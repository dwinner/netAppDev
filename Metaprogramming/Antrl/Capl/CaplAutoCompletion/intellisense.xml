<?xml version='1.0' encoding='UTF-8' standalone='no'?>

<root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:noNamespaceSchemaLocation="intellisense.xsd"
      version="1.0.0"
      xml:lang="en-US">
    <class name="Message">
        <field name="ID" type="dword">Message identifier</field>
        <field name="CAN" type="byte">Transmission channel or channel through which the frame has been received. Value range: 1..32</field>
        <field name="DLC" type="byte">The data field length of a message is coded with the DLC (Data Length Code). Value range: 0..15(Data field length: CAN messages: 0..8, CAN FD messages: 0..64, J1939 parameter groups: 0..1785)</field>
        <field name="DIR" type="byte">Direction of transmission, event classification; possible values: Rx, Tx, TXREQUEST</field>
        <field name="RTR" type="bool">Remote Transmission Request; possible values: 0 (no RTR), 1 (RTR)</field>
        <field name="TYPE" type="long">Combination of DIR and RTR for an efficient evaluation.</field>
        <field name="MsgChanel" type="word">Transmission channel or channel through which the frame has been received. Value range: 1..32</field>
        <field name="TIME" type="qword">Point in time, units: 10 microseconds. This selector is not available when executing CAPL code directly on hardware interfaces. Therefore you must use Time_ns</field>
        <field name="Time_NS" type="qword">Point in time, units: nanoseconds</field>
        <field name="SIMULATED" type="bool">Point in time, units: nanoseconds</field>
        <indexer name="byte" desc="Message data byte (unsigned 8 bit)" writeable="yes">
            <param name="i" type="byte">0…63</param>
            <return type="byte" />
        </indexer>
        <indexer name="word" desc="Message data word (unsigned 16 bit)" writeable="yes">
            <param name="i" type="byte">0…62. The index is byte-oriented; for example, word(1) references to the data beginning at byte 1 and consists of byte 1…2 (16 bit)</param>
            <return type="word" />
        </indexer>
        <indexer name="dword" desc="Message data word (unsigned 32 bit)" writeable="yes">
            <param name="i" type="byte">0…60. The index is byte-oriented; for example, dword(1) references to the data beginning at byte 1 and consists of byte 1…4 (32 bit)</param>
            <return type="dword" />
        </indexer>
        <indexer name="qword" desc="Message data word (unsigned 64 bit)" writeable="yes">
            <param name="i" type="byte">0…56</param>
            <return type="qword" />
        </indexer>
        <indexer name="char" desc="Message data byte (signed 8 bit)" writeable="yes">
            <param name="i" type="byte">0…63</param>
            <return type="char" />
        </indexer>
        <indexer name="short" desc="" writeable="yes">
            <param name="i" type="byte"></param>
            <return type="short" />
        </indexer>
        <indexer name="long" desc="Message data word (signed 32 bit)" writeable="yes">
            <param name="i" type="byte">0…60. The index is byte-oriented; for example, long(1) references to the data beginning at byte 1 and consists of byte 1…4 (32 bit)</param>
            <return type="long" />
        </indexer>
        <field name="BRS" type="bool">Bit Rate Switch. Only for CAN FD messages. 0: Use arbitration bit rate for data segment; 1: use data bit rate for data segment</field>
        <field name="EDL" type="bool">Bit Rate Switch. Only for CAN FD messages. 0: Use arbitration bit rate for data segment; 1: use data bit rate for data segment</field>
        <field name="FDF" type="bool">FD Format Indicator: 0 = Classic CAN message; 1 = CAN FD message</field>
        <method name="SetSignalStartValues"
                desc="Sets the values of the signals in the parameter to the start values defined in the database">
            <param name="msg" type="IMessage">Objects where the signals shall be set</param>
            <return type="long">
                0: function was successful\n
                1: message / frame / PDU / paramGroup wasn't found in the database\n
                2: at least one signal start value didn't fit into the signal in the message
            </return>
        </method>
        <field name="Name[]" type="char">Symbolic Name of the PDU Read only</field>
        <field name="BusType" desc="Returns the bus type to which the channel belongs" type="dword">1|cCAN  2|cJ1939  4|cTTP  5|cLIN  6|cMOST</field>
        <field name="MaxDLC" type="dword"></field>
        <field name="UpdateBit" type="char"></field>
        <field name="Payload[]" type="byte"></field>
        <field name="ValidationFlags" type="byte"></field>
        <field name="IsContained" type="bool"></field>
        <field name="AutosarPDUType" type="byte"></field>
        <field name="IsSecured" type="byte"></field>
        <field name="bitcount" type="dword">Number of bits in the signal</field>
    </class>
    <class name="ILinWakeupFrame">
        <field name="Time" type="Qword">Time stamp synchronized with the global time base on the PC (CAN hardware or PC system clock). Unit: 10µs</field>
        <field name="Time_NS" type="qword">Time stamp synchronized with the global time base on the PC (CAN hardware or PC system clock). Unit: nanoseconds</field>
        <field name="MsgOrigTime" type="dword">Time stamp generated by the LIN hardware. This time stamp is unsynchronized with the global time base on the PC and thus still original. It can be used to compare the time of two LIN hardware generated events. Unit: 10µs</field>
        <field name="MsgTimeStampStatus" type="byte">Status of MsgOrigTime: Bit 0 set - Time stamp is valid; Bit 0 not set - Time stamp is invalid; Bit 1 set - Time stamp was generated by software; Bit 1 not set - Time stamp was generated by hardware; Bit 4 - Has a bus-specific meaning; not currently in use for LIN</field>
        <field name="MsgChannel" type="word">Channel through which the event was received. Value range: 1..32</field>
        <field name="lin_Signal" type="byte">Signal actually received. Because of different baud rates of transmitter and receiver in Sleep state, this signal can take on the legal values 0x00, 0x80 (signal actually transmitted) and 0xC0</field>
        <field name="lin_External" type="byte">indicates whether the wake-up signal was received by an external device (selector set) or transmitted by the LIN hardware itself (selector not set)</field>
        <field name="length_ns" type="qword">Length of the wake-up signal in ns</field>
        <field name="SOF" type="qword">Start of wake-up signal time stamp in ns</field>
        <!-- attributes -->
    </class>
    <class name="PhysRawValue">
        <field name="ValuePhys" type="double">Double representation of value</field>
        <field name="ValueHex" type="qword">Hex representation of value</field>
    </class>
    <class name="Signal" base="IPhysRawValue">
        <!-- attributes -->
    </class>
    <class name="SignalVal" base="IPhysRawValue">
        <field name="rx" type="IPhysRawValue" />
        <field name="txrq" type="IPhysRawValue" />
    </class>
    <class name="ValueTable">
    </class>
    <class name="Timer">
        <method name="set" decs="Sets a timer">
            <param name="time" type="long"></param>
            <return type="void"></return>
        </method>
        <method name="cancel" desc="Stops an active timer">
            <return type="void"></return>
        </method>
        <method name="timeToElapse"
                desc="Returns a value indicating how much more time will elapse before an on timer event procedure is called">
            <return type="long"></return>
        </method>
    </class>
    <class name="msTimer" base="Timer">
    </class>
    <class name="Start"> <!-- on ... -->
        <field name="time" type="dword">Get time</field>
    </class>
    <class name="PreStart"> <!-- on ... -->
        <field name="time" type="dword">Get time</field>
    </class>
    <class name="PreStop"> <!-- on ... -->
        <field name="time" type="dword">Get time</field>
    </class>
    <class name="Stop"> <!-- on ... -->
        <field name="time" type="dword">Get time</field>
    </class>
    <class name="Key"> <!-- on key ... -->
        <field name="Key" type="word" />
        <field name="Modifier" type="dword" />
    </class>
    <class name="ErrorFrame">  <!-- on ... -->
        <field name="time_ns" type="qword"></field>
        <field name="time" type="dword">Gets time</field>
        <field name="channel" type="byte">Gets channel</field>
    </class>
    <class name="EnvVar">
        <field name="type" type="int">Gets the Type of the current instance</field>
        <field name="time_ns" type="qword"></field>
        <field name="name[]" type="char"></field>
        <!-- attributes -->
    </class>
    <class name="DiagBase">
        <method name="Initialize"
                desc="Reinitializes the object for the given service or primitive. Diagnostics request will be initialized with the default request parameters of the service, while diagnostic responses will be initialized with the default parameters of the first or specified primitive of the service. If the service is not defined, or the primitive is not defined at the given service, nothing happens and an error code is returned">
            <param name="serviceQualifier[]" type="char">Qualifier of the service that should be used for reinterpretation</param>
            <return type="long">0: No error, OK. Less then 0: Error code</return>
        </method>
        <method name="Initialize"
                desc="Reinitializes the object for the given service or primitive. Diagnostics request will be initialized with the default request parameters of the service, while diagnostic responses will be initialized with the default parameters of the first or specified primitive of the service. If the service is not defined, or the primitive is not defined at the given service, nothing happens and an error code is returned">
            <param name="serviceQualifier[]" type="char">Qualifier of the service that should be used for reinterpretation</param>
            <param name="primitiveQualifier[]" type="char">Qualifier of the service primitive that should be used for reinterpretation</param>
            <return type="long">0: No error, OK. Less then 0: Error code</return>
        </method>
        <method name="SetParameter" desc="Sets the numeric parameter to the specified value">
            <param name="mode" type="long">Access mode</param>
            <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
            <param name="newValue" type="double">Numeric value to which the parameter should be set</param>
            <return type="long">Error code</return>
        </method>
        <method name="SetParameter"
                desc="Sets a parameter to the symbolically-specified value. This is possible for all parameters, also numeric ones">
            <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
            <param name="newValue" type="double">Numeric value to which the parameter should be set</param>
            <return type="long">Error code</return>
        </method>
        <method name="SetParameter"
                desc="Sets a parameter to the symbolically-specified value. This is possible for all parameters, also numeric ones">
            <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
            <param name="newValue[]" type="char">Symbolic value</param>
            <return type="long">Error code</return>
        </method>
        <method name="GetParameter"
                desc="Returns the value of the numeric parameter, either in an output field or as return value (without the possibility of checking the correct function)">
            <param name="parameterName[]" type="char"></param>
            <param name="Output" type="double">Parameter qualifier</param>
            <return type="long">Error code or value of the parameter or 0.0 if this could not be acquired</return>
        </method>
        <method name="GetParameter"
                desc="Returns the value of the numeric parameter, either in an output field or as return value (without the possibility of checking the correct function)">
            <param name="parameterName[]" type="char">Parameter qualifier</param>
            <return type="double">Error code or value of the parameter or 0.0 if this could not be acquired</return>
        </method>
        <method nmae="GetParameter"
                desc="Returns the value of the numeric parameter, either in an output field or as return value (without the possibility of checking the correct function)">
            <param name="mode" type="long">Access mode</param>
            <param name="parameterName[]" type="char">Parameter qualifier</param>
            <return type="double">Error code or value of the parameter or 0.0 if this could not be acquired</return>
        </method>
        <method neme="GetParameter"
                desc="Returns the symbolic value of the parameter. This functions for all parameters. The values received can be used for setting the parameter">
            <param name="parameterName[]" type="char">Parameter qualifier</param>
            <param name="buffer[]" type="char">Output field</param>
            <param name="buffersize" type="dword">Size of the buffer</param>
            <return type="long">Number of chars written to buffer or error code</return>
        </method>
        <method name="SetPrimitiveData"
                desc="Reads/sets the raw data of the complete service primitive (all data that is transmitted via the transport protocol). When setting the data the length of the primitive is not changed">
            <param name="buffer[]" type="byte">Input/output buffer</param>
            <param name="buffersize" type="dword">Buffer size</param>
            <return type="long">Number of bytes copied into the buffer or error code</return>
        </method>
        <method name="GetPrimitiveData"
                desc="Reads/sets the raw data of the complete service primitive (all data that is transmitted via the transport protocol). When setting the data the length of the primitive is not changed">
            <param name="buffer[]" type="byte">Input/output buffer</param>
            <param name="buffersize" type="dword">Buffer size</param>
            <return type="long">Number of bytes copied into the buffer or error code</return>
        </method>
        <method name="Resize"
                desc="Adapt size of a diagnostic object to match specified parameter iterations, or set size of bus message to given number of byte">
            <param name="byteCount" type="dword">Length of data to send</param>
            <return type="long">Error code</return>
        </method>
        <method name="GetPrimitiveSize" desc="Returns the byte length of the object">
            <return type="long">
                Above 0: Number of bytes,  Less then 0: Error code
            </return>
        </method>
        <method name="GetParameterRaw"
                desc="Sets or specifies the value of a (complex) parameter directly via uncoded data bytes">
            <param name="parameterName[]" type="const char">Parameter qualifier</param>
            <param name="buffer[]" type="byte">Input/output buffer</param>
            <param name="buffersize" type="dword">Buffer size</param>
            <return type="long">0 if bytes were copied, otherwise Less then 0 for an error code</return>
        </method>
        <method name="SetParameterRaw"
                desc="Sets or specifies the value of a (complex) parameter directly via uncoded data bytes">
            <param name="parameterName[]" type="char">Parameter qualifier</param>
            <param name="buffer[]" type="byte">Input/output buffer</param>
            <param name="buffersize" type="dword">Buffer size</param>
            <return type="long">
                0 if bytes were copied, otherwise less then 0 for an error code
            </return>
        </method>
    </class>
    <class name="DiagResponse" base="IDiagBase">
        <method name="SendResponse"
                desc="Sends the response object back to the tester. Can only be called in the ECU simulation">
            <return type="long">Error code</return>
        </method>
        <method name="IsNegativeResponse" desc="Returns value != 0 if the object is a negative response to a request">
            <return type="long">0 or !=0</return>
        </method>
        <method name="GetResponseCode"
                desc="Returns the code of the specified response or last received response (for the specified request)">
            <return type="long">
                -1: The response was positive, i.e. there is no error code
                0: No response has been received yet
                >0: Error code of the negative response
                Error code
            </return>
        </method>
        <method name="GetLastResponse"
                desc="Returns the code of the specified response or last received response (for the specified request)">
            <return type="long">
                -1: The response was positive, i.e. there is no error code
                0: No response has been received yet
                >0: Error code of the negative response
                Error code
            </return>
        </method>
        <method name="IsPositiveResponse"
                desc="Sends the response object back to the tester. Can only be called in the ECU simulation">
            <return type="long">Error code</return>
        </method>
    </class>
    <class name="DiagRequest" base="IDiagBase">
        <method name="SendRequest" desc="Sends the request object to the ECU">
            <return type="long">Error code</return>
        </method>
        <method name="WaitForDiagResponse" desc="Waits for the arrival of the response to the given request">
            <param name="timeout" type="dword">[ms] Maximum wait time</param>
            <return type="long">
                Less then 0: An internal error occurred, e.g. a protocol error or a faulty configuration of the diagnostic layer
                0: The timeout was reached, i.e. the event of interest did not occur within the specified time
                1: The event occurred
            </return>
        </method>
        <method name="GetLastResponseCode"
                desc="Returns the code of the specified response or last received response (for the specified request)">
            <return type="long">
                -1: The response was positive, i.e. there is no error code
                0: No response has been received yet
                >0: Error code of the negative response
                Error code
            </return>
        </method>
    </class>
    <class name="CanError">   <!-- on errorPassive ... -->
        <field name="ErrorCountRx" type="long" />
        <field name="ErrorCountTx" type="long" />
        <field name="channel" type="byte">Gets channel</field>
    </class>
    <class name="EthernetPacketProtocolField">
        <field name="bitLength" type="long" />
        <field name="bitOffset" type="long" />
        <field name="byteLength" type="long" />
        <field name="byteOffset" type="long" />
        <indexer name="byte"
                 desc="Message data byte (unsigned 8 bit); Offset 0 is the byte directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="byte" />
        </indexer>
        <indexer name="word"
                 desc=">Message data word (unsigned 16 bit); Offset 0 is the word directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="word" />
        </indexer>
        <indexer name="dword"
                 desc="Message data word (unsigned 32 bit); Offset 0 is the dword directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="dword" />
        </indexer>
        <indexer name="qword" desc="Message data qword (unsigned 64 bit)" writeable="yes">
            <param name="i" type="int"></param>
            <return type="qword" />
        </indexer>
        <indexer name="char" desc="Message data byte (signed 8 bit); Offset 0 is the byte directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="char" />
        </indexer>
        <indexer name="short" desc="" writeable="yes">
            <param name="i" type="int"></param>
            <return type="short" />
        </indexer>
        <indexer name="long" desc="Message data word (signed 32 bit)" writeable="yes">
            <param name="i" type="int"></param>
            <return type="long" />
        </indexer>
        <indexer name="longlong" desc="Message data (signed 64 bit)" writeable="yes">
            <param name="i" type="int"></param>
            <return type="long" />
        </indexer>
        <method name="SetData" desc="Sets payload data of a protocol within an Ethernet packet">
            <param name="offset" type="dword"></param>
            <param name="source[]" type="byte"></param>
            <param name="length" type="word"></param>
            <return type="dword" />
        </method>
        <method name="GetData" desc="Gets payload data of a protocol within an Ethernet packet">
            <param name="offset" type="dword"></param>
            <param name="source[]" type="byte"></param>
            <param name="length" type="word"></param>
            <return type="dword" />
        </method>
        <method name="IsAvailable" desc="Sets the protocol field, which has type IPv4 or IPv6 address.">
            <param name="addressAsString[]" type="char"></param>
            <return type="long" />
        </method>
    </class>
    <class name="EthernetPacketProtocol">
        <field name="byteLength" type="long"></field>
        <field name="byteOffset" type="long"></field>
        <field name="nextOffset" type="long"></field>
        <indexer name="byte"
                 desc="Message data byte (unsigned 8 bit); Offset 0 is the byte directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="byte" />
        </indexer>
        <indexer name="word"
                 desc=">Message data word (unsigned 16 bit); Offset 0 is the word directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="word" />
        </indexer>
        <indexer name="dword"
                 desc="Message data word (unsigned 32 bit); Offset 0 is the dword directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="dword" />
        </indexer>
        <indexer name="qword" desc="Message data qword (unsigned 64 bit)" writeable="yes">
            <param name="i" type="int"></param>
            <return type="qword" />
        </indexer>
        <indexer name="char" desc="Message data byte (signed 8 bit); Offset 0 is the byte directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="char" />
        </indexer>
        <indexer name="short" desc="" writeable="yes">
            <param name="i" type="int"></param>
            <return type="short" />
        </indexer>
        <indexer name="long" desc="Message data long word (signed 32 bit)" writeable="yes">
            <param name="i" type="int"></param>
            <return type="long" />
        </indexer>
        <indexer name="longlong" desc="Message data (signed 64 bit)" writeable="yes">
            <param name="i" type="int"></param>
            <return type="long" />
        </indexer>
        <method name="SetData" desc="Sets payload data of a protocol within an Ethernet packet">
            <param name="offset" type="dword"></param>
            <param name="source[]" type="byte"></param>
            <param name="length" type="word"></param>
            <return type="dword" />
        </method>
        <method name="GetData" desc="Gets payload data of a protocol within an Ethernet packet">
            <param name="offset" type="dword"></param>
            <param name="source[]" type="byte"></param>
            <param name="length" type="word"></param>
            <return type="dword" />
        </method>
        <method name="IsAvailable" desc="Sets the protocol field, which has type IPv4 or IPv6 address.">
            <param name="addressAsString[]" type="char"></param>
            <return type="long" />
        </method>
        <method name="ResizeData" desc="Resizes the payload of a protocol within an Ethernet packet.">
            <param name="newLength" type="word"></param>
            <return type="long" />
        </method>
        <method name="Init" desc="Initialize the protocol within an Ethernet packet">
            <return type="long" />
        </method>
        <method name="CompletePacket" desc="Initialize the protocol within an Ethernet packet">
            <return type="word" />
        </method>
    </class>
    <class name="IPv4" base="EthernetPacketProtocol">
        <field name="Version" type="byte">4-bit internet protocol version number = 4</field>
        <field name="ihl" type="byte">Internet header length This is the length of the IP header as a multiple of 4 bytes. It is necessary due to possible options</field>
        <field name="dscp" type="byte">The Differentiated Services Code Point value (DSCP) sets the priority of the packet. The first three bits specify the Class Selector, the next three bits specify the Drop-Precedence</field>
        <field name="ecn" type="byte">If there is an overload possible the router can signal this with the Explicit Congestion Notification (ECN). 00: The sending host does not support ECN.  01 or 10: The sending host supports ECN.  11: A router is busy</field>
        <field name="length" type="Word">Total length of a single IP datagram in bytes (IP header plus payload)</field>
        <field name="identification" type="word">Identification of a datagram. If a datagram is fragmented each fragment has the same identification number</field>
        <field name="flags" type="byte">Various control flags: bit 0: reserved, must be zero; bit 1: don't fragment this datagram (DF); bit 2: more fragments flag (MF)</field>
        <field name="offset" type="word">The offset identifies the position of a fragment in the original IP packet. Due fragments always have a length of a multiple of 8 byte, 13 bit are adequate</field>
        <field name="ttl" type="byte">This value is decremented of the packet passed the router. If the value is set to 0 the packet is discarded</field>
        <field name="protocol" type="byte">Indication of the transported protocol: 1: ICMPv4; 2: IGMP; 6: TCP; 17: UDP</field>
        <field name="checksum" type="word">Checksum of the header. Some header fields can change (e.g. ttl), so the checksum is calculated and verified at each point that the Internet header is processed</field>
        <field name="source" type="dword">source IPv4 address. The first byte is the Source Network. The following three bytes are the Source Local Address</field>
        <field name="destination" type="dword">destination IPv4 address. The first byte is the Destination Network. The following three bytes are the Destination Local Address</field>
    </class>
    <class name="IPv6" base="EthernetPacketProtocol">
        <field name="version" type="byte">4-bit Internet Protocol version number = 6</field>
        <field name="class" type="byte">This eight bit field is available for use by originating nodes and/or forwarding routers to identify and distinguish between different classes or priorities of IPv6 packets</field>
        <field name="flow" type="dword">This field in the IPv6 header may be used by a source to label sequences of packets for which it requests special handling by the IPv6 routers, such as non-default quality of service or "real-time" service</field>
        <field name="length" type="word">Length of the IPv6 payload (without header) and the extension headers</field>
        <field name="next" type="byte">This field identifies the type of the next header, this can also be an extension header. The same values as in the IPv4 protocol field are used</field>
        <field name="hopLimit" type="byte">This fields sets the maximum number of steps through routers that a packet is allowed to cover. It is decremented by one on passing a router (hops). Packets with a hop limit of 0 are discarded</field>
        <field name="source" type="QWord">128-bit address of the sender of the packet</field>
        <field name="destination" type="QWord">128-bit address of the receiver of the packet. The receiver is possibly not the final receiver, if a routing header is present</field>
    </class>
    <class name="ICMPv6" base="EthernetPacketProtocol">
        <field name="type" type="byte">ICMP type</field>
        <field name="code" type="byte">Depends on the message type, and it is used to create an additional level of message granularity</field>
        <field name="checksum" type="word">Depends on the message type, and it is used to create an additional level of message granularity</field>
    </class>
    <class name="NDPRouterSolicitation" base="EthernetPacketProtocol">
    </class>
    <class name="NDPRouterAdvertisement" base="EthernetPacketProtocol">
        <field name="curHopLimit" type="byte">Default value that should be placed in the Hop Count field of the IP header for outgoing IP packets</field>
        <field name="managedAddrConfig" type="byte">When set, it indicates that addresses are available via DHCPv6</field>
        <field name="otherConfig" type="byte">When set, it indicates that other configuration information is available via DHCPv6</field>
        <field name="mobileHomeAgent" type="byte">When set, it indicates that the router sending this router Advertisement is also functioning as a mobile IPv6 home agent on this link</field>
        <field name="defaultRouterPrefs" type="byte">Indicates whether to prefer this router over other default routers(01 - high; 00 - medium; 11 - low; 10 - reserved)</field>
        <field name="neighborDiscoveryProxy" type="byte"></field>
        <field name="routerLifeTime" type="word">Lifetime associated with the default router in units of seconds</field>
        <field name="reachableTime" type="dword">Time in milliseconds that a node assumes a neighbor is reachable after having received a reachability confirmation</field>
        <field name="retransTime" type="dword">Time in milliseconds between retransmitted Neighbor Solicitation messages</field>
        <field name="target" type="qword">Time in milliseconds between retransmitted Neighbor Solicitation messages</field>
    </class>
    <class name="NDPNeighborAdvertisement" base="EthernetPacketProtocol">
        <field name="routerFlag" type="byte">When set, it indicates that the sender is a router</field>
        <field name="solicitedFlag" type="byte">When set, it indicates that the advertisement was sent in response to a Neighbor Solicitation</field>
        <field name="overrideFlag" type="byte">When set, it indicates that the advertisement should override an existing cache entry and update the cached link-layer address</field>
        <field name="target" type="qword">For a solicited advertisement: target address field in the Neighbor Solicitation message. For an unsolicited advertisement: address whose link-layer address has changed</field>
    </class>
    <class name="INDPRedirect" base="EthernetPacketProtocol">
        <field name="target" type="qword">IP address that is a better first hop to use for the ICMP destination address</field>
        <field name="destination" type="qword">IP address of the destination that is redirected to the target</field>
    </class>
    <class name="NDP">
        <field name="routerSolicitation" type="NDPRouterSolicitation">A host can request the router to send a Router Advertisement message</field>
        <field name="routerAdvertisement" type="NDPRouterAdvertisement">With this message the router announce themselves in the network. The message is sent from the router cyclically or is requested with a Router Solicitation message</field>
        <field name="neighborSolicitation" type="NDPNeighborSolicitation">A node can request the network address of another node with this message, or check if a node is still available. It can be checked too if an address is already assigned</field>
        <field name="neighborAdvertisement" type="NDPNeighborAdvertisement">This message is the answer to a Neighbor Solicitation message. A node can send this message too to announce a network address change</field>
        <field name="redirect" type="NDPRedirect">This message is used by the router to show a host a better way to a destination node</field>
        <field name="target" type="qword">IP address that is a better first hop to use for the ICMP destination address</field>
        <field name="destination" type="qword">IP address of the destination that is redirected to the target</field>
        <field name="routerFlag" type="byte">When set, it indicates that the sender is a router</field>
        <field name="solicitedFlag" type="byte">When set, it indicates that the advertisement was sent in response to a Neighbor Solicitation</field>
        <field name="overrideFlag" type="byte">When set, it indicates that the advertisement should override an existing cache entry and update the cached link-layer address</field>
        <field name="curHopLimit" type="byte">Default value that should be placed in the Hop Count field of the IP header for outgoing IP packets</field>
        <field name="managedAddrConfig" type="byte">When set, it indicates that addresses are available via DHCPv6</field>
        <field name="otherConfig" type="byte">When set, it indicates that other configuration information is available via DHCPv6</field>
        <field name="mobileHomeAgent" type="byte">When set, it indicates that the router sending this router Advertisement is also functioning as a mobile IPv6 home agent on this link</field>
        <field name="defaultRouterPrefs" type="byte">Indicates whether to prefer this router over other default routers: 01 - high; 00 - medium; 11 - low; 10 - reserved</field>
        <field name="neighborDiscoveryProxy" type="byte"></field>
        <field name="routerLifeTime" type="word">Lifetime associated with the default router in units of seconds</field>
        <field name="reachableTime" type="dword">Time in milliseconds that a node assumes a neighbor is reachable after having received a reachability confirmation</field>
        <field name="retransTime" type="dword">Time in milliseconds between retransmitted Neighbor Solicitation messages</field>
    </class>
    <class name="TCP" base="EthernetPacketProtocol">
        <field name="source" type="word">Source port number</field>
        <field name="destination" type="word">Destination port number</field>
        <field name="sequence" type="dword">Destination port number</field>
        <field name="ackNumber" type="dword">Destination port number</field>
        <field name="offset" type="byte">Number of 32 bit words in the TCP Header. This indicates where the data begins. The TCP header including options is an integral number of 32 bits long</field>
        <field name="flags" type="byte">
            8 bits (from lsb to msb):
            FIN -	more data from sender
            SYN - Synchronize sequence numbers
            RST - Reset the connection
            PSH - Push function
            ACK - Acknowledgment field significant
            URG - Urgent Pointer field significant
            ECE - ECN-Echo
            CWR - Congestion Window Reduced
        </field>
        <field name="window" type="word">The number of data bytes beginning with the one indicated in the field which the sender of this segment is willing to accept</field>
        <field name="checksum" type="word">The 16 bit one's complement of the one's complement sum of all 16 bit words in the header and text. If a segment contains an odd number of header and text bytes to be checksummed, the last byte is padded on the right with zeros to form a 16 bit word for checksum purposes. The pad is not transmitted as part of the segment. While computing the checksum, the checksum field itself is replaced with zeros</field>
        <field name="pointer" type="word">16 bit offset from the sequence number indicating the last urgent data byte</field>
    </class>
    <class name="UDP" base="EthernetPacketProtocol">
        <field name="source" type="word">Port number of the source (optional), 0: unknown port</field>
        <field name="destination" type="word">Port number of the destination</field>
        <field name="length" type="word">Length of this user datagram (in bytes) including this header and the data. This means the minimum value of the length is eight</field>
        <field name="checksum" type="word">Optional checksum, composed of information of the IP header, the UDP header and the data</field>
    </class>
    <class name="EthernetPacket">
        <field name="Time_NS" type="qword">Point in time, units: nanoseconds</field>
        <field name="DIR" type="byte"></field>
        <field name="MsgChannel" type="word"></field>
        <field name="Length" type="word">Length of Ethernet payload data (starting after the Ethertype)</field>
        <field name="FCS" type="Dword">Ethernet frame checksum. For some Ethernet hardware this value is not available (value 0)</field>
        <field name="FrameLen" type="INT64">Frame duration in ns. For some Ethernet hardware this value is not available (value 0)</field>
        <field name="SOF" type="INT64">Start-of-Frame time stamp in ns. For some Ethernet hardware this value is not available (value 0)</field>
        <field name="Type" type="word">Ethertype</field>
        <field name="Source" type="qword">Source Ethernet MAC address. Only 6 bytes of the QWord are used and network byte order is used</field>
        <field name="Destination" type="qword">Destination Ethernet MAC address. Only 6 bytes of the QWord are used and network byte order is used</field>
        <indexer name="byte"
                 desc="Message data byte (unsigned 8 bit); Offset 0 is the byte directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="byte" />
        </indexer>
        <indexer name="word"
                 desc=">Message data word (unsigned 16 bit); Offset 0 is the word directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="word" />
        </indexer>
        <indexer name="dword"
                 desc="Message data word (unsigned 32 bit); Offset 0 is the dword directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="dword" />
        </indexer>
        <indexer name="qword" desc="Message data qword (unsigned 64 bit)" writeable="yes">
            <param name="i" type="int"></param>
            <return type="qword" />
        </indexer>
        <indexer name="char" desc="Message data byte (signed 8 bit); Offset 0 is the byte directly after the Ethertype"
                 writeable="yes">
            <param name="i" type="int"></param>
            <return type="char" />
        </indexer>
        <indexer name="short" desc="" writeable="yes">
            <param name="i" type="int"></param>
            <return type="short" />
        </indexer>
        <indexer name="long" desc="Message data long word (signed 32 bit)" writeable="yes">
            <param name="i" type="int"></param>
            <return type="long" />
        </indexer>
        <indexer name="longlong" desc="Message data (signed 64 bit)" writeable="yes">
            <param name="i" type="int"></param>
            <return type="long" />
        </indexer>
        <method name="StartGenerator"
                desc="Starts the Ethernet packet generator that sends continuously the configured packets">
            <param name="transmissionRate" type="dword">The rate in frames per second the packet should be transmitted. Range: [1 ... 1000000]</param>
            <param name="numberOfFrames" type="dword">The number of Frames that should be transmitted overall. Range: [0x1 ... 0xFFFFFFFE], 0xFFFFFFFF to send until EthStopPacketGenerator</param>
            <param name="counterByteOffset" type="dword">The position a 4 byte counter is placed inside the Ethernet-payload on a zero based index</param>
            <return type="void">
                0: Success
                -1: Output on specified Ethernet channel not allowed
                -2: Packet generator not supported in simulation mode
                -3: Packet generator is only available with Vector Ethernet network hardware
                -4: Configuration of packet generator failed
                -5: Starting of packet generator failed
            </return>
        </method>
        <method name="StopGenerator" desc="This function stops the Ethernet packet generator">
            <return type="void">0 or error code</return>
        </method>
        <method name="SetData" desc="Sets payload data of a protocol within an Ethernet packet">
            <param name="offset" type="word"></param>
            <param name="source[]" type="byte"></param>
            <param name="length" type="byte"></param>
            <return type="long" />
        </method>
        <method name="GetData" desc="Gets payload data of a protocol within an Ethernet packet">
            <param name="offset" type="word"></param>
            <param name="source[]" type="byte"></param>
            <param name="length" type="byte"></param>
            <return type="long" />
        </method>
        <method name="Clear" desc="">
            <return type="long" />
        </method>
        <method name="CompletePacket" desc="">
            <return type="long" />
        </method>
        <method name="GetProtocolErrorText" desc="">
            <param name="buffer[]" type="char"></param>
            <return type="word" />
        </method>
        <method name="GetVlan" desc="">
            <param name="tpid" type="word"></param>
            <param name="tci" type="word"></param>
            <return type="long" />
        </method>
        <method name="GetVlan" desc="">
            <param name="vlanIndex" type="dword"></param>
            <param name="tpid" type="word"></param>
            <param name="tci" type="word"></param>
            <return type="long" />
        </method>
        <method name="GetVlanId" desc="">
            <param name="tpid" type="word"></param>
            <param name="tci" type="word"></param>
            <return type="long" />
        </method>
        <method name="GetVlanId" desc="">
            <param name="vlanIndex" type="dword"></param>
            <return type="long" />
        </method>
        <method name="GetVlanPriority" desc="">
            <return type="dword" />
        </method>
        <method name="GetVlanPriority" desc="">
            <param name="vlanIndex" type="dword"></param>
            <return type="dword" />
        </method>
        <method name="HasProtocolError" desc="">
            <return type="word" />
        </method>
        <method name="HasVlan" desc="">
            <return type="word" />
        </method>
        <method name="RemoveVlan" desc="">
            <return type="word" />
        </method>
        <method name="RemoveVlan" desc="">
            <param name="vlanIndex" type="dword"></param>
            <return type="word" />
        </method>
        <method name="SetVlan" desc="">
            <param name="tpid" type="word"></param>
            <param name="tci" type="word"></param>
            <return type="long" />
        </method>
        <method name="SetVlan" desc="">
            <param name="vlanIndex" type="dword"></param>
            <param name="tpid" type="word"></param>
            <param name="tci" type="word"></param>
            <return type="long" />
        </method>
        <method name="SetVlanId" desc="">
            <param name="vlanId" type="word"></param>
            <return type="dword" />
        </method>
        <method name="SetVlanId" desc="">
            <param name="vlanIndex" type="dword"></param>
            <param name="vlanId" type="word"></param>
            <return type="dword" />
        </method>
        <method name="SetVlanPriority" desc="">
            <param name="vlanPriority" type="word"></param>
            <return type="dword" />
        </method>
        <method name="SetVlanPriority" desc="">
            <param name="vlanIndex" type="dword"></param>
            <param name="vlanPriority" type="word"></param>
            <return type="dword" />
        </method>
        <field name="IPv4" type="IPv4" />
        <field name="IPv6" type="IPv6" />
        <field name="ICMPv6" type="ICMPv6" />
        <field name="NDP" type="NDP" />
        <field name="TCP" type="TCP" />
        <field name="UDP" type="UDP" />
    </class>
    <class name="EthernetStatus">  <!-- on ethernetStatus ... -->
        <field name="Status" type="long">0 = link down; 1 = link up</field>
        <field name="Bitrate" type="dword">Bit rate in Bit per sec</field>
        <field name="MsgChannel" type="word"></field>
        <field name="HwChannel" type="word"></field>
        <field name="time_ns" type="qword">Point in time, units: nanoseconds</field>
    </class>
    <class name="Diag">  <!-- on diag??? ... -->
        <field name="Status" type="long"></field>
    </class>
    <method name="elCount" desc="Determines the number of elements in an array">
        <param name="array" type=""></param>
        <return type="long"></return>
    </method>
    <method name="cancelTimer" desc="Stops an active timer">
        <param name="timer" type="msTimer t">Timer or msTimer variable</param>
    </method>
    <method name="atodbl"
            desc="The function converts the string s into a double number. Normally, the base is decimal and must have the following format: [Blank space] [Sign] [Digits] [.Digits] [ {d | D | e | E}[Sign]Digits]">
        <param name="input[]" type="char">Input string to be converted</param>
        <return type="double">Double number, the converted string</return>
    </method>
    <method name="atol"
            desc="This function converts the string s to a LONG number. The number base is decimal. Starting with string 0x, base 16 is used. Leading blanks are not read">
        <param name="s[]" type="char">String to be converted</param>
        <return type="long">integer</return>
    </method>

    <method name="ltoa"
            desc="The number val is converted to a string s. In this case, base indicates a number base between 2 and 36. s must be large enough to accept the converted number!">
        <param name="val" type="long">Number to be converted</param>
        <param name="s" type="char">String, which contains the converted number</param>
        <param name="base" type="long">Number base</param>
        <return type="void"></return>
    </method>

    <method name="_round"
            desc="Rounds x to the nearest integral number. The rounding method used is symmetric arithmetic rounding">
        <param name="x" type="double">Number to be rounded</param>
        <return type="long">Nearest integral number</return>
    </method>

    <method name="_round64"
            desc="Rounds x to the nearest integral number. The rounding method used is symmetric arithmetic rounding">
        <param name="x" type="double">Number to be rounded</param>
        <return type="int64">Nearest integral number</return>
    </method>

    <method name="_floor"
            desc="Calculates the floor of a value, i.e. the largest integer smaller or equal to the value">
        <param name="x" type="float">Value of which the floor shall be calculated</param>
        <return type="float">Floor of x</return>
    </method>

    <method name="_ceil"
            desc="Calculates the ceiling of a value, i.e. the smallest integer larger or equal to the value">
        <param name="x" type="float">Value of which the ceiling shall be calculated</param>
        <return type="float">Ceiling of x</return>
    </method>

    <method name="random" desc="Calculates a random number between 0 and x-1">
        <param name="x" type="dword">Determines the interval</param>
        <return type="dword">Random number between 0 and x-1</return>
    </method>

    <method name="loadPanel" desc="Loads a panel">
        <param name="panelName[]" type="char">Panel name, restricted to 128 characters</param>
        <return type="void"></return>
    </method>

    <method name="openPanel" desc="Opens a panel">
        <param name="panelName[]" type="char">Panel name, restricted to 128 characters</param>
        <return type="void"></return>
    </method>

    <method name="closePanel" desc="Closes a panel">
        <param name="panelName[]" type="char">Panel name, restricted to 128 characters</param>
        <return type="void"></return>
    </method>

    <method name="SetControlBackColor" desc="Sets the background color of panel elements">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters</param>
        <param name="control[]" type="char">Name of the control, restricted to 128 characters</param>
        <param name="color" type="long">Color value (e.g. calculated by MakeRGB)</param>
        <return type=""></return>
    </method>

    <method name="SetControlForeColor" desc="Sets the foreground color of panel elements">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters</param>
        <param name="control[]" type="char">Name of the control, restricted to 128 characters</param>
        <param name="color" type="long"></param>
        <return type="void"></return>
    </method>

    <method name="SetControlColors" desc="Sets the background and text color of panel elements">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters</param>
        <param name="control[]" type="char">Name of the control, restricted to 128 characters</param>
        <param name="backcolor" type="long">Color value (e.g. calculated by MakeRGB)</param>
        <param name="textcolor" type="long">Color value (e.g. calculated by MakeRGB)</param>
        <return type="void"></return>
    </method>

    <method name="enableControl"
            desc="Selective activation and deactivation of the following elements:
		control elements
		control and display elements">
        <param name="panel[]" type="char">Name of the panel, restricted to 128 characters</param>
        <param name="control[]" type="char">Name of the control, restricted to 128 characters</param>
        <param name="enable" type="long">
            0 turn off (disable)
            1 turn on (enable)
        </param>
        <return type="void"></return>
    </method>

    <method name="SetControlVisibility" desc="Sets the visibility of panel elements">
        <param name="control[]" type="char">Name of the control, restricted to 128 characters</param>
        <param name="panel[]" type="char">Panel name, restricted to 128 characters</param>
        <param name="visible" type="long">
            Sets if the panel element should be visible or not
            visible = 1 => Panel element is visible
            visible = 0 => Panel element is not visible
        </param>
        <return type="void"></return>
    </method>

    <method name="SetClockControlTimeByValues" desc="Sets the time of the Panel Designer Clock Control">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters</param>
        <param name="control[]" type="char">Name of the control, restricted to 128 characters</param>
        <param name="hours" type="int">Defines the hours of the time to be displayed in the clock control</param>
        <param name="minutes" type="int">Defines the minutes of the time to be displayed in the clock control</param>
        <param name="seconds" type="int">Defines the seconds of the time to be displayed in the clock control</param>
        <return type=""></return>
    </method>

    <method name="SetClockControlTime" desc="Sets the time of the Panel Designer Clock Control">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters</param>
        <param name="control[]" type="char">Name of the control, restricted to 128 characters</param>
        <param name="time" type="int">Defines the time in seconds to be displayed in the clock control. The corresponding hours, minutes and seconds are calculated during runtime</param>
        <return type="void"></return>
    </method>

    <method name="ClockControlStart"
            desc="Starts the Clock Control designed as stop watch in the Panel Designer (setting Mode = StopWatch)">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters</param>
        <param name="control[]" type="char">Name of the control, restricted to 128 characters</param>
        <return type="void"></return>
    </method>

    <method name="ClockControlStop"
            desc="Stops the Clock Control designed as stop watch with the Panel Designer (setting Mode = StopWatch)">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters</param>
        <param name="control[]" type="char">Name of the control, restricted to 128 characters</param>
        <return type="void"></return>
    </method>

    <method name="ClockControlReset"
            desc="Resets the Clock Control designed as stop watch with the Panel Designer (setting Mode = StopWatch)">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters</param>
        <param name="control[]" type="char">Name of the control, restricted to 128 characters</param>
        <return type="void"></return>
    </method>

    <method name="fileReadArray_Internal"
            desc="Searches for the variable entry in the section section of the file file. Its contents are interpreted as a list of byte values. The number format is decimal or with the prefix 0x it is hexadecimal. Numbers are separated by spaces, tabs, a comma, semi-colon or slash. The buffer is filled up to a quantity of bufferlen bytes">
        <param name="section[]" type="char">Section of file</param>
        <param name="entry[]" type="char">Name of variable</param>
        <param name="buffer[]" type="char">Buffer for characters to be read</param>
        <param name="bufferlen" type="long">Size of buffer in byte</param>
        <param name="filename[]" type="char">Size of buffer in byte</param>
        <return type="long">Number of characters read</return>
    </method>

    <method name="fileReadFloat_Internal" desc="Analogous to fileReadInt for floats">
        <param name="section[]" type="char">Section of file</param>
        <param name="entry[]" type="char">Name of variable</param>
        <param name="def" type="float">Value</param>
        <param name="file" type="char">Name of file</param>
        <return type="float">Number of characters read</return>
    </method>

    <method name="fileReadInt_Internal"
            desc="Searches for the variable entry in the section section of the file filename. If its value is a number, this number is returned as the functional result. If the file or entry is not found, or if entry does not contain a valid number, the default value def is returned as the functional result">
        <param name="section[]" type="char">Section of file</param>
        <param name="entry[]" type="char">Name of variable</param>
        <param name="def" type="long">Value</param>
        <param name="file" type="char">Name of file</param>
        <return type="long">Integer read</return>
    </method>

    <method name="fileReadString_Internal"
            desc="Searches for the variable entry in the section section of the file filename. Its content (value) is written to the buffer buffer. Its length must be passed correctly to bufferlen. If the file or entry is not found, the default value def is copied to buffer">
        <param name="section[]" type="char">Section of file</param>
        <param name="entry[]" type="char">Name of variable</param>
        <param name="def[]" type="char">Value</param>
        <param name="filename[]" type="char">Name of file</param>
        <param name="buffer[]" type="char">Buffer for characters to be read</param>
        <param name="bufferlen" type="long">Size of buffer in byte</param>
        <return type="long">Number of bytes read</return>
    </method>

    <method name="fileWriteFloat_Internal"
            desc="Analogous to fileWriteInt, but writes a float variable to the file instead of a text">
        <param name="section[]" type="char">Section of file</param>
        <param name="entry[]" type="char">Name of variable</param>
        <param name="def" type="float">Value</param>
        <param name="file[]" type="char">Name of file</param>
        <return type="long">0 if an error has occurred else 1</return>
    </method>

    <method name="fileWriteInt_Internal"
            desc="Analogous to fileWriteString, but writes a long variable to the file instead of a text">
        <param name="section[]" type="char">Section of file</param>
        <param name="entry[]" type="char">Name of variable</param>
        <param name="def" type="long">Value</param>
        <param name="file[]" type="char">Name of file</param>
        <return type="long">0 if an error has occurred else 1</return>
    </method>

    <method name="fileWriteString_Internal"
            desc="Opens the file filename, finds the section section and writes the variable entry with the value value. If entry already exists, the old value is overwritten. The functional result is the number of characters written, or 0 for an error">
        <param name="section[]" type="char">Section of file</param>
        <param name="entry[]" type="char">Name of variable</param>
        <param name="value[]" type="char">value</param>
        <param name="filename[]" type="char">Name of file</param>
        <return type="long">Number of written characters of 0 if an error has occurred</return>
    </method>
    <method name="getLocalTime" desc="Returns details to the current date and time in an array of type long">
        <param name="time[]" type="long">
            An array of type long with at least 9 entries. The entries of the array will be filled with the following information:
            1 Seconds (0 - 60)
            2 Minutes (0 - 60)
            3 Hours (0 - 24)
            4 Day of month (1 - 31)
            5 Month (0 - 11)
            6 Year (starting with 1900)
            7 Day of week (0 - 7)
            8 Day of Year (0 - 365)
            9 Flag for daylight saving time (0 - 1, 1 = daylight saving time)
        </param>
        <return type="void"></return>
    </method>

    <method name="getLocalTimeString"
            desc="Copies a printed representation of the current date and time into the supplied character buffer">
        <param name="timeBuffer[]" type="char">The buffer the string will be written in.  This buffer must be at least 26 characters long</param>
        <return type="void"></return>
    </method>

    <method name="getProfileArray_Internal"
            desc="Searches the file under section section for the variable entry. Entry is interpreted as a list of numerical values, separated by comma, tab, space, semicolon or slash. A 0x prefix indicates hex values">
        <param name="section[]" type="char">Section as a string</param>
        <param name="entry[]" type="char">Name as a string</param>
        <param name="filename[]" type="char">File path as a string</param>
        <param name="buff[]" type="char">Buffer for the read-in numerical values</param>
        <param name="buffsize" type="long">Size of buff: Maximum number of read in numerical values (max. 1279 characters)</param>
        <return type="long">Number of numerical values read in</return>
    </method>

    <method name="getProfileFloat_Internal"
            desc="Searches the file filename under section section for the variable entry. If its value is a number, this number is returned as the functional result. If the file or entry is not found, or if entry does not contain a valid number, the default value def is returned as the functional result">
        <param name="section[]" type="char">Section as a string</param>
        <param name="entry[]" type="char">Name as a string</param>
        <param name="filename[]" type="char">File path as a string</param>
        <param name="def" type="long">Default value in case of error as a float</param>
        <return type="float">Number of numerical values read in</return>
    </method>

    <method name="getProfileInt_Internal"
            desc="Searches the file filename under section section for the variable entry. If its value is a number, this number is returned as the functional result. If the file or entry is not found, or if entry does not contain a valid number, the default value def is returned as the functional result">
        <param name="section[]" type="char">Section as a string</param>
        <param name="entry[]" type="char">Name as a string</param>
        <param name="filename[]" type="char">File path as a string</param>
        <param name="def" type="long">Default value in case of error as an integer</param>
        <return type="long">Integer that was read in</return>
    </method>

    <method name="getProfileString_Internal"
            desc="Searches the file filename under section section for the variable entry. Its contents (value) are written to the buffer buff. Its length must be passed correctly in buffsize. If the file or entry is not found, the default value def is copied to buffer. If the read string length is longer than the buffer, the string will be cut to the buffer length">
        <param name="section[]" type="char">Section as a string</param>
        <param name="entry[]" type="char">Variable name as a string</param>
        <param name="filename[]" type="char">File path as a string</param>
        <param name="buff[]" type="char">Buffer for the read-in numerical as a string</param>
        <param name="buffsize" type="long">Size of buff in bytes (max. 1022 characters)</param>
        <return type="long">
            Length of the read string
            Length of the default string: Fault Key not found
            -1: Fault File not found
        </return>
    </method>

    <method name="ErrorFrameCount" desc="Returns the number of Error Frames on channel x since start of measurement">
        <return type="long">Number of Error Frames on channel x since start of measurement</return>
    </method>

    <method name="getSignal" desc="Gets the value of a signal">
        <param name="aSignal" type="Signal">The signal to be polled</param>
        <return type="double"></return>
    </method>

    <method name="setSignal" desc="Sets the transmitted signal aSignal to the accompanying value">
        <param name="aSignal" type="Signal">Signal to be set</param>
        <param name="aValue" type="double">Physical value to be accepted</param>
        <return type="void"></return>
    </method>
    <method name="setSignal" desc="Sets the transmitted signal aSignal to the accompanying value">
        <param name="aSignal[]" type="char">Signal to be set</param>
        <param name="aValue" type="double">Physical value to be accepted</param>
        <return type="void"></return>
    </method>
    <method name="getRawSignal" desc="Retrieves the current raw value of a signal">
        <param name="dbSignal" type="Signal">The signal</param>
        <return type="Int64">the current raw value of the signal</return>
    </method>
    <method name="getRawSignal" desc="Retrieves the current raw value of a signal">
        <param name="dbSignal" type="Signal">The signal</param>
        <param name="data[]" type="byte">Receives the data bytes of the signal</param>
        <param name="dataLength" type="dword">Length of the data buffer</param>
        <return type="long">0 on success, -1 on error</return>
    </method>
    <method name="setRawSignal" desc="Sets the raw value of a signal">
        <param name="dbSignal" type="Signal">The signal</param>
        <return type="void"></return>
    </method>
    <method name="setRawSignal" desc="Sets the raw value of a signal">
        <param name="dbSignal" type="Signal">The signal</param>
        <param name="data[]" type="byte">The data bytes of the signal</param>
        <param name="dataLength" type="dword">Length of the data</param>
        <return type="word">0 on success, -1 on error</return>
    </method>
    <method name="sysSetVariableFloat" desc="Sets the value of a variable of the double type">
        <param name="namespace[]" type="char">Name of the name space</param>
        <param name="name[]" type="char">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <param name="val" type="float">New value of the variable</param>
        <return type="long">
            0: no error, function successful
            1: name space was not found or second try to define the same name space
            2: variable was not found or second try to define the same variable
            3: no writing right for the name space available
            4: the variable has no suitable type for the function
        </return>
    </method>

    <method name="sysSetVariableFloat" desc="Sets the value of a variable of the double type">
        <param name="name" type="SysVar">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <param name="val" type="float">New value of the variable</param>
        <return type="long">
            0: no error, function successful
            1: name space was not found or second try to define the same name space
            2: variable was not found or second try to define the same variable
            3: no writing right for the name space available
            4: the variable has no suitable type for the function
        </return>
    </method>

    <method name="sysSetVariableInt" desc="Sets the value of a variable of a 32 bit integer type">
        <param name="namespace[]" type="char">Name of the name space</param>
        <param name="name[]" type="char">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <param name="val" type="long">New value of the variable</param>
        <return type="long">
            0: no error, function successful
            1: name space was not found or second try to define the same name space
            2: variable was not found or second try to define the same variable
            3: no writing right for the name space available
            4: the variable has no suitable type for the function
        </return>
    </method>

    <method name="sysSetVariableInt" desc="Sets the value of a variable of a 32 bit integer type">
        <param name="name" type="SysVar">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <param name="val" type="long">New value of the variable</param>
        <return type="long">
            0: no error, function successful
            1: name space was not found or second try to define the same name space
            2: variable was not found or second try to define the same variable
            3: no writing right for the name space available
            4: the variable has no suitable type for the function
        </return>
    </method>

    <method name="sysSetVariableLongLong" desc="Sets the value of a variable of a 64 bit integer type">
        <param name="namespace[]" type="char">Name of the name space</param>
        <param name="name[]" type="char">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <param name="val" type="long long">New value of the variable</param>
        <return type="long">
            0: no error, function successful
            1: name space was not found or second try to define the same name space
            2: variable was not found or second try to define the same variable
            3: no writing right for the name space available
            4: the variable has no suitable type for the function
        </return>
    </method>

    <method name="sysSetVariableLongLong" desc="Sets the value of a variable of a 64 bit integer type">
        <param name="name" type="SysVar">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <param name="val" type="long long">New value of the variable</param>
        <return type="long">
            0: no error, function successful
            1: name space was not found or second try to define the same name space
            2: variable was not found or second try to define the same variable
            3: no writing right for the name space available
            4: the variable has no suitable type for the function
        </return>
    </method>

    <method name="sysSetVariableFloatArray" desc="Sets the value of a variable of the float[] type.">
        <param name="namespace[]" type="char">Name of the name space</param>
        <param name="name[]" type="char">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <param name="values[]" type="float">New value of the variable</param>
        <param name="size" type="long">Number of values in the array</param>
        <return type="long">
            0: no error, function successful
            1: name space was not found or second try to define the same name space
            2: variable was not found or second try to define the same variable
            3: no writing right for the name space available
            4: the variable has no suitable type for the function
        </return>
    </method>

    <method name="sysSetVariableFloatArray" desc="Sets the value of a variable of the float[] type">
        <param name="name" type="SysVar">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <param name="values[]" type="float">New value of the variable</param>
        <param name="size" type="long">Number of values in the array</param>
        <return type="long">
            0: no error, function successful
            1: name space was not found or second try to define the same name space
            2: variable was not found or second try to define the same variable
            3: no writing right for the name space available
            4: the variable has no suitable type for the function
        </return>
    </method>

    <method name="sysSetVariableLongArray" desc="Sets the value of a variable of the int[] type">
        <param name="namespace[]" type="char">Name of the name space</param>
        <param name="name[]" type="char">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <param name="values[]" type="long">New value of the variable</param>
        <param name="size" type="long">Number of values in the array</param>
        <return type="long">
            0: no error, function successful
            1: name space was not found or second try to define the same name space
            2: variable was not found or second try to define the same variable
            3: no writing right for the name space available
            4: the variable has no suitable type for the function
        </return>
    </method>

    <method name="sysSetVariableLongArray" desc="Sets the value of a variable of the int[] type">
        <param name="name" type="SysVar">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <param name="values[]" type="long">New value of the variable</param>
        <param name="size" type="long">Number of values in the array</param>
        <return type="long">
            0: no error, function successful
            1: name space was not found or second try to define the same name space
            2: variable was not found or second try to define the same variable
            3: no writing right for the name space available
            4: the variable has no suitable type for the function
        </return>
    </method>

    <method name="sysGetVariableArrayLength" desc="Returns the length of the array of the system variable">
        <param name="namespace[]" type="char">Name of the name space</param>
        <param name="name[]" type="char">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <return type="dword">
            For system variables of type data, returns the current size (in bytes) of the value.
            For system variables of type long or float array, returns the number of elements in the array.
            For system variables of type string, returns the length of the string, excluding the terminating 0 character.
            For system variables of type long or float, returns 1.
        </return>
    </method>

    <method name="sysGetVariableArrayLength" desc="Returns the length of the array of the system variable">
        <param name="name" type="SysVar">Name of the fully qualified name of the system variable, including all name spaces, separated by "::". The name must be preceded by "sysVar::"</param>
        <return type="dword">
            For system variables of type data, returns the current size (in bytes) of the value.
            For system variables of type long or float array, returns the number of elements in the array.
            For system variables of type string, returns the length of the string, excluding the terminating 0 character.
            For system variables of type long or float, returns 1.
        </return>
    </method>

    <method name="getValueSize" desc="Returns the size of the environment variable value in bytes">
        <param name="name" type="EnvVar">Environment variable name. Must exist in the database</param>
        <return type="int">Size of the data in bytes</return>
    </method>

    <method name="isExtId" desc="Checks parameter for extended identifier (29 bit) or standard identifier (11 Bit)">
        <param name="id" type="dword">Variable</param>
        <return type="long">1 if check was successful, else 0</return>
    </method>

    <method name="isStdId" desc="Checks parameter for extended identifier (29 bit) or standard identifier (11 Bit)">
        <param name="m" type="Message">Id part of a message</param>
        <return type="long">1 if check was successful, else 0</return>
    </method>

    <method name="isStdId" desc="Checks parameter for extended identifier (29 bit) or standard identifier (11 Bit)">
        <param name="id" type="dword">Id part of a message</param>
        <return type="long">1 if check was successful, else 0</return>
    </method>

    <method name="MakeRGB" desc="Calculates the color value from the three primary color components">
        <param name="Red" type="long">Red color component (0 - 255)</param>
        <param name="Green" type="long">Green color component (0 - 255)</param>
        <param name="Blue" type="long">Blue color component (0 - 255)</param>
        <return type="long">Color value (type: long)</return>
    </method>

    <method name="mkExtId" desc="Returns an extended id">
        <param name="message" type="dword">Id part of a message</param>
        <return type="dword">Extended identifier</return>
    </method>

    <method name="output" desc="Outputs a message">
        <param name="m" type="Message">Variable of type message. Output(message msg)</param>
        <return type="void"></return>
    </method>

    <method name="output" desc="Outputs a Ethernet packet from the program block">
        <param name="packet" type="ethernetPacket">Variable of type ethernetPacket</param>
        <return type="void"></return>
    </method>

    <method name="setBtr"
            desc="Sets another baud rate. The values do not become active until the next call of the function resetCan">
        <param name="channel" type="long">channel 0: All controllers; 1 - 32: channel 1 - 32</param>
        <param name="btr0" type="byte">Value of Bit Timing Register 0</param>
        <param name="btr1" type="byte">Value of Bit Timing Register 1</param>
        <return type="long">Always 1</return>
    </method>

    <method name="snprintf" desc="Write char buffer">
        <param name="dest[]" type="char">Character buffer to print to</param>
        <param name="len" type="long">Maximum number of characters printed to buffer including terminating '\0'. Must be at most the size of the buffer</param>
        <param name="format[]" type="char">Formatted string printed to buffer</param>
        <param name="..." type=""></param>
        <return type="long">The number of characters written</return>
    </method>

    <method name="stop"
            desc="Programmed interrupt of the ongoing measurement.In offline mode this function interrupts but does not end the measurement. In offline mode the measurement can only be ended with ESC">
        <return type="void"></return>
    </method>

    <method name="strncpy"
            desc="This function copies src to dest. len indicates the size of the string that shall be copied. The function ensures that there is a terminating '\0'. Thus, a maximum of len-1 characters are copied">
        <param name="dest[]" type="char">Destination buffer</param>
        <param name="src[]" type="char">Source string</param>
        <param name="len" type="long">Maximum number of characters printed to buffer including terminating '\0'. Must be at most the size of the buffer</param>
        <return type="void"></return>
    </method>

    <method name="strstr" desc="Searches in s1 for s2">
        <param name="s1[]" type="char">First string</param>
        <param name="s2[]" type="char">Second string</param>
        <return type="long">First position of s2 in s1, or -1 if s2 is not found in s1</return>
    </method>

    <method name="strstr_off" desc="Searches in s1 for s2">
        <param name="s1[]" type="char">First string</param>
        <param name="offset" type="long">Offset in s1 at which the search shall be started</param>
        <param name="s2[]" type="char">Second string</param>
        <return type="long">First position of s2 in s1 with offset, or -1 if s2 is not found in s1</return>
    </method>

    <method name="strncmp" desc="This function compares s1 with s2 for a maximum of len characters.">
        <param name="s1[]" type="char">First string</param>
        <param name="s2[]" type="char">Second string</param>
        <param name="len" type="long">Maximum number of characters to compare</param>
        <return type="long">
            -1 if s1 is less than s2
            1 if s2 is less than s1
            0 if the strings are equal
        </return>
    </method>

    <method name="strncmp" desc="This function starts the comparison in s2 at the specified offset">
        <param name="s1[]" type="char">First string</param>
        <param name="s2[]" type="char">Second string</param>
        <param name="s2offset" type="long">Offset in s2</param>
        <param name="len" type="long">Maximum number of characters to compare</param>
        <return type="long">
            -1 if s1 is less than s2
            1 if s2 is less than s1
            0 if the strings are equal
        </return>
    </method>

    <method name="strncpy_off"
            desc="This function copies src to dest. max indicates the size of dest. The function ensures that there is a terminating '\0'. Thus, a maximum of max-1-destOffset characters are copied. Characters are overwritten in dest starting at destOffset">
        <param name="dest[]" type="char">Destination buffer</param>
        <param name="destOffset" type="long">Offset in destination buffer</param>
        <param name="src[]" type="char">Source string</param>
        <param name="max" type="long">Is used to determine the maximum number of copied characters. Must not be larger than the size of dest. A maximum of max-1-destOffset characters are copied.If src is shorter than that, characters are only copied until a terminating '\0' is encountered</param>
        <return type="void"></return>
    </method>

    <method name="substr_cpy"
            desc="This function copies a substring of src to dest. max indicates the size of dest. The function ensures that there is a terminating '\0'. Thus, a maximum of max-1 characters are copied">
        <param name="dest[]" type="char">Destination buffer</param>
        <param name="src[]" type="char">Source string</param>
        <param name="srcStart" type="long">Start index in src of substring</param>
        <param name="len" type="long">Length of the substring, or -1 to copy the string until the end</param>
        <param name="max" type="long">Size of dest</param>
        <return type="void"></return>
    </method>

    <method name="substr_cpy_off"
            desc="This function copies a substring of src to dest. max indicates the the size of dest">
        <param name="dest[]" type="char">Destination buffer</param>
        <param name="destOffset" type="long">Offset in destination buffer</param>
        <param name="src[]" type="char">Source string</param>
        <param name="srcStart" type="long">Start index in src of substring</param>
        <param name="len" type="long">Length of the substring, or -1 to copy the string until the end</param>
        <param name="max" type="long">Size of dest</param>
        <return type="void"></return>
    </method>

    <method name="mbstrncpy_off_internal"
            desc="This function copies src to dest. len indicates the size of the string that shall be copied. The function ensures that there is a terminating '\0'. Thus, a maximum of len-1 characters are copied">
        <param name="dest[]" type="char">Destination buffer</param>
        <param name="destSize" type="long">Size of dest</param>
        <param name="src[]" type="char">Source string</param>
        <param name="srcSize" type="long">Size of src</param>
        <return type="void"></return>
    </method>

    <method name="SysGetVariableFloat" desc="Returns the value of a variable of the double type">
        <param name="namespace[]" type="char">Name of the name space</param>
        <param name="variable[]" type="char">Name of the variable</param>
        <return type="double">Value of the variable or 0 in case of error</return>
    </method>

    <method name="SysGetVariableInt" desc="Returns the value of a variable of a 32 bit integer type">
        <param name="namespace[]" type="char">Name of the name space</param>
        <param name="variable[]" type="char">Name of the variable</param>
        <return type="long">Value of the variable or 0 in case of error</return>
    </method>

    <method name="valOfId"
            desc="Returns the value of a message identifier independent of its type. Identifier as long value">
        <param name="id" type="dword">Identifier</param>
        <return type="long">Identifier as long value</return>
    </method>

    <method name="valOfId"
            desc="Returns the value of a message identifier independent of its type. Identifier as long value">
        <param name="m" type="Message">Message identifier</param>
        <return type="long">Identifier as long value</return>
    </method>

    <method name="writeProfileFloat"
            desc="Opens the file filename, searches the section section and writes the variable entry with the value value. If entry already exists the old value is overwritten">
        <param name="section[]" type="char">Section of the file as a string</param>
        <param name="entry[]" type="char">Variable name as a string</param>
        <param name="value" type="float">Value as a float</param>
        <param name="filename[]" type="char">File path as a string</param>
        <return type="long">The functional result is 0 in case of an error</return>
    </method>

    <method name="writeProfileInt"
            desc="Opens the file filename, searches the section section and writes the variable entry with the value value. If entry already exists the old value is overwritten">
        <param name="section[]" type="char">Section of the file as a string</param>
        <param name="entry[]" type="char">Variable name as a string</param>
        <param name="value" type="long">Value as a int</param>
        <param name="filename[]" type="char">File path as a string</param>
        <return type="long">The functional result is 0 in case of an error</return>
    </method>

    <method name="writeProfileString"
            desc="Opens the file filename, searches the section section and writes the variable entry with the value value. If entry already exists the old value is overwritten">
        <param name="section[]" type="char">Section of the file as a string</param>
        <param name="entry[]" type="char">Variable name as a string</param>
        <param name="value[]" type="char">Value as a string</param>
        <param name="filename[]" type="char">File path as a string</param>
        <return type="long">The functional result is 0 in case of an error</return>
    </method>

    <method name="beep" desc="Tone output. In the Windows Version the parameter duration has no effect">
        <param name="freq" type="int">
            Integer for tone pitch. In the Windows version, the parameters freq defines the tone output. Different sounds are defined in the section [SOUND] in the file WIN.ini:
            freq 0x0000 (SystemDefault)
            freq 0x0010 (SystemHand)
            freq 0x0020 (SystemQuestion)
            freq 0x0030 (SystemExclamation)
            freq 0x0040 (SystemAsterisk)
            freq 0xFFFF Standard Beep
        </param>
        <param name="duration" type="int">Integer for tone length</param>
        <return type="void"></return>
    </method>

    <method name="canGetBusLoad" desc="Returns the current busload of the specified channel">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Current busload of the specified channel in percent</return>
    </method>

    <method name="canGetChipState" desc="Returns the current chip state of the specified CAN controller">
        <param name="channel" type="long">CAN channel</param>
        <return type="long">
            Chip state of the specified CAN controller. See the following table for a description of the return values
            0 Value not available
            1 Simulated
            3 Error Active
            4 Warning Level
            5 Error Passive
            6 Bus Off
        </return>
    </method>

    <method name="canGetErrorCount"
            desc="Returns the number of Error Frames on the specified channel since start of measurement">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Number of Error Frames on the specified channel since start of measurement</return>
    </method>

    <method name="canGetErrorRate" desc="Returns the current rate of CAN error messages of the specified channel">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Current Rate of CAN error messages on the specified channel in messages per second</return>
    </method>

    <method name="canGetExtData"
            desc="Returns the number of extended CAN frames on the specified channel since start of measurement">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Number of extended CAN frames on the specified channel since start of measurement</return>
    </method>

    <method name="canGetExtDataRate" desc="Returns the current rate of extended CAN frames on the specified channel">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Current rate of extended CAN frames on the specified channel in messages per second</return>
    </method>

    <method name="canGetExtRemote"
            desc="Returns the number of extended remote CAN messages on the specified channel since start of measurement">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Number of extended remote CAN messages on the specified channel since start of measurement</return>
    </method>

    <method name="canGetExtRemoteRate"
            desc="Returns the current rate of extended remote CAN messages on the specified channel">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Current rate of extended remote CAN messages on the specified channel in frames per second</return>
    </method>

    <method name="canGetOverloadCount"
            desc="Returns the number of CAN overload frames on the specified channel since start of measurement">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Number of CAN overload frames on the specified channel since start of measurement</return>
    </method>

    <method name="canGetOverloadRate" desc="Returns the current rate of CAN overload frames on the specified channel">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Current rate of CAN overload frames on the specified channel in messages per second</return>
    </method>

    <method name="canGetPeakLoad" desc="Returns the peakload of the specified channel">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Peakload of the specified channel in percent</return>
    </method>

    <method name="canGetRxErrorCount"
            desc="Returns the current RX error count in the receiver of the specified CAN channel">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Current error count in the receiver of the specified CAN channel</return>
    </method>

    <method name="canGetStdData"
            desc="Returns the number of standard CAN frames on the specified channel since start of measurement">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Number of standard CAN frames on the specified channel since start of measurement</return>
    </method>

    <method name="canGetStdDataRate" desc="Returns the current rate of standard CAN frames on the specified channel">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Current rate of standard CAN frames on the specified channel in messages per second</return>
    </method>

    <method name="canGetStdRemote"
            desc="Returns the number of standard remote CAN frames on the specified channel since start of measurement">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Number of standard remote CAN frames on the specified channel since start of measurement</return>
    </method>

    <method name="canGetStdRemoteRate"
            desc="Returns the current rate of standard remote CAN frames of the specified channel">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Current rate of standard remote CAN frames of the specified channel in messages per second</return>
    </method>

    <method name="canGetTxErrorCount"
            desc="Returns the current number of TX errors in the CAN receiver of the specified channel">
        <param name="channel" type="long">
            CAN channel
            Vector API driver Values 1 ... 32
            Softing API driver Values 1, 2
        </param>
        <return type="long">Current number of errors in the CAN receiver of the specified channel</return>
    </method>

    <method name="canSetChannelAcc"
            desc="Via an acceptance filter the CAN controllers control which received messages are sent through to CANoe">
        <param name="channel" type="long">channel</param>
        <param name="code" type="dword">Code for ID filtering</param>
        <param name="mask" type="dword">Mask for ID filtering</param>
        <return type="long">0: ok</return>
    </method>

    <method name="canSetChannelMode"
            desc="Activates/deactivates the TXRQ and Tx of the CAN controller. This function does nothing with the Ack bit">
        <param name="channel" type="long">channel</param>
        <param name="gtx" type="long">
            0: gtx off
            1: gtx on
        </param>
        <param name="gtxreq" type="long">
            0: gtxreq off
            1: gtxreq on
        </param>
        <return type="long">0: ok</return>
    </method>

    <method name="canSetChannelOutput"
            desc="Defines the response of the CAN controller to the bus traffic and sets the ACK bit">
        <param name="channel" type="long">channel</param>
        <param name="silent" type="long">
            0: silent
            1: normal
        </param>
        <return type="long">0: ok</return>
    </method>

    <method name="fileClose" desc="This function closes the specified file">
        <param name="handle" type="dword">The integer contains the handle to the file</param>
        <return type="long">If an error occurs the return value is 0, else 1</return>
    </method>

    <method name="fileClose" desc="The function reads characters from the specified file in binary format">
        <param name="buff[]" type="byte">Buffer</param>
        <param name="buffsize" type="long">Maximum of buffsize characters</param>
        <param name="handle" type="dword">The integer contains the handle to the file</param>
        <return type="long">The function returns the number of characters read</return>
    </method>

    <method name="fileGetString"
            desc="The function reads a string from the specified file into the buffer buff. Characters are read until the end of line is reached or the number of read characters is equal to buffsize -1. The end of line is marked either by a single line feed or a carriage return and a line feed (DOS file)">
        <param name="buff[]" type="char">Buffer for the read-out string</param>
        <param name="buffsize" type="long">Length of the string</param>
        <param name="handle" type="dword">The integer contains the handle to the file</param>
        <return type="long">If an error occurs, the return value is 0, else 1</return>
    </method>

    <method name="fileGetStringSZ"
            desc="The function reads a string from the specified file into the buffer buff. Characters are read until the end of line is reached or the number of read characters is equal to buffsize -1. The end of line is marked either by a single line feed or a carriage return and a line feed (DOS file)">
        <param name="buff[]" type="char">Buffer for the read-out string</param>
        <param name="buffsize" type="long">Length of the string</param>
        <param name="handle" type="dword">The integer contains the handle to the file</param>
        <return type="long">If an error occurs, the return value is 0, else 1</return>
    </method>

    <method name="filePutString" desc="This function writes a string in the specified file">
        <param name="buff[]" type="char">Buffer for the read-out string</param>
        <param name="buffsize" type="long">Length of the string</param>
        <param name="handle" type="dword">The integer contains the handle to the file</param>
        <return type="long">If an error occurs, the return value is 0, else 1</return>
    </method>

    <method name="fileRewind" desc="This function resets the position pointer to the beginning of the file">
        <param name="handle" type="dword">The integer contains the handle to the file</param>
        <return type="long">If an error occurs, the return value is 0, else 1</return>
    </method>

    <method name="fileWriteBinaryBlock" desc="This function writes buffsize bytes in the specified file">
        <param name="buff" type="const byte*">Buffer, with the binary data to be written</param>
        <param name="buffsize" type="long">Number of bytes to be written</param>
        <param name="handle" type="dword">The integer contains the handle to the file</param>
        <return type="long">The function returns the number of bytes written</return>
    </method>

    <method name="getCardType"
            desc="Determines the type of CAN platform being used. Is needed e.g. to program the BTR / OCR values">
        <return type="long">
            17: for Vector drivers
            For other manufacturer other values will be returned
        </return>
    </method>

    <method name="getCardTypeEx"
            desc="Determines the card type of CAN channel. Is needed e.g. to program the BTR / OCR values">
        <param name="channel" type="int">Channel number</param>
        <return type="long">
            Type of board as one of the following values:
            -1: Unknown or Invalid hardware type
            3: DEMO - Demo driver
            25: Vector PCMCIA CANcardXL
            27: Vector USB CANcaseXL
            28: Vector CANcaseXLLog (USB + memory)
            29: Vector CANboardXL PCI
            30: Vector CPCI CANboardXL Compact
            31: Vector CANboardXL PCI express
            33: Vector VN7600
            34: Vector ExpressCard CANcardXLe
            36: Vector VN3300
            37: Vector VN3600
            38: Vector VN2610
            40: Vector VN8950
            41: Remote (IP) Device
            43: Vector VN8910
            46: Vector VN6104
            47: Vector VN8970
            48: Vector VN2640
            49: Vector VN1610
            50: Vector VN1611
            51: Vector VN1630
            52: Vector VN1640
            53: Vector VN5610
            54: Vector VN7570
            55: Vector IP Server
            61: Vector VN7572
            62: Vector VN8972
            63: Vector VN7610
            75: Vector VX1131
        </return>
    </method>

    <method name="getChipType" desc="Determines the type of CAN controller used">
        <param name="channel" type="long">
            Channel:
            0: both controller
            1: Channel 1
            2: Channel 2
        </param>
        <return type="long">
            Type of controller with the following values:
            5: NEC 72005
            200: Philipps PCA82C200
            526: Intel 82526
            527: Intel 82527
            1000,1001: Philipps SJA1000
            Other types may occur. DEMO versions return the result 0 or simulate one of the existing types. If an attempt is made to access a nonexistent channel (e.g. Channel 2 for CPC/PP) or if the driver used does not support this function, the functional result is 0
        </return>
    </method>

    <method name="getDrift" desc="Determines the constant deviation when Drift is set">
        <return type="int">Drift in parts per thousand</return>
    </method>

    <method name="GetEventSortingStatus" desc="Determines the type of CAN controller used">
        <param name="msg" type="Message">Message</param>
        <return type="int">
            0: Invalid state
            1: sorted
            2: unsorted
        </return>
    </method>

    <method name="GetFirstCANdbName" desc="Finds out the name of the first assigned database">
        <param name="buffer[]" type="char">Buffer in which the database name is written</param>
        <param name="size" type="dword">Size of the buffer in Buyte</param>
        <return type="dword">If successful unequal 0, otherwise 0</return>
    </method>

    <method name="getJitterMax" desc="Determines the upper limit for the allowable deviation when Jitter is set">
        <return type="int">Upper deviation in parts per thousand</return>
    </method>

    <method name="getJitterMax" desc="Determines the lower limit for the allowable deviation when Jitter is set">
        <return type="int">Lower deviation in parts per thousand</return>
    </method>

    <method name="GetMessageAttrInt" desc="Determines the type of CAN controller used">
        <param name="canMessage" type="Message">Message variable</param>
        <param name="attributeName[]" type="char">Attribute name</param>
        <return type="long">Value of the attribute (or default value) from the database</return>
    </method>

    <method name="GetMessageName" desc="Finds out the message name">
        <param name="id" type="dword">Id of the message for which the message name should be found</param>
        <param name="context" type="dword">Context of the message</param>
        <param name="buffer[]" type="char">Buffer</param>
        <param name="size" type="dword">Buffer size</param>
        <return type="dword">If successful unequal 0, otherwise 0</return>
    </method>

    <method name="GetNextCANdbName" desc="Finds out the names of the other assigned databases with pos">
        <param name="pos" type="dword">Position number of the database to be found</param>
        <param name="buffer[]" type="char">Buffer in which the database name is written</param>
        <param name="size" type="dword">Size of the buffer in Byte</param>
        <return type="dword">If successful unequal 0, otherwise 0</return>
    </method>

    <method name="getStartdelay"
            desc="Determines the value of the start delay configured for this network node in the Simulation Setup">
        <return type="int">Start delay in ms. If no start delay was set the function returns the value zero</return>
    </method>

    <method name="halt"
            desc="The function stops both the debugged program as well as the simulation. The debugger window opens and the halt() command is displayed. The function thus creates a breakpoint while simultaneously interrupting the measurement in simulated mode (also for test modules). The simulation can be continued with F9. The halt instruction is ignored in Real mode">
        <return type="void"></return>
    </method>

    <method name="inspect"
            desc="This function causes an update of the variables displayed on the Inspect side of the Write window">
        <return type="void"></return>
    </method>

    <method name="isSimulated" desc="This function is used to get the information if CANoe is in simulated mode">
        <return type="long">
            1: True, CANoe is in simulated mode
            0: False, CANoe is in real mode
        </return>
    </method>

    <method name="isStatisticAcquisitionRunning"
            desc="This function is used to test whether an acquisition range has already been started">
        <return type="long">The function returns 1 if an evaluation is already running. Otherwise it returns 0</return>
    </method>

    <method name="isTimerActive"
            desc="Return value indicates whether a specific timer is active. This is the case between the call to the setTimer function and the call to the on timer event procedure">
        <param name="t" type="timer">Timer variable</param>
        <return type="int">1, if the timer is active; otherwise 0. 0 is also returned within the on timer event procedure</return>
    </method>

    <method name="isTimerActive"
            desc="Return value indicates whether a specific timer is active. This is the case between the call to the setTimer function and the call to the on timer event procedure">
        <param name="mst" type="mstimer">Timer variable</param>
        <return type="int">1, if the timer is active; otherwise 0. 0 is also returned within the on timer event procedure</return>
    </method>

    <method name="keypressed"
            desc="This function returns the key code of a currently pressed key. If no key is being pressed it returns 0.. For example, pressing of a key can be queried in a timer function. The reaction can also be to letting go of a key">
        <return type="dword">Key code of pressed key</return>
    </method>

    <method name="MessageTimeNS" desc="Returns the time stamp in nanoseconds">
        <param name="msg" type="Message">CAN message</param>
        <return type="float">Time stamp of the message in ns</return>
    </method>

    <method name="MessageTimeNS" desc="Returns the time stamp in nanoseconds">
        <param name="msg" type="linmessage">LIN frame</param>
        <return type="float">Time stamp of the message in ns</return>
    </method>

    <method name="MessageTimeNS" desc="Returns the time stamp in nanoseconds">
        <param name="msg" type="mostMessage">Message</param>
        <return type="doufloatble">Time stamp of the message in ns</return>
    </method>

    <method name="MessageTimeNS" desc="Returns the time stamp in nanoseconds">
        <param name="msg" type="mostAmsMessage">Message</param>
        <return type="float">Time stamp of the message in ns</return>
    </method>

    <method name="MessageTimeNS" desc="Returns the time stamp in nanoseconds">
        <param name="msg" type="mostRawMessage">Message</param>
        <return type="float">Time stamp of the message in ns</return>
    </method>

    <method name="msgBeep"
            desc="The msgBeep function plays back a sound predefined by the Windows system. It replaces the previous beep function">
        <param name="soundType" type="long">
            Integer for the predefined sound. Specifically these are:
            0: MB_ICONASTERISK SystemAsterisk
            1: MB_ICONEXCLAMATION SystemExclamation
            2: MB_ICONHAND SystemHand
            3: MB_ICONQUESTION SystemQuestion
            4: MB_OK SystemDefault
            5: Standard beep using the PC speaker (default)
        </param>
        <return type="void"></return>
    </method>

    <method name="openFileRead"
            desc="This function opens the file named filename for the read access. If mode=0 the file is opened in ASCII mode, if mode=1 the file is opened in binary mode.">
        <param name="filename[]" type="char">File name</param>
        <param name="mode" type="dword">Mode</param>
        <return type="dword">The return value is the file handle that must be used for read operations. If an error occurs, the return value is 0</return>
    </method>

    <method name="openFileWrite"
            desc="This function opens the file named filename for the read access. If mode=0 the file is opened in ASCII mode, if mode=1 the file is opened in binary mode.">
        <param name="filename[]" type="char">File name</param>
        <param name="mode" type="dword">Mode</param>
        <return type="dword">The return value is the file handle that must be used for write operations If an error occurs, the return value is 0</return>
    </method>

    <method name="DeleteControlContent"
            desc="Deletes the content of the Panel Designer CAPL Output View control. The panel is accessed by its individual panel name that is entered in the Panel Designer">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <return type="void"></return>
    </method>

    <method name="putValueToControlString"
            desc="Puts a string value to the content of the Panel Designer CAPL Output View control. The panel is accessed by its individual panel name that is entered in the Panel Designer">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="value[]" type="char">String value</param>
        <return type="void"></return>
    </method>

    <method name="putValueToControlInt"
            desc="Puts a int value to the content of the Panel Designer CAPL Output View control. The panel is accessed by its individual panel name that is entered in the Panel Designer">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="value" type="long">Int value</param>
        <return type="void"></return>
    </method>

    <method name="putValueToControlIntParagraph"
            desc="Puts a int paragraph value to the content of the Panel Designer CAPL Output View control. The panel is accessed by its individual panel name that is entered in the Panel Designer">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="value" type="long">Int value</param>
        <param name="paragraph" type="long">Paragraph value</param>
        <return type="void"></return>
    </method>

    <method name="putValueToControlIntHex"
            desc="Puts a int value as hex to the content of the Panel Designer CAPL Output View control. The panel is accessed by its individual panel name that is entered in the Panel Designer">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="value" type="long">Int value</param>
        <return type="void"></return>
    </method>

    <method name="putValueToControlDouble"
            desc="Puts a double value to the content of the Panel Designer CAPL Output View control. The panel is accessed by its individual panel name that is entered in the Panel Designer">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="value" type="double">Double value</param>
        <return type="void"></return>
    </method>

    <method name="putValueToControlDoubleParagraph"
            desc="Puts a double paragraph value to the content of the Panel Designer CAPL Output View control. The panel is accessed by its individual panel name that is entered in the Panel Designer">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="value" type="double">Double value</param>
        <param name="paragraph" type="long">Paragraph value</param>
        <return type="void"></return>
    </method>

    <method name="putValueToControlObj"
            desc="Puts a object value to the content of the Panel Designer CAPL Output View control. The panel is accessed by its individual panel name that is entered in the Panel Designer">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="value" type="Message">Object value</param>
        <return type="void"></return>
    </method>

    <method name="putValueToControlInt"
            desc="Puts a object paragraph value to the content of the Panel Designer CAPL Output View control. The panel is accessed by its individual panel name that is entered in the Panel Designer">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="value" type="Message">Object value</param>
        <param name="paragraph" type="long">Paragraph value</param>
        <return type="void"></return>
    </method>

    <method name="putValueToControlInt"
            desc="Puts a object value as hex to the content of the Panel Designer CAPL Output View control. The panel is accessed by its individual panel name that is entered in the Panel Designer">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="value" type="Message">Object value</param>
        <return type="void"></return>
    </method>

    <method name="setPictureBoxImage"
            desc="Replaces the image of the Panel Designer Picture Box control during runtime. The panel is accessed by its individual panel name that is entered in the Panel Designer">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="imagefile[]" type="char">Path and name of the image file</param>
        <return type="void"></return>
    </method>

    <method name="resetCan"
            desc="Resets the CAN controller. Can be used to reset the CAN controller after a BUSOFF or to activate configuration changes. Since execution of the function takes some time and the CAN controller is disconnected from the bus briefly, messages can be lost when this is performed">
        <return type="void"></return>
    </method>

    <method name="ResetCanEx"
            desc="Resets the CAN controller for one specific CAN channel. Can be used to reset the CAN controller after a BUSOFF or to activate configuration changes. Since execution of the function takes a certain amount of time and the CAN controller is disconnected from the bus for a brief period messages may be lost">
        <param name="channel" type="long">CAN channel</param>
        <return type="void"></return>
    </method>

    <method name="runError"
            desc="Triggers a run error. Outputs the error number to the Write Window indicating the error number and the passed number, and then terminates the measurement">
        <param name="err" type="long">Error code</param>
        <param name="value" type="long">Numbers that are represented in CANoe as a references for the user. The values under 1000 are reserved for internal purposes. The second parameter is reserved for future expansions</param>
        <return type="void"></return>
    </method>

    <method name="ScanBaudrateActive"
            desc="The function determines the baud rate for the given channel. Result of the function is written into the Write Window">
        <param name="channel" type="dword">Channel number. (1,..,32)</param>
        <param name="messageID" type="dword">ID of the message that the scanner will send to detect the baud rate. The DLC of the message is always 8</param>
        <param name="firstBaudrate" type="double">Baud rate range to scan (from)</param>
        <param name="lastBaudrate" type="double">Baud rate range to scan (to)</param>
        <param name="timeout" type="dword">Period of time [ms] the scanner waits when the message is sent</param>
        <return type="long">Returns 0 if the scan function was successfully started. Otherwise the return value is non-zero</return>
    </method>

    <method name="ScanBaudratePassive"
            desc="Baud rate scanner checks different baud rates and tries to receive a message on the channel. Function starts the scan and detects the baud rate on the given channel. Result of the function is written into the Write Window">
        <param name="channel" type="dword">Channel number. (1,..,32)</param>
        <param name="messageID" type="dword">ID of the message that the scanner will send to detect the baud rate. The DLC of the message is always 8</param>
        <param name="firstBaudrate" type="double">Baud rate range to scan (from)</param>
        <param name="lastBaudrate" type="double">Baud rate range to scan (to)</param>
        <param name="timeout" type="dword">Period of time [ms] the scanner waits when the message is sent</param>
        <param name="bAcknowledge" type="dword">Acknowledge mode on (1)/off (0). If a wrong baud rate is present, CANoe cannot receive messages and sends an Error Frame, which can be put on the bus using the parameter bAcknowledge. The parameter serves for the fact that CANoe - as a passive receiver - can participate indirectly in the network communication by sending an Error Frame. The parameter does not change the acknowledge settings of the Hardware Configuration dialog. The parameter has an effect only during runtime of the function.</param>
        <return type="long">Returns 0 if the scan function was successfully started. Otherwise the return value is non-zero</return>
    </method>

    <method name="setCanCabsMode" desc="Various CANcabs modes may be set. Replaces the setPortBits functions">
        <param name="type" type="long">Unused, must be set to 0</param>
        <param name="channel" type="long">CAN channel</param>
        <param name="mode" type="long">
            Is used for the control of the board lines via a bit pattern. Mode, valid values:
            0: NORMAL
            1: SLEEP
            2: HIVOLTAGE
            3: HISPEED
            4: DUAL_WIRE
            5: SINGLE_WIRE_LOW
            6: SINGLE_WIRE_HIGH
            7: is reserved
        </param>
        <param name="flags" type="long">Is used for the control of the board lines via a bit pattern</param>
        <return type="long">0: ok</return>
    </method>

    <method name="setDrift"
            desc="A constant deviation can be set for the timers of a network node with this function. Inputs for the two values may lie between 10000 and 10000 (corresponds to 100.00% to 100.00%). If the value does not lie within this range, a message is output in the Write Window">
        <param name="drift" type="int">Value for the constant deviation</param>
        <return type="void"></return>
    </method>

    <method name="setJitter"
            desc="The Jitter interval for the timers of a network node can be set with this function. The two values may lie between 10000 and 10000 (corresponds to 100.00% to 100.00%). If one of the two values does not lie within this range, a message is output in the Write Window">
        <param name="min" type="int">Value for the lower interval limit</param>
        <param name="max" type="int">Value for the upper interval limit</param>
        <return type="void"></return>
    </method>

    <method name="setLogFileName"
            desc="The Jitter interval for the timers of a network node can be set with this function. The two values may lie between 10000 and 10000 (corresponds to 100.00% to 100.00%). If one of the two values does not lie within this range, a message is output in the Write Window">
        <param name="fileName[]" type="char">File name path</param>
        <return type="void"></return>
    </method>

    <method name="setOcr"
            desc="Sets the Output Control Register. The values do not become active until the next call of the function resetCan()">
        <param name="channel" type="long">channel  0 - all channels; > 0 - only the given channel</param>
        <param name="OCR" type="byte">Value of the Output Control Register</param>
        <return type="void"></return>
    </method>

    <method name="setPostTrigger"
            desc="Sets the posttrigger of the logging. The posttrigger set with this function is valid until the end of the measurement or until the next call of this function">
        <param name="value" type="long">New posttrigger value in milliseconds. If a value of -1 is supplied, the prosttrigger will be set to infinity</param>
        <return type="void"></return>
    </method>

    <method name="setPreTrigger"
            desc="Sets the pretrigger of the logging. The pretrigger set with this function is valid until the end of the measurement or until the next call of this function">
        <param name="value" type="long">New pretrigger value in milliseconds</param>
        <return type="void"></return>
    </method>

    <method name="setWriteDbgLevel"
            desc="This function sets the priority level for the writeDbgLevel CAPL function. The output priority must be set for every network node">
        <param name="priority" type="WORD">
            Priority of current CAPL node for output to the Write Window. Rays for priority: 0 to 15
            0 - Only write output with a priority of 0 are shown in the Write Window.
            5 - Write output with a priority ranging from 0 to 5 are shown.
            15 - All outputs are shown
        </param>
        <return type="void"></return>
    </method>

    <method name="SetControlProperty" desc="Sets a property of a Panel Editor ActiveX control">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="property[]" type="char">Name of the property</param>
        <param name="value[]" type="char">Value to be set</param>
        <return type="void"></return>
    </method>

    <method name="SetControlProperty" desc="Sets a property of a Panel Editor ActiveX control">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="property[]" type="char">Name of the property</param>
        <param name="value" type="long">Value to be set</param>
        <return type="void"></return>
    </method>

    <method name="SetControlProperty" desc="Sets a property of a Panel Editor ActiveX control">
        <param name="panel[]" type="char">Panel name, restricted to 128 characters. "" references all panels</param>
        <param name="control[]" type="char">Name of the CAPL Output View control, restricted to 128 characters. "" references all CAPL Output View controls on the panel</param>
        <param name="property[]" type="char">Name of the property</param>
        <param name="value" type="float">Value to be set</param>
        <return type="void"></return>
    </method>

    <method name="setTimer" desc="Sets a timer">
        <param name="timer" type="timer">The timer to be set</param>
        <param name="time" type="long">Time in milliseconds in which the timer is restarted in case of expiration</param>
        <return type="void"></return>
    </method>

    <method name="setTimer" desc="Sets a timer">
        <param name="timer" type="timer">The timer to be set</param>
        <param name="firstDuration" type="long">Time in milliseconds until the timer runs out for the first time</param>
        <param name="period" type="long">Time in milliseconds in which the timer is restarted in case of expiration</param>
        <return type="void"></return>
    </method>

    <method name="setTimerCyclic" desc="Sets a cyclical timer">
        <param name="timer" type="msTimer">The timer to be set</param>
        <param name="time" type="long">Time in milliseconds in which the timer is restarted in case of expiration</param>
        <return type="void"></return>
    </method>

    <method name="setTimerCyclic" desc="Sets a cyclical timer">
        <param name="timer" type="msTimer">The timer to be set</param>
        <param name="firstDuration" type="long">Time in milliseconds until the timer runs out for the first time</param>
        <param name="period" type="long">Time in milliseconds in which the timer is restarted in case of expiration</param>
        <return type="void"></return>
    </method>

    <method name="startLogging" desc="Starts all Logging Blocks immediately bypassing all logging trigger settings">
        <return type="void"></return>
    </method>

    <method name="startLogging" desc="Starts logging Block by name">
        <param name="strLoggingBlockName[]" type="char">Name of the Logging Block</param>
        <return type="void"></return>
    </method>

    <method name="startLogging" desc="Starts logging Block by name and time interval">
        <param name="strLoggingBlockName[]" type="char">Name of the Logging Block</param>
        <param name="preTriggerTime" type="long">Pre-trigger time interval in ms</param>
        <return type="void"></return>
    </method>

    <method name="stopLogging" desc="Stops all Logging Blocks immediately bypassing all logging trigger settings">
        <return type="void"></return>
    </method>

    <method name="stopLogging" desc="Stops logging Block by name">
        <param name="strLoggingBlockName[]" type="char">Name of the Logging Block</param>
        <return type="void"></return>
    </method>

    <method name="stopLogging" desc="Stops logging Block by name and time interval">
        <param name="strLoggingBlockName[]" type="char">Name of the Logging Block</param>
        <param name="postTriggerTime" type="long">Post-trigger time interval in ms</param>
        <return type="void"></return>
    </method>

    <method name="StartMacroFile" desc="Starts playing the macro with the fileName">
        <param name="fileName[]" type="char">Macro file path</param>
        <return type="dword">The returned handle is required to stop the macro playback</return>
    </method>

    <method name="StartReplayFile"
            desc="Starts playing the replay file with the name fileName. This function replays events of the following types:\n
	CAN messages\n
	CAN Error Frames\n
	CAN overload frames (not sent, only visible in Measurement Setup)\n
	J1708 messages\n
	Ethernet packets\n
	WLAN packets\n
	AFDX packets\n
	Diagnostic requests\n
	GPS events\n
	Signal values\n
	System variable updates\n
	Environment variable updates">
        <param name="fileName[]" type="char">Replay file</param>
        <return type="dword">The returned handle is required to stop the replay file</return>
    </method>

    <method name="StopMacroFile" desc="Stops the macro from playing with the handle">
        <param name="handle" type="dword">Handle of the started macro</param>
        <return type="void"></return>
    </method>

    <method name="StopReplayFile" desc="Stops the replay file from playing with the handle">
        <param name="handle" type="dword">Handle of the started replay file</param>
        <return type="void"></return>
    </method>

    <method name="stopStatisticAcquisition"
            desc="A started acquisition range is stopped with this function. If no acquisition range has been started yet, this function has no effect">
        <return type="void"></return>
    </method>

    <method name="sysExit" desc="Exits the system (CANoe) from within a CAPL program">
        <return type="void"></return>
    </method>

    <method name="sysMinimize"
            desc="The application window of CANoe will be minimized or restored. The first call of the function minimizes the window, afterwards the window will be restored to normal size and minimized alternaltly">
        <return type="void"></return>
    </method>

    <method name="timeDiff"
            desc="Time difference between messages or between a message and the current time in ms (msg2 - msg1 or now - msg1). Starting with CANalyzer 2.xx this difference can be calculated directly (Units of 10 microseconds)">
        <param name="msg1" type="Message">First message</param>
        <return type="long">Time difference in ms</return>
    </method>

    <method name="timeDiff"
            desc="Time difference between messages or between a message and the current time in ms (msg2 - msg1 or now - msg1). Starting with CANalyzer 2.xx this difference can be calculated directly (Units of 10 microseconds)">
        <param name="msg1" type="Message">First message</param>
        <param name="msg2" type="Message">Second message</param>
        <return type="long">Time difference in ms</return>
    </method>

    <method name="timeNow"
            desc="Supplies the current simulation time (maximum time: .2^32 * 10 microseconds = 11 hours, 55 minutes, 49 seconds, 672 milliseconds, 96 microseconds)\n
The simulation time can be correlated with the hardware results of the interface cards (e.g. CANcardXL).\n
The resolution of this time is dependent upon the hardware used (usually a millisecond or better).\n
Depending on the hardware configuration, the simulation time\n
will be the same as the message time calculated by the interface cards\n
(e.g., system with two CAN channels connected to one CANcardXL)\n
	or\n
the message times will have a higher accuracy">
        <return type="dword">Simulation time in 10 microseconds</return>
    </method>

    <method name="timeNowFloat"
            desc="Supplies the current simulation time (maximum time: .2^32 * 10 microseconds = 11 hours, 55 minutes, 49 seconds, 672 milliseconds, 96 microseconds)\n
The simulation time can be correlated with the hardware results of the interface cards (e.g. CANcardXL).\n
The resolution of this time is dependent upon the hardware used (usually a millisecond or better).\n
Depending on the hardware configuration, the simulation time\n
will be the same as the message time calculated by the interface cards\n
(e.g., system with two CAN channels connected to one CANcardXL)\n
	or\n
the message times will have a higher accuracy">
        <return type="double">Simulation time in 10 microseconds</return>
    </method>

    <method name="timeNowNS"
            desc="Supplies the current simulation time (maximum time: .2^32 * 10 microseconds = 11 hours, 55 minutes, 49 seconds, 672 milliseconds, 96 microseconds)\n
The simulation time can be correlated with the hardware results of the interface cards (e.g. CANcardXL).\n
The resolution of this time is dependent upon the hardware used (usually a millisecond or better).\n
Depending on the hardware configuration, the simulation time\n
will be the same as the message time calculated by the interface cards\n
(e.g., system with two CAN channels connected to one CANcardXL)\n
	or\n
the message times will have a higher accuracy">
        <return type="double">Simulation time in 10 microseconds</return>
    </method>

    <method name="timeNowInt64"
            desc="Supplies the current simulation time (maximum time: .2^32 * 10 microseconds = 11 hours, 55 minutes, 49 seconds, 672 milliseconds, 96 microseconds)\n
The simulation time can be correlated with the hardware results of the interface cards (e.g. CANcardXL).\n
The resolution of this time is dependent upon the hardware used (usually a millisecond or better).\n
Depending on the hardware configuration, the simulation time\n
will be the same as the message time calculated by the interface cards\n
(e.g., system with two CAN channels connected to one CANcardXL)\n
	or\n
the message times will have a higher accuracy">
        <return type="int64">Simulation time in 10 microseconds</return>
    </method>

    <method name="timeToElapse"
            desc="Returns a value indicating how much more time will elapse before an on timer event procedure is called">
        <param name="t" type="timer">Timer</param>
        <return type="long">Time to go until the timer elapses and the event procedure is called</return>
    </method>

    <method name="timeToElapse"
            desc="Returns a value indicating how much more time will elapse before an on timer event procedure is called">
        <param name="mst" type="msTimer">MSTimer</param>
        <return type="long">Time to go until the timer elapses and the event procedure is called</return>
    </method>

    <method name="traceSetEventColors" desc="Sets the text and background color for displaying msg in the Trace Window">
        <param name="variable" type="Message">Variable type: message, errorFrame, pg, linMessage, mostRawMessage, mostMessage, mostAmsMessage, frFrame, frError, frameError, nullFrame, pdu, pocState, slot, symbol, startCycle</param>
        <return type="long">Time to go until the timer elapses and the event procedure is called</return>
    </method>

    <method name="trigger"
            desc="Sends a trigger event to all CANoe Logging or Trigger Blocks\n
For a Logging Block, the trigger event starts and stops logging, depending on\n
	the trigger mode (single or toggle trigger)\n
	the trigger conditions for toggle on and toggle off">
        <return type="void"></return>
    </method>

    <method name="triggerEx"
            desc="Sends a trigger event to all CANoe Logging or Trigger Blocks\n
For a Logging Block, the trigger event starts and stops logging, depending on\n
	the trigger mode (single or toggle trigger)\n
	the trigger conditions for toggle on and toggle off">
        <param name="name[]" type="char">Name of the Logging or Trigger Block</param>
        <return type="void"></return>
    </method>

    <method name="writeCreate"
            desc="Generates a new page in the Write Window with the specified name. The page is automatically deleted the next time a measurement starts">
        <param name="name[]" type="char">Name of the page to be generated</param>
        <return type="dword">Sink identifier that is valid for output to the new page</return>
    </method>

    <method name="writeDestroy"
            desc="Removes the specified page from the Write Window. Only pages that have been created with the aid of the writeCreate function can be removed">
        <param name="sink" type="dword">Target identifier for the page to be removed</param>
        <return type="void"></return>
    </method>

    <method name="writeClear" desc="Clears the contents of the specified page in the Write Window">
        <param name="sink" type="dword">Target identifier for the page to be cleared</param>
        <return type="void"></return>
    </method>

    <method name="write" desc="Clears the contents of the specified page in the Write Window">
        <param name="Format[]" type="char">
            String, variables or expressions. Legal format expressions:
            "%ld","%d" decimal display
            "%lx","%x" hexadecimal display
            "%lX","%X" hexadecimal display (upper case)
            "%lu","%u" unsigned display
            "%lo","%o" octal display
            "%s" display a string
            "%g","%f" floating point displa e.g. %5.3f means, 5 digits in total (decimal point inclusive) and 3 digits after the decimal point. 5 is the minimum of digits in this case.
            "%c" display a character
            "%%" display %-character
            "%I64d","%lld" decimal display of a 64 bit value
            "%I64x","%llx hexadecimal display of a 64 bit value
            "%I64X","%llX" hexadecimal display of a 64 bit value (upper case)
            "%I64u","%llu" unsigned display of a 64 bit value
            "%I64o","%llo" octal display of a 64 bit value
        </param>
        <param name="..." type=""></param>
        <return type="void"></return>
    </method>

    <method name="writeEx"
            desc="Writes the text into the last line of the specified CANoe window, into a page of the Write Window or into a logging file without previously creating a new line">
        <param name="sink" type="long">
            Sink identifier of the page to which the output will take place. Values:
            -3 Trace Window
            -2 Output to the logging file (only in ASC format and if the CAPL node is inserted in the Measurement Setup in front of the Logging Block)
            -1 Reserved
            0 Output to the System page of the Write Window
            1 Output to the CAPL page of the Write Window
            4 Output to the Test page of the Write Window
        </param>
        <param name="severity" type="dword">
            Constant for the type of message. Values:
            0 Success
            1 Information
            2 Warning
            3 Error
        </param>
        <param name="format[]" type="char">Formatting character sequence</param>
        <param name="..." type=""></param>
        <return type="void"></return>
    </method>

    <method name="writeLineEx"
            desc="Writes the text into a new line of the specified window, into a page of the CANoe Write Window or into a logging file">
        <param name="sink" type="dword">
            Sink identifier of the page to which the output will take place. Values:
            -3 Trace Window
            -2 Output to the logging file (only in ASC format and if the CAPL node is inserted in the Measurement Setup in front of the Logging Block)
            -1 Reserved
            0 Output to the System page of the Write Window
            1 Output to the CAPL page of the Write Window
            4 Output to the Test page of the Write Window
        </param>
        <param name="severity" type="dword">
            Constant for the type of message. Values:
            0 Success
            1 Information
            2 Warning
            3 Error
        </param>
        <param name="format[]" type="char">Formatting character sequence</param>
        <param name="..." type=""></param>
        <return type="void"></return>
    </method>

    <method name="writeTextBkgColor"
            desc="Sets the color for text background of the specified page in the Write Window">
        <param name="sink" type="dword">The target identifier of the page on which the color settings should have an effect</param>
        <param name="red" type="dword">Specifies the intensity of the red color</param>
        <param name="green" type="dword">Specifies the intensity of the green color</param>
        <param name="blue" type="dword">Specifies the intensity of the blue color</param>
        <return type="void"></return>
    </method>

    <method name="writeTextColor" desc="Sets the color for text of the specified page in the Write Window">
        <param name="sink" type="dword">The target identifier of the page on which the color settings should have an effect</param>
        <param name="red" type="dword">Specifies the intensity of the red color</param>
        <param name="green" type="dword">Specifies the intensity of the green color</param>
        <param name="blue" type="dword">Specifies the intensity of the blue color</param>
        <return type="void"></return>
    </method>

    <method name="writeToLog"
            desc="Writes an output string to an ASCII logging file. Write is based on the C function printf">
        <param name="Format[]" type="char">
            String, variables or expressions. Legal format expressions:
            "%ld","%d" decimal display
            "%lx","%x" hexadecimal display
            "%lX","%X" hexadecimal display (upper case)
            "%lu","%u" unsigned display
            "%lo","%o" octal display
            "%s" display a string
            "%g","%f" floating point displa e.g. %5.3f means, 5 digits in total (decimal point inclusive) and 3 digits after the decimal point. 5 is the minimum of digits in this case.
            "%c" display a character
            "%%" display %-character
            "%I64d","%lld" decimal display of a 64 bit value
            "%I64x","%llx hexadecimal display of a 64 bit value
            "%I64X","%llX" hexadecimal display of a 64 bit value (upper case)
            "%I64u","%llu" unsigned display of a 64 bit value
            "%I64o","%llo" octal display of a 64 bit value
        </param>
        <param name="..." type=""></param>
        <return type="void"></return>
    </method>

    <method name="writeToLogEx"
            desc="Writes an output string to an ASCII logging file. Write is based on the C function printf">
        <param name="Format[]" type="char">
            String, variables or expressions. Legal format expressions:
            "%ld","%d" decimal display
            "%lx","%x" hexadecimal display
            "%lX","%X" hexadecimal display (upper case)
            "%lu","%u" unsigned display
            "%lo","%o" octal display
            "%s" display a string
            "%g","%f" floating point displa e.g. %5.3f means, 5 digits in total (decimal point inclusive) and 3 digits after the decimal point. 5 is the minimum of digits in this case.
            "%c" display a character
            "%%" display %-character
            "%I64d","%lld" decimal display of a 64 bit value
            "%I64x","%llx hexadecimal display of a 64 bit value
            "%I64X","%llX" hexadecimal display of a 64 bit value (upper case)
            "%I64u","%llu" unsigned display of a 64 bit value
            "%I64o","%llo" octal display of a 64 bit value
        </param>
        <param name="..." type=""></param>
        <return type="void"></return>
    </method>

    <method name="writeDbgLevel"
            desc="Outputs a message to the Write Window with the specified priority. This function can be used for debugging to vary the output to the Write Window. This function is especially useful if nodelayer-DLL's are used">
        <param name="priority" type="dword">Output priority from 0 to 15</param>
        <param name="Format[]" type="char">
            Format string, variables or expressions. legal format expressions:
            "%ld", "%d" decimal display
            "%lx", "%x" hexadecimal display
            "%lX", "%X" hexadecimal display (upper case)
            "%lu", "%u" unsigned display
            "%lo", "%o" octal display
            "%s" display a string
            "%g", "%lf" floating point display
            "%c" display a character
            "%%" display %-character
        </param>
        <param name="..." type=""></param>
        <return type="void"></return>
    </method>

    <method name="validatePlugin" desc="">
        <return type="bool"></return>
    </method>

    <method name="swapWord"
            desc="Swaps bytes of parameters. CAPL arithmetics follows the 'little-endian-format' (Intel). The swap-functions serve for swapping bytes for the transition to and from the 'big-endian-format' (Motorola)">
        <param name="in" type="WORD">Value whose bytes are to be swapped</param>
        <return type="WORD">Value with swapped bytes</return>
    </method>

    <method name="swapInt"
            desc="Swaps bytes of parameters. CAPL arithmetics follows the 'little-endian-format' (Intel). The swap-functions serve for swapping bytes for the transition to and from the 'big-endian-format' (Motorola)">
        <param name="in" type="int">Value whose bytes are to be swapped</param>
        <return type="int">Value with swapped bytes</return>
    </method>

    <method name="swapDWord"
            desc="Swaps bytes of parameters. CAPL arithmetics follows the 'little-endian-format' (Intel). The swap-functions serve for swapping bytes for the transition to and from the 'big-endian-format' (Motorola)">
        <param name="in" type="dword">Value whose bytes are to be swapped</param>
        <return type="dword">Value with swapped bytes</return>
    </method>

    <method name="swapQWord"
            desc="Swaps bytes of parameters. CAPL arithmetics follows the 'little-endian-format' (Intel). The swap-functions serve for swapping bytes for the transition to and from the 'big-endian-format' (Motorola)">
        <param name="in" type="qword">Value whose bytes are to be swapped</param>
        <return type="qword">Value with swapped bytes</return>
    </method>

    <method name="swapLong"
            desc="Swaps bytes of parameters. CAPL arithmetics follows the 'little-endian-format' (Intel). The swap-functions serve for swapping bytes for the transition to and from the 'big-endian-format' (Motorola)">
        <param name="in" type="long">Value whose bytes are to be swapped</param>
        <return type="long">Value with swapped bytes</return>
    </method>

    <method name="swapInt64"
            desc="Swaps bytes of parameters. CAPL arithmetics follows the 'little-endian-format' (Intel). The swap-functions serve for swapping bytes for the transition to and from the 'big-endian-format' (Motorola)">
        <param name="in" type="int64">Value whose bytes are to be swapped</param>
        <return type="int64">Value with swapped bytes</return>
    </method>

    <method name="TalkNM" desc="Activates network management, enabling participation in the ring">
        <return type="void"></return>
    </method>

    <method name="SilentNM"
            desc="This call results in network management no longer participating in the ring and no longer observing incoming messages">
        <return type="void"></return>
    </method>

    <method name="GotoMode_BusSleep"
            desc="This function indicates to network management that the application is ready to sleep">
        <return type="void"></return>
    </method>

    <method name="GotoMode_Awake"
            desc="This function can be used while network management is running to reverse the ready-to-sleep status of the application. If the application is already asleep, this function should be called in order to initialize network management. The function is then generally called from the apCanWakeUp function">
        <return type="void"></return>
    </method>

    <method name="linSendWakeup"
            desc="This command is used to send Wakeup frames. Wakeup frames can only be sent while the LIN hardware is in Sleep mode. If no parameters are given, the default values of the parameters are used">
        <param name="ttobrk" type="long">
            This parameter specifies the time difference between the transmissions of two consecutive Wakeup frames, i.e. the time between end of one wake-up frame and start of the next one
            Units of this parameter as well as default value depend on the hardware settings (see Hardware Configuration: LIN)
            Value range (for units expected in bit times): 20 .. 50000
            Value range (for units expected in ms): 1 .. 65536
        </param>
        <param name="count" type="long">
            Sets the number of Wakeup frame retransmissions
            Value range: 1...255
            Default value depends on the hardware settings: see Hardware Configuration: LIN
        </param>
        <param name="length" type="long">
            This parameter sets the length of the wake-up frame to be sent in microseconds. The resolution is 50's
            This parameter is only used by LIN2.x slave nodes
            Value range: 250...5000's
            Default value depends on the hardware settings: see Hardware Configuration: LIN
        </param>
        <return type="long">On success, a value unequal to zero, otherwise zero</return>
    </method>

    <method name="linChangeSchedTable" desc="This function switches from the current schedule table to another one">
        <param name="tableIndex" type="long">Index of the schedule table to be changed to. Value range: 0..N-1, where N is a total number of  defined schedule tables</param>
        <param name="slotIndex" type="long">Index of slot to be started within the new schedule table. Default value: 0. Value range: 0..Y-1, where Y is a total number of slots in the new schedule table</param>
        <param name="onSlotIndex" type="long">
            Index of last slot in the current schedule table to be sent before changing to the new schedule table. Default value: -2 - makes change immediately
            Value range: -2..X-1, where X is a total number of slots in the current schedule table
            Value: -1 - makes change on reaching the end of current schedule table
            Value: -2 - makes change immediately
        </param>
        <return type="long">Index of the current schedule table or -1 if no active schedule table exists and on failure</return>
    </method>

    <method name="linSendSleepModFrm" desc="This function leads to a transmission of a go-to-sleep-command">
        <param name="silent" type="long">When this flag is set the LIN hardware switches to Sleep mode without sending a go-to-sleep-command before</param>
        <param name="restartScheduler" type="long">Determines if index of the slot to be started with after wake-up has to be reset, i.e. it becomes 0</param>
        <param name="wakeupIdentifier" type="long">LIN frame identifier to be sent additionally directly after sending a wake-up signal</param>
        <return type="long">On success, a value unequal to zero, otherwise zero</return>
    </method>

    <method name="linGetProtectedID"
            desc="With this function it is possible to calculate protected ID for the corresponding LIN frame identifier (i.e. the frame identifier with parity bits)">
        <param name="silent" type="long">LIN frame identifier whose protected ID will be calculated. Value range: 0 .. 63</param>
        <return type="long">Returns the calculated protected identifier or -1 on failure</return>
    </method>

    <method name="IsRunningOnRemoteKernel"
            desc="This function is used to get the information whether the CAPL code is executed on the local PC or by a runtime kernel running on a remote device (VN8900/CANoe RT Server)">
        <return type="long">
            1 : True (execution on remote runtime kernel)
            0 : False (execution on local PC)
        </return>
    </method>

    <method name="strtoul"
            desc="Converts the string s to an unsigned 32bit integer. The number base is hexadecimal if the string starts with 0x, octal if it starts with 0, decimal otherwise. Whitespace (spaces or tabs) at the start of the string is ignored">
        <param name="s[]" type="char">String to be converted</param>
        <param name="result" type="dword">Contains the converted value after the call. The value is 0 if the string can't be converted to a number. It is the largest possible positive/negative number in case of overflow</param>
        <return type="long">
            -2: If s is empty or startIndex is larger than strlen(s)
            -1: An overflow occurs
            Otherwise, returns the index of the first character after the number
        </return>
    </method>

    <method name="strtoul"
            desc="Converts the string s to an unsigned 32bit integer. The number base is hexadecimal if the string starts with 0x, octal if it starts with 0, decimal otherwise. Whitespace (spaces or tabs) at the start of the string is ignored">
        <param name="s[]" type="char">String to be converted</param>
        <param name="startIndex" type="dword">Position in s where the conversion shall begin</param>
        <param name="result" type="dword">Contains the converted value after the call. The value is 0 if the string can't be converted to a number. It is the largest possible positive/negative number in case of overflow</param>
        <return type="long">
            -2: If s is empty or startIndex is larger than strlen(s)
            -1: An overflow occurs
            Otherwise, returns the index of the first character after the number
        </return>
    </method>

    <method name="strtoull"
            desc="Converts the string s to an unsigned 64bit integer. The number base is hexadecimal if the string starts with 0x, octal if it starts with 0, decimal otherwise. Whitespace (spaces or tabs) at the start of the string is ignored">
        <param name="s[]" type="char">String to be converted</param>
        <param name="result" type="qword">Contains the converted value after the call. The value is 0 if the string can't be converted to a number. It is the largest possible positive/negative number in case of overflow</param>
        <return type="long">
            -2: If s is empty or startIndex is larger than strlen(s)
            -1: An overflow occurs
            Otherwise, returns the index of the first character after the number
        </return>
    </method>

    <method name="strtoull_index"
            desc="Converts the string s to an unsigned 64bit integer. The number base is hexadecimal if the string starts with 0x, octal if it starts with 0, decimal otherwise. Whitespace (spaces or tabs) at the start of the string is ignored">
        <param name="s[]" type="char">String to be converted</param>
        <param name="startIndex" type="dword">Position in s where the conversion shall begin</param>
        <param name="result" type="qword">Contains the converted value after the call. The value is 0 if the string can't be converted to a number. It is the largest possible positive/negative number in case of overflow</param>
        <return type="long">
            -2: If s is empty or startIndex is larger than strlen(s)
            -1: An overflow occurs
            Otherwise, returns the index of the first character after the number
        </return>
    </method>

    <method name="strstr_regex" desc="Searches for a regular expression pattern in a string">
        <param name="s[]" type="char">String to be searched</param>
        <param name="pattern[]" type="char">Regular expression which is searched. For the regular expression, the same syntax is used as in the Perl programming language</param>
        <return type="long">The position in s where the pattern was found, or -1 if it wasn't found</return>
    </method>

    <method name="strstr_regex_off" desc="Searches for a regular expression pattern in a string">
        <param name="s[]" type="char">String to be searched</param>
        <param name="offset" type="dword">Offset in s at which the search shall be started</param>
        <param name="pattern[]" type="char">Regular expression which is searched. For the regular expression, the same syntax is used as in the Perl programming language</param>
        <return type="long">The position in s where the pattern was found, or -1 if it wasn't found</return>
    </method>

    <method name="str_replace" desc="Replaces all occurrences of a text in a string with another string">
        <param name="s[]" type="char">String to be modified</param>
        <param name="searched[]" type="char">Text which shall be replaced</param>
        <param name="replacement[]" type="char">Text which replaces the original characters</param>
        <return type="long">1 if successful, 0 if the resulting string would be too long for the buffer s</return>
    </method>

    <method name="str_replace_off" desc="Replaces all occurrences of a text in a string with another string">
        <param name="s[]" type="char">String to be modified</param>
        <param name="offset" type="dword">Offset at which to start replacing characters</param>
        <param name="replacement[]" type="char">Text which replaces the original characters</param>
        <param name="length" type="dword">Maximum number of characters to replace</param>
        <return type="long">1 if successful, 0 if the resulting string would be too long for the buffer s</return>
    </method>

    <method name="getConfigurationName"
            desc="Returns the file name of the currently loaded configuration. It includes neither the file extension nor any path information, for example CANSystemDemo">
        <param name="buffer[]" type="char">Space for the returned name</param>
        <param name="bufferLength" type="dword">Length of the buffer</param>
        <return type="long">-1 Buffer too small. >= 0 Operation successful. The return value specifies the length of the configuration name</return>
    </method>

    <method name="convertTimestamp" desc="Converts a time stamp to separate parts">
        <param name="timestamp" type="dword">Time stamp in nanoseconds</param>
        <param name="days" type="dword">Receives the days of the time stamp</param>
        <param name="hours" type="byte">Receives the hours the time stamp (between 0 and 23)</param>
        <param name="minutes" type="byte">Receives the minutes of the time stamp (between 0 and 59)</param>
        <param name="seconds" type="byte">Receives the seconds of the time stamp (between 0 and 59)</param>
        <param name="milliseconds" type="word">Receives the milliseconds of the time stamp (between 0 and 999)</param>
        <param name="microseconds" type="word">Receives the microseconds of the time stamp (between 0 and 999)</param>
        <return type="void"></return>
    </method>

    <method name="convertTimestamp" desc="Converts a time stamp to separate parts">
        <param name="timestamp" type="qword">Time stamp in 10 microseconds</param>
        <param name="days" type="dword">Receives the days of the time stamp</param>
        <param name="hours" type="dword">Receives the hours the time stamp (between 0 and 23)</param>
        <param name="minutes" type="dword">Receives the minutes of the time stamp (between 0 and 59)</param>
        <param name="seconds" type="dword">Receives the seconds of the time stamp (between 0 and 59)</param>
        <param name="milliseconds" type="dword">Receives the milliseconds of the time stamp (between 0 and 999)</param>
        <param name="microseconds" type="dword">Receives the microseconds of the time stamp (between 0 and 999)</param>
        <return type="void"></return>
    </method>

    <method name="str_match_regex" desc="Checks whether a string completely matches a regular expression pattern">
        <param name="s[]" type="char">String to be checked</param>
        <param name="pattern[]" type="char">Regular expression against which the string is matched. For the regular expression, the same syntax is used as in the Perl programming language</param>
        <return type="long">1 if the string matches the pattern, 0 if it doesn't match the pattern</return>
    </method>

    <method name="toUpperChar"
            desc="Transforms a character or string to upper case. Only characters a-z and A-Z are supported">
        <param name="c" type="char">Character to be transformed</param>
        <return type="char">Character to be transformed</return>
    </method>

    <method name="toUpperInternal"
            desc="Transforms a character or string to upper case. Only characters a-z and A-Z are supported">
        <param name="buffer[]" type="char">Destination buffer for the transformed string</param>
        <param name="source[]" type="char">String to be transformed</param>
        <param name="bufferSize" type="dword">Size of the destination buffer</param>
        <param name="sourceSize" type="dword">Size of the source buffer</param>
        <return type="char">Character to be transformed</return>
    </method>

    <method name="interpretAsFloat"
            desc="These functions interpret the actual bytes of a value as if the value was of another data type">
        <param name="x" type="float">The number which shall be interpreted</param>
        <return type="dword">The interpreted value</return>
    </method>

    <method name="interpretAsDword"
            desc="These functions interpret the actual bytes of a value as if the value was of another data type">
        <param name="x" type="dword">The number which shall be interpreted</param>
        <return type="float">The interpreted value</return>
    </method>

    <method name="interpretAsDouble"
            desc="These functions interpret the actual bytes of a value as if the value was of another data type">
        <param name="x" type="double">The number which shall be interpreted</param>
        <return type="qword">The interpreted value</return>
    </method>

    <method name="interpretAsQword"
            desc="These functions interpret the actual bytes of a value as if the value was of another data type">
        <param name="x" type="qword">The number which shall be interpreted</param>
        <return type="double">The interpreted value</return>
    </method>

    <method name="interpret"
            desc="These functions interpret the actual bytes of a value as if the value was of another data type">
        <param name="x" type="EnvVar">Value</param>
        <return type="dword">The interpreted value</return>
    </method>

    <method name="interpret"
            desc="These functions interpret the actual bytes of a value as if the value was of another data type">
        <param name="x" type="EnvVar">Value</param>
        <return type="float">The interpreted value</return>
    </method>

    <method name="interpret"
            desc="These functions interpret the actual bytes of a value as if the value was of another data type">
        <param name="x" type="EnvVar">Value</param>
        <return type="qword">The interpreted value</return>
    </method>

    <method name="interpret"
            desc="These functions interpret the actual bytes of a value as if the value was of another data type">
        <param name="x" type="EnvVar">Value</param>
        <return type="double">The interpreted value</return>
    </method>

    <method name="ReplayState" desc="Returns the state of the Replay Block with the name">
        <param name="name[]" type="char">Name of the Replay Block</param>
        <return type="dword">
            0: Replay Block is stopped (state: stopped)
            1: Execution of the Replay file was started (state: running)
            2: Execution of the Replay file was stopped (state: suspended)
            -1: when the Replay Block does not exist
        </return>
    </method>

    <method name="ReplayStart" desc="Starts the Replay Block with the name">
        <param name="name[]" type="char">Name of the Replay Block</param>
        <return type="dword">
            1: If successful
            0: If the Replay Block does not exist or cannot be restarted
        </return>
    </method>

    <method name="ReplayStop" desc="Stops the Replay Block with the name">
        <param name="name[]" type="char">Name of the Replay Block</param>
        <return type="dword">
            1: If successful
            0: If the Replay Block does not exist or cannot be stoped
        </return>
    </method>

    <method name="ReplaySuspend" desc="Suspends the Replay Block with the name">
        <param name="name[]" type="char">Name of the Replay Block</param>
        <return type="dword">
            1: If successful
            0: If the Replay Block does not exist or cannot be suspended
        </return>
    </method>

    <method name="ReplayResume" desc="Starts the Replay Block with the name after it is suspended by ReplaySuspend">
        <param name="name[]" type="char">Name of the Replay Block</param>
        <return type="dword">
            1: If successful
            0: If the Replay Block does not exist or cannot be started
        </return>
    </method>

    <method name="ILControlInit"
            desc="Initialization of CANoe IL. This function may only be used in on preStart to prevent the IL autostart function">
        <return type="long">
            0: No error
            -1: Momentary state of the IL does not permit this query
            -50: Node layer is inactive: possibly deactivated in the node's configuration dialog
        </return>
    </method>

    <method name="ILControlStart"
            desc="Cyclical sending starts; setting signals is now possible. Signal changes that occurred while the interaction layer was switched off (by ILControlStop or ILControlSimulationOff) are not considered on its activation">
        <return type="long">
            0: No error
            -1: Momentary state of the IL does not permit this query
            -50: Node layer is inactive: possibly deactivated in the node's configuration dialog
        </return>
    </method>

    <method name="ILControlStop"
            desc="Sending is completely stopped. In this state the interaction layer is inoperative. Neither function calls, nor signal changes are considered during its inactivity and on its activation (by ILControlStart)">
        <return type="long">
            0: No error
            -1: Momentary state of the IL does not permit this query
            -50: Node layer is inactive: possibly deactivated in the node's configuration dialog
        </return>
    </method>

    <method name="ILControlWait"
            desc="Cyclical sending is stopped; setting signals is possible. Cyclical sending is continued only after an ILControlResume">
        <return type="long">
            0: No error
            -1: Momentary state of the IL does not permit this query
            -50: Node layer is inactive: possibly deactivated in the node's configuration dialog
        </return>
    </method>

    <method name="ILControlResume" desc="Cyclical sending restarts. This function may only be used after ILControlWait">
        <return type="long">
            0: No error
            -1: Momentary state of the IL does not permit this query
            -50: Node layer is inactive: possibly deactivated in the node's configuration dialog
        </return>
    </method>

    <method name="ILActivateClamp15"
            desc="Forwards the appropriate state (active/deactive) of clamp 15 to the NM simulation (if present)">
        <return type="long">
            0: No error
            -1: The IL is not initialized properly. The function is ignored
        </return>
    </method>

    <method name="ILDeactivateClamp15"
            desc="Forwards the appropriate state (active/deactive) of clamp 15 to the NM simulation (if present)">
        <return type="long">
            0: No error
            -1: The IL is not initialized properly. The function is ignored
        </return>
    </method>

    <method name="ILControlSimulationOn"
            desc="Start the simulation of the IL. The IL is in the same state as it was before stopping it by the function ILControlSimulationOff">
        <return type="long">
            0: No error
            -1: Momentary state of the IL does not permit this query
        </return>
    </method>

    <method name="ILControlSimulationOff"
            desc="The simulation of the IL is stopped. After that no other function to control the IL has an effect to the IL. To restart the simulation of the IL use ILControlSimulationOn">
        <return type="long">0: No error</return>
    </method>

    <method name="ILSetMsgEvent"
            desc="Sends the transferred message directly to the bus if the network is active. The send model is ignored">
        <param name="msg" type="Message">Message that should be sent</param>
        <return type="long">
            0: No error
            -1: Momentary state of the IL does not permit this query
            -50: Nodelayer is inactive: possibly deactivated in the node's configuration dialog
            -100: Signal or message was not found in the database or is not mapped to this node
            -104: General error for invalid calls
        </return>
    </method>

    <method name="ILFaultInjectionEnableMsg" desc="Enables the sending of the message">
        <param name="msg" type="Message">Message that should be re-enabled after having disabled it with ILFaultInjectionDisableMsg</param>
        <return type="long">
            0: No error
            -1: Momentary state of the IL does not permit this query
            -100: Signal or message was not found in the database or is not mapped to this node
        </return>
    </method>

    <method name="ILFaultInjectionDisableMsg"
            desc="Disables the sending of the message except by calling the function ILSetMsgEvent">
        <param name="msg" type="Message">Message that should be disabled</param>
        <return type="long">
            0: No error
            -1: Momentary state of the IL does not permit this query
            -50: Nodelayer is inactive: possibly deactivated in the node's configuration dialog
            -100: Signal or message was not found in the database or is not mapped to this node
        </return>
    </method>
    !!!
    CAPL_FUNC(long, ILSetPDUTimingCyclic)(LPCSTR sMsgRef, long timing, long offset, long period, long disturbanceCount, long flags);
    CAPL_FUNC(long, ILResetPDUTimingCyclic)(LPCSTR sMsgRef, long timing);
    CAPL_FUNC(long, ILResetPDUTimingEvent)(LPCSTR sMsgRef, long timing);
    CAPL_FUNC(long, ILSetPDUAsrTXMode)(LPCSTR sMsgRef, long mode, long disturbanceCount, long flags);
    CAPL_FUNC(long, ILSetPDUTimingEvent)(LPCSTR sMsgRef, long timing, long enabled,
    long repetitionCount, long repetitionPeriod,
    long debounceDelay, long disturbanceCount, long flags);

    CAPL_FUNC(long, ILSetPDUEvent)(LPCSTR sMsgRef);
    !!!
    <method name="diagInitialize" desc="Sends diagnosise request">
        <param name="request" type="IDiagRequest">Diagnostics object to re-initialize</param>
        <return type="long">0: No error, OK. Less then 0: Error code</return>
    </method>

    <method name="diagInitialize"
            desc="Reinitializes the object for the given service or primitive. Diagnostics request will be initialized with the default request parameters of the service, while diagnostic responses will be initialized with the default parameters of the first or specified primitive of the service. If the service is not defined, or the primitive is not defined at the given service, nothing happens and an error code is returned">
        <param name="object" type="IDiagRequest">Diagnostics object to re-initialize</param>
        <param name="serviceQualifier[]" type="char">Qualifier of the service that should be used for reinterpretation</param>
        <return type="long">0: No error, OK. Less then 0: Error code</return>
    </method>

    <method name="diagInitialize"
            desc="Reinitializes the object for the given service or primitive. Diagnostics request will be initialized with the default request parameters of the service, while diagnostic responses will be initialized with the default parameters of the first or specified primitive of the service. If the service is not defined, or the primitive is not defined at the given service, nothing happens and an error code is returned">
        <param name="object" type="diagResponse">Diagnostics object to re-initialize</param>
        <param name="serviceQualifier[]" type="char">Qualifier of the service that should be used for reinterpretation</param>
        <param name="primitiveQualifier[]" type="char">Qualifier of the service primitive that should be used for reinterpretation</param>
        <return type="long">0: No error, OK. Less then 0: Error code</return>
    </method>

    <method name="diagSetParameter" desc="Sets the numeric parameter to the specified value">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
        <param name="newValue" type="double">Numeric value to which the parameter should be set</param>
        <return type="long">0: No error, OK. Less then 0: Error code</return>
    </method>

    <method name="diagSetParameter" desc="Sets the numeric parameter to the specified value">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <param name="mode" type="long">Access</param>
        <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
        <param name="newValue" type="double">Numeric value to which the parameter should be set</param>
        <return type="long">0: No error, OK. Less then 0: Error code</return>
    </method>

    <method name="diagSetParameter"
            desc="Sets a parameter to the symbolically-specified value. This is possible for all parameters, also numeric ones">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
        <param name="newValue[]" type="char">Symbolic value to which the parameter should be set</param>
        <return type="long">0: No error, OK. Less then 0: Error code</return>
    </method>

    <method name="diagGetParameter"
            desc="Returns the value of the numeric parameter, either in an output field or as return value (without the possibility of checking the correct function)">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
        <param name="output[1]" type="double">Output field</param>
        <return type="long">Error code or value of the parameter or 0.0 if this could not be acquired</return>
    </method>

    <method name="diagGetParameter"
            desc="Returns the value of the numeric parameter, either in an output field or as return value (without the possibility of checking the correct function)">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
        <return type="double">Error code or value of the parameter or 0.0 if this could not be acquired</return>
    </method>

    <method name="diagGetParameter"
            desc="Returns the value of the numeric parameter, either in an output field or as return value (without the possibility of checking the correct function)">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <param name="mode" type="long">Access</param>
        <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
        <param name="output[1]" type="double">Output field</param>
        <return type="long">Error code or value of the parameter or 0.0 if this could not be acquired</return>
    </method>

    <method name="diagGetParameter"
            desc="Returns the value of the numeric parameter, either in an output field or as return value (without the possibility of checking the correct function)">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <param name="mode" type="long">Access</param>
        <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
        <return type="double">Error code or value of the parameter or 0.0 if this could not be acquired</return>
    </method>

    <method name="diagGetParameter"
            desc="Returns the value of the numeric parameter, either in an output field or as return value (without the possibility of checking the correct function)">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
        <param name="buffer[]" type="char">Output field</param>
        <param name="buffersize" type="long">Size of the buffer</param>
        <return type="long">Number of chars written to buffer or error code</return>
    </method>

    <method name="diagSendRequest" desc="Sends the request object to the ECU">
        <param name="object" type="IDiagRequest">Diagnostics object</param>
        <return type="long">Error code</return>
    </method>

    <method name="diagSendResponse"
            desc="Sends the response object back to the tester. Can only be called in the ECU simulation">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <return type="long">Error code</return>
    </method>

    <method name="diagGetPrimitiveData"
            desc="Reads the raw data of the complete service primitive (all data that is transmitted via the transport protocol). When setting the data the length of the primitive is not changed">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <param name="buffer[]" type="byte">Input/output buffer</param>
        <param name="buffersize" type="long">Buffer size</param>
        <return type="long">Number of bytes copied into the buffer or error code</return>
    </method>

    <method name="diagSetPrimitiveData"
            desc="Sets the raw data of the complete service primitive (all data that is transmitted via the transport protocol). When setting the data the length of the primitive is not changed">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <param name="buffer[]" type="byte">Input/output buffer</param>
        <param name="buffersize" type="long">Buffer size</param>
        <return type="long">Number of bytes copied into the buffer or error code</return>
    </method>

    <method name="diagGetPrimitiveSize" desc="Returns the byte length of the object">
        <param name="object" type="IDiagRequest">Request/Response</param>
        <return type="long">Number of bytes</return>
    </method>

    <method name="diagIsNegativeResponse" desc="Returns value != 0 if the object is a negative response to a request">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <return type="long">Returns value != 0 if the object is a negative response to a request</return>
    </method>

    <method name="diagIsPositiveResponse" desc="Returns value != 0 if the object is a positive response to a request">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <return type="long">Returns value != 0 if the object is a positive response to a request</return>
    </method>

    <method name="diagGetResponseCode"
            desc="Returns the code of the specified response or last received response (for the specified request)">
        <param name="object" type="diagResponse">Diagnostics object</param>
        <return type="long">
            -1: The response was positive, i.e. there is no error code.
            0: No response has been received yet.
            >0: Error code of the negative response.
        </return>
    </method>

    <method name="diagGetLastResponseCode"
            desc="Returns the code of the specified response or last received response (for the specified request)">
        <param name="object" type="IDiagRequest">Diagnostics object</param>
        <return type="long">
            -1: The response was positive, i.e. there is no error code.
            0: No response has been received yet.
            >0: Error code of the negative response.
        </return>
    </method>

    <method name="diagGetLastResponse"
            desc="Saves the last response received (for the specified request) in the output object">
        <param name="respOut" type="diagResponse">Output object for the received response</param>
        <return type="long">Error code</return>
    </method>

    <method name="diagGetParameterRaw" desc="Get the value of a (complex) parameter directly via uncoded data bytes">
        <param name="object" type="IDiagRequest">Diagnostics object</param>
        <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
        <param name="buffer[]" type="byte">Input/output buffer</param>
        <param name="buffersize" type="long">Buffer size</param>
        <return type="long">Number of bytes copied into the buffer or error code</return>
    </method>

    <method name="diagSetParameterRaw" desc="Set the value of a (complex) parameter directly via uncoded data bytes">
        <param name="object" type="IDiagRequest">Diagnostics object</param>
        <param name="parameterName[]" type="char">Parameter qualifier (NOT the language-dependent name of the parameter!)</param>
        <param name="buffer[]" type="byte">Input/output buffer</param>
        <param name="buffersize" type="long">Buffer size</param>
        <return type="long">Number of bytes copied into the buffer or error code</return>
    </method>

    <method name="testWaitForDiagResponse" desc="Waits for the arrival of the response to the given request">
        <param name="object" type="IDiagRequest">Sent request</param>
        <param name="timeout" type="long">[ms] Maximum wait time</param>
        <return type="long">
            >0: An internal error occurred, e.g. a protocol error or a faulty configuration of the diagnostic layer
            0: The timeout was reached, i.e. the event of interest did not occur within the specified time
            1: The event occurred
        </return>
    </method>

    <method name="diagStartTesterPresentObj"
            desc="Starts sending autonomous/cyclical Tester Present requests from CANoe to the specified or current ECU">
        <param name="ecuQualifier[]" type="char">Qualifier of the ECU as specified in the diagnostic configuration dialog, for which the Tester Present service shall be started</param>
        <return type="long">Error code</return>
    </method>

    <method name="TestStep"
            desc="With these functions, test steps can be reported within a test case. TestStep reports a test step without influence on the result. TestStepPass reports a test step that was executed as expected. This is displayed accordingly in the test report">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStep"
            desc="With these functions, test steps can be reported within a test case. TestStep reports a test step without influence on the result. TestStepPass reports a test step that was executed as expected. This is displayed accordingly in the test report">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="handle" type="long">Handle to the table to be displayed within the step content, created by the function TestInfoTable</param>
        <return type="long"></return>
    </method>

    <method name="TestStep"
            desc="With these functions, test steps can be reported within a test case. TestStep reports a test step without influence on the result. TestStepPass reports a test step that was executed as expected. This is displayed accordingly in the test report">
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepPass"
            desc="With these functions, test steps can be reported within a test case. TestStepPass reports a test step that was executed as expected. This is displayed accordingly in the test report">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepPass"
            desc="With these functions, test steps can be reported within a test case. TestStepPass reports a test step that was executed as expected. This is displayed accordingly in the test report">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="handle" type="long">Handle to the table to be displayed within the step content, created by the function TestInfoTable</param>
        <return type="long"></return>
    </method>

    <method name="TestStepPass"
            desc="With these functions, test steps can be reported within a test case. TestStepPass reports a test step that was executed as expected. This is displayed accordingly in the test report">
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepPass"
            desc="With these functions, test steps can be reported within a test case. TestStepPass reports a test step that was executed as expected. This is displayed accordingly in the test report">
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepPass"
            desc="With these functions, test steps can be reported within a test case. TestStepPass reports a test step that was executed as expected. This is displayed accordingly in the test report">
        <return type="long"></return>
    </method>

    <method name="TestStepFail"
            desc="With these functions, test steps can be reported within a test case. TestStepFail describes a test step that causes an error. Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to fail">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepFail"
            desc="With these functions, test steps can be reported within a test case. TestStepFail describes a test step that causes an error. Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to fail">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="handle" type="long">Handle to the table to be displayed within the step content, created by the function TestInfoTable</param>
        <return type="long"></return>
    </method>

    <method name="TestStepFail"
            desc="With these functions, test steps can be reported within a test case. TestStepFail describes a test step that causes an error. Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to fail">
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepFail"
            desc="With these functions, test steps can be reported within a test case. TestStepFail describes a test step that causes an error. Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to fail">
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepFail"
            desc="With these functions, test steps can be reported within a test case. TestStepFail describes a test step that causes an error. Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to fail">
        <return type="long"></return>
    </method>

    <method name="TestStepWarning"
            desc="With these functions, test steps can be reported within a test case. TestStepWarning describes a test case that was executed without errors but whose result could contribute to a problem later on. This is represented appropriately in the test report">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepWarning"
            desc="With these functions, test steps can be reported within a test case. TestStepWarning describes a test case that was executed without errors but whose result could contribute to a problem later on. This is represented appropriately in the test report">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="handle" type="long">Handle to the table to be displayed within the step content, created by the function TestInfoTable</param>
        <return type="long"></return>
    </method>

    <method name="TestStepWarning"
            desc="With these functions, test steps can be reported within a test case. TestStepWarning describes a test case that was executed without errors but whose result could contribute to a problem later on. This is represented appropriately in the test report">
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepWarning"
            desc="With these functions, test steps can be reported within a test case. TestStepWarning describes a test case that was executed without errors but whose result could contribute to a problem later on. This is represented appropriately in the test report">
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepWarning"
            desc="With these functions, test steps can be reported within a test case. TestStepWarning describes a test case that was executed without errors but whose result could contribute to a problem later on. This is represented appropriately in the test report">
        <return type="long"></return>
    </method>

    <method name="TestStepInconclusive"
            desc="With these functions, test steps can be reported within a test case. TestStepInconclusive describes a test step which can not clearly marked as passed or failed . Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to inconclusive">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepInconclusive"
            desc="With these functions, test steps can be reported within a test case. TestStepInconclusive describes a test step which can not clearly marked as passed or failed . Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to inconclusive">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="handle" type="long">Handle to the table to be displayed within the step content, created by the function TestInfoTable</param>
        <return type="long"></return>
    </method>

    <method name="TestStepInconclusive"
            desc="With these functions, test steps can be reported within a test case. TestStepInconclusive describes a test step which can not clearly marked as passed or failed . Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to inconclusive">
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepInconclusive"
            desc="With these functions, test steps can be reported within a test case. TestStepInconclusive describes a test step which can not clearly marked as passed or failed . Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to inconclusive">
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepInconclusive"
            desc="With these functions, test steps can be reported within a test case. TestStepInconclusive describes a test step which can not clearly marked as passed or failed . Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to inconclusive">
        <return type="long"></return>
    </method>

    <method name="TestStepErrorInTestSystem"
            desc="With these functions, test steps can be reported within a test case. TestStepErrorInTestSystem describes a test step that causes an error in test system. Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to error in test system">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepErrorInTestSystem"
            desc="With these functions, test steps can be reported within a test case. TestStepErrorInTestSystem describes a test step that causes an error in test system. Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to error in test system">
        <param name="LevelOfDetail" type="dword">It is possible to identify with a number how important this test step is. In the test report, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance. Without an explicit specification, a LevelOfDetail of 0 is assumed</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="handle" type="long">Handle to the table to be displayed within the step content, created by the function TestInfoTable</param>
        <return type="long"></return>
    </method>

    <method name="TestStepErrorInTestSystem"
            desc="With these functions, test steps can be reported within a test case. TestStepErrorInTestSystem describes a test step that causes an error in test system. Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to error in test system">
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepErrorInTestSystem"
            desc="With these functions, test steps can be reported within a test case. TestStepErrorInTestSystem describes a test step that causes an error in test system. Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to error in test system">
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestStepErrorInTestSystem"
            desc="With these functions, test steps can be reported within a test case. TestStepErrorInTestSystem describes a test step that causes an error in test system. Also this is displayed accordingly in the test report. The verdict of the test case is hereby set automatically to error in test system">
        <return type="long"></return>
    </method>

    <method name="TestWaitForTimeout" desc="Waits until the expiration of the specified timeout time">
        <param name="Timeout" type="long">Maximum time that should be waited [ms]. (Transmission of 0: no timeout controlling. In this function this results in a hang up of the test module)</param>
        <return type="long">
            -2: Resume due to constraint violation
            -1: General error, for example, functionality is not available
            0: Resume due to timeout
        </return>
    </method>

    <method name="TestWaitForTesterConfirmation"
            desc="Creates a popup window that presents the given string to the tester. The tester can acknowledge the window with Yes or No. Wait function has no timeout so it waits for the confirmation of the tester">
        <param name="text[]" type="char">This is shown in the popup window. The maximum length of the string is limited (4096 characters)</param>
        <return type="long">
            0: Timeout occurred
            1: The tester clicked Yes
            2: The tester clicked No
            -1: General error, e.g. due to a call outside of a test sequence
            -2: Constraint occurred
        </return>
    </method>

    <method name="TestWaitForTesterConfirmation"
            desc="Creates a popup window that presents the given string to the tester. The tester can acknowledge the window with Yes or No. Wait function has a timeout, i.e. the dialog is automatically terminated after the timeout expires">
        <param name="text[]" type="char">This is shown in the popup window. The maximum length of the string is limited (4096 characters)</param>
        <param name="timeout" type="long">Time in milliseconds after which the dialog is automatically ended</param>
        <return type="long">
            0: Timeout occurred
            1: The tester clicked Yes
            2: The tester clicked No
            -1: General error, e.g. due to a call outside of a test sequence
            -2: Constraint occurred
        </return>
    </method>

    <method name="TestWaitForTesterConfirmation"
            desc="Creates a popup window that presents the given string to the tester. The tester can acknowledge the window with Yes or No. Wait function has a timeout and can show a resource, i.e. the dialog can show additional information">
        <param name="text[]" type="char">This is shown in the popup window. The maximum length of the string is limited (4096 characters)</param>
        <param name="timeout" type="long">Time in milliseconds after which the dialog is automatically ended</param>
        <param name="heading[]" type="char">A heading above the dialog text. The maximum length of the string is limited (256 characters)</param>
        <param name="resource[]" type="char">A URL or file path</param>
        <param name="resourceCaption[]" type="char">A caption respectively a description for the resource. The maximum length of the string is limited (256 characters)</param>
        <return type="long">
            0: Timeout occurred
            1: The tester clicked Yes
            2: The tester clicked No
            -1: General error, e.g. due to a call outside of a test sequence
            -2: Constraint occurred
        </return>
    </method>

    <method name="TestStepBegin"
            desc="With these functions, test steps can be logged within a test case. Such a test step is introduced with TestStepBegin, which is then completed with TestStepPass, TestStepFail or TestStepWarning. A test step is noted in the test report only with this conclusion">
        <param name="Importance" type="long">It is possible to identify with a number how important this test step is, it is possible that only test steps up to a certain importance will be displayed. 0 means "very important", higher numbers indicate lower degrees of importance</param>
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <return type="long"></return>
    </method>

    <method name="TestStepBegin"
            desc="With these functions, test steps can be logged within a test case. Such a test step is introduced with TestStepBegin, which is then completed with TestStepPass, TestStepFail or TestStepWarning. A test step is noted in the test report only with this conclusion">
        <param name="Identifier[]" type="char">Test step number</param>
        <param name="Description[]" type="char">Description</param>
        <return type="long"></return>
    </method>

    <method name="TestWaitForSignalMatch"
            desc="Checks the given value against the value of the signal, the system variable or the environment variable. The resolution of the signal is considered">
        <param name="Signal" type="Signal">Signal to be queried</param>
        <param name="CompareValue" type="float">Value which is compared to the signal value</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms]</param>
        <return type="long">
            -1: General error
            -2: Signal is not valid
            0: Wait state is exited due to a timeout
            1: Wait state is exited due to condition fulfillment
        </return>
    </method>

    <method name="TestWaitForSignalMatch"
            desc="Checks the given value against the value of the signal, the system variable or the environment variable. The resolution of the signal is considered">
        <param name="EnvVar" type="EnvVar">Environment variable to be queried</param>
        <param name="CompareValue" type="float">Value which is compared to the signal value</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms]</param>
        <return type="long">
            -1: General error
            -2: Type of the environment variable is not valid, only float or integer are valid
            0: Wait state is exited due to a timeout
            1: Wait state is exited due to condition fulfillment
        </return>
    </method>

    <method name="TestWaitForSignalMatch"
            desc="Checks the given value against the value of the signal, the system variable or the environment variable. The resolution of the signal is considered">
        <param name="SysVar" type="EnvVar">System variable to be queried. May also be a specific element of a variable of type struct or generic array</param>
        <param name="CompareValue" type="float">Value which is compared to the signal value</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms]</param>
        <return type="long">
            -1: General error
            -2: Type of the system variable is not valid, only float or integer are valid
            0: Wait state is exited due to a timeout
            1: Wait state is exited due to condition fulfillment
        </return>
    </method>

    <method name="TestWaitForSignalInRange"
            desc="Checks the value of the signal, the system or the environment variable against the condition: aLowLimit &lt;= Value &lt;= aHighLimit. If this condition is already met when this function is called, it returns immediately without waiting. The test step is evaluated as either passed or failed depending on the results">
        <param name="Signal" type="Signal">Signal to be queried</param>
        <param name="LowLimit" type="float">Lower limit of the value</param>
        <param name="HighLimit" type="float">Upper limit of the value</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms]</param>
        <return type="long">
            -1: General error
            -2: Signal is not valid or invalid limits of the given range
            0: Wait state is exited due to a timeout
            1: Wait state is exited due to condition fulfillment
        </return>
    </method>

    <method name="TestWaitForSignalInRange"
            desc="Checks the value of the signal, the system or the environment variable against the condition: aLowLimit &lt;= Value &lt;= aHighLimit. If this condition is already met when this function is called, it returns immediately without waiting. The test step is evaluated as either passed or failed depending on the results">
        <param name="EnvVar" type="EnvVar">Environment variable to be queried</param>
        <param name="LowLimit" type="float">Lower limit of the value</param>
        <param name="HighLimit" type="float">Upper limit of the value</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms]</param>
        <return type="long">
            -1: General error
            -2: Type of the environment variable is not valid, only float or integer are valid, or invalid limits of the given range
            0: Wait state is exited due to a timeout
            1: Wait state is exited due to condition fulfillment
        </return>
    </method>

    <method name="TestWaitForSignalInRange"
            desc="Checks the value of the signal, the system or the environment variable against the condition: aLowLimit &lt;= Value &lt;= aHighLimit. If this condition is already met when this function is called, it returns immediately without waiting. The test step is evaluated as either passed or failed depending on the results">
        <param name="SysVar" type="EnvVar">System variable to be queried. May also be a specific element of a variable of type struct or generic array</param>
        <param name="LowLimit" type="float">Lower limit of the value</param>
        <param name="HighLimit" type="float">Upper limit of the value</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms]</param>
        <return type="long">
            -1: General error
            -2: Type of the system variable is not valid, only float or integer are valid, or invalid limits of the given range
            0: Wait state is exited due to a timeout
            1: Wait state is exited due to condition fulfillment
        </return>
    </method>

    <method name="TestReportAddEngineerInfo"
            desc="With these functions, information pairs of name and description (e.g. serial number and S012345AB) can be taken up into the report in the areas TestEngineer, TestSetUp, and device (SUT) to be tested. The three areas named must not be created; they are automatically available in the report. In the course of the test execution, any number of information pairs can be written\n
Information pair of name and description\n
The format string has the same meaning as with the write function and is described there">
        <param name="name[]" type="char">Name</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestReportAddSetupInfo"
            desc="With these functions, information pairs of name and description (e.g. serial number and S012345AB) can be taken up into the report in the areas TestEngineer, TestSetUp, and device (SUT) to be tested.">
        <param name="name[]" type="char">Name</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestReportAddSUTInfo"
            desc="With these functions, information pairs of name and description (e.g. serial number and S012345AB') can be taken up into the report in the areas TestEngineer, TestSetUp, and device (SUT) to be tested">
        <param name="name[]" type="char">Name</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestReportAddMiscInfo"
            desc="With these functions, information pairs of name and description (e.g. 'serial number' and 'S012345AB') can be taken up into the report in the areas TestEngineer, TestSetUp, and device (SUT) to be tested. The three areas named must not be created; they are automatically available in the report. In the course of the test execution, any number of information pairs can be written\n
Information pair of name and description\n
The format string has the same meaning as with the write function and is described there">
        <param name="name[]" type="char">Name</param>
        <param name="Description[]" type="char">Description</param>
        <param name="..." type=""></param>
        <return type="long"></return>
    </method>

    <method name="TestModuleTitle"
            desc="The title of the test module is acquired automatically from the name of the test node in the simulation structure. It can also be set explicitly with this function">
        <param name="title[]" type="char">Title of the test module</param>
        <return type="long"></return>
    </method>

    <method name="TestModuleDescription"
            desc="With this function, a description text for the test module can be written into the report. The function can be called several times in a row, the transmitted texts are then added to one another without additional separation">
        <param name="description[]" type="char">Description text for the test module</param>
        <return type="long"></return>
    </method>

    <method name="TestSupplyTextEvent"
            desc="Signals the specified event. Consequently resolves a possibly-active wait condition on this event">
        <param name="Text[]" type="char">Name of the event to be signaled</param>
        <return type="long">
            0: Event was signaled successfully
            -1: Event could not be signaled
        </return>
    </method>

    <method name="TestWaitForTextEvent"
            desc="Waits for the signaling of the specified textual event from the individual test module. A signaling from another test module does not effect this wait instruction">
        <param name="Text[]" type="char">Name of the event to be signaled</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms](Transmission of 0: no timeout controlling)</param>
        <return type="long">
            -2: Resume due to constraint violation
            -1: General error, for example, functionality is not available
            0: Resume due to timeout
            1: Resume due to event occurred
        </return>
    </method>

    <method name="TestWaitForEnvVar"
            desc="Waits for the description of the specified environment variable (aEnvVar or with the name aEnvVarName). Should the event not occur before the expiration of the time aTimeout, the wait condition is resolved nevertheless">
        <param name="EnvVar" type="EnvVar">Environment variable that should be awaited</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms](Transmission of 0: no timeout controlling)</param>
        <return type="long">
            -2: Resume due to constraint violation
            -1: General error, for example, functionality is not available or environment variable cannot be found
            0: Resume due to timeout
            1: Resume due to event occurred
        </return>
    </method>

    <method name="TestWaitForEnvVar"
            desc="Waits for the description of the specified environment variable with the name EnvVarName. Should the event not occur before the expiration of the time aTimeout, the wait condition is resolved nevertheless">
        <param name="EnvVarName[]" type="char">Name of environment variable that should be awaited</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms](Transmission of 0: no timeout controlling)</param>
        <return type="long">
            -2: Resume due to constraint violation
            -1: General error, for example, functionality is not available or environment variable with name EnvVarName cannot be found
            0: Resume due to timeout
            1: Resume due to event occurred
        </return>
    </method>

    <method name="TestWaitForSysVar"
            desc="Waits for the next system variable SysVar. Should the event not occur before the expiration of the time aTimeout, the wait condition is resolved nevertheless">
        <param name="SysVar" type="EnvVar">System variable that should be awaited</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms](Transmission of 0: no timeout controlling)</param>
        <return type="long">
            -2: Resume due to constraint violation
            -1: General error, for example, functionality is not available or system variable cannot be found
            0: Resume due to timeout
            1: Resume due to event occurred
        </return>
    </method>

    <method name="TestWaitForSysVarName"
            desc="Waits for the next system variable with name. Should the event not occur before the expiration of the time aTimeout, the wait condition is resolved nevertheless">
        <param name="SysVarName[]" type="char">Name of system variable that should be awaited</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms](Transmission of 0: no timeout controlling)</param>
        <return type="long">
            -2: Resume due to constraint violation
            -1: General error, for example, functionality is not available or system variable with name SysVar cannot be found
            0: Resume due to timeout
            1: Resume due to event occurred
        </return>
    </method>

    <method name="TestWaitForMessage"
            desc="Waits for the occurrence of the specified message aMessage. Should the message not occur before the expiration of the time aTimeout, the wait condition is resolved nevertheless">
        <param name="Timeout" type="dword">Maximum time that should be waited [ms]</param>
        <return type="long">
            -2: Resume due to constraint violation
            -1: General error, for example, functionality is not available
            0: Resume due to timeout
            1: Resume due to event occurred
        </return>
    </method>

    <method name="TestWaitForMessage"
            desc="Waits for the occurrence of the specified message aMessage. Should the message not occur before the expiration of the time aTimeout, the wait condition is resolved nevertheless">
        <param name="MessageId" type="dword">Numeric ID of the message that should be awaited</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms]</param>
        <return type="long">
            -2: Resume due to constraint violation
            -1: General error, for example, functionality is not available
            0: Resume due to timeout
            1: Resume due to event occurred
        </return>
    </method>

    <method name="TestWaitForMessage"
            desc="Waits for the occurrence of the specified message aMessage. Should the message not occur before the expiration of the time aTimeout, the wait condition is resolved nevertheless">
        <param name="Message" type="Message">Message that should be awaited</param>
        <param name="Timeout" type="dword">Maximum time that should be waited [ms]</param>
        <return type="long">
            -2: Resume due to constraint violation
            -1: General error, for example, functionality is not available
            0: Resume due to timeout
            1: Resume due to event occurred
        </return>
    </method>

    <method name="TestCaseTitle"
            desc="The title of a test case is acquired automatically from the test case name in the CAPL program">
        <param name="title[]" type="char">Title of the test case</param>
        <param name="identifier[]" type="char">Test case number</param>
        <return type="long"></return>
    </method>

    <method name="TestCaseDescription"
            desc="With this function, a description test for a test case can be written into the report">
        <param name="discription[]" type="char">Description test for the test case</param>
        <return type="long"></return>
    </method>

    <method name="TestCaseComment"
            desc="With this function within a test case a commentary can be taken over into the report. This comment can relate to a message that can also be output in the report">
        <param name="Comment[]" type="char">Commentary to be taken over into the report</param>
        <return type="long"></return>
    </method>

    <method name="TestCaseComment"
            desc="With this function within a test case a commentary can be taken over into the report. This comment can relate to a message that can also be output in the report">
        <param name="Comment[]" type="char">Commentary to be taken over into the report</param>
        <param name="Msg" type="const message">CAN-, GMLAN-, LIN-, MOST-, MOST-AMS- or MOST system message to be taken over into the report</param>
        <return type="long"></return>
    </method>

    <method name="TestCaseComment"
            desc="With this function within a test case a commentary can be taken over into the report. This comment can relate to a message that can also be output in the report">
        <param name="Comment[]" type="char">Commentary to be taken over into the report</param>
        <param name="RawString[]" type="char">Here you may enter any ASCII characters. They will be added to the comment in the following way: Hex value of the given character>(ASCII display of the given charcter). In ASCII display special characters will be replaced by '.'</param>
        <return type="long"></return>
    </method>

    <method name="TestReportFileName" desc="Sets the name and path of a report file">
        <param name="name[]" type="char">Name and path of the report file. Without path specification, the directory of the CANoe configuration file is used. The extension .XML or. .html is added automatically</param>
        <return type="long"></return>
    </method>

    <method name="TestJoinMessageEvent"
            desc="Completes the current set of 'joined events' with the transmitted event. This function does not wait">
        <param name="Message" type="Message">Message that should be awaited</param>
        <return type="long">
            -3: Join error
            -1: General error, for example, functionality is not available
            >0: Number of the joined event
        </return>
    </method>

    <method name="TestJoinMessageEvent"
            desc="Completes the current set of 'joined events' with the transmitted event. This function does not wait">
        <param name="MessageID" type="dword">Numeric ID of the message for which should be waited</param>
        <return type="long">
            -3: Join error
            -1: General error, for example, functionality is not available
            >0: Number of the joined event
        </return>
    </method>

    <method name="TestJoinEnvVarEvent"
            desc="Completes the current set of 'joined events' with the transmitted event. This function does not wait">
        <param name="EnvVar" type="EnvVar">Environment variable that should be awaited</param>
        <return type="long">
            -3: Join error
            -1: General error, for example, functionality is not available
            >0: Number of the joined event
        </return>
    </method>

    <method name="TestJoinTextEvent"
            desc="Completes the current set of 'joined events' with the transmitted event. This function does not wait">
        <param name="Text[]" type="char">Textual event that should be awaited</param>
        <return type="long">
            -3: Join error
            -1: General error, for example, functionality is not available
            >0: Number of the joined event
        </return>
    </method>

    <method name="TestWaitForAnyJoinedEvent"
            desc="Waits for the current set of 'joined events'. Each individual of these events can resolve the wait state">
        <param name="Timeout" type="long">Maximum time that should be waited [ms] (Transmission of 0: no timeout controlling)</param>
        <return type="long">
            -2: Resume due to constraint violation
            -1: General error, for example, functionality is not available
            0: Resume due to timeout
            >0: Resume due to event occurred The return value returns the number of the joined event that triggered the resolution
        </return>
    </method>

    <method name="TestWaitForAllJoinedEvents"
            desc="Waits for the current set of 'joined events'. The wait condition is resolved if all of the joined events were signaled">
        <param name="Timeout" type="long">Maximum time that should be waited [ms] (Transmission of 0: no timeout controlling)</param>
        <return type="long">
            -2: Resume due to constraint violation
            -1: General error, for example, functionality is not available
            0: Resume due to timeout
            >0: Resume due to event occurred The return value returns the number of the joined event that triggered the resolution
        </return>
    </method>

    <method name="TestGroupBegin"
            desc="A test group is opened with this function. It may only be called in a test module, but not in a test case. All test cases and test groups that are executed before call of the corresponding function TestGroupEnd are part of this test group. If a test group is not closed with TestGroupEnd, then at the end of the test module, a warning is written in the Write Window and the test group is closed automatically">
        <param name="title[]" type="char">Title for the test group</param>
        <param name="discription[]" type="char">Description text for the test group</param>
        <return type="long"></return>
    </method>

    <method name="TestGroupBegin"
            desc="A test group is opened with this function. It may only be called in a test module, but not in a test case. All test cases and test groups that are executed before call of the corresponding function TestGroupEnd are part of this test group. If a test group is not closed with TestGroupEnd, then at the end of the test module, a warning is written in the Write Window and the test group is closed automatically">
        <param name="identifier[]" type="char">A test group number</param>
        <param name="title[]" type="char">Title for the test group</param>
        <param name="discription[]" type="char">Description text for the test group</param>
        <return type="long"></return>
    </method>

    <method name="TestGroupEnd"
            desc="The function closes a test group opened with TestGroupBegin. If several test groups were opened, then the last-opened and not yet closed test group is closed">
        <return type="long"></return>
    </method>

    <method name="TestGetWaitEventMsgData"
            desc="If a message event is the last event that triggers a wait instruction, the message content can be called up with the first function">
        <param name="Message" type="Message">Message variable that should be filled in with this function</param>
        <return type="long">
            0: Data access successful
            -1: Data access could not be executed, the last event was not a message event
        </return>
    </method>

    <method name="TestGetWaitEventMsgDataIndex"
            desc="The function can only be used for 'joined events'. The number of the 'joined event' (return value of 'testJoin...') is here being used as an index">
        <param name="index" type="dword">Number of the "joined event" corresponds with the return value of "testJoin..."</param>
        <param name="Message" type="Message">Message variable that should be filled in with this function</param>
        <return type="long">
            0: Data access successful
            -1: Data access could not be executed, the last event was not a message event
        </return>
    </method>

    <method name="DeferStop" desc="Defers measurement stop">
        <param name="maxDeferTime" type="dword">Indicates the time interval in milliseconds after which completion of pre-stop activities is indicated automatically if it has not yet been done explicitly via CompleteStop</param>
        <return type="void"></return>
    </method>

    <method name="CompleteStop"
            desc="Indicates completion of pre-stop actions carried out in a certain node after a measurement stop has been deferred by DeferStop.">
        <return type="void"></return>
    </method>

    <method name="CanTpCreateConnection" desc="Create a new connection using the given address mode">
        <param name="addrMode" type="dword">
            Address mode:
            0: Normal
            1: Extended (based)
            2: NormalFixed
            3: Mixed
            4: Mixed /11 bit)
            5: Extended (free)
        </param>
        <return type="long">Connection handler</return>
    </method>

    <method name="CanTpCloseConnection"
            desc="Close an existing connection. No further events will be reported for the connection, and CAPL function calls indicating this connection will fail">
        <param name="connHandle" type="long">Connection handler</param>
        <return type="long"></return>
    </method>

    <method name="CanTpSetTxIdentifier"
            desc="Set the CAN ID of the message the connection uses to send (Tx) protocol data in">
        <param name="connHandle" type="long">Connection handler</param>
        <param name="txID" type="dword">ID of the message the connection uses to send</param>
        <return type="long"></return>
    </method>

    <method name="CanTpSetRxIdentifier"
            desc="Set the CAN ID of the message the connection uses to receive (Rx) protocol data in">
        <param name="connHandle" type="long">Connection handler</param>
        <param name="rxID" type="dword">ID of the message the connection uses to receive</param>
        <return type="long"></return>
    </method>

    <method name="CanTpSendData" desc="Request the sending of the first txSize bytes from the byte array txData">
        <param name="connHandle" type="long">Connection handler</param>
        <param name="txData[]" type="byte">Buffer to send</param>
        <param name="txSize" type="dword">Buffer size</param>
        <return type="long"></return>
    </method>
    !!!
    CAPL_FUNC(long, ShowToManyConnectionsMessageBox)(LPCSTR nodeName, LPCSTR fileName);

    // Initialisiert die Diagnose
    CAPL_FUNC(CAPL_HANDLE, AIDA_InitInternal)(LPCSTR sBusRef, LPCSTR sConfig);


    // Deinitialisiert die Diagnose
    CAPL_FUNC(void, AIDA_DeInitInternal)(CAPL_HANDLE hStack);


    // Sendet eine Diagnose-Anforderung.
    CAPL_FUNC(void, AIDA_DataReqInternal)(CAPL_HANDLE hStack, const byte* pData, long lBufferSize);

    // Holt die empfangenen Daten von der DLL ab.
    CAPL_FUNC(void, AIDA_GetRxDataInternal)(CAPL_HANDLE hStack, byte* pData, long lBufferSize);

    // Spezifiziert die Sende-ID, auf der CanEasy Diagnose-Kommandos absetzt.
    CAPL_FUNC(void, OSEKTL_SetTxIdInternal)(CAPL_HANDLE hStack, dword txId);

    // Gibt die Empfangs-ID an, auf der CanEasy die angeforderten Diagnose-Daten empfangen soll.
    CAPL_FUNC(void, OSEKTL_SetRxIdInternal)(CAPL_HANDLE hStack, dword rxId);

    // Liefert die Sende-ID.
    CAPL_FUNC(long, OSEKTL_GetTxIdInternal)(CAPL_HANDLE hStack);

    // Liefert die Empfangs-ID.
    CAPL_FUNC(long, OSEKTL_GetRxIdInternal)(CAPL_HANDLE hStack);

    // Toggles to normal addressing
    CAPL_FUNC(void, OSEKTL_SetNrmlModeInternal)(CAPL_HANDLE hStack);

    // Toggles to mixed addressing
    CAPL_FUNC(void, OSEKTL_SetMixedModeInternal)(CAPL_HANDLE hStack);

    // Toggles to extended addressing
    CAPL_FUNC(void, OSEKTL_SetExtModeInternal)(CAPL_HANDLE hStack);

    CAPL_FUNC(void, OSEKTL_UseExtIdInternal)(CAPL_HANDLE hStack, byte val);
    CAPL_FUNC(void, OSEKTL_SetEcuNumberInternal)(CAPL_HANDLE hStack, byte val);
    CAPL_FUNC(void, OSEKTL_SetBSInternal)(CAPL_HANDLE hStack, byte val);
    CAPL_FUNC(void, OSEKTL_SetSTMINInternal)(CAPL_HANDLE hStack, byte val);
    CAPL_FUNC(void, OSEKTL_SetTgtAdrInternal)(CAPL_HANDLE hStack, long val);
    CAPL_FUNC(void, OSEKTL_SetUseFCInternal)(CAPL_HANDLE hStackm, byte val);
    CAPL_FUNC(void, OSEKTL_SetDLC8Internal)(CAPL_HANDLE hStack);
    CAPL_FUNC(void, OSEKTL_SetEvalAllFCInternal)(CAPL_HANDLE hStack);
    CAPL_FUNC(void, OSEKTL_SetTimeoutArInternal)(CAPL_HANDLE hStack, WORD timeout);
    CAPL_FUNC(void, OSEKTL_SetTimeoutAsInternal)(CAPL_HANDLE hStack, WORD timeout);
    CAPL_FUNC(void, OSEKTL_SetTimeoutBsInternal)(CAPL_HANDLE hStack, WORD timeout);
    CAPL_FUNC(void, OSEKTL_SetTimeoutCrInternal)(CAPL_HANDLE hStack, WORD timeout);
    !!!
    <method name="RS232Open" desc="Opens a serial port">
        <param name="port" type="dword">A number between 1 and 255 identifying a serial port</param>
        <return type="dword">0: error</return>
    </method>

    <method name="RS232Send" desc="Sends a block of bytes to a serial port">
        <param name="port" type="dword">A number between 1 and 255 identifying a serial port</param>
        <param name="buffer[]" type="byte">An array of bytes of which number will be sent</param>
        <param name="number" type="dword">Number of bytes to send</param>
        <return type="dword">0: error</return>
    </method>

    <method name="RS232WriteByte" desc="Sends one bytes to a serial port">
        <param name="port" type="dword">A number between 1 and 255 identifying a serial port</param>
        <param name="datum" type="dword">Byte to be sent (lowest 8 bits)</param>
        <return type="dword">0: error</return>
    </method>

    <method name="RS232WriteBlock" desc="Sends a block of bytes to a serial port">
        <param name="port" type="dword">A number between 1 and 255 identifying a serial port</param>
        <param name="buffer[]" type="byte">An array of bytes of which number will be sent</param>
        <param name="number" type="dword">Number of bytes to send</param>
        <return type="dword">0: error</return>
    </method>

    <method name="RS232Close" desc="Closes a serial port">
        <param name="port" type="dword">A number between 1 and 255 identifying a serial port</param>
        <return type="dword">
            0: error The error occurs if the serial port with the given number does not exist on the system
            1: success
        </return>
    </method>

    <method name="RS232CloseHandle" desc="Closes a serial port">
        <param name="port" type="dword">A number between 1 and 255 identifying a serial port</param>
        <return type="dword">
            0: error The error occurs if the serial port with the given number does not exist on the system
            1: success
        </return>
    </method>

    <method name="RS232Receive" desc="Receive blocks of bytes from a serial port">
        <param name="port" type="dword">A number between 1 and 255 identifying a serial port</param>
        <param name="buffer[]" type="byte">An array of bytes</param>
        <param name="size" type="dword">Maximum number of bytes which can be received</param>
        <return type="dword">0: error The error occurs if the serial port with the given number does not exist on the system the port has not been opened</return>
    </method>

    <method name="RS232Configure" desc="Configures a serial port">
        <param name="port" type="dword">A number between 1 and 255 identifying a serial port</param>
        <param name="baudrate" type="dword">The symbol rate to use for reception and transmission</param>
        <param name="numberOfDataBits" type="dword">The number of data bits within a transmission frame</param>
        <param name="numberOfStopBits" type="dword">A code which sets the number of stop bits within a transmission frame</param>
        <param name="parity" type="dword">A code which identifies the parity mode to use</param>
        <return type="dword">0: error The error occurs if the serial port with the given number does not exist on the system and the port has not been opened</return>
    </method>

    <method name="RS232SetSignalLine" desc="Sets signal lines on serial port">
        <param name="port" type="dword">A number between 1 and 255 identifying a serial port</param>
        <param name="line" type="dword">Specifies signal line of which the state shall be set</param>
        <param name="state" type="dword">0 - disabled; 1 - enabled</param>
        <return type="dword">0: error The error occurs if the serial port with the given number does not exist on the system and the port has not been opened</return>
    </method>

    <method name="RS232EscapeCommExt" desc="Sets signal line on a specific serial port">
        <param name="port" type="dword">A number between 1 and 255 identifying a serial port</param>
        <param name="modemControl" type="dword">Signal lines and levels to bet set on all open ports (opened by CANoe/CANalyzer)</param>
        <return type="dword">0: error The error occurs if the serial port with the given number does not exist on the system and the port has not been opened</return>
    </method>

    <method name="RS232EscapeCommFunc" desc="Sets signal lines on all open serial ports (opened by CANoe/CANalyzer)">
        <param name="modemControl" type="dword">Signal lines and levels to bet set on all open ports (opened by CANoe/CANalyzer)</param>
        <return type="dword">0: error The error occurs if the serial port with the given number does not exist on the system and the port has not been opened</return>
    </method>

    <method name="RS232SetHandshake" desc="Sets handshake parameters on serial port">
        <param name="port" type="dword">A number between 1 and 255 identifying a serial port</param>
        <param name="handshake" type="dword">Sets variant of handshake to use</param>
        <param name="XonLimit" type="dword">Parameter for software flow control. Specifies the minimum number of bytes allowed in the input buffer before the XonChar is sent</param>
        <param name="XoffLimit" type="dword">Parameter for software flow control. Specifies the maximum number of bytes in the input buffer before the XoffChar is sent. The maximum number of bytes allowed is calculated by subtracting this value from the size, in bytes, of the input buffer</param>
        <param name="XonChar" type="dword">Parameter for software flow control. It specifies the value of the XON character to start an operation (transmission as well as reception)</param>
        <param name="XoffChar" type="dword">Parameter for software flow control. It specifies the value of the XOFF character to suspend an operation (transmission as well as reception)</param>
        <param name="timeout" type="dword">Timeout in milliseconds for all send and receive operations: -1 - infinite; less 10 - not allowed</param>
        <return type="dword">0: error The error occurs if the serial port with the given number does not exist on the system and the port has not been opened</return>
    </method>

    <method name="sysExec"
            desc="Executes an external command. Does not wait until the command has completed its execution. SysExec must be given an executable; sysExecCmd calls cmd.EXE /K with the first parameter, which opens a command window where the command is executed as if it was entered directly">
        <param name="cmd[]" type="char">The command to be executed. Either the full absolute path or a path relative to the current working directory must be given or the command must be in the system path</param>
        <param name="params[]" type="char">Parameters to the command. A parameter which contains spaces must be enclosed in " "</param>
        <return type="long">1 if the command was successfully started, else 0</return>
    </method>

    <method name="sysExec"
            desc="Executes an external command. Does not wait until the command has completed its execution. SysExec must be given an executable; sysExecCmd calls cmd.EXE /K with the first parameter, which opens a command window where the command is executed as if it was entered directly">
        <param name="cmd[]" type="char">The command to be executed. Either the full absolute path or a path relative to the current working directory must be given or the command must be in the system path</param>
        <param name="params[]" type="char">Parameters to the command. A parameter which contains spaces must be enclosed in " "</param>
        <param name="directory[]" type="char">Working directory for the command. Either an absolute path or a path relative to the current working directory must be given</param>
        <return type="long">1 if the command was successfully started, else 0</return>
    </method>

    <method name="sysExecCmd"
            desc="Executes an external command. Does not wait until the command has completed its execution. SysExec must be given an executable; sysExecCmd calls cmd.EXE /K with the first parameter, which opens a command window where the command is executed as if it was entered directly">
        <param name="cmd[]" type="char">The command to be executed. Either the full absolute path or a path relative to the current working directory must be given or the command must be in the system path</param>
        <param name="params[]" type="char">Parameters to the command. A parameter which contains spaces must be enclosed in " "</param>
        <return type="long">1 if the command was successfully started, else 0</return>
    </method>

    <method name="sysExecCmd"
            desc="Executes an external command. Does not wait until the command has completed its execution. SysExec must be given an executable; sysExecCmd calls cmd.EXE /K with the first parameter, which opens a command window where the command is executed as if it was entered directly">
        <param name="cmd[]" type="char">The command to be executed. Either the full absolute path or a path relative to the current working directory must be given or the command must be in the system path</param>
        <param name="params[]" type="char">Parameters to the command. A parameter which contains spaces must be enclosed in " "</param>
        <param name="directory[]" type="char">Working directory for the command. Either an absolute path or a path relative to the current working directory must be given</param>
        <return type="long">1 if the command was successfully started, else 0</return>
    </method>

    <method name="IpGetAddressAsArray"
            desc="The function converts an address string in colon notation to a 16 byte array with the address bytes in network order">
        <param name="address[]" type="char">The numerical IPv4 address to be converted</param>
        <param name="ipv6Address[]" type="byte">The array used to store the converted IPv6 address as 16 byte array</param>
        <return type="dword">0xFFFFFF: The specified address string was invalid</return>
    </method>

    <method name="IpGetAddressAsNumber"
            desc="The function converts an IPv4 address string in dot notation to it's numerical value in network-byte order">
        <param name="address[]" type="char">The numerical IPv4 address to be converted</param>
        <return type="dword">4294967295 (0xFFFFFFF, the equivalent of "255.255.255.255"): The specified address string was invalid</return>
    </method>

    <method name="IpGetAddressAsString"
            desc="The function converts a numeric address in host-byte order (little endian) to an address string in dot notation as in '192.168.0.10'. For IPv6 the address string has to contain a string in colon notation as in '1234:5678:9ABC:DEF1:2345:6789:ABCD:EF12'">
        <param name="numericAddress" type="dword">The numerical IPv4 address to be converted</param>
        <param name="address[]" type="char">The buffer used to store the converted IPv4 address</param>
        <param name="count" type="dword">The size of the address buffer</param>
        <return type="dword">0: The function completed successfully</return>
    </method>

    <method name="IpGetAddressAsString"
            desc="The function converts a numeric address in host-byte order (little endian) to an address string in dot notation as in '192.168.0.10'. For IPv6 the address string has to contain a string in colon notation as in '1234:5678:9ABC:DEF1:2345:6789:ABCD:EF12'">
        <param name="ipv6Address[]" type="byte">The local IPv6 address in a 16 byte array</param>
        <param name="address[]" type="char">The buffer used to store the converted IPv4 address</param>
        <param name="count" type="dword">The size of the address buffer</param>
        <return type="dword">0: The function completed successfully</return>
    </method>

    <method name="IpGetLastError"
            desc="The function returns the Winsock 2 error code of the last operation that failed">
        <return type="long">The error code as provided by the Winsock 2 WSAGetLastError function</return>
    </method>

    <method name="IpGetLastSocketError"
            desc="The function returns the Winsock 2 error code of the last operation that failed on the specified socket">
        <param name="socket" type="dword">The socket handle</param>
        <return type="long">Windows Sockets Error Code</return>
    </method>

    <method name="IpGetLastSocketErrorAsString"
            desc="The function retrieves the error message of the last operation that failed on the specified socket (see Winsock 2 error code)">
        <param name="socket" type="dword">The socket handle</param>
        <param name="text[]" type="char">The buffer used to store the error message</param>
        <param name="count" type="dword">The size of the text buffer</param>
        <return type="long">0: The error message was written into the text buffer. In case of an invalid error code, the error message has the format "Unknown error: x" assuming the last error code x for the specified socket</return>
    </method>

    <method name="IpGetAdapterCount"
            desc="The function returns the number of network interfaces for the local computer, not including the loopback interface">
        <return type="dword">The number of network interfaces</return>
    </method>

    <method name="IpGetAdapterAddressCount"
            desc="The function returns the count of addresses belonging to the given address family which are assigned to the adapter with the given index">
        <param name="ifIndex" type="dword">The 1-based network interface index</param>
        <param name="addressFamily" type="dword">
            The address family of the addresses, the address count will be returned
            Possible values are:
            AF_INET (2): IPv4 address family
            AF_INET6 (28): IPv6 address family
        </param>
        <return type="long">The count of addresses of the given address family will be returned</return>
    </method>

    <method name="IpGetAdapterAddress"
            desc="The function returns the count of addresses belonging to the given address family which are assigned to the adapter with the given index">
        <param name="ifIndex" type="dword">The 1-based network interface index</param>
        <param name="addresses" type="dword*">The array used to store the numerical IPv4 addresses</param>
        <param name="count" type="dword">The size of the address array</param>
        <return type="long">
            0: The function completed successfully.
            ERROR_NOT_ENOUGH_MEMORY (8): The address array was insufficient
            WSA_INVALID_PARAMETER (87): The specified network interface index was invalid
            WSAEADDRNOTAVAIL (10049): No adapter address available
        </return>
    </method>

    <method name="IpGetAdapterAddress"
            desc="The function returns the count of addresses belonging to the given address family which are assigned to the adapter with the given index">
        <param name="ifIndex" type="dword">The 1-based network interface index</param>
        <param name="ipv6Addresses" type="byte**">The array used to store the IPv6 addresses as 16 byte arrays</param>
        <param name="count" type="dword">The size of the address array</param>
        <return type="long">
            0: The function completed successfully.
            ERROR_NOT_ENOUGH_MEMORY (8): The address array was insufficient
            WSA_INVALID_PARAMETER (87): The specified network interface index was invalid
            WSAEADDRNOTAVAIL (10049): No adapter address available
        </return>
    </method>

    <method name="IpAddAdapterAddress"
            desc="The function adds an address to the network interface with the given index">
        <param name="ifIndex" type="dword">The 1-based network interface index</param>
        <param name="address" type="dword">The numerical IPv4 address to add to the interface</param>
        <param name="mask" type="dword">The IPv4 network mask in network byte order</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified network interface index was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastSocketError to get a more specific error code
        </return>
    </method>

    <method name="IpAddAdapterAddress"
            desc="The function adds an address to the network interface with the given index">
        <param name="ifIndex" type="dword">The 1-based network interface index</param>
        <param name="ipv6Address[]" type="byte">The IPv6 address in 16 byte array</param>
        <param name="prefix" type="dword">The IPv6 prefix for the given IPv6 address</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified network interface index was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastSocketError to get a more specific error code
        </return>
    </method>

    <method name="IpRemoveAdapterAddress"
            desc="The function removes an address from the network interface with the given index.">
        <param name="ifIndex" type="dword">The 1-based network interface index</param>
        <param name="address" type="dword">The numerical IPv4 address to add to the interface</param>
        <param name="mask" type="dword">The IPv4 network mask in network byte order</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified network interface index was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastSocketError to get a more specific error code
        </return>
    </method>

    <method name="IpRemoveAdapterAddress"
            desc="The function adds an address to the network interface with the given index">
        <param name="ifIndex" type="dword">The 1-based network interface index</param>
        <param name="ipv6Address[]" type="byte">The IPv6 address in 16 byte array</param>
        <param name="prefix" type="dword">The IPv6 prefix for the given IPv6 address</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified network interface index was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastSocketError to get a more specific error code
        </return>
    </method>

    <method name="IpGetAdapterDescription"
            desc="The function retrieves the description of the specified network interface">
        <param name="ifIndex" type="dword">The 1-based network interface index</param>
        <param name="name[]" type="char">The buffer used to store the description</param>
        <param name="count" type="dword">The size of the name buffer</param>
        <return type="long">
            0: The function completed successfully
            ERROR_NOT_ENOUGH_MEMORY (8): The name buffer was insufficient
            WSA_INVALID_PARAMETER (87): The specified network interface index was invalid
        </return>
    </method>

    <method name="IpSetMulticastInterface"
            desc="Set the interface for outgoing multicast messages. Without calling this no multicast messages can be sent on the given socket">
        <param name="socket" type="dword">The socket handle</param>
        <param name="ifIndex" type="dword">The 1-based network interface index</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified network interface index was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastSocketError to get a more specific error code
        </return>
    </method>

    <method name="IpJoinMulticastGroup"
            desc="Joins the multicast group on the given socket, to be able to receive multicast messages">
        <param name="socket" type="dword">The socket handle</param>
        <param name="ifIndex" type="dword">The 1-based network interface index</param>
        <param name="address" type="dword">The numerical IPv4 address of the destination</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified network interface index was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastSocketError to get a more specific error code
        </return>
    </method>

    <method name="IpJoinMulticastGroup"
            desc="Joins the multicast group on the given socket, to be able to receive multicast messages">
        <param name="socket" type="dword">The socket handle</param>
        <param name="ifIndex" type="dword">The 1-based network interface index</param>
        <param name="ipv6Address[]" type="byte">The local IPv6 address in a 16 byte array</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified network interface index was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastSocketError to get a more specific error code
        </return>
    </method>

    <method name="EthInitPacket"
            desc="This function creates a new Ethernet packet. Other functions can access to the newly created packet with the returned handle">
        <return type="long">handle of the created packet or 0</return>
    </method>

    <method name="EthInitPacket"
            desc="This function creates a new Ethernet packet. Other functions can access to the newly created packet with the returned handle. Protocol fields that are marked as InitProtocol in the protocol description are initialized">
        <param name="protocolDesignator[]" type="char">Designator of the protocol, which should be used for initialization</param>
        <return type="long">Handle of the created packet or 0. With EthGetLastError you can check if the function has been processed successfully</return>
    </method>

    <method name="EthInitPacket"
            desc="This function creates a new Ethernet packet. Other functions can access to the newly created packet with the returned handle. Protocol fields that are marked as InitProtocol in the protocol description are initialized">
        <param name="protocolDesignator[]" type="char">Designator of the protocol, which should be used for initialization</param>
        <param name="packetTypeDesignator[]" type="char">Designator of the packet type</param>
        <return type="long">Handle of the created packet or 0. With EthGetLastError you can check if the function has been processed successfully</return>
    </method>

    <method name="EthInitPacket"
            desc="This function creates a new Ethernet packet. Other functions can access to the newly created packet with the returned handle. Protocol fields that are marked as InitProtocol in the protocol description are initialized">
        <param name="srcMacAddress[6]" type="byte">Source MAC address as struct</param>
        <param name="dstMacAddress[6]" type="byte">Destination MAC address as struct</param>
        <param name="ethernetType" type="long">Ethernet type (16 Bit)</param>
        <return type="long">Handle of the created packet or 0. With EthGetLastError you can check if the function has been processed successfully</return>
    </method>

    <method name="EthInitPacket"
            desc="This function creates a new Ethernet packet. Other functions can access to the newly created packet with the returned handle. Protocol fields that are marked as InitProtocol in the protocol description are initialized">
        <param name="packetToCopy" type="long">Handle of the created packet or 0 With EthGetLastError you can check if the function has been processed successfully</param>
        <return type="long">Handle of the created packet or 0. With EthGetLastError you can check if the function has been processed successfully</return>
    </method>

    <method name="EthInitPacket"
            desc="This function creates a new Ethernet packet. Other functions can access to the newly created packet with the returned handle. Protocol fields that are marked as InitProtocol in the protocol description are initialized">
        <param name="rawDataLength" type="long">Length of rawData in byte</param>
        <param name="rawData[]" type="byte">Raw data of an Ethernet packet that is used to initialized the new packet</param>
        <return type="long">Handle of the created packet or 0. With EthGetLastError you can check if the function has been processed successfully</return>
    </method>

    <method name="EthInitPacket"
            desc="This function creates a new Ethernet packet. Other functions can access to the newly created packet with the returned handle. Protocol fields that are marked as InitProtocol in the protocol description are initialized">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, taken from the protocol overview</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthInitPacket"
            desc="This function creates a new Ethernet packet. Other functions can access to the newly created packet with the returned handle. Protocol fields that are marked as InitProtocol in the protocol description are initialized">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, taken from the protocol overview</param>
        <param name="packetTypeDesignator[]" type="char">Type of the packet, taken from the protocol overview</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthGetLastError" desc="Returns the error code of the last called Ethernet function">
        <return type="long">Error code</return>
    </method>

    <method name="EthGetLastErrorText" desc="Gets the error code description of the last called Ethernet function">
        <param name="bufferSize" type="dword">Size of buffer in which the description text is copied</param>
        <param name="buffer[]" type="char">Buffer in which the description text is copied</param>
        <return type="long">Number of copied bytes</return>
    </method>

    <method name="EthAddToken"
            desc="The function adds an additional token at the end of a protocol header or at a specific position (for details see protocol help)">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, e.g. "dhcpv4"</param>
        <param name="tokenDesignator[]" type="char">Name of the token, e.g. "option1"</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthRemoveToken" desc="The function removes a token from a protocol header">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, e.g. "dhcpv4"</param>
        <param name="tokenDesignator[]" type="char">Name of the token, e.g. "option1"</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthGetTokenLengthBit" desc="The function returns the length of a token in bit">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, e.g. "ipv4"</param>
        <param name="tokenDesignator[]" type="char">Name of the token, e.g. "source"</param>
        <return type="long">Length of the token in bit With EthGetLastError you can check if the function has been processed successfully</return>
    </method>

    <method name="EthGetTokenInt" desc="The function requests the integer value of a token">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, e.g. "ipv4"</param>
        <param name="tokenDesignator[]" type="char">Name of the token, e.g. "source"</param>
        <return type="long">Integer value of the token or 0 With EthGetLastError you can check if the function has been processed successfully</return>
    </method>

    <method name="EthGetTokenInt" desc="The function requests the integer value of a token">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, e.g. "ipv4"</param>
        <param name="tokenDesignator[]" type="char">Name of the token, e.g. "source"</param>
        <param name="byteOffset" type="long">Offset from the beginning of the token in byte</param>
        <param name="length" type="long">Length of the integer value, must be 1, 2, 3 or 4 byte</param>
        <param name="networkByteOrder" type="long">
            0: INTEL (little-endian)
            1: MOTOROLA (big-endian)
        </param>
        <return type="long">Integer value of the token or 0 With EthGetLastError you can check if the function has been processed successfully</return>
    </method>

    <method name="EthSetTokenData"
            desc="The function sets the data or a part of data of a token. It does not resize the token. Use EthResizeToken to change the length">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, e.g. "ipv4"</param>
        <param name="tokenDesignator[]" type="char">Name of the token, e.g. "source"</param>
        <param name="length" type="long">Number of bytes to be copied</param>
        <param name="data[]" type="char">Data that are copied to the token</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthSetTokenData"
            desc="The function sets the data or a part of data of a token. It does not resize the token. Use EthResizeToken to change the length">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, e.g. "ipv4"</param>
        <param name="tokenDesignator[]" type="char">Name of the token, e.g. "source"</param>
        <param name="byteOffset" type="long">Offset from the beginning of the token in byte</param>
        <param name="length" type="long">Number of bytes to be copied</param>
        <param name="data[]" type="char">Data that are copied to the token</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthSetTokenInt" desc="The function sets the integer value of a token">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, e.g. "ipv4"</param>
        <param name="tokenDesignator[]" type="char">Name of the token, e.g. "source"</param>
        <param name="value" type="long">New integer value</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthSetTokenInt" desc="The function with byte offset sets a part of the token data as integer">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, e.g. "ipv4"</param>
        <param name="tokenDesignator[]" type="char">Name of the token, e.g. "source"</param>
        <param name="byteOffset" type="long">Offset from the beginning of the token in byte</param>
        <param name="length" type="long">Length of the integer value, must be 1, 2, 3 or 4 byte</param>
        <param name="networkByteOrder" type="long">
            0: INTEL (little-endian)
            1: MOTOROLA (big-endian)
        </param>
        <param name="value" type="long">New integer value</param>
        <return type="long">0 or error code</return>
    </method>
    !!!
    CAPL_FUNC(long, EthGetTokenIntOffset)(long packet, const char protocolDesignatorl[], const char tokenDesignator[], long byteOffset, long length, long networkByteOrder); // form 2

    -----CAPL_FUNC(long, EthSetTokenInt64Offset)(long packet, const char protocolDesignatorl[], const char tokenDesignator[], long byteOffset, long length, long networkByteOrder, int64 value); // form 2
    CAPL_FUNC(long, EthSetTokenInt64)(long packet, const char protocolDesignatorl[], const char tokenDesignator[], int64 value); // form 1
    CAPL_FUNC(long, IpSetSocketOption)(dword socket, long level, long name, long value); // form 1
    CAPL_FUNC(long, IpSetSocketOptionName)(dword socket, const char level[], const char name[], long value); // form 2
    CAPL_FUNC(int64, EthGetTokenInt64)(long packet, const char protocolDesignator[], const char tokenDesignator[]); // form 1
    CAPL_FUNC(int64, EthGetTokenInt64Offset)(long packet, const char protocolDesignatorl[], const char tokenDesignator[], long byteOffset, long length, long networkByteOrder); // form 2
    CAPL_FUNC(qword, EthGetThisTimeNS)();
    !!!
    <method name="EthResizeToken"
            desc="The function can only be used with resizable tokens. These are i.g. the 'header' and 'data' tokens. If a token is not resizable the error code 46-0125 is returned">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="protocolDesignator[]" type="char">Name of the protocol, e.g. "ipv4"</param>
        <param name="tokenDesignator[]" type="char">Name of the token, e.g. "source"</param>
        <param name="newBitLength" type="long">New length of the token in bits</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthSetTokenSignalValue"
            desc="Functions assume that the packet's payload is described in the database. It writes the signal's value into the packet's payload">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="signal" type="Signal">Signal name from database. The signal must be assigned to the node as Tx signal</param>
        <param name="physValue" type="double">Physical value</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthSetTokenSignalValue"
            desc="Functions assume that the packet's payload is described in the database. It writes the signal's value into the packet's payload">
        <param name="packet" type="long">Handle of a packet that has been created with EthInitPacket</param>
        <param name="signal" type="Signal">Signal name from database. The signal must be assigned to the node as Tx signal</param>
        <param name="physValue" type="double">Physical value</param>
        <param name="index" type="dword">Zero based index of element</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthCompletePacket"
            desc="The function completes a packet before sending it with EthOutputPacket. It calculates the fields that are marked with CompleteProtocol in the protocol overview, e.g. checksum, lengths, etc">
        <param name="packet" type="long">Handle of the packet that has been created with EthInitPacket</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthOutputPacket" desc="This function sends an Ethernet packet">
        <param name="packet" type="long">Handle of the packet to send</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthOutputPacket" desc="This function sends an Ethernet packet">
        <param name="packet" type="long">Handle of the packet to send</param>
        <param name="fcs" type="dword">user-defined frame check sequence</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthReleasePacket"
            desc="The function deletes a packet created with EthInitPacket. The handle can not be used any longer">
        <param name="packet" type="long">Handle of the packet to delete</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthGetMacAddressAsNumber"
            desc="Converts a MAC address string, i.e. '02:00:00:00:00:01', to a qword-number, which can be used with ethernetPacket.source and ethernetPacket.destination.">
        <param name="macAddrStr[]" type="char">address as string, i.e. "02:00:00:00:00:01"</param>
        <return type="qword">The MAC address as qword or 0, if failed</return>
    </method>

    <method name="EthGetMacAddressAsString"
            desc="Converts a MAC address from qword to string. The function is helpful with ethernetPacket.source and ethernetPacket.destination">
        <param name="macAddrStr" type="qword">MAC address as qword, i.e. from ethernetPacket.source</param>
        <param name="buffer[]" type="char">Buffer where the MAC address string is copied to</param>
        <param name="bufferLength" type="dword">Length of buffer</param>
        <return type="long">
            0: The function completed successfully
            8: The address buffer was insufficient
        </return>
    </method>

    <method name="EthStartPacketGenerator"
            desc="Starts the Ethernet packet generator that sends continuously the configured packets">
        <param name="txPacket" type="ethernetPacket">The Ethernet packet which was used to start the generator</param>
        <param name="transmissionRate" type="dword">The rate in frames per second the packet should be transmitted. Range: [1 ... 1000000]</param>
        <return type="long">
            0: Success
            -1: Output on specified Ethernet channel not allowed
            -2: Packet generator not supported in simulation mode
            -3: Packet generator is only available with Vector Ethernet network hardware
            -4: Configuration of packet generator failed
            -5: Starting of packet generator failed
        </return>
    </method>

    <method name="EthStartPacketGenerator"
            desc="Starts the Ethernet packet generator that sends continuously the configured packets">
        <param name="txPacket" type="ethernetPacket">The Ethernet packet which was used to start the generator</param>
        <param name="transmissionRate" type="dword">The rate in frames per second the packet should be transmitted. Range: [1 ... 1000000]</param>
        <param name="numberOfFrames" type="dword">The number of Frames that should be transmitted overall. Range: [0x1 ... 0xFFFFFFFE], 0xFFFFFFFF to send until EthStopPacketGenerator</param>
        <return type="long">
            0: Success
            -1: Output on specified Ethernet channel not allowed
            -2: Packet generator not supported in simulation mode
            -3: Packet generator is only available with Vector Ethernet network hardware
            -4: Configuration of packet generator failed
            -5: Starting of packet generator failed
        </return>
    </method>

    <method name="EthStartPacketGenerator"
            desc="Starts the Ethernet packet generator that sends continuously the configured packets">
        <param name="txPacket" type="ethernetPacket">The Ethernet packet which was used to start the generator</param>
        <param name="transmissionRate" type="dword">The rate in frames per second the packet should be transmitted. Range: [1 ... 1000000]</param>
        <param name="numberOfFrames" type="dword">The number of Frames that should be transmitted overall. Range: [0x1 ... 0xFFFFFFFE], 0xFFFFFFFF to send until EthStopPacketGenerator</param>
        <param name="counterByteOffset" type="dword">The position a 4 byte counter is placed inside the Ethernet-payload on a zero based index. Index 0 is the first byte after the source MAC Address. Take care that the counter has to fit completely into the payload</param>
        <return type="long">
            0: Success
            -1: Output on specified Ethernet channel not allowed
            -2: Packet generator not supported in simulation mode
            -3: Packet generator is only available with Vector Ethernet network hardware
            -4: Configuration of packet generator failed
            -5: Starting of packet generator failed
        </return>
    </method>

    <method name="EthStopPacketGenerator"
            desc="Stops the Ethernet packet generator, which was started with EthStartPacketGenerator">
        <param name="txPacket" type="ethernetPacket">The Ethernet packet which was used to start the generator</param>
        <return type="long">0: Success</return>
    </method>

    <method name="TcpOpen"
            desc="The function creates a TCP socket for use in connection-based, message-oriented communications. All parameters may be zero. If the port parameter is non-zero the socket is implicitly bound to the given port">
        <param name="address" type="dword">The numerical local IPv4 address to be used with the socket If set to 0, then the socket is address unspecific (address wildcard). It then can be used for all adapters on any address. It can be bound later on with IpBind or TcpConnect</param>
        <param name="port" type="dword">The port in host-byte order to be used with the socket. If set to 0, then the socket is port unspecific (port wildcard). It then can be used for all ports on given address. It can be bound later on with IpBind or TcpConnect</param>
        <return type="dword">
            INVALID_SOCKET (~0): The function failed. Call IpGetLastError to get a more specific error code
            Any other value: A valid socket handle identifying the created socket
        </return>
    </method>

    <method name="TcpOpen"
            desc="The function creates a TCP socket for use in connection-based, message-oriented communications. All parameters may be zero. If the port parameter is non-zero the socket is implicitly bound to the given port">
        <param name="ipv6Address[]" type="byte">The local IPv6 address in a 16 byte array</param>
        <param name="port" type="dword">The port in host-byte order to be used with the socket. If set to 0, then the socket is port unspecific (port wildcard). It then can be used for all ports on given address. It can be bound later on with IpBind or TcpConnect</param>
        <return type="dword">
            INVALID_SOCKET (~0): The function failed. Call IpGetLastError to get a more specific error code
            Any other value: A valid socket handle identifying the created socket
        </return>
    </method>

    <method name="TcpConnect" desc="The function establishes a connection with the specified location">
        <param name="socket" type="dword">The socket handle</param>
        <param name="address" type="dword">The numerical IPv4 address of the destination</param>
        <param name="port" type="dword">The port of the destination in host-byte order</param>
        <return type="long">
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): Call IpGetLastSocketError to get a more specific error code. If the error code is different from 10035 this indicates a connection error
        </return>
    </method>

    <method name="TcpClose"
            desc="The function closes the TCP socket. Upon successful completion the passed socket is no longer valid">
        <param name="socket" type="dword">The socket to be closed</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="TcpAccept"
            desc="Accepts an incoming connection request on a specified socket resulting in a new socket.">
        <param name="socket" type="dword">The socket handle of the listen socket that was created with TcpListen.</param>
        <return type="dword">
            INVALID_SOCKET (~0): The function failed. Call IpGetLastError to get a more specific error code
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): Call IpGetLastSocketError to get a more specific error code. If the error code is different from 10035 this indicates a connection error
        </return>
    </method>

    <method name="TcpListen" desc="Causes the socket to listen for incoming connection requests.">
        <param name="socket" type="dword">The socket handle</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="TcpReceive" desc="Receives data into a specified buffer.">
        <param name="socket" type="dword">The socket handle</param>
        <param name="buffer[]" type="char">The buffer used to store the incoming data</param>
        <param name="size" type="dword">The size of the data buffer</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="TcpSend" desc="Sends data on a specified socket.">
        <param name="socket" type="dword">The socket handle</param>
        <param name="buffer[]" type="char">The buffer containing the data to be sent</param>
        <param name="size" type="dword">The size of the data to be sent</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="TcpSend" desc="Sends data on a specified socket.">
        <param name="socket" type="dword">The socket handle</param>
        <param name="data[]" type="struct">The struct containing the data to be sent</param>
        <param name="size" type="dword">The size of the data to be sent</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="TcpSend" desc="Sends data on a specified socket.">
        <param name="socket" type="dword">The socket handle</param>
        <param name="buffer[]" type="byte">The buffer containing the data to be sent</param>
        <param name="size" type="dword">The size of the data to be sent</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="TcpShutdown" desc="Disables send operations on a specified socket.">
        <param name="socket" type="dword">The socket handle</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="UdpOpen"
            desc="The function creates an UDP socket for use in connectionless, datagramm-oriented communications. All parameters may be zero. If  the port parameter is non-zero the socket is implicitly bound to the given port">
        <param name="address" type="dword">The numerical local IPv4 address to be used with the socket. If set to 0, then the socket is address unspecific (address wildcard). It then can be used for all adapters on any address. It can be bound later on with IpBind or UdpSendTo</param>
        <param name="port" type="dword">The port in host-byte order to be used with the socket. If set to 0, then the socket is port unspecific (port wildcard). It then can be used for all ports on given address. It can be bound later on with IpBind or UdpSendTo</param>
        <return type="dword">
            INVALID_SOCKET (~0): The function failed. Call IpGetLastError to get a more specific error code
            Any other value: A valid socket handle identifying the created socket
        </return>
    </method>

    <method name="UdpOpen"
            desc="The function creates an UDP socket for use in connectionless, datagramm-oriented communications. All parameters may be zero. If  the port parameter is non-zero the socket is implicitly bound to the given port">
        <param name="ipv6Address[]" type="byte">The local IPv6 address in a 16 byte array. Like in the IPv4 address an address wildcard can be retrieved using IpGetAddressAsArray('::', ipv6AddrArray)</param>
        <param name="port" type="dword">The port in host-byte order to be used with the socket. If set to 0, then the socket is port unspecific (port wildcard). It then can be used for all ports on given address. It can be bound later on with IpBind or UdpSendTo</param>
        <return type="dword">
            INVALID_SOCKET (~0): The function failed. Call IpGetLastError to get a more specific error code
            Any other value: A valid socket handle identifying the created socket
        </return>
    </method>

    <method name="UdpClose"
            desc="The function closes the UDP socket. Upon successful completion the passed socket is no longer valid">
        <param name="socket" type="dword">The socket to be closed</param>
        <return type="long">
            0: The function completed successfully
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="EthReceivePacket"
            desc="Use this function to register a CAPL callback function to receive Ethernet packets. The callback has a packet handle as parameter and the functions to access the tokens can be used. The EthGetThis-functions can be used to access the payload of the highest interpretable protocol">
        <param name="onPacketCallback[]" type="char">Name of CAPL callback function</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthReceiveRawPacket"
            desc="Use this function to register a CAPL function to receive Ethernet packets. The callback function is called, if a packet with the specified MAC addresses and Ethernet type is received.">
        <param name="flags" type="long">Used to ignore the Ethernet type or the MAC address, e.g. flag = 7 receives all packets</param>
        <param name="srcMacAddress[6]" type="byte">Source MAC address</param>
        <param name="dstMacAddress[6]" type="byte">Destination MAC address</param>
        <param name="ethernetType" type="long">Ethernet type (16 Bit)</param>
        <param name="callback[]" type="char">CAPL callback function name</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="EthGetThisData"
            desc="The function gets the returned data. It is only usable in a CAPL callback function that had been registered with EthReceiveRawPacket or EthReceivePacket">
        <param name="offset" type="long">Byte offset relative to the beginning of a data packet or the payload (see description above)</param>
        <param name="bufferSize" type="long">Number of requested bytes</param>
        <param name="buffer[]" type="byte">Buffer in which the requested data are copied</param>
        <return type="long">0 or error code</return>
    </method>

    <method name="TcpSend"
            desc="The function sends data on the specified socket. If the send operation does not complete immediately the operation is performed asynchronously and the function will return SOCKET_ERROR (-1)">
        <param name="socket" type="dword">The socket handle</param>
        <param name="buffer[]" type="char">The buffer containing the data to be sent</param>
        <param name="bufferSize" type="dword">The size of the data to be sent</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="UdpSendTo" desc="The function sends data to the specified location">
        <param name="socket" type="dword">The socket handle</param>
        <param name="address" type="dword">The numerical IPv4 address of the destination in network-byte order</param>
        <param name="port" type="dword">The port of the destination in host-byte order</param>
        <param name="buffer[]" type="char">The buffer containing the data to be sent</param>
        <param name="bufferSize" type="dword">The size of the data to be sent</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="UdpSendTo" desc="The function sends data to the specified location">
        <param name="socket" type="dword">The socket handle</param>
        <param name="ipv6Address[]" type="byte">The local IPv6 address in a 16 byte array</param>
        <param name="port" type="dword">The port of the destination in host-byte order</param>
        <param name="buffer[]" type="char">The buffer containing the data to be sent</param>
        <param name="bufferSize" type="dword">The size of the data to be sent</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="UdpReceiveFrom"
            desc="The function receives data into the specified buffer. If the receive operation does not complete immediately the operation is performed asynchronously and the function will return SOCKET_ERROR (-1)">
        <param name="socket" type="dword">The socket handle</param>
        <param name="buffer[]" type="char">The buffer used to store the incoming data</param>
        <param name="bufferSize" type="dword">The size of the data buffer</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="TcpReceive" desc="The function receives data into the specified buffer">
        <param name="socket" type="dword">The socket handle</param>
        <param name="buffer[]" type="char">The buffer used to store the incoming data</param>
        <param name="bufferSize" type="dword">The size of the data buffer</param>
        <return type="long">
            0: The function completed successfully
            WSA_INVALID_PARAMETER (87): The specified socket was invalid
            SOCKET_ERROR (-1): The function failed. Call IpGetLastError to get a more specific error code
        </return>
    </method>

    <method name="GetComputerName" desc="Retrieves the fully qualified name of the computer">
        <param name="buffer[]" type="char">Space for the returned name</param>
        <param name="bufferSize" type="dword">Length of the buffer</param>
        <return type="long">0 if the function completed successfully, else unequal 0</return>
    </method>
</root>